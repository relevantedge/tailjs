{"version":3,"file":"tail.debug.js","sources":["../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/client/src/pusher.ts","../../../../../npm/packages/@tailjs/util/src/events.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["// MUST MATCH packages\\@tailjs\\engine\\src\\RequestHandler.ts\nexport const MUTEX_REQUEST_COOKIE = \".tail.rq\";\nexport const MUTEX_RESPONSE_COOKIE = \".tail.rs\";\nexport const CONTEXT_MENU_COOKIE = \".tail.cm\";\n\nexport const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_MENU_QUERY = \"mnt\";\n","import { createChainedEvent } from \"@tailjs/util\";\r\n\r\n//const lck = createLock(\"test\");\r\nexport const attach = async () => {\r\n  const [register, invoke] = createChainedEvent<Promise<number>>();\r\n\r\n  const [unbind2] = register(async (next) => {\r\n    //console.log(\"Basso\");\r\n    return (await next()) + 1;\r\n  });\r\n\r\n  register(async (next) => {\r\n    //console.log(\"Basso2\");\r\n    return 12;\r\n  });\r\n\r\n  const [unbind, bind] = register(async (next) => {\r\n    return (await next()) + 4;\r\n  }, -1);\r\n\r\n  console.log(await invoke());\r\n  unbind();\r\n  console.log(await invoke());\r\n  bind();\r\n  console.log(await invoke());\r\n  unbind2();\r\n  console.log(await invoke());\r\n\r\n  // let invocations = 0;\r\n  // let clicked = false;\r\n  // const pump = clock(\r\n  //   async () => {\r\n  //     const capturedClick = clicked;\r\n  //     if (!clicked && invocations % 2 === 1) {\r\n  //       await wait(1500);\r\n  //     }\r\n  //     console.log(`${++invocations}, clicked: ${capturedClick}.`);\r\n  //   },\r\n  //   { frequency: 1000, queue: false }\r\n  // );\r\n\r\n  // let testId = 1;\r\n  // listen(document.body, \"click\", async (e) => {\r\n  //   // clicked = true;\r\n  //   // console.log(pump.active, pump.busy);\r\n  //   // e.shiftKey && pump.toggle(!pump.active);\r\n  //   // console.log(await pump.trigger(true));\r\n  //   // (async () => {\r\n  //   //   clicked = false;\r\n  //   // })();\r\n  //   post([`Test ${testId++}`]);\r\n  // });\r\n  // listen(document.body, \"click\", () => {\r\n  //   updateTabState((tab) => (tab.navigated = now()));\r\n\r\n  //   lck(async () => {\r\n  //     console.log(\"Lock acquired.\");\r\n  //     await wait(5000);\r\n  //   });\r\n  // });\r\n  // listen(\r\n  //   window,\r\n  //   \"pageshow\",\r\n  //   () =>\r\n  //     activeTabs.update(\r\n  //       (current) => (\r\n  //         ((current = cast(current, isObject) ?? {})[TAB_ID] = now()), current\r\n  //       )\r\n  //     )\r\n  //   //activeStorage.update((current) => (current ?? 0) + 1)\r\n  // );\r\n  // listen(\r\n  //   window,\r\n  //   \"pagehide\",\r\n  //   () =>\r\n  //     activeTabs.update(\r\n  //       (current) => (isObject(current) && delete current[TAB_ID], current)\r\n  //     )\r\n  //   // activeStorage.update((current: any) =>\r\n  //   //   current > 0 ? current - 1 : current\r\n  //   // )\r\n  // );\r\n};\r\n","import { filter, isUndefined, reduce } from \".\";\r\n\r\nexport type Rebinder = () => boolean;\r\nexport type Unbinder = () => boolean;\r\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\r\n\r\nexport type SourceListener<Args extends any[]> = (...args: Args) => void;\r\nexport type Listener<Args extends any[]> = (\r\n  ...args: [...args: Args, unbind: Unbinder]\r\n) => void;\r\n\r\nexport const createEventBinders = <Args extends any[]>(\r\n  listener: Listener<Args>,\r\n  attach: (listener: SourceListener<Args>) => void,\r\n  detach: (listener: SourceListener<Args>) => void\r\n): Binders => {\r\n  let bound = false;\r\n\r\n  const outerListener = (...args: Args) => listener(...args, unbind);\r\n\r\n  const unbind = () =>\r\n    bound !== (bound = false) && (detach(outerListener), true);\r\n\r\n  const rebind = () =>\r\n    bound !== (bound = true) && (attach(outerListener), true);\r\n\r\n  rebind();\r\n  return [unbind, rebind];\r\n};\r\n\r\nexport const joinEventBinders = (\r\n  ...binders: (Binders | undefined)[]\r\n): Binders => (\r\n  (binders = filter(binders)),\r\n  [\r\n    () => reduce(binders, (changed, binder) => binder![0]() || changed, false),\r\n    () => reduce(binders, (changed, binder) => binder![1]() || changed, false),\r\n  ]\r\n);\r\n\r\nexport type EventHandler<Args extends any[]> = (...payload: Args) => void;\r\n\r\nexport const createEvent = <Args extends any[]>(): [\r\n  listen: (listener: Listener<Args>) => Binders,\r\n  dispatch: (...payload: Args) => void\r\n] => {\r\n  const listeners = new Set<SourceListener<Args>>();\r\n\r\n  return [\r\n    (handler) =>\r\n      createEventBinders(\r\n        handler,\r\n        (handler) => listeners.add(handler),\r\n        (handler) => listeners.delete(handler)\r\n      ),\r\n    (...payload) => listeners.forEach((handler) => handler(...payload)),\r\n  ];\r\n};\r\n\r\nexport type ChainedEventHandler<Args extends any[], T> = (\r\n  ...args: [\r\n    ...args: Args,\r\n    next: {\r\n      (): T;\r\n      (...args: Args): T;\r\n    },\r\n    unbind: Unbinder\r\n  ]\r\n) => T;\r\n\r\ntype LinkedNode<T> = [\r\n  prev: LinkedNode<T> | undefined,\r\n  item: T,\r\n  next: LinkedNode<T> | undefined\r\n];\r\n\r\nexport const createChainedEvent = <T = void, Args extends any[] = []>(): [\r\n  register: (\r\n    handler: ChainedEventHandler<Args, T>,\r\n    priority?: number\r\n  ) => Binders,\r\n  invoke: (...args: Args) => T | undefined\r\n] => {\r\n  type Item = [\r\n    handler: ChainedEventHandler<Args, T>,\r\n    priority: number,\r\n    binders: Binders\r\n  ];\r\n  type Node = LinkedNode<Item>;\r\n  let head: Node | undefined;\r\n  let tail: Node | undefined;\r\n  let next: Node | undefined;\r\n\r\n  const register = (\r\n    handler: ChainedEventHandler<Args, T>,\r\n    // Make sure that handler gets rebound at their previous priority without jumping discrete increments.\r\n    // (It is deseriable to be able to specfiy priority 0 or  10 without having to think about how many 0s there are)\r\n    priority = (tail?.[1][1] ?? 0) + 0.000001\r\n  ) => {\r\n    const registerNode = (node?: Node) => {\r\n      let bound = true;\r\n      node ??= [\r\n        undefined,\r\n        [\r\n          handler,\r\n          priority,\r\n          [\r\n            () => {\r\n              if (!bound) return false;\r\n              node![0] ? (node![0][2] = node![2]) : (head = node![2]);\r\n              node![2] ? (node![2][0] = node![0]) : (tail = node![0]);\r\n              node![0] = node![2] = undefined;\r\n              return !(bound = false);\r\n            },\r\n            () => (bound ? false : (registerNode(node), (bound = true))),\r\n          ],\r\n        ],\r\n        undefined,\r\n      ];\r\n      next = head;\r\n      if (!next) {\r\n        head = tail = node;\r\n      } else if (priority >= tail![1][1]) {\r\n        node[0] = tail;\r\n        tail = tail![2] = node;\r\n      } else {\r\n        // INV: priority < tail.priority, so next will be non-null after loop;\r\n        while ((next![1][1] as any) <= priority) {\r\n          next = next[2]!;\r\n        }\r\n\r\n        (node[0] = (node[2] = next)[0]) ? (node[0][2] = node) : (head = node);\r\n        next[0] = node;\r\n      }\r\n\r\n      return node[1][2];\r\n    };\r\n    return registerNode();\r\n  };\r\n\r\n  const invoke = (node: Node | undefined, args: Args) => (\r\n    (next = node?.[2]),\r\n    node\r\n      ? node[1][0](\r\n          ...args,\r\n          (...nextArgs: Args) =>\r\n            invoke(next!, nextArgs.length ? nextArgs : args),\r\n          node[1][2][0]\r\n        )\r\n      : undefined\r\n  );\r\n\r\n  return [register, (...args) => invoke(head, args)];\r\n};\r\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\n//import { initializeTracker } from \"./initializeTracker\";\n//import { F, T, define, window } from \"./lib\";\nimport { attach } from \"./pusher\";\n\n// This assumes the script is loaded from the RequestHandler's ?cfg route.\n\n// To prevent external scripts from eaves-dropping and get a hold of the storage key, this is how initialization works:\n// 1: The configuration scripts appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overriden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nwindow[INITIALIZE_TRACKER_FUNCTION] = (callback: any) => {\n  callback(attach);\n};\n\n// let loaded = F;\n// define(window, {\n//   [INITIALIZE_TRACKER_FUNCTION]: [\n//     (callback: (init: typeof initializeTracker) => void) => {\n//       if (loaded === (loaded = T)) return;\n//       callback(initializeTracker);\n//     },\n//   ],\n// });\n"],"names":["attach","async","register","invoke","head","tail","next","node","args","nextArgs","length","handler","priority","registerNode","bound","createChainedEvent","unbind2","unbind","bind","console","log","window","callback"],"mappings":"mBAMO,ICHMA,EAASC,UACpB,IAAOC,EAAUC,GCwEe,MAa5B,IAAAC,EACAC,EACAC,EAiDEH,EAAS,CAACI,EAAwBC,KACrCF,EAAOC,IAAO,GACfA,EACIA,EAAK,GAAG,MACHC,GACH,IAAIC,IACFN,EAAOG,EAAOG,EAASC,OAASD,EAAWD,IAC7CD,EAAK,GAAG,GAAG,SAEb,GAGN,MAAO,CA3DU,CACfI,EAGAC,GAAYP,IAAO,GAAG,IAAM,GAAK,QAE3B,IAAAQ,EAAgBN,IACpB,IAAIO,GAAQ,EAoBZ,GAnBSP,IAAA,MACP,EACA,CACEI,EACAC,EACA,CACE,OACOE,IACLP,EAAM,GAAMA,EAAM,GAAG,GAAKA,EAAM,GAAOH,EAAOG,EAAM,GACpDA,EAAM,GAAMA,EAAM,GAAG,GAAKA,EAAM,GAAOF,EAAOE,EAAM,GACpDA,EAAM,GAAKA,EAAM,QAAK,EACbO,GAAQ,IAEnB,KAAOA,IAAiBD,EAAaN,GAAQO,GAAQ,UAGzD,GAEKR,EAAAF,KAGIQ,EAAYP,EAAM,GAAG,GAGzB,CAEL,KAAQC,EAAM,GAAG,IAAcM,GAC7BN,EAAOA,EAAK,IAGbC,EAAK,IAAMA,EAAK,GAAKD,GAAM,IAAOC,EAAK,GAAG,GAAKA,EAASH,EAAOG,EAChED,EAAK,GAAKC,CACZ,MAVEA,EAAK,GAAKF,EACHA,EAAAA,EAAM,GAAKE,OAHlBH,EAAOC,EAAOE,EAcT,OAAAA,EAAK,GAAG,EAAC,EAElB,OAAOM,GAAa,EAeJ,IAAIL,IAASL,EAAOC,EAAMI,GAAK,EDpJtBO,IAEpBC,GAAWd,GAASD,MAAOK,SAElBA,IAAU,IAG1BJ,GAASD,MAAOK,GAEP,KAGT,IAAOW,EAAQC,GAAQhB,GAASD,MAAOK,SACvBA,IAAU,IACrB,GAEGa,QAAAC,UAAUjB,KACXc,IACCE,QAAAC,UAAUjB,KACbe,IACGC,QAAAC,UAAUjB,KACVa,IACAG,QAAAC,UAAUjB,IAAQ,EEd5BkB,OHN2C,iBGMJC,IACrCA,EAAStB,EAAM"}