{"version":3,"file":"tail.debug.js","sources":["../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/util/src/regex.ts","../../../../../npm/packages/@tailjs/client/src/lib/dom/dom-util.ts","../../../../../npm/packages/@tailjs/types/src/EventMetadata.ts","../../../../../npm/packages/@tailjs/types/src/util/parseTags.ts","../../../../../npm/packages/@tailjs/client/src/lib/dom/dom-data.ts","../../../../../npm/packages/@tailjs/transport/src/transport.ts","../../../../../npm/packages/@tailjs/client/src/initializeTracker.ts","../../../../../npm/packages/@tailjs/client/src/extensions/view.ts","../../../../../npm/packages/@tailjs/client/src/extensions/components.ts","../../../../../npm/packages/@tailjs/util/src/types/validation.ts","../../../../../npm/packages/@tailjs/util/src/types/types.ts","../../../../../npm/packages/@tailjs/util/src/iterators.ts","../../../../../npm/packages/@tailjs/util/src/accessors.ts","../../../../../npm/packages/@tailjs/util/src/time.ts","../../../../../npm/packages/@tailjs/util/src/concurrency.ts","../../../../../npm/packages/@tailjs/util/src/strings.ts","../../../../../npm/packages/@tailjs/util/src/events.ts","../../../../../npm/packages/@tailjs/util/src/enums.ts","../../../../../npm/packages/@tailjs/util/src/parsers.ts","../../../../../npm/packages/@tailjs/util/src/intervals.ts","../../../../../npm/packages/@tailjs/client/src/lib/consts.ts","../../../../../npm/packages/@tailjs/client/src/lib/dom/dom-alias.ts","../../../../../npm/packages/@tailjs/types/src/DataClassification.ts","../../../../../npm/packages/@tailjs/types/src/DataPurposes.ts","../../../../../npm/packages/@tailjs/types/src/EventPatch.ts","../../../../../npm/packages/@tailjs/types/src/protocol/Variable.ts","../../../../../npm/packages/@tailjs/types/src/protocol/VariableResult.ts","../../../../../npm/packages/@tailjs/types/src/protocol/VariableSetter.ts","../../../../../npm/packages/@tailjs/types/src/events/TrackedEvent.ts","../../../../../npm/packages/@tailjs/types/src/events/ViewEvent.ts","../../../../../npm/packages/@tailjs/types/src/util/type-test.ts","../../../../../npm/packages/@tailjs/client/src/lib/config.ts","../../../../../npm/packages/@tailjs/transport/src/base64.ts","../../../../../npm/packages/@tailjs/transport/src/lfsr.ts","../../../../../npm/node_modules/.pnpm/github.com+nielskuhnel+msgpack.js@ad309e8a7e5319c2472193e3b28df68124caa590/node_modules/@ygoe/msgpack/msgpack.js","../../../../../npm/packages/@tailjs/client/src/lib/env.ts","../../../../../npm/packages/@tailjs/client/src/lib/cipher.ts","../../../../../npm/packages/@tailjs/client/src/lib/errors.ts","../../../../../npm/packages/@tailjs/client/src/lib/page-events.ts","../../../../../npm/packages/@tailjs/client/src/lib/LocalVariables.ts","../../../../../npm/packages/@tailjs/client/src/lib/shared-state.ts","../../../../../npm/packages/@tailjs/client/src/lib/request.ts","../../../../../npm/packages/@tailjs/client/src/lib/concurrency.ts","../../../../../npm/packages/@tailjs/client/src/lib/TrackerVariableStorage.ts","../../../../../npm/packages/@tailjs/client/src/lib/ImpressionObserver.ts","../../../../../npm/packages/@tailjs/client/src/extensions/deviceDetection.ts","../../../../../npm/packages/@tailjs/client/src/extensions/user-agent.ts","../../../../../npm/packages/@tailjs/client/src/extensions/userInteraction.ts","../../../../../npm/packages/@tailjs/client/src/lib/EventQueue.ts","../../../../../npm/packages/@tailjs/client/src/lib/debug-listeners.ts","../../../../../npm/packages/@tailjs/client/src/extensions/commerce.ts","../../../../../npm/packages/@tailjs/client/src/extensions/forms.ts","../../../../../npm/packages/@tailjs/client/src/extensions/consent.ts","../../../../../npm/packages/@tailjs/client/src/extensions/defaultExtensions.ts","../../../../../npm/packages/@tailjs/client/src/lib/scanComponents.ts","../../../../../npm/packages/@tailjs/client/src/extensions/scroll.ts","../../../../../npm/packages/@tailjs/client/src/commands/shared.ts","../../../../../npm/packages/@tailjs/client/src/commands/CartCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ChangeUserCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ConfigCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ToggleCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/BoundaryCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ExtensionCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/FlushCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/GetCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ListenerCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/OrderCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ScanComponentsCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/SetCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/TrackerAvailableCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ConsentCommand.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["export const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const INIT_SCRIPT_QUERY = \"init\";\nexport const CLIENT_SCRIPT_QUERY = \"opt\";\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_NAV_QUERY = \"mnt\";\nexport const SCHEMA_QUERY = \"$types\";\nexport const BUILD_REVISION_QUERY = \"rev=\" + globalThis.REVISION;\n\nexport const SCOPE_INFO_KEY = \"@info\";\nexport const CONSENT_INFO_KEY = \"@consent\";\nexport const SESSION_REFERENCE_KEY = \"@session_reference\";\n\nexport const PATCH_EVENT_POSTFIX = \"_patch\";\n\nexport const CLIENT_STORAGE_PREFIX = \"_tail:\";\n\nexport const CLIENT_STATE_CHANNEL_ID = CLIENT_STORAGE_PREFIX + \"state\";\n\nexport const CLIENT_CALLBACK_CHANNEL_ID = CLIENT_STORAGE_PREFIX + \"push\";\n","import {\n  If,\n  MaybeUndefined,\n  Nullable,\n  distinct,\n  filter,\n  isArray,\n  isBoolean,\n  isString,\n  join,\n  map,\n  nil,\n  undefined,\n  type ConstToNormal,\n  type IterableOrSelf,\n  type Nullish,\n} from \".\";\n\n/**\n * Common definition of expressions that are used for string matching.\n *\n * If not already a regular expression, a string that starts with `/` and optionally ends with `/` is parsed as regular expressions with flags `gu` applied (global and Unicode).\n * This enables defining regular expression in text based configuration files that do not have native regular expressions.\n *\n * For convenience an asterisk (`*`) can be used to match any number of characters in strings, and  `,` and white-space ` ` are interpreted as list separators.\n * `\\` is used as the escape character so the string `\\/escaped\\*,and\\ this` will only match the strings, literally, `\\/escaped\\*` and `and this`.\n * This also means that intentional backslashes, commas and spaces must be escaped as `\\\\`, `\\,` and `\\ ` respectively.\n *\n * Arrays of strings and/or regular expressions are evaluated as unions (_string 1_ \"or\" _string 2_ \"or\" ...).\n *\n * The special values `null`, `undefined`, the empty string,  and `false` are interpreted as \"never\", and `true` is \"always\".\n *\n * Regarding separators, they may be different in specific contexts. If so, it will be mentioned there.\n */\nexport type ParsableRegExp =\n  | IterableOrSelf<null | undefined | boolean | string | RegExp>\n  | Iterable<ParsableRegExp>;\n\nexport const testRegex = <Nulls>(\n  s: Nullable<string, Nulls>,\n  match: Nullable<RegExp, Nulls>\n) => (!match || s == null ? undefined : match.test(s));\n\nexport const matches = <R, Nulls>(\n  s: Nullable<string, Nulls>,\n  regex: RegExp | Nullish,\n  selector: (...args: string[]) => R | Nullish\n): MaybeUndefined<Nulls, ConstToNormal<R>[]> => match(s, regex, selector, true);\n\nlet matchProjection: any;\nlet collected: any[];\n\n/**\n * Matches a regular expression against a string and projects the matched parts, if any.\n */\nexport const match: {\n  <R, Nulls, Collect extends boolean = false>(\n    s: Nullable<string, Nulls>,\n    regex: RegExp | Nullish,\n    selector: (...args: (string | undefined)[]) => R | Nullish,\n    collect?: Collect\n  ): MaybeUndefined<Nulls, If<Collect, ConstToNormal<R>[], R | undefined>>;\n  (s: string | Nullish, match: RegExp | Nullish): RegExpMatchArray | null;\n} = <R>(\n  s: string,\n  regex: RegExp,\n  selector?: (...args: (string | undefined)[]) => R,\n  collect = false\n) =>\n  (s ?? regex) == nil\n    ? undefined\n    : selector\n    ? ((matchProjection = undefined),\n      collect\n        ? ((collected = []),\n          match(\n            s,\n            regex,\n            (...args) =>\n              (matchProjection = selector(...args)) != null &&\n              collected.push(matchProjection)\n          ))\n        : s.replace(\n            // Replace seems to be a compact way to get the details of each match\n            regex,\n            (...args) => (matchProjection = selector(...args)) as any\n          ),\n      matchProjection)\n    : s.match(regex);\n\n/**\n * Replaces reserved characters to get a regular expression that matches the string.\n */\nexport const escapeRegEx = <T extends string | Nullish>(\n  input: T\n): MaybeUndefined<T, string> =>\n  input?.replace(/[\\^$\\\\.*+?()[\\]{}|]/g, \"\\\\$&\") as any;\n\nconst REGEX_NEVER = /\\z./g;\nconst unionOrNever = (parts: (string | Nullish)[], joined?: string) =>\n  (joined = join(distinct(filter(parts, (part) => part?.length)), \"|\"))\n    ? new RegExp(joined, \"gu\")\n    : REGEX_NEVER;\n\nconst stringRuleCache: { [pattern: string]: RegExp } = {};\nexport const isRegEx = (value: any): value is RegExp => value instanceof RegExp;\n\n/**\n * Tests or parses a regular expression accepting the {@link ParsableRegExp} format.\n *\n * Strings are cached, so there is no need to do additional caching outside this function (as far as the caching would only concern strings).\n */\nexport const parseRegex = <T>(\n  input: T,\n  separators: readonly string[] = [\",\", \" \"]\n): T extends ParsableRegExp ? RegExp : undefined =>\n  isRegEx(input)\n    ? input\n    : isArray(input) // Parse individual specifiers, and join them into one long regex. An empty array is interpreted as \"never\".\n    ? unionOrNever(map(input, (part) => parseRegex(part, separators)?.source)!)\n    : isBoolean(input)\n    ? input // `true` is \"always\", `false` is \"never\"\n      ? /./g\n      : REGEX_NEVER // Matches nothing. End of string followed by something is never the case.\n    : isString(input)\n    ? (stringRuleCache[input] ??= match(\n        input || \"\",\n        /^(?:\\/(.+?)\\/?|(.*))$/gu,\n        (_, regex, text) =>\n          regex\n            ? new RegExp(regex, \"gu\")\n            : unionOrNever(\n                map(\n                  split(\n                    text!,\n                    new RegExp(\n                      `(?<!(?<!\\\\\\\\)\\\\\\\\)[${join(separators, escapeRegEx)}]`\n                    )\n                  ),\n                  (text) =>\n                    text &&\n                    `^${join(\n                      // Split on non-escaped asterisk (Characterized by a leading backslash that is not itself an escaped backslash).\n                      split(text, /(?<!(?<!\\\\)\\\\)\\*/),\n                      (part) =>\n                        escapeRegEx(\n                          // Remove backslashes used for escaping.\n                          replace(part, /\\\\(.)/g, \"$1\")\n                        ),\n                      // Join the parts separated by non-escaped asterisks with the regex wildcard equivalent.\n                      \".*\"\n                    )}$`\n                )\n              )\n      )!)\n    : (undefined as any);\n\n/**\n * Better minifyable version of `String`'s `split` method that allows a null'ish parameter.\n */\nexport const split = <T extends string | Nullish>(\n  s: T,\n  separator: RegExp | string\n): MaybeUndefined<T, string[]> => s?.split(separator) ?? (s as any);\n\n/**\n * Better minifyable version of `String`'s `replace` method that allows a null'ish parameter.\n */\nexport const replace = <T extends string | Nullish>(\n  s: T,\n  match: RegExp,\n  replaceValue: string | ((...args: string[]) => string)\n): T => s?.replace(match, replaceValue as any) ?? (s as any);\n","import {\n  type Domain,\n  type Position,\n  type Rectangle,\n  type ScreenPosition,\n  type Size,\n  type Viewport,\n} from \"@tailjs/types\";\nimport {\n  Binders,\n  F,\n  MAX_SAFE_INTEGER,\n  NOOP,\n  Nullable,\n  T,\n  Unbinder,\n  array,\n  concat,\n  createEventBinders,\n  createTimeout,\n  forEach,\n  isArray,\n  nil,\n  parseBoolean,\n  parseUri,\n  replace,\n  restrict,\n  round,\n  tryCatch,\n  type MaybeUndefined,\n  type Nullish,\n} from \"@tailjs/util\";\nimport { body, document, httpDecode, httpDecrypt } from \"..\";\n\nexport type NodeWithParentElement = Node | EventTarget;\n\nexport let MAX_ANCESTOR_DISTANCE = MAX_SAFE_INTEGER;\n\nexport const forAncestorsOrSelf = <T = any>(\n  el: NodeWithParentElement | Nullish,\n  action: (\n    el: Element,\n    returnValue: (value: T | undefined, replace?: boolean) => void,\n    distance: number\n  ) => any,\n  stoppingCriterion: (el: Element, distance: number) => boolean = (\n    el,\n    distance\n  ) => distance >= MAX_ANCESTOR_DISTANCE\n): T | undefined => {\n  let i = 0;\n  let returnValue: any;\n  let stop = F;\n  while (\n    el?.[\"nodeType\"] === 1 &&\n    !stoppingCriterion(el as Element, i++) &&\n    action(\n      el as Element,\n      (value, replace) => (\n        value != nil &&\n          ((returnValue = value), (stop = replace !== T && returnValue != nil)),\n        T\n      ),\n      i - 1\n    ) !== F &&\n    !stop\n  ) {\n    const prev = el;\n    el = (el as Element).parentElement;\n    if (el === null && (prev as Element)?.ownerDocument !== document) {\n      el = (prev as Element)?.ownerDocument.defaultView?.frameElement;\n    }\n  }\n\n  return returnValue;\n};\n\nexport type AttributeValueType =\n  /**\n   * The normalized attribute value, int the sense it gets trimmed and lowercased.\n   * The empty spring is considered undefined.\n   *\n   * This is the default.\n   */\n  | true\n  | \"z\"\n\n  /**\n   * The attribute value as a boolean or undefined if it does match `0`, `1`, `true`, `false` or \"\".\n   * The empty string matches existence of an attribute `<tag attribute/>`.\n   * If parsing arrays of booleans, the empty string will be considered undefined since that is an empty element in this context.\n   */\n  | \"b\"\n\n  /** The attribute value as a number or undefined if it does not look like a number. */\n  | \"n\"\n\n  /** The raw attribute value. */\n  | false\n  | \"r\"\n\n  /**  The attribute value parsed as JSON. */\n  | \"j\"\n\n  /**  The attribute value parsed as a HTTP encoded string (from @tailjs/util/transport). */\n  | \"h\"\n\n  /**  The attribute value parsed as a client encrypted value (from @tailjs/util/transport). This also supports JSON. */\n  | \"e\"\n\n  /**\n   * This means the attribute value will be parsed as an array with elements separated by `,`.\n   * Whitespace is trimmed, and empty values are considered undefined.\n   *\n   * A type may be included in the tuple to parse the items as this type. In this case unparsable values will be included in the array\n   * as undefined.\n   */\n  | readonly [type?: AttributeValueType & string];\n\ntype ParsedAttributeValue<\n  T extends AttributeValueType | Nullish,\n  EncodedType = any\n> = T extends readonly [infer T extends AttributeValueType]\n  ? ParsedAttributeValue<T>[]\n  : T extends (boolean | \"z\" | Nullish) | \"r\"\n  ? string\n  : T extends \"b\"\n  ? boolean | undefined\n  : T extends \"n\"\n  ? number | undefined\n  : T extends \"j\" | \"h\" | \"e\"\n  ? EncodedType | undefined\n  : never;\n\nexport const parseAttributeValue: <\n  V,\n  Type extends AttributeValueType | Nullish = \"z\"\n>(\n  value: V,\n  type: Type\n) => MaybeUndefined<\n  V,\n  Type extends \"b\"\n    ? boolean\n    : V extends \"\"\n    ? undefined\n    : ParsedAttributeValue<Type>\n> = (value: any, type = \"z\" as any) => {\n  if (value == null || value === \"null\" || (value === \"\" && type !== \"b\"))\n    return undefined;\n\n  switch (type) {\n    case true:\n    case \"z\":\n      return (\"\" + value).trim()?.toLowerCase();\n    case false:\n    case \"r\":\n      value;\n    case \"b\":\n      return value === \"\" || parseBoolean(value);\n    case \"n\":\n      return parseFloat(value);\n    case \"j\":\n      return tryCatch(() => JSON.parse(value), NOOP);\n    case \"h\":\n      return tryCatch(() => httpDecode(value), NOOP);\n    case \"e\":\n      return tryCatch(() => httpDecrypt?.(value), NOOP);\n    default:\n      return isArray(type)\n        ? value === \"\"\n          ? undefined\n          : (\"\" + value)\n              .split(\",\")\n              .map(\n                (value) =>\n                  (value =\n                    value.trim() === \"\"\n                      ? undefined\n                      : parseAttributeValue(value, type![0]))\n              )\n        : undefined;\n  }\n};\n\nexport const attr = <\n  Node extends NodeWithParentElement | Nullish,\n  Type extends AttributeValueType | Nullish = \"z\"\n>(\n  node: Node,\n  name: string,\n  type?: Type\n) => parseAttributeValue((node as any)?.getAttribute(name), type);\n\nexport const setAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string,\n  value: any\n) =>\n  value === nil\n    ? (node as any)?.removeAttribute(name)\n    : (node as any)?.setAttribute(name, \"\" + value);\n\nexport const scopeAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string,\n  type?: AttributeValueType\n) => forAncestorsOrSelf(node, (el, value) => value(attr(el, name, type)));\n\nexport const inElementScope = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) =>\n  forAncestorsOrSelf(node, (el, value) =>\n    value(tagName(el) === name || undefined)\n  );\n\nexport const normalizedAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) => attr(node, name)?.trim()?.toLowerCase();\n\nlet value: string | undefined;\n\nexport const booleanAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) => (value = attr(node, name)) === \"\" || parseBoolean(value);\n\nexport const numericAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) => parseFloat(\"\" + (value = attr(node, name))) ?? undefined;\n\nexport const attributeNames = <\n  T extends NodeWithParentElement | Nullish | Nullish\n>(\n  node: T\n): MaybeUndefined<T, string[]> => (node as any)?.getAttributeNames();\n\nexport const cssProperty = (el: Element, name: string) =>\n  getComputedStyle(el).getPropertyValue(name) || nil;\n\nexport const tagName = <T extends Element | Nullish>(\n  el: T\n): T extends Nullish ? null : string => (el != nil ? (el.tagName as any) : nil);\n\nlet pos: Position;\nexport const relativeScrollPos = (): Position => (\n  (pos = scrollPos(F)),\n  {\n    x: pos.x / (body.offsetWidth - window.innerWidth) || 0,\n    y: pos.y / (body.offsetHeight - window.innerHeight) || 0,\n  }\n);\n\nexport const scrollPos = (int?: boolean): Position => ({\n  x: round(scrollX, int),\n  y: round(scrollY, int),\n});\n\nexport const matchExHash = (href1: string, href2: string) =>\n  replace(href1, /#.*$/, \"\") === replace(href2, /#.*$/, \"\");\n\nlet screenPos: Position | undefined;\nexport const getScreenPos = <T extends Element | Nullish>(\n  el: T,\n  mouseEvent?: MouseEvent,\n  includeFold = T\n): MaybeUndefined<ScreenPosition> =>\n  (screenPos = getPos(el, mouseEvent)) &&\n  (restrict<ScreenPosition>({\n    xpx: screenPos.x,\n    ypx: screenPos.y,\n    x: round(screenPos.x / body.offsetWidth, 4),\n    y: round(screenPos.y / body.offsetHeight, 4),\n    pageFolds: includeFold ? screenPos.y / window.innerHeight : undefined,\n  }) as any);\n\nlet x: number;\nlet y: number;\nexport const getPos = <Nulls>(\n  el: Nullable<Element, Nulls>,\n  mouseEvent?: MouseEvent\n): MaybeUndefined<Nulls, Position> => {\n  return !!mouseEvent?.[\"pointerType\"] && mouseEvent?.pageY != nil\n    ? { x: mouseEvent.pageX, y: mouseEvent.pageY }\n    : el\n    ? (({ x, y } = getRect(el)!), { x, y })\n    : (undefined as any);\n};\n\nlet rect: DOMRect;\nexport const getRect = <Nulls>(\n  el: Nullable<Element, Nulls>\n): MaybeUndefined<Nulls, Rectangle> =>\n  el\n    ? ((rect = el.getBoundingClientRect()),\n      (pos = scrollPos(F)),\n      {\n        x: round(rect.left + pos.x),\n        y: round(rect.top + pos.y),\n        width: round(rect.width),\n        height: round(rect.height),\n      })\n    : (undefined as any);\n\ntype AllMaps = WindowEventMap &\n  GlobalEventHandlersEventMap &\n  DocumentEventMap &\n  HTMLElementEventMap & {\n    freeze: PageTransitionEvent;\n    resume: PageTransitionEvent;\n  };\n\nexport const listen = <K extends keyof AllMaps>(\n  target: {\n    addEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions\n    ): void;\n    removeEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | EventListenerOptions\n    ): void;\n  },\n  name: K | K[],\n  listener: (\n    ev: AllMaps[K extends any[] ? K[number] : K],\n    unbind: Unbinder\n  ) => any,\n  options: AddEventListenerOptions = { capture: true, passive: true }\n): Binders => {\n  name = array(name) as any;\n  return createEventBinders(\n    listener,\n    (listener) =>\n      forEach(name, (name) => target.addEventListener(name, listener, options)),\n    (listener) =>\n      forEach(name, (name) =>\n        target.removeEventListener(name, listener, options)\n      )\n  );\n};\n\nexport const parseDomain = (href: string): Domain => {\n  const { host, scheme, port } = parseUri(href, false, true);\n  return { host: host + (port ? \":\" + port : \"\"), scheme };\n};\n\nexport const getViewportSize = (): Size => ({\n  width: window.innerWidth,\n  height: window.innerHeight,\n});\n\nexport const getViewport = (): Viewport => (\n  (pos = scrollPos(T)),\n  {\n    ...pos,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    totalWidth: body.offsetWidth,\n    totalHeight: body.offsetHeight,\n  }\n);\n\nexport type Overlay = {\n  move(rect: DOMRect | Element): Overlay;\n  text(text: string): Overlay;\n  toggle(show: boolean): Overlay;\n};\nexport const overlay = (\n  rect?: DOMRect | Element,\n  text?: string,\n  pulse?: boolean\n): Overlay => {\n  let backdropEl: HTMLElement | undefined;\n  let textEl: HTMLElement | undefined;\n\n  let currentText = text;\n  let currentRect: DOMRect | undefined = rect as any;\n  const ensureElements = () => {\n    if (backdropEl) return true;\n\n    backdropEl = document.createElement(\"div\");\n    backdropEl.style.cssText =\n      \"position:absolute;border:4px solid blue;pointer-events:none;z-index:100\";\n    body.appendChild(backdropEl);\n\n    textEl = document.createElement(\"div\");\n    textEl.style.cssText =\n      \"position:absolute; font-family: sans-serif; font-size: 14px; right: 0; top: 0;margin:10px\";\n    backdropEl.appendChild(textEl);\n\n    overlay.move(currentRect).text(currentText);\n    return false;\n  };\n\n  const cleaner = createTimeout();\n\n  const overlay = {\n    move(rect: DOMRect | Element | Nullish) {\n      currentRect = rect = (rect as Element).getBoundingClientRect?.() ??\n        rect ?? {\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0,\n        };\n\n      if (!ensureElements()) {\n        return overlay;\n      }\n\n      if (!currentRect!.width) {\n        return overlay.toggle(false);\n      }\n\n      let offset = body.getBoundingClientRect();\n      [\"top\", \"left\", \"width\", \"height\"].forEach((p, i) => {\n        backdropEl!.style[p] = rect![p] - (i < 2 ? offset[p] : 0) + \"px\";\n      });\n      offset = backdropEl!.getBoundingClientRect();\n      textEl!.style.top = (offset.top < 0 ? -offset.top : 0) + \"px\";\n\n      textEl!.style.right =\n        (offset.right > window.innerWidth\n          ? offset.right - window.innerWidth\n          : 0) + \"px\";\n\n      return overlay;\n    },\n    text: (text: string | Nullish) => (\n      ensureElements() && (textEl!.innerText = currentText = text ?? \"\"),\n      overlay\n    ),\n\n    toggle(show: boolean) {\n      if (!backdropEl) {\n        if (!show) return overlay;\n        ensureElements();\n      }\n      backdropEl!.style.transition = show ? \"\" : \"opacity 1s .5s\";\n      backdropEl!.style.opacity = show ? \"1\" : \"0\";\n\n      show\n        ? cleaner(false)\n        : cleaner(() => {\n            if (!backdropEl) return;\n            body.removeChild(backdropEl);\n            backdropEl = textEl = undefined;\n          }, 1100);\n      return overlay;\n    },\n  };\n\n  currentRect && overlay.move(currentRect).text(currentText);\n  pulse && overlay.toggle(true).toggle(false);\n\n  return overlay;\n};\n","import { Nullish } from \"@tailjs/util\";\nimport { TrackedEvent } from \".\";\n\n/** These properties are used to track the state of events as they get collected, and not stored. */\nexport interface EventMetadata {\n  /** Hint to the request handler that new sessions should not be started if all posted events are passive. */\n  passive?: boolean;\n\n  /** Hint that the event has been queued. */\n  queued?: boolean;\n\n  /** Hint to client code, that the event has been posted to the server. */\n  posted?: boolean;\n}\n\nlet metadata: EventMetadata | undefined;\nexport const clearMetadata = <\n  T extends TrackedEvent | Nullish,\n  ClientSide extends boolean\n>(\n  event: T,\n  client: ClientSide\n): T &\n  (ClientSide extends true\n    ? { metadata?: { posted?: undefined } }\n    : { metadata?: undefined }) => (\n  (metadata = event?.metadata) &&\n    (client\n      ? (delete metadata.posted,\n        delete metadata.queued,\n        !Object.entries(metadata).length && delete event.metadata)\n      : delete event.metadata),\n  event as any\n);\n","import {\n  MaybeUndefined,\n  Nullish,\n  forEach,\n  isIterable,\n  isString,\n  map,\n  match,\n} from \"@tailjs/util\";\nimport { ParsableTags, Tag } from \"..\";\n\nconst maybeDecode = <S extends string | Nullish>(s: S): S =>\n  // It qualifies:\n  s &&\n  /^(%[A-F0-9]{2}|[^%])*$/gi.test(s) &&\n  // It needs it:\n  /[A-F0-9]{2}/gi.test(s)\n    ? decodeURIComponent(s)\n    : (s as any);\n\nexport type TagCollection = Map<string, Tag>;\n\nexport const parseTags = <Input extends ParsableTags>(\n  tagString: Input,\n  prefix?: string\n): MaybeUndefined<Input, Tag[]> =>\n  map(collectTags(tagString, prefix)?.values()) as any;\n\nexport const parseTagValue = <Value extends string | Nullish>(\n  value: string | (string | null)[] | null | undefined,\n  tagName = \"tag\"\n): Value => parseTags(tagName + value)?.[0] as any;\n\nlet key: string;\nlet current: Tag | undefined;\nconst collect = (collected: TagCollection, tag: Tag | Nullish) =>\n  tag &&\n  (!(current = collected.get((key = tag.tag + (tag.value ?? \"\")))) ||\n    (current.score ?? 1) < (tag.score ?? 1)) &&\n  collected.set(key, tag);\n\n/**\n * Parses tags from a string or array of strings and collects them in a map to avoid duplicates.\n * In case of ties between tags with the same names and values but with different scores, the highest wins.\n */\nexport const collectTags = <Input extends ParsableTags>(\n  tagString: Input,\n  prefix = \"\",\n  collected: TagCollection = new Map()\n): MaybeUndefined<Input, TagCollection> => {\n  if (!tagString) return undefined as any;\n  if (isIterable(tagString)) {\n    forEach(tagString, (input) => collectTags(input, prefix, collected));\n    return collected as any;\n  }\n\n  /**\n   * [namespace::]name[ws*][(:|=)[ws*]value][`~`score] [( |,|;|&|#) more tags]\n   *\n   * The parts of a tail.j tag are:\n   * 1. Optional namespace (utm, ai, cms).\n   *   - Anything not whitespace, colon (`:`) or tilde (`~`) followed by double colon `::`.\n   * 2. Tag name:\n   *   - Anything not whitespace, colon (`:`), tilde `~` or equality (`=`).\n   * 3. Optional value.\n   *   - Anything not a separator a other whitespace than space (` `).\n   *   - If the value is supposed to contain one of these characters it must be quoted in either single (`\\`) or double quotes (`\"`).\n   *   - The tag name and value are separated by either:\n   *     - `:` - Follows normal writing convention in many languages (`country: Denmark, name: Glottal sound`), or\n   *     - `=` - Is what you typically write in programming.\n   *   - Escaping values within quotes is not required. The last quote followed by a terminator or score ends the value. (`tag1: \"This \"value\" contains\" quotes\" tag2=...`)\n   * 4. Optional score. How much the tag applies to the target (for example audience:investors~9 audience:consumers~3 - very relevant for investors, a little bit for consumers).\n   *   - You can use decimals in the score (e.g. 5.343).\n   *   - The parsed score gets divided by 10, so you should generally aim for values between 0 and 10 since that corresponds to a percentage between 0 and 100%.\n   *     This also means that if you output machine generated scores (could be from an algorithm) they tend to already be between 0 and 1, so here you must multiply them with 10 when encoding the tag to get the intended result.\n   *   - The default is 10 (100 %).\n   *\n   *  Tags are separated by either:\n   *     - Space (` `) (input friendly)\n   *     - Hash tag (`#`) - Some people might do that without thinking about it since that is how they normally write tags\n   *     - Comma (`,`) - How most would intuitively join strings in code),\n   *     - Semicolon (`;`) - CSS style\n   *     - Ampersand - URL query string style.\n   *     - Repeated separators gets ignored so don't worry about empty entries if you write something like `tag1,,,,tag2`.\n   *\n   *   Both namespace, name and value will be URI decoded if they contain %xx anywhere in them.\n   */\n\n  isString(tagString)\n    ? match(\n        tagString,\n        /(?:([^\\s:~]+)::(?![ :=]))?([^\\s~]+?)(?:\\s*[:=]\\s*(?:\"((?:\"[^\"]*|.)*?)(?:\"|$)|'((?:'[^'~]*|.)*?)(?:'|$)|((?: *(?:(?:[^,&;#\\s~])))*))\\s*)?(?: *~ *(\\d*(?:\\.\\d*)?))?(?:[\\s,&;#~]+|$)/g,\n        (_, ns, localName: string, quoted1, quoted2, unquoted, score) => {\n          const name =\n            (ns ? maybeDecode(ns) + \"::\" : \"\") +\n            prefix +\n            maybeDecode(localName);\n\n          let tag: Tag = {\n            tag: name,\n            value: maybeDecode(quoted1 ?? quoted2 ?? unquoted),\n          };\n          score &&\n            parseFloat(score) !== 10 &&\n            (tag.score = parseFloat(score) / 10);\n          collect(collected, tag);\n        }\n      )\n    : collect(collected, tagString);\n\n  return collected as any;\n};\n\nexport const encodeTag = <T extends Tag | null | undefined>(\n  tag: T\n): T extends Tag ? string : null | undefined =>\n  tag == null\n    ? (tag as any)\n    : tag.tag +\n      (tag.value\n        ? \":\" + (/[,&;#~]/.test(tag.value) ? '\"' + tag.value + '\"' : tag.value)\n        : \"\") +\n      (tag.score && tag.score !== 1 ? \"~\" + tag.score * 10 : \"\");\n","import {\n  ParsableTags,\n  TagCollection,\n  collectTags,\n  type Tag,\n} from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  concat,\n  flatMap,\n  forEach,\n  isFunction,\n  isIterable,\n  isPlainObject,\n  isRegEx,\n  isString,\n  join,\n  map,\n  matches,\n  nil,\n  parseBoolean,\n  parseRegex,\n  replace,\n  stop,\n  testRegex,\n  values,\n  type Nullish,\n} from \"@tailjs/util\";\n\nimport {\n  NodeWithParentElement,\n  attr,\n  attributeNames,\n  createElement,\n  cssProperty,\n  forAncestorsOrSelf,\n  matchSelector,\n  trackerConfig,\n} from \"..\";\nimport type { BoundaryData, TagMappings } from \"../..\";\n\nexport const boundaryData = new WeakMap<Node, BoundaryData<true>>();\nexport const getBoundaryData = (el: Node) => boundaryData.get(el);\n\nexport const trackerPropertyName = (name: string, css = F) =>\n  (css ? \"--track-\" : \"track-\") + name;\n\n// const trackerProperty = (\n//   el: Element,\n//   name: string,\n//   value = attr(el, trackerPropertyName(name)),\n//   css = cssProperty(el as Element, trackerPropertyName(name, T))\n// ) => (value ? (css ? value + \" \" + css : value) : css);\n\ntype MatchAttributeRule = readonly [\n  match: RegExp,\n  selector?: string,\n  baseRank?: string\n];\n\ntype CacheMatchRules = [\n  eligibleCache: { [name: string]: boolean },\n  rules: MatchAttributeRule[] | Nullish\n];\n\n/**\n * Extracts an element's tags given an attribute name, and a list of rules about how to match..\n * Since this function is external, its local variables are added as local parameters. Don't tamper.\n *\n * An optional `eligibleCache` can be passed along to speed up rejecting attribute names that definitely don't match anything.\n */\nconst matchAttributeNames = (\n  el: Element | Nullish,\n  cached: CacheMatchRules | Nullish,\n  tags: TagCollection,\n  prefix?: string | boolean,\n  value?: string,\n  eligible?: boolean\n) =>\n  cached?.[1] &&\n  forEach(\n    attributeNames(el),\n    (name) =>\n      (cached[0][name] ??=\n        ((eligible = F),\n        isString(\n          (prefix =\n            // No cache. Let's loop through them then.\n            forEach(\n              cached[1],\n              ([match, selector, prefix], _) =>\n                testRegex(name, match) &&\n                // Sneakily we \"delete\" the eligible flag, so the skipNameCache's `??=` assignment will always be reevaluated.\n                // If this code branch is never hit, we return the initial value `false`, and this check will never be performed again.\n                // We do this check before the selector check, since this result is not generally cacheable.\n                ((eligible = undefined),\n                !selector || matchSelector(el, selector)) &&\n                stop(prefix ?? name)\n            ))\n        ) && // The empty string is also \"true\" since it means presence of the attribute without a value (as in `<div tag-yes />).\n          (!(value = el!.getAttribute(name)!) || parseBoolean(value)) &&\n          collectTags(value, replace(prefix, /\\-/g, \":\"), tags),\n        eligible))\n  );\n\n// We cache the tracker configuration's rules for tag mappings.\nlet cachedTagMapper: (el: Element, tags: TagCollection) => void = () => {};\nlet cachedMappings: TagMappings | undefined;\nconst parseTagAttributes = (el: Element, tags: TagCollection) => {\n  if (cachedMappings === (cachedMappings = trackerConfig.tags)) {\n    return cachedTagMapper(el, tags);\n  }\n\n  const parse = (rule: TagMappings[string]): MatchAttributeRule[] =>\n      !rule\n        ? []\n        : isRegEx(rule)\n        ? [[rule]]\n        : isIterable(rule)\n        ? flatMap(rule, parse)\n        : [\n            isPlainObject(rule)\n              ? [parseRegex(rule.match)!, rule.selector, rule.prefix]\n              : [parseRegex(rule)!],\n          ],\n    cache: CacheMatchRules = [\n      {},\n      // Start by checking whether we have any of the good ol', documented, \"tail.js official\" tag attributes.\n      [[/^(?:track\\-)?tags?(?:$|\\-)(.*)/], ...parse(values(cachedMappings))],\n    ];\n\n  (cachedTagMapper = (el: Element, tags: TagCollection) =>\n    matchAttributeNames(el, cache, tags))(el, tags);\n};\n\nconst cssPropertyWithBase = (el: Element, name: string) =>\n  join(\n    concat(\n      cssProperty(el, trackerPropertyName(name, T)),\n      cssProperty(el, trackerPropertyName(\"base-\" + name, T))\n    ),\n    \" \"\n  );\n\n// We cannot cache as broadly for CSS based rules, so we cache per selector instead.\nconst parsedCssRules: {\n  [rule: string]: CacheMatchRules;\n} = {};\n\nconst parseCssMappingRules = (\n  el: Element,\n  tags: TagCollection,\n  rulesString = cssPropertyWithBase(el, \"attributes\")\n) => {\n  rulesString &&\n    matchAttributeNames(\n      el,\n      (parsedCssRules[rulesString] ??= [\n        {},\n        matches(\n          rulesString,\n          /(?:(\\S+)\\:\\s*)?(?:\\((\\S+)\\)|([^\\s,:]+))\\s*(?!\\S*\\:)/g,\n          (_, prefix, rule1, rule2) =>\n            [parseRegex(rule1 || rule2), , prefix] as const\n        ),\n      ]),\n      tags\n    );\n  collectTags(cssPropertyWithBase(el, \"tags\"), undefined, tags);\n};\n\nlet currentBoundaryData: BoundaryData<true> | Nullish;\nexport const trackerProperty = (\n  el: Element,\n  name: string,\n  inherit:\n    | boolean\n    | ((el: NodeWithParentElement, distance: number) => boolean) = F,\n  boundaryData?: (el: BoundaryData<true>) => string | Nullish\n): string | null =>\n  (inherit\n    ? forAncestorsOrSelf(\n        el,\n        (el, r) => r(trackerProperty(el, name, F)),\n        isFunction(inherit) ? inherit : undefined\n      )\n    : join(\n        concat(\n          attr(el, trackerPropertyName(name)),\n          cssProperty(el, trackerPropertyName(name, T))\n        ),\n        \" \"\n      )) ??\n  (boundaryData &&\n    (currentBoundaryData = getBoundaryData(el)) &&\n    boundaryData(currentBoundaryData)) ??\n  nil;\n\nlet propertyValue: string | Nullish;\nexport const trackerFlag = (\n  el: Element,\n  name: string,\n  inherit:\n    | boolean\n    | ((el: NodeWithParentElement, distance: number) => boolean) = F,\n  boundaryData?: (data: BoundaryData) => boolean | Nullish\n) =>\n  (propertyValue = trackerProperty(el, name, inherit, boundaryData as any)) ===\n    \"\" || (propertyValue == nil ? propertyValue : parseBoolean(propertyValue));\n\nexport type ParsedTags = { tags?: Tag[] };\n\nexport const parseTags = (\n  sourceEl: Element | Nullish,\n  stoppingCriterion?: (el: Element, distance: number) => boolean,\n  elementTagData?: (el: Element) => ParsableTags,\n  tags?: TagCollection\n): ParsedTags =>\n  !sourceEl\n    ? {}\n    : ((tags ??= new Map()),\n      parseCssMappingRules(sourceEl, tags),\n      forAncestorsOrSelf(\n        sourceEl,\n        (el) => {\n          parseTagAttributes(el, tags!);\n          collectTags(elementTagData?.(el), undefined, tags!);\n        },\n        stoppingCriterion\n      ),\n      tags.size ? { tags: [...tags.values()] } : {});\n\nlet styleElement: Node;\nexport const injectCssDefaults = (document: Document) => {\n  document.body.appendChild(\n    (((styleElement =\n      // --track-base-attributes and --track-base-tags are not set, since they are supposed to be inherited.\n      createElement(\"style\")).innerText = `* { ${trackerPropertyName(\n      \"tags\",\n      T\n    )}:; ${trackerPropertyName(\"attributes\", T)}:;}`),\n    styleElement)\n  );\n};\n","import msgpack from \"@ygoe/msgpack\";\nconst { deserialize: msgDeserialize, serialize: msgSerialize } = msgpack;\n\nimport {\n  IsNever,\n  Nullish,\n  isArray,\n  isFunction,\n  isIterable,\n  isNumber,\n  isObject,\n  isPlainObject,\n  isString,\n  isSymbol,\n  map,\n  tryCatch,\n  undefined,\n  IDENTITY,\n} from \"@tailjs/util\";\nimport { HashFunction, from64u, lfsr, to64u } from \".\";\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\nexport type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the contract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properties that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param binary whether to serialize to a string (URL safe base 64) or Uint8Array. @default false\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  <Binary extends boolean = false>(\n    value: any,\n    binary?: Binary\n  ): Binary extends true ? Uint8Array : string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(\n  encoded: string | Uint8Array | Nullish\n) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\nconst includeValue = (key: any, value: any, includeDefaultValues: boolean) =>\n  isSymbol(key)\n    ? undefined\n    : includeDefaultValues\n    ? value !== undefined\n    : value === null || value;\n\n/**\n * Converts an in-memory object to a format that can be serialized over a wire including cyclic references.\n */\nconst serialize = <Msgpack extends boolean>(\n  value: any,\n  msgpack: Msgpack,\n  { defaultValues = true, prettify = false }\n): Msgpack extends true ? Uint8Array : string => {\n  // TODO: Clone when required instead of adding \"cleaners\". Probably adds more overhead.\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number | undefined;\n  const patchProperty = (\n    target: any,\n    key: any,\n    value = target[key],\n    patched = includeValue(key, value, defaultValues) ? inner(value) : undefined\n  ) => (\n    value !== patched &&\n      (patched === undefined && !isArray(target)\n        ? delete target[key]\n        : (target[key] = patched),\n      addCleaner(() => (target[key] = value))),\n    patched\n  );\n\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (value == null || isFunction(value) || isSymbol(value)) {\n      return undefined;\n    }\n\n    if (!isObject(value)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if ((refIndex = refs?.get(value)) != null) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isPlainObject(value)) {\n      (refs ??= new Map()).set(value, refs.size + 1);\n      for (const key in value) patchProperty(value, key);\n    } else if (isIterable(value) && !(value instanceof Uint8Array)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : // Handle arrays like [value1,,value3,value4,,,value6]. The missing elements does not serialize well with msgpack.\n            ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  return tryCatch(\n    () =>\n      msgpack\n        ? (msgSerialize(inner(value) ?? null) as any)\n        : tryCatch(\n            () => JSON.stringify(value, undefined, prettify ? 2 : 0),\n            () => JSON.stringify(inner(value), undefined, prettify ? 2 : 0)\n          ),\n    true,\n    () => cleaners?.forEach((cleaner) => cleaner())\n  );\n};\n\n/**\n * Hydrates the format returned by {@link serialize} back to its original in-memory format.\n */\nconst deserialize = (value: string | Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value)) return value;\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return inner(\n    isString(value)\n      ? JSON.parse(value)\n      : value != null\n      ? tryCatch(\n          () => msgDeserialize(value),\n          () => (console.error(`Invalid message received.`, value), undefined)\n        )\n      : value\n  );\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<any>\n];\n\nexport interface TransportOptions {\n  /**\n   * Serialize/deserialize as JSON.\n   *\n   * @default false\n   */\n  json?: boolean;\n\n  /**\n   * Omit falsish values (`\"\"`, `0` and `false`) unless explicitly set to `null`.\n   *\n   * @default true\n   */\n  defaultValues?: boolean;\n\n  /** Indent JSON encoded strings. @default true */\n  prettify?: boolean;\n}\n\nlet _defaultTransports: [cipher: Transport, json: Transport] | undefined;\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lfsr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (\n  key?: string | Nullish,\n  options: TransportOptions = {}\n): Transport => {\n  const factory = (\n    key: string | Nullish,\n    { json = false, ...serializeOptions }: TransportOptions\n  ): Transport => {\n    const fastStringHash = (value: any, bitsOrNumeric: any) => {\n      if (isNumber(value) && bitsOrNumeric === true) return value;\n\n      value = isString(value)\n        ? new Uint8Array(map(value.length, (i) => value.charCodeAt(i) & 255))\n        : json\n        ? tryCatch(\n            () => JSON.stringify(value),\n            () => JSON.stringify(serialize(value, false, serializeOptions))\n          )\n        : serialize(value, true, serializeOptions);\n      return hash(value, bitsOrNumeric);\n    };\n    const jsonDecode = (encoded: any) =>\n      encoded == null\n        ? undefined\n        : tryCatch(() => deserialize(encoded), undefined);\n    if (json) {\n      return [\n        (data: any) => serialize(data, false, serializeOptions) as any,\n        jsonDecode,\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ];\n    }\n    const [encrypt, decrypt, hash] = lfsr(key);\n\n    return [\n      (data: any, binary) =>\n        (binary ? IDENTITY : to64u)(\n          encrypt(serialize(data, true, serializeOptions))\n        ) as any,\n      (encoded: any) =>\n        encoded != null\n          ? deserialize(\n              decrypt(\n                encoded instanceof Uint8Array ? encoded : from64u(encoded)\n              )\n            )\n          : null,\n      (value: any, numericOrBits?: any) =>\n        fastStringHash(value, numericOrBits) as any,\n    ];\n  };\n\n  if (!key) {\n    let json = +(options.json ?? 0);\n    if (json && options.prettify !== false) {\n      return (_defaultTransports ??= [\n        factory(null, { json: false }),\n        factory(null, { json: true, prettify: true }),\n      ])[+json];\n    }\n  }\n  return factory(key, options);\n};\n\nexport const defaultTransport = createTransport();\nexport const defaultJsonTransport = createTransport(null, {\n  json: true,\n  prettify: true,\n});\n\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\nexport const [jsonEncode, jsonDecode] = defaultJsonTransport;\n","import { CONSENT_INFO_KEY, SCOPE_INFO_KEY } from \"@constants\";\n\nimport { createTransport } from \"@tailjs/transport\";\nimport { SessionInfo, isTrackedEvent, requireFound } from \"@tailjs/types\";\nimport {\n  F,\n  FOREVER,\n  T,\n  array,\n  assign,\n  filter,\n  flatMap,\n  isArray,\n  isString,\n  map,\n  nil,\n  now,\n  push,\n  remove,\n  sort,\n  throwError,\n  tryCatch,\n  type Nullish,\n} from \"@tailjs/util\";\nimport {\n  Listener,\n  Tracker,\n  TrackerCommand,\n  TrackerClientConfiguration,\n  TrackerExtension,\n  TrackerExtensionFactory,\n  defaultExtensions,\n  isExtensionCommand,\n  isFlushCommand,\n  isGetCommand,\n  isListenerCommand,\n  isSetCommand,\n  isTagAttributesCommand,\n  isToggleCommand,\n  isTrackerAvailableCommand,\n  postUserAgentEvent,\n} from \".\";\nimport {\n  ERR_INTERNAL_ERROR,\n  ERR_INVALID_COMMAND,\n  TrackerContext,\n  VAR_URL,\n  addDebugListeners,\n  addStateListener,\n  createEventQueue,\n  createVariableStorage,\n  errorLogger,\n  httpDecode,\n  isTracker,\n  logError,\n  nextId,\n  setStorageKey,\n  trackerConfig,\n  window,\n} from \"./lib\";\n\nexport let tracker: Tracker;\nexport const initializeTracker = (\n  config: TrackerClientConfiguration | string\n) => {\n  if (tracker) return tracker;\n  let clientEncryptionKey: string;\n  if (isString(config)) {\n    // Decode the temporary key for decrypting the configuration payload.\n    [clientEncryptionKey, config] =\n      httpDecode<[key: string, configuration: any]>(config)!;\n    // Decrypt\n    config = createTransport(clientEncryptionKey)[1](config as any)!;\n  }\n\n  assign(trackerConfig, config);\n\n  setStorageKey(remove(trackerConfig, \"encryptionKey\"));\n\n  const apiProtectionKey = remove(trackerConfig, \"key\");\n\n  const queuedCommands = window[trackerConfig.name]?._ ?? [];\n  if (!isArray(queuedCommands)) {\n    throwError(\n      `The global variable for the tracker \"${trackerConfig.name}\" is used for something else than an array of queued commands.`\n    );\n    return;\n  }\n\n  // Extensions / listeners\n  const extensions: [\n    priority: number,\n    extension: TrackerExtension,\n    source: TrackerExtensionFactory\n  ][] = [];\n  let listeners: Listener[] = [];\n  // Extensions may post commands when constructed and while the tracker is initializing\n\n  const callListeners = (event: string, ...args: any[]) => {\n    let keep = T;\n    listeners = filter(listeners, (listener) =>\n      tryCatch(\n        () => (\n          listener[event]?.(...args, {\n            tracker: tracker,\n            unsubscribe: () => (keep = F),\n          }),\n          keep // Will be set synchronously in the unsubscribe handler before this value is returned.\n        ),\n        errorLogger(listener)\n      )\n    );\n  };\n\n  const pendingStateCommands: TrackerCommand[] = [];\n\n  const trackerContext: TrackerContext = {\n    applyEventExtensions(event) {\n      event.clientId ??= nextId();\n      event.timestamp ??= now();\n\n      insertArgs = T;\n      let skip = F;\n      map(extensions, ([, extension]) => {\n        if (skip || extension.decorate?.(event) === F) {\n          skip = T;\n        }\n      });\n\n      return skip ? undefined : event;\n    },\n    validateKey: (key: string | Nullish, throwIfInvalid = true) =>\n      (!apiProtectionKey && !key) ||\n      key === apiProtectionKey ||\n      ((throwIfInvalid\n        ? throwError(`'${key}' is not a valid key.`)\n        : false) as any),\n  };\n  // Variables\n  const variables = createVariableStorage(VAR_URL, trackerContext);\n\n  // Main\n  const events = createEventQueue(VAR_URL, trackerContext);\n\n  let mainArgs: TrackerCommand[] | null = nil;\n  let currentArg = 0;\n  let insertArgs = F;\n\n  let globalStateResolved = F;\n\n  tracker = ((...commands: (TrackerCommand | string)[]) => {\n    if (!commands.length) {\n      return;\n    }\n\n    let key: string | Nullish;\n    if (commands.length > 1 && (!commands[0] || isString(commands[0]))) {\n      key = commands[0];\n      commands = commands.slice(1);\n    }\n\n    if (isString(commands[0])) {\n      const payload = commands[0];\n      commands = payload.match(/^[{[]/)\n        ? JSON.parse(payload)\n        : httpDecode(payload);\n    }\n\n    let flush = F; // // Flush after these commands, optionally without waiting for other requests to finish (because the page is unloading and we have no better option even though it may split sessions.)\n\n    commands = filter(\n      flatMap(commands, (command) =>\n        isString(command) ? httpDecode<TrackerCommand>(command) : command\n      ),\n      (command) => {\n        if (!command) return F;\n\n        if (isTagAttributesCommand(command)) {\n          trackerConfig.tags = assign(\n            {} as any,\n            trackerConfig.tags,\n            command.tagAttributes\n          );\n        } else if (isToggleCommand(command)) {\n          trackerConfig.disabled = command.disable;\n          return F;\n        } else if (isFlushCommand(command)) {\n          flush = T;\n          return F;\n        } else if (isTrackerAvailableCommand(command)) {\n          command(tracker);\n          return F;\n        }\n        if (\n          !globalStateResolved &&\n          !isListenerCommand(command) &&\n          !isExtensionCommand(command)\n        ) {\n          pendingStateCommands.push(command);\n          return F;\n        }\n        // #endregion\n        return T;\n      }\n    );\n\n    if (!commands.length && !flush) {\n      return;\n    }\n\n    const getCommandRank = (cmd: TrackerCommand) =>\n      isExtensionCommand(cmd)\n        ? -100\n        : isListenerCommand(cmd)\n        ? -50\n        : isSetCommand(cmd)\n        ? -10\n        : isTrackedEvent(cmd)\n        ? 90\n        : 0;\n\n    // Put events last to allow listeners and interceptors from the same batch to work on them.\n    // Sets come before gets to avoid unnecessary waiting\n    // Extensions then listeners are first so they can evaluate the rest.\n    const expanded: TrackerCommand[] = sort(commands, getCommandRank);\n\n    // Allow nested calls to tracker.push from listeners and interceptors. Insert commands in the currently processed main batch.\n    if (\n      mainArgs &&\n      mainArgs.splice(\n        insertArgs ? currentArg + 1 : mainArgs.length,\n        0,\n        ...expanded\n      )\n    )\n      return;\n\n    mainArgs = expanded;\n\n    for (currentArg = 0; currentArg < mainArgs.length; currentArg++) {\n      const command = mainArgs![currentArg];\n\n      if (!command) continue;\n\n      trackerContext.validateKey(key ?? command.key),\n        tryCatch(\n          () => {\n            const command = mainArgs![currentArg];\n            callListeners(\"command\", command);\n            insertArgs = F;\n            if (isTrackedEvent(command)) {\n              events.post(command);\n            } else if (isGetCommand(command)) {\n              variables.get(...array(command.get));\n            } else if (isSetCommand(command)) {\n              variables.set(...array(command.set));\n            } else if (isListenerCommand(command)) {\n              push(listeners, command.listener);\n            } else if (isExtensionCommand(command)) {\n              let extension: TrackerExtension | Nullish;\n              if (\n                (extension = tryCatch(\n                  () => command.extension.setup(tracker),\n                  (e) => logError(command.extension.id, e)\n                )!)\n              ) {\n                push(extensions, [\n                  command.priority ?? 100,\n                  extension,\n                  command.extension,\n                ]);\n                sort(extensions, ([priority]) => priority);\n              }\n            } else if (isTrackerAvailableCommand(command)) {\n              command(tracker); // Variables have already been loaded once.\n            } else {\n              let success = F;\n              for (const [, extension] of extensions) {\n                if ((success = extension.processCommand?.(command) ?? F)) {\n                  break;\n                }\n              }\n              !success &&\n                logError(\n                  ERR_INVALID_COMMAND,\n                  command,\n                  \"Loaded extensions:\",\n                  extensions.map((extension) => extension[2].id)\n                );\n            }\n          },\n          (e) => logError(tracker, ERR_INTERNAL_ERROR, e)\n        );\n    }\n\n    mainArgs = nil;\n    if (flush) {\n      events.post([], { flush });\n    }\n  }) as any;\n\n  Object.defineProperty(window, trackerConfig.name, {\n    value: Object.freeze(\n      Object.assign(tracker, {\n        id: \"tracker_\" + nextId(),\n        events,\n        variables,\n        [isTracker]: T,\n      })\n    ),\n    configurable: false,\n    writable: false,\n  });\n\n  // TODO: Add conditional compiler flag.\n  addDebugListeners();\n\n  addStateListener(async (event, _1, _2, unbind) => {\n    // Make sure we have a session on the server before posting anything.\n    // As part of this, we also get the device session ID.\n    if (event === \"ready\") {\n      const session = requireFound(\n        (\n          await variables.get(\n            {\n              scope: \"session\",\n              key: SCOPE_INFO_KEY,\n              refresh: true,\n            },\n            {\n              scope: \"session\",\n              key: CONSENT_INFO_KEY,\n              // Refresh the consent status at every new page view in the case the server made changes in the background.\n              // After that, cache it indefinitely since it is presumably only changed by the client until the next page view (in any tab).\n              refresh: true,\n              cache: FOREVER,\n            }\n          )\n        )[0]\n      ).value as SessionInfo;\n      trackerContext.deviceSessionId = session.deviceSessionId;\n\n      if (!session.hasUserAgent) {\n        postUserAgentEvent(tracker);\n        session.hasUserAgent = true;\n      }\n      globalStateResolved = true;\n      pendingStateCommands.length && tracker(pendingStateCommands);\n\n      unbind();\n\n      tracker(\n        ...map(defaultExtensions, (extension) => ({ extension })),\n        ...queuedCommands,\n        { set: { scope: \"view\", key: \"loaded\", value: true } }\n      );\n    }\n  }, true);\n\n  return tracker;\n};\n","import { SCOPE_INFO_KEY } from \"@constants\";\n\nimport {\n  LocalID,\n  View,\n  ViewEvent,\n  ViewTimingData,\n  isEventPatch,\n  isViewEvent,\n} from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  add,\n  array,\n  clock,\n  createEvent,\n  createTimer,\n  forEach,\n  map,\n  nil,\n  now,\n  parseQueryString,\n  parseUri,\n  push,\n  replace,\n} from \"@tailjs/util\";\nimport { TrackerExtensionFactory, isChangeUserCommand } from \"..\";\nimport { tracker } from \"../initializeTracker\";\nimport {\n  TAB_ID,\n  addPageVisibleListener,\n  getActiveTime,\n  getViewport,\n  isInternalUrl,\n  listen,\n  matchExHash,\n  nextId,\n  parseDomain,\n  setLocalVariables,\n  tryGetVariable,\n} from \"../lib\";\n\nexport let currentViewEvent: ViewEvent | undefined;\n\nexport const getCurrentViewId = () => currentViewEvent?.clientId;\n\nlet pushPopNavigation: ViewEvent[\"navigationType\"] | undefined;\n\nconst referrerKey = {\n  scope: \"shared\",\n  key: \"referrer\",\n} as const;\n\nexport const pushNavigationSource = (\n  navigationEventId: LocalID,\n  consumed?: () => void\n) => {\n  tracker.variables.set({\n    ...referrerKey,\n    value: [getCurrentViewId()!, navigationEventId],\n  });\n\n  consumed &&\n    tracker.variables.get({\n      // Grr! Intellisense won't use the constant scope and key values if `...referrerKey`.\n      scope: referrerKey.scope,\n      key: referrerKey.key,\n      result: (current: any, previous: any, poll) =>\n        current?.value\n          ? poll()\n          : previous?.value?.[1] === navigationEventId && consumed(),\n    });\n};\n\nconst totalDuration = createTimer();\nconst visibleDuration = createTimer();\n\nlet activations = 1;\n\nexport const getVisibleDuration = () => visibleDuration();\n\nconst [addViewChangedListener, dispatchViewChanged] =\n  createEvent<[viewEvent: ViewEvent]>();\n\nexport { addViewChangedListener };\n\nexport const createViewDurationTimer = (started?: boolean) => {\n  const totalTime = createTimer(started, totalDuration);\n  const visibleTime = createTimer(started, visibleDuration);\n  const activeTime = createTimer(started, getActiveTime);\n  const activationsCounter = createTimer(started, () => activations);\n  return (toggle?: boolean, reset?: boolean): ViewTimingData => ({\n    totalTime: totalTime(toggle, reset),\n    visibleTime: visibleTime(toggle, reset),\n    activeTime: activeTime(toggle, reset),\n    activations: activationsCounter(toggle, reset),\n  });\n};\n\nconst timer = createViewDurationTimer();\nexport const getViewTimeOffset = () => timer();\n\nconst [addFrameListenerInternal, callOnFrame] =\n  createEvent<[frame: HTMLIFrameElement]>();\nexport const onFrame: typeof addFrameListenerInternal = (\n  listener,\n  triggerCurrent\n) => {\n  triggerCurrent &&\n    forEach(frames as any as Iterable<HTMLIFrameElement>, (frame) =>\n      listener(frame, () => false)\n    );\n  return addFrameListenerInternal(listener);\n};\n//export { addFrameListener as onFrame };\n\nconst knownFrames = new WeakSet<any>();\nconst frames = document.getElementsByTagName(\"iframe\");\n\nexport const context: TrackerExtensionFactory = {\n  id: \"context\",\n  setup(tracker) {\n    clock(\n      () =>\n        forEach(\n          frames as any as Iterable<HTMLIFrameElement>,\n          (frame) => add(knownFrames, frame) && callOnFrame(frame)\n        ),\n      1000\n    ).trigger();\n\n    // View definitions may be loaded asynchronously both before and after navigation happens.\n    // This means the `definition` property of the current view event is updated independently of its creation.\n    // If the event has already been sent, and additional patch event is sent with the definition.\n    // When a definition has been associated with the current view event, it will not be changed.\n    // Instead any new view definition that arrives before the next navigation is assumed to be for the next view event.\n\n    let pendingViewDefinition: View | undefined;\n\n    tracker.variables.get({\n      scope: \"view\",\n      key: \"view\",\n      result: (definition, _, poll) => {\n        if (\n          currentViewEvent == null ||\n          !definition?.value ||\n          currentViewEvent?.definition\n        ) {\n          // Buffer for next navigation.\n          pendingViewDefinition = definition?.value;\n        } else {\n          currentViewEvent.definition = definition.value;\n          if (currentViewEvent.metadata?.posted) {\n            // Send the definition as a patch because the view event has already been posted.\n            tracker.events.postPatch(currentViewEvent, {\n              definition: pendingViewDefinition,\n            });\n          }\n        }\n\n        return poll();\n      },\n    });\n\n    let viewIndex =\n      tryGetVariable({ scope: \"tab\", key: \"viewIndex\" })?.value ?? 0;\n    let tabIndex = tryGetVariable({ scope: \"tab\", key: \"tabIndex\" })?.value;\n\n    if (tabIndex == null) {\n      tabIndex =\n        tryGetVariable({ scope: \"shared\", key: \"tabIndex\" })?.value ??\n        // If we are the only tab, we'll see if we can get the number of previous tabs in the session\n        // from the session info variable.\n        (tryGetVariable({ scope: \"session\", key: SCOPE_INFO_KEY })?.value\n          ?.tabs as number) ??\n        0;\n      setLocalVariables(\n        {\n          scope: \"tab\",\n          key: \"tabIndex\",\n          value: tabIndex,\n        },\n        {\n          scope: \"shared\",\n          key: \"tabIndex\",\n          value: tabIndex + 1,\n        }\n      );\n    }\n\n    let currentLocation: string | null = nil;\n\n    const postView = (force = F) => {\n      if (\n        matchExHash(\"\" + currentLocation, (currentLocation = location.href)) &&\n        !force\n      ) {\n        return;\n      }\n\n      const {\n        source: href,\n        scheme,\n        host,\n      } = parseUri(location.href + \"\", true, true);\n      currentViewEvent = {\n        type: \"view\",\n        timestamp: now(),\n        clientId: nextId(),\n        tab: TAB_ID,\n        href,\n        path: location.pathname,\n        hash: location.hash || undefined,\n        domain: { scheme, host },\n        tabNumber: tabIndex + 1,\n        tabViewNumber: viewIndex + 1,\n        viewport: getViewport(),\n        duration: timer(undefined, true),\n      };\n\n      tabIndex === 0 && (currentViewEvent.firstTab = T);\n      tabIndex === 0 && viewIndex === 0 && (currentViewEvent.landingPage = T);\n\n      setLocalVariables({ scope: \"tab\", key: \"viewIndex\", value: ++viewIndex });\n\n      const qs = parseQueryString(location.href);\n      map(\n        [\"source\", \"medium\", \"campaign\", \"term\", \"content\"],\n        (p, _) =>\n          ((currentViewEvent!.utm ??= {})[p] = array(qs[`utm_${p}`])?.[0])\n      );\n\n      !(currentViewEvent.navigationType = pushPopNavigation) &&\n        performance &&\n        map(\n          performance.getEntriesByType(\"navigation\"),\n          (entry: PerformanceNavigationTiming) => {\n            currentViewEvent!.redirects = entry.redirectCount;\n            currentViewEvent!.navigationType = replace(\n              entry.type,\n              /\\_/g,\n              \"-\"\n            ) as any;\n          }\n        );\n\n      pushPopNavigation = undefined;\n\n      if ((currentViewEvent.navigationType ??= \"navigate\") === \"navigate\") {\n        // Try find related event and parent tab context if any.\n        // And only if navigating (not back/forward/refresh)\n\n        const referrer = tryGetVariable(referrerKey)?.value;\n\n        if (referrer && isInternalUrl(document.referrer)) {\n          currentViewEvent.view = referrer?.[0];\n          currentViewEvent.relatedEventId = referrer?.[1];\n          tracker.variables.set({ ...referrerKey, value: undefined });\n        }\n      }\n\n      // Referrer\n      const referrer = document.referrer || nil;\n      referrer &&\n        !isInternalUrl(referrer) &&\n        (currentViewEvent!.externalReferrer = {\n          href: referrer,\n          domain: parseDomain(referrer),\n        });\n\n      // If we already have a view definition ready, set this on the event, and reset the buffer.\n      currentViewEvent.definition = pendingViewDefinition;\n      pendingViewDefinition = undefined;\n\n      tracker.events.post(currentViewEvent);\n\n      tracker.events.registerEventPatchSource(currentViewEvent!, () => ({\n        duration: getViewTimeOffset(),\n      }));\n\n      dispatchViewChanged(currentViewEvent);\n    };\n\n    addPageVisibleListener((visible) => {\n      if (visible) {\n        visibleDuration(T);\n        ++activations;\n      } else {\n        visibleDuration(F);\n      }\n    });\n\n    listen(\n      window,\n      \"popstate\",\n      () => ((pushPopNavigation = \"back-forward\"), postView())\n    );\n    map([\"push\", \"replace\"], (name) => {\n      const inner = history[(name += \"State\")];\n      history[name] = (...args: any) => {\n        inner.apply(history, args);\n        pushPopNavigation = \"navigate\";\n        postView();\n      };\n    });\n\n    postView();\n\n    return {\n      processCommand: (command) =>\n        isChangeUserCommand(command) &&\n        (tracker(\n          command.username\n            ? { type: \"login\", username: command.username }\n            : { type: \"logout\" }\n        ),\n        T),\n\n      decorate: (event) => {\n        currentViewEvent &&\n          !isViewEvent(event) &&\n          !isEventPatch(event) &&\n          (event.view = currentViewEvent.clientId);\n      },\n    };\n  },\n};\n","import {\n  type ActivatedComponent,\n  type ActivatedContent,\n  type ConfiguredComponent,\n  type Rectangle,\n  type UserInteractionEvent,\n} from \"@tailjs/types\";\nimport {\n  F,\n  MaybeUndefined,\n  Nullish,\n  T,\n  array,\n  concat,\n  filter,\n  flatMap,\n  forEach,\n  get,\n  isString,\n  join,\n  map,\n  max,\n  push,\n  remove,\n  some,\n  unshift,\n  update,\n} from \"@tailjs/util\";\nimport {\n  BoundaryCommand,\n  BoundaryData,\n  TrackerExtensionFactory,\n  isDataBoundaryCommand,\n  isScanComponentsCommand,\n} from \"..\";\nimport {\n  NodeWithParentElement,\n  boundaryData,\n  createImpressionObserver,\n  forAncestorsOrSelf,\n  getRect,\n  parseTags,\n  scanAttributes,\n  trackerProperty,\n} from \"../lib\";\nexport type ActivatedDomComponent = ConfiguredComponent & ActivatedComponent;\n\nexport const componentDomConfiguration = Symbol(\"DOM configuration\");\n\nexport const parseActivationTags = (el: Element) =>\n  parseTags(el, undefined, (el) => map(array(get(boundaryData, el)?.tags)));\n\nconst hasComponentOrContent = (boundary?: BoundaryData<true> | null) =>\n  boundary?.component || boundary?.content;\n\nlet entry: BoundaryData<true> | undefined;\nexport const parseBoundaryTags = (el: Element) => {\n  return parseTags(\n    el,\n    (ancestor) =>\n      ancestor !== el && !!hasComponentOrContent(get(boundaryData, ancestor)),\n    (el) => {\n      entry = get(boundaryData, el)!;\n      return (\n        (entry = get(boundaryData, el)) &&\n        flatMap(concat(entry.component, entry.content, entry), \"tags\")\n      );\n    }\n  );\n};\n\nlet content: ActivatedContent[] | undefined;\nconst stripRects = (\n  component: ActivatedDomComponent,\n  keep?: boolean\n): ActivatedDomComponent =>\n  keep\n    ? component\n    : {\n        ...component,\n        rect: undefined,\n        content:\n          (content = component.content) &&\n          map(content, (content) => ({ ...content, rect: undefined })),\n      };\n\nconst enum IncludeState {\n  Secondary = 0,\n  Primary = 1,\n  Promoted = 2,\n}\n\nexport const getComponentContext = (\n  el: NodeWithParentElement,\n  directOnly = F,\n  includeRegion?: boolean | Nullish\n) => {\n  let collectedContent: ActivatedContent[] = [];\n\n  type Area = {} & string; // For clarity.\n  let collected: (ActivatedDomComponent | Area)[] = [];\n\n  let includeState = IncludeState.Secondary;\n  let rect: Rectangle | undefined;\n  forAncestorsOrSelf(el, (el) => {\n    const entry = get(boundaryData, el);\n    if (!entry) {\n      return;\n    }\n\n    if (hasComponentOrContent(entry)) {\n      const components = filter(\n        array(entry.component),\n        (entry) =>\n          includeState === IncludeState.Secondary ||\n          (!directOnly &&\n            ((includeState === IncludeState.Primary &&\n              entry.track?.secondary !== T) ||\n              entry.track?.promote))\n      );\n\n      rect =\n        ((includeRegion ?? some(components, (item) => item.track?.region)) &&\n          getRect(el)) ||\n        undefined;\n      const tags = parseBoundaryTags(el);\n      entry.content &&\n        unshift(\n          collectedContent,\n          ...map(entry.content, (item) => ({\n            ...item,\n            rect,\n            ...tags,\n          }))\n        );\n\n      components?.length &&\n        (unshift(\n          collected,\n          ...map(\n            components,\n            (item) => (\n              (includeState = max(\n                includeState,\n                item.track?.secondary // INV: Secondary components are only included here if we did not have any components from a child element.\n                  ? IncludeState.Primary\n                  : IncludeState.Promoted\n              )),\n              stripRects(\n                {\n                  ...item,\n                  content: collectedContent,\n                  rect,\n                  ...tags,\n                },\n                !!rect\n              )\n            )\n          )\n        ),\n        (collectedContent = []));\n    }\n\n    const area = entry.area || trackerProperty(el, \"area\");\n    area && unshift(collected, ...map(array(area)));\n  });\n\n  let areaPath: string[] | undefined;\n  let components: ActivatedComponent[] | undefined;\n\n  if (collectedContent.length) {\n    // Content without a containing component is gathered in an ID-less component.\n    push(collected, stripRects({ id: \"\", rect, content: collectedContent }));\n  }\n\n  forEach(collected, (item) => {\n    if (isString(item)) {\n      push((areaPath ??= []), item);\n    } else {\n      item.area ??= join(areaPath, \"/\");\n      unshift((components ??= []), item);\n    }\n  });\n\n  return components || areaPath\n    ? { components: components, area: join(areaPath, \"/\") }\n    : undefined;\n};\n\nexport const components: TrackerExtensionFactory = {\n  id: \"components\",\n  setup(tracker) {\n    const impressions = createImpressionObserver(tracker);\n\n    const normalizeBoundaryData = <T extends BoundaryData | Nullish>(\n      data: T\n    ): MaybeUndefined<T, BoundaryData<true>> =>\n      data == null\n        ? (undefined as any)\n        : ({\n            ...data,\n            component: array(data.component),\n            content: array(data.content),\n            tags: array(data.tags),\n          } as BoundaryData<true>);\n\n    const registerComponent = ({\n      boundary: el,\n      ...command\n    }: BoundaryCommand) => {\n      update(boundaryData, el, (current) =>\n        normalizeBoundaryData(\n          \"add\" in command\n            ? {\n                ...current,\n                component: concat(current?.component, command.component),\n                content: concat(current?.content, command.content),\n                area: command?.area ?? current?.area,\n                tags: concat(current?.tags, command.tags),\n                cart: command.cart ?? current?.cart,\n                track: command.track ?? current?.track,\n              }\n            : \"update\" in command\n            ? command.update(current)\n            : command\n        )\n      );\n\n      impressions(el, get(boundaryData, el));\n    };\n\n    return {\n      decorate(eventData) {\n        // Strip tracking configuration.\n        forEach((eventData as UserInteractionEvent).components, (component) =>\n          remove(component as any, \"track\")\n        );\n      },\n      processCommand(cmd) {\n        return isDataBoundaryCommand(cmd)\n          ? (registerComponent(cmd), T)\n          : isScanComponentsCommand(cmd)\n          ? (map(\n              scanAttributes(cmd.scan.attribute, cmd.scan.components),\n              registerComponent\n            ),\n            T)\n          : F;\n      },\n    };\n  },\n};\n","import {\n  Defined,\n  Falsish,\n  If,\n  IsAny,\n  MaybePromise,\n  NotFunction,\n  Nullish,\n  OmitNullish,\n  TogglePromise,\n  UnwrapPromiseLike,\n  Wrapped,\n  isObject,\n  isArray,\n  isBoolean,\n  isError,\n  isFunction,\n  isString,\n  unwrap,\n  MaybeUndefined,\n  ToggleReadonly,\n  isAwaitable,\n  MaybeOmit,\n} from \"..\";\n\nexport type ErrorGenerator = string | Error | (() => string | Error);\n\nexport const throwError = (\n  error: ErrorGenerator,\n  transform: (string: string) => Error = (message) => new Error(message)\n): never => {\n  throw isString((error = unwrap(error))) ? transform(error) : error;\n};\n\ntype CombineTypeTests<T> = T extends []\n  ? {}\n  : T extends [infer F, ...infer Rest]\n  ? F extends (value: any) => value is infer R\n    ? (IsAny<R> extends true ? T : R) & CombineTypeTests<Rest>\n    : never\n  : never;\n\nexport const validate = <\n  T,\n  Validator extends\n    | ((candidate: T) => candidate is any)\n    | ((candidate: T) => R)\n    | [\n        validate: (candidate: T) => any,\n        ...typeTests: ((candidate: T) => candidate is any)[]\n      ]\n    | (R & NotFunction),\n  R\n>(\n  value: T,\n  validate: Validator | R,\n  validationError?: ErrorGenerator,\n  undefinedError?: ErrorGenerator\n): Defined<\n  If<\n    IsAny<Validator>,\n    T,\n    Validator extends readonly [any, ...infer TypeTests]\n      ? CombineTypeTests<TypeTests>\n      : Validator extends ((value: any) => infer R) | infer R\n      ? R extends Falsish\n        ? never\n        : Validator extends (value: any) => value is infer R\n        ? Defined<R>\n        : T\n      : never\n  >\n> =>\n  (\n    isArray(validate)\n      ? validate.every((test) => test(value))\n      : isFunction(validate)\n      ? validate(value)\n      : validate\n  )\n    ? value\n    : required(value, undefinedError ?? validationError) &&\n      (throwError(validationError ?? \"Validation failed.\") as any);\n\nexport class InvariantViolatedError extends Error {\n  constructor(invariant?: string) {\n    super(invariant ? \"INV: \" + invariant : \"An invariant was violated.\");\n  }\n}\n\nexport const structuralEquals = (\n  value1: any,\n  value2: any,\n  depth = -1\n): boolean => {\n  if (value1 === value2) return true;\n  // interpret `null` and `undefined` as the same.\n  if ((value1 ?? value2) == null) return true;\n\n  if (isObject(value1) && isObject(value2) && value1.length === value2.length) {\n    let n = 0;\n    for (const key in value1) {\n      if (\n        value1[key] !== value2[key] &&\n        !structuralEquals(value1[key], value2[key], depth - 1)\n      ) {\n        return false;\n      }\n      ++n;\n    }\n    return n === Object.keys(value2).length;\n  }\n  return false;\n};\n\n/** Tests whether a value equals at least one of some other values.  */\nexport const equalsAny: <T extends readonly any[]>(\n  target: any,\n  ...values: T\n) => target is T[number] = ((\n  target: any,\n  singleValue: any,\n  ...otherValues: any\n) =>\n  target === singleValue ||\n  (otherValues.length > 0 &&\n    otherValues.some((value: any) => equalsAny(target, value)))) as any;\n\n/**\n * States an invariant.\n */\nexport const invariant = <T>(\n  test: Wrapped<T | false>,\n  description?: string\n): Defined<T> => {\n  const valid = unwrap(test);\n  return valid != null && valid !== false\n    ? (valid as any)\n    : throwError(new InvariantViolatedError(description));\n};\n\nexport const required = <T>(value: T, error?: ErrorGenerator): OmitNullish<T> =>\n  value != null\n    ? (value as any)\n    : throwError(\n        error ?? \"A required value is missing\",\n        (text) => new TypeError(text.replace(\"...\", \" is required.\"))\n      );\n\nexport const tryCatch = <T, E = true>(\n  expression: () => T,\n  errorHandler: E | (boolean | ((error?: any) => any) | Nullish) = true as any,\n  always?: () => void\n):\n  | T\n  | (E extends Nullish | true\n      ? never\n      : E extends false\n      ? undefined\n      : E extends (...args: any) => infer R\n      ? R extends Error\n        ? never\n        : R extends void\n        ? undefined\n        : R\n      : E) => {\n  try {\n    return expression();\n  } catch (e) {\n    return isFunction(errorHandler)\n      ? isError((e = errorHandler(e)))\n        ? throwError(e)\n        : e\n      : isBoolean(errorHandler)\n      ? console.error(errorHandler ? throwError(e) : e)\n      : (errorHandler as any);\n  } finally {\n    always?.();\n  }\n};\n\nexport type ErrorHandler = Nullish | boolean | ((error: any) => any);\ntype ErrorHandlerResult<Handler> = Handler extends true\n  ? never\n  : Handler extends (...args: any) => infer R\n  ? TogglePromise<UnwrapPromiseLike<R> extends Error ? never : R, R>\n  : void;\n\nconst maybeAwait = <T, R>(value: MaybePromise<T>, action: (value: T) => R): R =>\n  (value as any)?.then(action) ?? action(value as any);\n\nconst handleError = <Handler extends ErrorHandler>(\n  errorHandler: Handler,\n  error: any,\n  log = true\n): ErrorHandlerResult<Handler> =>\n  errorHandler === false\n    ? undefined\n    : errorHandler === true ||\n      errorHandler == null ||\n      isError((error = errorHandler(error)))\n    ? maybeAwait(\n        error,\n        (error) => (log && console.error(error), throwError(error))\n      )\n    : error;\n\ntype DeferredProperties<T> = { resolved?: Awaited<T> };\n\ntype NotDeferred = { resolved?: undefined };\n\nexport type Deferred<T> = (() => T) & DeferredProperties<T>;\n\nexport type DeferredAsync<T> = Deferred<MaybePromise<T>>;\n\nexport type MaybeDeferred<T> = (T & NotDeferred) | Deferred<T>;\nexport type MaybeDeferredAsync<T> =\n  | ((T | PromiseLike<T>) & NotDeferred)\n  | DeferredAsync<T>;\n\nexport const resolveDeferred: {\n  <T>(value: Deferred<T>): T;\n  <T>(value: T): T;\n} = (value: Deferred<any>) =>\n  isFunction(value) ? (value as any)?.resolved ?? value() : value;\n\n/** A value that is initialized lazily on-demand. */\nexport const deferred = <T>(\n  expression: Wrapped<T>\n): T extends PromiseLike<infer T> ? DeferredAsync<T> : Deferred<T> => {\n  let result: any;\n  const getter = (() => {\n    if (getter.initialized || result) {\n      // Result may either be the resolved value or a pending promise for the resolved value.\n      return result;\n    }\n    result = unwrap(expression) as any;\n    if (result.then) {\n      return (result = result.then((resolvedValue: any) => {\n        getter.initialized = true;\n        return (getter.resolved = result = resolvedValue);\n      }));\n    }\n    getter.initialized = true;\n    return (getter.resolved = result);\n  }) as any;\n  return getter;\n};\n\nexport const asDeferred = <T extends MaybeDeferred<any>>(\n  deferredOrResolved: T\n): T extends Deferred<any> ? T : Deferred<T> =>\n  isFunction(deferredOrResolved)\n    ? deferredOrResolved\n    : (Object.assign(() => deferredOrResolved, {\n        resolved: isAwaitable(deferredOrResolved)\n          ? undefined\n          : deferredOrResolved,\n      }) as any);\n\nexport interface DeferredPromise<T> extends PromiseLike<T> {\n  initialized: boolean;\n}\n\nexport type MaybeDeferredPromise<T> =\n  | (T & { initialized?: boolean })\n  | DeferredPromise<T>;\n\n/**\n * A promise that is initialized lazily on-demand.\n * For promises this is more convenient than {@link deferred}, since it just returns a promise instead of a function.\n */\nexport const deferredPromise = <T>(\n  expression: Wrapped<MaybePromise<T>>\n): DeferredPromise<T> => {\n  let promise: DeferredPromise<T> = {\n    initialized: true,\n    then: thenMethod(() => ((promise.initialized = true), unwrap(expression))),\n  };\n  return promise;\n};\n\nexport const thenMethod = <T>(\n  expression: Wrapped<MaybePromise<T>>\n): (<TResult1 = T, TResult2 = never>(\n  onfulfilled?:\n    | ((value: T) => TResult1 | PromiseLike<TResult1>)\n    | undefined\n    | null,\n  onrejected?:\n    | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n    | undefined\n    | null\n) => PromiseLike<TResult1 | TResult2>) => {\n  let result = deferred(expression);\n  return (onfullfilled?, onrejected?) =>\n    tryCatchAsync(result, [onfullfilled, onrejected] as any);\n};\n\nexport const tryCatchAsync = async <\n  T,\n  C = void,\n  E extends boolean | ((error: any) => MaybePromise<C>) = true,\n  T1 = T\n>(\n  expression: Wrapped<MaybePromise<T>>,\n  errorHandler: E = true as any,\n  always?: () => MaybePromise<any>\n): Promise<T1 | C> => {\n  try {\n    const result = (await unwrap(expression)) as any;\n    return isArray(errorHandler) ? errorHandler[0]?.(result) : result;\n  } catch (e) {\n    if (!isBoolean(errorHandler)) {\n      if (isArray(errorHandler)) {\n        if (!errorHandler[1]) throw e;\n        return errorHandler[1](e) as any;\n      }\n\n      const error = (await (errorHandler as any)?.(e)) as any;\n      if (error instanceof Error) throw error;\n      return error;\n    } else if (errorHandler) {\n      throw e;\n    } else {\n      // `false` means \"ignore\".\n      console.error(e);\n    }\n  } finally {\n    await always?.();\n  }\n\n  return undefined as any;\n};\n\n/**\n *  No-op function to validate types in TypeScript. Because function parameters are contravariant, passing an event that does not match on all properties will get red wiggly lines)\n */\nexport const restrict: {\n  <T>(item: T): T;\n} = (item: any) => item as any;\n","import {\n  Defined,\n  Extends,\n  IsAny,\n  MaybeUndefined,\n  ToggleReadonly,\n  tryCatch,\n} from \"..\";\n\n/**\n * The ECMAScript primitive types.\n */\nexport type Primitives =\n  | null\n  | undefined\n  | void\n  | boolean\n  | number\n  | bigint\n  | string\n  | symbol\n  | Date;\n\nexport type NonAsync =\n  | Primitives\n  | Iterable<any>\n  | ((...args: any[]) => any)\n  | RecordType;\n\n/**\n * Common function type used for projection of [key,value] entries.\n */\nexport type KeyValueProjection<K, V, R> = (\n  entry: [key: K, value: V],\n  index: number\n) => R;\n\n/**\n * Anything but a promise.\n */\nexport type NotPromise = { then?: never };\n\n/**\n * Anything but a function.\n */\nexport type NotFunction =\n  | bigint\n  | boolean\n  | null\n  | number\n  | string\n  | symbol\n  | undefined\n  | {\n      [key: string | number | symbol]: any;\n      [Symbol.hasInstance]?: never;\n    };\n\n/** Shorter than writing all this out, and slightly easier to read. */\nexport type Nullish = null | undefined;\n\n/** A record type that is neither iterable or a function. */\nexport type RecordType<K extends keyof any = keyof any, V = any> = object & {\n  readonly [P in K]?: V;\n} & {\n  [Symbol.iterator]?: never;\n  [Symbol.asyncIterator]?: never;\n  [Symbol.hasInstance]?: never;\n\n  then?(\n    onfulfilled?: ((value: any) => any) | undefined | null,\n    onrejected?: ((reason: any) => any) | undefined | null\n  ): never;\n};\n\nexport type UnwrapPromiseLike<T> = T extends PromiseLike<infer T>\n  ? UnwrapPromiseLike<T>\n  : T;\n\nexport type MaybePromise<T> = T | PromiseLike<T>;\n/**\n * Shorthand for a value that is optionally awaitable.\n */\nexport type TogglePromise<T, Toggle = boolean> = Toggle extends\n  | true\n  | PromiseLike<any>\n  ? T extends PromiseLike<any>\n    ? T\n    : PromiseLike<T>\n  : T extends PromiseLike<infer T>\n  ? UnwrapPromiseLike<T>\n  : T;\n\n/**\n * Trick for having a function that returns a non-null value, if a formal parameter always has a non-null value,\n * similar to .NET's [NotNullIfNotNull].\n *\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n *\n * @obsolete\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\n/** All keys of any type in a union */\nexport type AllKeys<Ts> = Ts extends infer T\n  ? unknown extends T\n    ? keyof any\n    : keyof T\n  : never;\n\n/** If any type in a union has a value for the given property that cannot be null'ish.*/\nexport type HasRequiredProperty<T, P> = true extends (\n  T extends infer T\n    ? true extends Extends<\n        Nullish,\n        keyof T extends P ? T[P & keyof T] : P extends keyof T ? T[P] : never\n      >\n      ? false\n      : true\n    : never\n)\n  ? true\n  : false;\n\nexport type IfNever<T, Default> = [T] extends [never] ? Default : T;\n\nexport type Filter<T, FilterTypes, Default = never> = IfNever<\n  T extends infer T ? (T extends FilterTypes ? T : never) : never,\n  Default\n>;\n\n/** Returns the type of a property for each type in a union when the type has the given property. */\nexport type Property<T, P> = T extends infer T\n  ? keyof T extends P\n    ? T[P & keyof T]\n    : P extends keyof T\n    ? T[P]\n    : never\n  : never;\n\n/**\n * Creates a new type where with all the properties from any of the specified types.\n * This can make life easier for code working with polymorphic types.\n */\n\nexport type CommonTypeTemplate<Ts> = {\n  [P in AllKeys<Ts>]?: Ts extends infer T\n    ? P extends keyof T\n      ? T[P]\n      : never\n    : never;\n};\n\n/**\n * Maps all null'ish types to `undefined`.\n */\nexport type Undefined<T> = T extends Nullish | void ? undefined : T;\n\nexport type ExpandTypes<\n  Ts,\n  Common = CommonTypeTemplate<Ts>\n> = Ts extends infer T\n  ? {\n      [P in keyof Common]: P extends keyof T ? T[P] : Common[P];\n    }\n  : never;\n\n/* JSON */\n\nexport type JsonArray = Json[];\n\nexport type JsonTuple = {\n  [TupleIndex in number]?: Json;\n};\n\nexport type JsonObject = {\n  [props: string | number]: Json;\n} & { [symbols: symbol]: never };\n\ntype JsonOnly<T> = T extends Json ? T : never;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Json<T = unknown> = unknown extends T\n  ? Nullish | string | number | boolean | JsonArray | JsonTuple | JsonObject\n  : Omit<\n      {\n        [P in keyof T]: JsonOnly<T[P]>;\n      },\n      symbol\n    >;\n\nexport type ToJsonAble<T> = { toJSON(): T };\n\n/** Minify friendly version of `false`. */\nexport const undefined = void 0;\n\n/** Caching this value potentially speeds up tests rather than using `Number.MAX_SAFE_INTEGER`. */\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/** Caching this value potentially speeds up tests rather than using `Number.MAX_SAFE_INTEGER`. */\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\n\n/** Minify friendly version of `false`. */\nexport const F = false;\n\n/** Minify friendly version of `true`. */\nexport const T = true;\n\n/** Minify friendly version of `null`. */\nexport const nil = null;\n\nexport type NoOpFunction = (...args: any) => void;\n\n/** A function that does nothing. */\nexport const NOOP: NoOpFunction = () => {};\n\nexport type IdentityFunction = <T>(item: T, ...args: any) => T;\n\n/** The identity function (x)=>x. */\nexport const IDENTITY: IdentityFunction = (item: any) => item;\n\nexport type NullFilterFunction = <T>(item: T | Nullish) => boolean;\n\n/** A function that filters out values != null. */\nexport const FILTER_NULLISH: NullFilterFunction = (item: any) => item != nil;\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = <V, P extends boolean = true>(\n  value: V,\n  parse?: P\n) => T extends Nullish\n  ? undefined\n  : V extends T\n  ? V\n  : (true extends P ? T : never) | undefined;\n\n/** Using this cached value speeds up testing if an object is iterable seemingly by an order of magnitude. */\nexport const symbolIterator = Symbol.iterator;\n\n/** Using this cached value speeds up testing if an object is iterable seemingly by an order of magnitude. */\nexport const symbolAsyncIterator = Symbol.asyncIterator;\n\nexport const createTypeConverter =\n  <T>(\n    typeTester: TypeTester<T>,\n    parser?: (value: any) => T | undefined\n  ): TypeConverter<T> =>\n  (value: any, parse = true as any) =>\n    typeTester(value)\n      ? value\n      : parser && parse && value != null && (value = parser(value)) != null\n      ? value\n      : (undefined as any);\n\nexport const ifDefined = <T, P, R>(\n  value: T,\n  resultOrProperty: (\n    | (AllKeys<T> & (keyof any & {}))\n    | ((value: Exclude<T, Nullish>) => R)\n  ) &\n    P\n): MaybeUndefined<T, P extends keyof any ? Exclude<T, Nullish> : R> =>\n  isFunction(resultOrProperty)\n    ? value !== undefined\n      ? (resultOrProperty(value as any) as any)\n      : undefined\n    : value?.[resultOrProperty as any] !== undefined\n    ? value\n    : undefined;\n\nexport const isNullish = (value: any): value is undefined | void | null =>\n  value == null;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\n\nexport const parseBoolean = createTypeConverter(isBoolean, (value) =>\n  value == 0 // Both numbers and string with the value 0 or 1\n    ? false\n    : value == 1\n    ? true\n    : value === \"false\"\n    ? false\n    : value === \"true\"\n    ? true\n    : undefined\n);\n\nexport const isTruish = <T>(value: T): value is Exclude<T, Falsish> => !!value;\n\nexport const isTrue = (value: any): value is true => value === T;\nexport const isNotTrue = <T>(value: T): value is Exclude<T, true> =>\n  value !== T;\n\nexport type Falsish = void | null | undefined | 0 | \"\" | false;\n\nexport const isFalsish = (value: any): value is Falsish => !value;\n\nexport const isFalse = (value: any): value is false => value === F;\nexport const isNotFalse = <T>(value: T): value is Exclude<T, false> =>\n  value !== F;\n\n/** An array where it is easy to conditionally leave elements out like `[\"item1\", condition&&\"item2\", undefined]`. */\nexport type MaybeFalsish<T> = T extends readonly (infer Item)[]\n  ? ToggleReadonly<MaybeFalsish<Item>[], T>\n  : T | Falsish;\n\nexport const truish: {\n  <T>(items: Iterable<T | Falsish>, keepUndefined?: false): T[];\n  <T>(items: Iterable<T>, keepUndefined: true): (T extends Falsish\n    ? undefined\n    : T)[];\n  <T extends { [Symbol.iterator]?: never } | string>(\n    value: T | Falsish\n  ): T extends Falsish ? undefined : Exclude<T, Falsish>;\n} = (value: any, keepUndefined?: boolean) =>\n  isArray(value)\n    ? keepUndefined\n      ? value.map((item) => (!!item ? item : undefined))\n      : value.filter((item: any) => !!item)\n    : !!value\n    ? (value as any)\n    : undefined;\n\nexport const isInteger: (value: any) => value is number =\n  Number.isSafeInteger as any;\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\n\nexport const isFinite: (value: any) => value is number = Number.isFinite as any;\n\nexport const parseNumber = createTypeConverter(isNumber, (value) =>\n  isNaN((value = parseFloat(value))) ? undefined : value\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\n\nexport const parseBigInt = createTypeConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createTypeConverter(isString, (value) =>\n  value?.toString()\n);\n\nexport const isArray: (value: any) => value is any[] = Array.isArray;\n\nexport const isError = (value: any): value is Error => value instanceof Error;\n\n/**\n * Returns the value as an array following these rules:\n * - If the value is undefined (this does not include `null`), so is the return value.\n * - If the value is already an array its original value is returned unless `clone` is true. In that case a copy of the value is returned.\n * - If the value is iterable, an array containing its values is returned\n * - Otherwise, an array with the value as its single item is returned.\n */\nexport const array: {\n  // <T>(value: AsyncIterable<T>, clone?: boolean): MaybeUndefined<\n  //   [T][0],\n  //   Promise<T[]>\n  // >;\n  <T>(value: T, clone?: boolean): T extends Nullish\n    ? undefined\n    : T extends Iterable<infer Item>\n    ? T extends Item[]\n      ? T\n      : Item[]\n    : T[];\n} = (value: any, clone = false as any): any =>\n  value == null\n    ? undefined\n    : !clone && isArray(value)\n    ? value\n    : isIterable(value)\n    ? [...value]\n    : // : isAsyncIterable(value)\n      // ? toArrayAsync(value)\n      ([value] as any);\n\nexport const isObject = (value: any): value is Record<keyof any, any> =>\n  value !== null && typeof value === \"object\";\n\nconst objectPrototype = Object.prototype;\nconst getPrototypeOf = Object.getPrototypeOf;\n\nexport const isPlainObject = (\n  value: any\n): value is RecordType<keyof any, any> =>\n  value != null && getPrototypeOf(value) === objectPrototype;\n\nexport const hasProperty = <P extends keyof any>(\n  value: any,\n  property: P\n): value is { [Prop in P]: any } => isObject(value) && property in value;\n\nexport const hasMethods = <Names extends readonly (keyof any)[]>(\n  value: any,\n  ...names: Names\n): value is {\n  [P in Names[number]]: (...args: any) => any;\n} =>\n  value == null\n    ? false\n    : names.every((name) => typeof value[name] === \"function\");\n\nexport const hasMethod = <Name extends keyof any>(\n  value: any,\n  name: Name\n): value is {\n  [P in Name]: (...args: any) => any;\n} => typeof (value as any)?.[name] === \"function\";\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createTypeConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\n\nexport const isIterable = (\n  value: any,\n  acceptStrings = false\n): value is Iterable<any> =>\n  !!(value?.[symbolIterator] && (typeof value === \"object\" || acceptStrings));\n\nexport const isAsyncIterable = (value: any): value is AsyncIterable<any> =>\n  !!value?.[symbolAsyncIterator];\n\nexport const toIterable = <T>(value: T | Iterable<T>): Iterable<T> =>\n  isIterable(value) ? value : [value];\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\n/**\n * If the value is a promise, it will be awaited.\n */\nexport const awaitIfAwaitable = <T, R>(\n  value: T,\n  action: (value: T extends PromiseLike<infer T> ? T : T) => R\n): TogglePromise<R, T> =>\n  (value as any)?.then?.((value: any) => action(value)) ?? action(value as any);\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == null\n    ? value === null\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\n/**\n * Round a number of to the specified number of decimals.\n */\nexport const round = <T extends number | Nullish>(\n  number: T,\n  decimals?: number | boolean\n): MaybeUndefined<T, number> =>\n  number == null\n    ? (undefined as any)\n    : decimals === false\n    ? number\n    : ((decimals = Math.pow(10, !decimals || decimals === true ? 0 : decimals)),\n      Math.round(number * decimals) / decimals);\n\nexport const isJsonObject = (value: any): value is JsonObject =>\n  isPlainObject(value);\n","import {\n  AllKeys,\n  AnyAll,\n  ArraysAsEmpty,\n  Entries,\n  Extends,\n  FILTER_NULLISH,\n  GeneralizeConstants,\n  If,\n  IfNot,\n  IsAny,\n  IterableOrArrayLike,\n  KeyValuePairsToObject,\n  KeyValueSource,\n  KeyValueSourcesToObject,\n  MAX_SAFE_INTEGER,\n  MaybeArray,\n  MaybeUndefined,\n  Minus,\n  Nullish,\n  OmitNullish,\n  Property,\n  RecordType,\n  StrictUndefined,\n  UndefinedIfEmpty,\n  add,\n  array,\n  get,\n  ifDefined,\n  isObject,\n  isArray,\n  isBoolean,\n  isFalsish,\n  isFunction,\n  isIterable,\n  isMap,\n  isNumber,\n  isPlainObject,\n  isSet,\n  isString,\n  isTruish,\n  symbolIterator,\n  undefined,\n  enumerate,\n  EnumerationSeparators,\n} from \".\";\n\nexport const UTF16MAX = 0xffff;\n\nlet stopInvoked = false;\nexport const stop = (yieldValue?: any) => ((stopInvoked = true), yieldValue);\n\nexport const toCharCodes = (s: string) =>\n  [...new Array(s.length)].map((_, i) => s.charCodeAt(i));\nexport const codePoint = (string: string, index: number = 0) =>\n  string.codePointAt(index)!;\n\nexport type IteratorSource =\n  | Nullish\n  | number\n  | Iterable<any>\n  | RecordType\n  | NavigatingIteratorStep;\n\nexport type IteratorSourceOf<T> =\n  | (T extends number ? number : never)\n  | Iterable<T>\n  | (T extends readonly [infer K, infer V]\n      ? K extends keyof any\n        ? RecordType<K, V>\n        : never\n      : never)\n  | NavigatingIteratorStep<T>;\n\nexport type IteratorItem<S extends IteratorSource> = unknown extends S\n  ? any\n  : S extends number\n  ? number\n  : S extends Iterable<infer T>\n  ? T\n  : S extends RecordType<infer K, infer V>\n  ? readonly [K, V]\n  : S extends ArrayLike<infer T>\n  ? T\n  : S extends (...args: any) => infer T | Nullish\n  ? T\n  : never;\n\nexport type IteratorItems<S extends readonly IteratorSource[]> =\n  S extends readonly [infer S]\n    ? IteratorItem<S & IteratorSource>\n    : S extends readonly [infer S, ...infer Rest]\n    ? IteratorItem<S & IteratorSource> | IteratorItems<Rest & IteratorSource[]>\n    : S extends readonly (infer S)[]\n    ? IteratorItem<S & IteratorSource>\n    : never;\n\nexport interface IteratorControl<S extends IteratorSource> {\n  source: S;\n  prev: IteratorItem<S> | undefined;\n  skip(): void;\n  end(): void;\n  end<P>(value: P): P;\n}\n\nexport type FunctionalIteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = any,\n  Value = IteratorItem<S>\n> = (\n  value: Value,\n  index: number\n) => Projection | readonly [any, any] | typeof stop | Nullish;\n\nexport type IteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = unknown,\n  Value = IteratorItem<S>\n> = AllKeys<IteratorItem<S>> | FunctionalIteratorAction<S, Projection, Value>;\n\n// We need both the inferred return value from the IteratorAction and the IteratorAction itself used as the parameter\n// in functions like `<S extends IteratorSource, Return, Action>(source: S, action: IteratorAction<S,Return> | P)=>IteratorProjection<S,Return,Action>.\n// It is important to set the generic type for Action's default value to undefined\n// This seems to be the only way we can both automatically infer non-readonly tuples from `()=>[\"test\", 1]` as tuples, and at the same time\n// allow property names from the source's items. If we did not include the parameter itself it would not be possible to differentiate\n// between property names and return values.\ntype IteratorProjection<\n  S extends IteratorSource,\n  Return,\n  Action,\n  Default = IteratorItem<S>\n> = Action extends Nullish\n  ? Default\n  : unknown extends Action\n  ? Default\n  : Action extends keyof any\n  ? Exclude<Property<IteratorItem<S>, Action>, Nullish>\n  : Return;\n\ntype IteratorProjectionWithUndefined<\n  S extends IteratorSource,\n  Return,\n  Action,\n  Default = IteratorItem<S>\n> =\n  | IteratorProjection<S, Return, Action, Default>\n  | (Action extends (...args: any) => infer R\n      ? R extends typeof stop\n        ? undefined\n        : StrictUndefined<R>\n      : Action extends keyof any\n      ? StrictUndefined<Property<IteratorItem<S>, Action>>\n      : never) extends infer T\n  ? T\n  : never;\n\ntype StartEndArgs<S extends IteratorSource> =\n  | []\n  | (S extends number\n      ? [offset?: number | Nullish]\n      : S extends NavigatingIteratorStep<infer T>\n      ? [seed?: T, maxIterations?: number]\n      : [start: number | Nullish, end?: number | Nullish]);\n\nexport type NavigatingIteratorStep<T = any> = (\n  current: T | undefined\n) => T | undefined;\n\ntype FlatIteratorItem<T, D extends number = 1, Object = false> = T extends\n  | undefined\n  | void\n  ? never\n  : D extends 0\n  ? T\n  : T extends\n      | Iterable<any>\n      | (Object extends true ? Record<keyof any, any> : never)\n  ? D extends 1\n    ? IteratorItem<T>\n    : FlatIteratorItem<IteratorItem<T>, Minus<D, 1>, Object>\n  : T;\n\nconst wrapProjection = <P>(\n  projection: P | undefined\n): undefined | ((item: any, index: number) => any) =>\n  projection == null\n    ? undefined\n    : isFunction(projection)\n    ? (projection as any)\n    : (item) => item[projection as any];\n\nfunction* createFilteringIterator<S extends IteratorSource, R, P>(\n  source: S,\n  projection?: IteratorAction<S, R> | P\n): Iterable<IteratorProjection<S, R, P>> {\n  if (source == null) return;\n  if (projection) {\n    projection = wrapProjection(projection)!;\n    let i = 0;\n    for (let item of source as any) {\n      if ((item = projection(item, i++)) != null) {\n        yield item;\n      }\n      if (stopInvoked) {\n        stopInvoked = false;\n        break;\n      }\n    }\n  } else {\n    for (let item of source as any) {\n      if (item != null) yield item;\n    }\n  }\n}\n\nfunction* createObjectIterator<S extends Record<keyof any, any>, R, P>(\n  source: S,\n  action?: IteratorAction<S, R> | P\n): Iterable<IteratorProjection<S, P, R>> {\n  action = wrapProjection(action);\n  let i = 0;\n  for (const key in source) {\n    let value = [key, source[key]] as any;\n    action && (value = action(value, i++));\n\n    if (value != null) {\n      yield value;\n    }\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n}\n\nfunction* createRangeIterator(length = 0, offset?: number): Iterable<number> {\n  if (length < 0) {\n    offset ??= -length - 1;\n    while (length++) yield offset--;\n  } else {\n    offset ??= 0;\n    while (length--) yield offset++;\n  }\n}\n\nexport function* createStringIterator(\n  input: string,\n  start: number,\n  end: number\n): Iterable<[char: string, codePoint: number]> {\n  while (start < end) {\n    const codePoint = input.codePointAt(start)!;\n    let p = input[start++];\n    if (codePoint > UTF16MAX) {\n      start++;\n      p = String.fromCodePoint(codePoint);\n    }\n    yield [p, codePoint];\n  }\n}\n\nexport function* createNavigatingIterator<T>(\n  step: NavigatingIteratorStep<T>,\n  start?: T | undefined,\n  maxIterations = Number.MAX_SAFE_INTEGER\n): Iterator<T> {\n  if (start != null) yield start;\n  while (maxIterations-- && (start = step(start)) != null) {\n    yield start;\n  }\n}\n\nconst sliceAction = <S extends IteratorSource, R, P>(\n  action: IteratorAction<S, R> | P,\n  start: any,\n  end: any\n): P =>\n  (start ?? end) !== undefined\n    ? ((action = wrapProjection(action)!),\n      (start ??= 0),\n      (end ??= MAX_SAFE_INTEGER),\n      (value, index) =>\n        start--\n          ? undefined\n          : end!--\n          ? action\n            ? (action as any)(value, index)\n            : value\n          : end)\n    : (action as any);\n\nexport type IteratorFilter<S extends IteratorSource> = (\n  value: IteratorItem<S>,\n  index: number\n) => any;\n\n/** Faster way to exclude null'ish elements from an array than using {@link filter} or {@link map} */\nexport const filterArray = <T extends readonly any[] | undefined>(\n  array: T\n): T extends readonly (infer Item)[] ? OmitNullish<Item>[] : undefined =>\n  array?.filter(FILTER_NULLISH) as any;\n\nconst createIterator = <S extends IteratorSource, R, P>(\n  source: S,\n  projection?: IteratorAction<S, R> | P,\n  start?: any,\n  end?: any\n): Iterable<IteratorProjection<S, R, P>> =>\n  source == null\n    ? ([] as any)\n    : !projection && isArray(source)\n    ? filterArray(source)\n    : source[symbolIterator]\n    ? createFilteringIterator(\n        source,\n        start === undefined\n          ? projection\n          : sliceAction(projection, start as any, end)\n      )\n    : isObject(source)\n    ? createObjectIterator(\n        source as any,\n        sliceAction(projection, start as any, end)\n      )\n    : createIterator(\n        isFunction(source)\n          ? createNavigatingIterator(source, start, end)\n          : (createRangeIterator(source as number, start as any) as any),\n        projection\n      );\n\nconst mapToArray = <T, M>(\n  projected: Iterable<T>,\n  map: M\n): true extends M ? T[] : Iterable<T> =>\n  map && !isArray(projected) ? [...projected] : (projected as any);\n\ntype ProjectFunction = {\n  <S extends IteratorSource, R, P>(\n    source: S,\n    projection?: IteratorAction<S, R> | P,\n    ...rest: StartEndArgs<S>\n  ): Iterable<IteratorProjection<S, R, P>>;\n};\n\ntype MapFunction = {\n  <S extends IteratorSource, R, P>(\n    source: S,\n    projection?: IteratorAction<S, R> | P,\n    ...rest: StartEndArgs<S>\n  ): MaybeUndefined<S, Exclude<IteratorProjection<S, R, P>, Nullish>[]>;\n};\n\ntype FlatProjectFunction = <\n  S extends IteratorSource,\n  R,\n  P,\n  D extends number = 1,\n  O extends boolean = false\n>(\n  source: S,\n  projection?: IteratorAction<S, R> | P,\n  depth?: D,\n  expandObjects?: O,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<\n  S,\n  Iterable<FlatIteratorItem<IteratorProjection<S, R, P>, D, O>>\n>;\n\nexport const project: ProjectFunction = ((\n  source: any,\n  projection: any,\n  start: any,\n  end: any\n) => createIterator(source, projection, start, end)) as any;\n\nfunction* flattenInternal(\n  value: any,\n  depth: number,\n  expandObjects: boolean,\n  nested: boolean\n) {\n  if (value != null) {\n    if (value[symbolIterator] || (expandObjects && isObject(value))) {\n      for (const item of nested ? createIterator(value) : value) {\n        if (depth !== 1) {\n          yield* flattenInternal(item, depth - 1, expandObjects, true);\n        } else {\n          yield item;\n        }\n      }\n    } else {\n      yield value;\n    }\n  }\n}\nexport const flatten: FlatProjectFunction = (\n  source,\n  projection?,\n  depth = 1 as any,\n  expandObjects: any = false,\n  start?: any,\n  end?: any\n) =>\n  flattenInternal(\n    createIterator(source, projection as any, start, end),\n    depth + 1,\n    expandObjects,\n    false\n  ) as any;\n\nexport const map: MapFunction = (\n  source: any,\n  projection?: any,\n  start?: any,\n  end?: any\n) => {\n  projection = wrapProjection(projection);\n  if (isArray(source)) {\n    let i = 0;\n    const mapped: any[] = [];\n    start = start! < 0 ? source.length + start! : start ?? 0;\n    end = end! < 0 ? source.length + end! : end ?? source.length;\n    for (; start < end && !stopInvoked; start++) {\n      let value = source[start];\n      if ((projection ? (value = projection(value, i++)) : value) != null) {\n        mapped.push(value);\n      }\n    }\n    stopInvoked = false;\n    return mapped;\n  }\n  return source != null\n    ? array(project(source, projection, start, end))\n    : (undefined as any);\n};\n\nexport const mapAsync: <S extends IteratorSource, R, P>(\n  source: S,\n  projection: IteratorAction<S, R> | P,\n  ...rest: StartEndArgs<S>\n) => Promise<\n  MaybeUndefined<S, Exclude<Awaited<IteratorProjection<S, R, P>>, Nullish>[]>\n> = async (source: any, projection?: any, start?: any, end?: any) => {\n  projection = wrapProjection(projection);\n  const mapped: any = [];\n  await forEachAsync(\n    source,\n    async (item) => (item = await projection(item)) != null && mapped.push(item)\n  );\n  return mapped as any;\n};\n\nexport const zip = <Lhs extends IteratorSource, Rhs extends IteratorSource>(\n  lhs: Lhs,\n  rhs: Rhs\n): Iterable<[IteratorItem<Lhs>, IteratorItem<Rhs> | undefined]> => {\n  const it2 = createIterator(rhs)[Symbol.iterator]();\n  return createIterator(lhs, (lhs) => [lhs, it2.next()?.value] as [any, any]);\n};\n\nexport const distinct: {\n  <S extends IteratorSource, R, P>(\n    source: S,\n    projection?: IteratorAction<S, R>,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorProjection<S, R, P>>;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorItem<S>>;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  source != null\n    ? new Set<any>([...project(source, projection, start, end)])\n    : undefined;\n\nexport const single: {\n  <S extends IteratorSource, R, P>(\n    source: S,\n    projection?: IteratorAction<S, R> | P,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorProjection<S, R, P> | undefined;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorItem<S> | undefined;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  source == null\n    ? undefined\n    : (source = mapDistinct(source, projection, start, end) as any).length > 1\n    ? undefined\n    : source[0];\n\nexport const mapDistinct: MapFunction = (\n  source: any,\n  projection?: any,\n  start?: any,\n  end?: any\n) =>\n  source != null\n    ? [...(distinct as any)(source, projection, start, end)]\n    : source;\n\nexport function* concatIterators<S extends IteratorSource[]>(\n  ...iterators: S\n): Iterable<IteratorItems<S>> {\n  for (const iterator of iterators) {\n    if (!iterator) continue;\n    yield* createIterator(iterator);\n  }\n}\n\nexport const intersection = <\n  T,\n  A extends Iterable<T> | undefined,\n  B extends Iterable<T> | undefined,\n  MapToArray extends boolean = A extends any[]\n    ? true\n    : B extends any[]\n    ? true\n    : false\n>(\n  a: A,\n  b: B,\n  mapToArray?: MapToArray\n): MapToArray extends true ? T[] : Iterable<T> => {\n  if (!a || !b) return [];\n  isSet(b) && ([b, a] = [a, b] as any);\n  const lookup = isSet(a) ? a : new Set(a);\n  return filter(b, (value) => lookup.has(value), mapToArray) as any;\n};\n\nexport const intersects = (\n  a: Iterable<any> | undefined,\n  b: Iterable<any> | undefined\n) => !!count(intersection(a, b));\n\nexport const flatMapKv = <S extends IteratorSource, R, P, D extends number = 1>(\n  source: S,\n  action?: IteratorAction<S, R> | P,\n  depth: D = 1 as any\n): FlatIteratorItem<IteratorProjection<S, R, P>, D, true>[] =>\n  flatMap(source, action, depth, true);\n\nexport const flatMap: <\n  S extends IteratorSource,\n  R,\n  P,\n  D extends number = 1,\n  O extends boolean = false\n>(\n  source: S,\n  action?: IteratorAction<S, R> | P,\n  depth?: D,\n  expandObjects?: O,\n  ...rest: StartEndArgs<S>\n) => FlatIteratorItem<IteratorProjection<S, R, P>, D, O>[] = (\n  source,\n  action,\n  depth = 1 as any,\n  expandObjects = false as any,\n  start?: any,\n  end?: any\n) =>\n  array(\n    (flatten as any)(source, action, depth, expandObjects, start, end) as any\n  ) as any;\n\nconst traverseInternal = <T>(\n  root: T | T[] | undefined,\n  selector: (current: T) => Iterable<T> | undefined,\n  include: boolean,\n  results: T[],\n  seen: Set<T>\n) => {\n  if (isArray(root)) {\n    forEachInternal(root, (item) =>\n      traverseInternal(item, selector, include, results, seen)\n    );\n    return results;\n  }\n  if (!root || !add(seen, root)) {\n    return undefined;\n  }\n  include && results.push(root);\n  forEachInternal(selector(root), (item) =>\n    traverseInternal(item, selector, true, results, seen)\n  );\n\n  return results;\n};\n\ntype ConcatResult_<T> = T extends readonly []\n  ? never\n  : T extends readonly [infer Item, ...infer Rest]\n  ?\n      | Exclude<Item extends Iterable<infer T> ? T : Item, Nullish>\n      | ConcatResult_<Rest>\n  : T extends Iterable<infer Item>\n  ? Exclude<Item extends Iterable<infer T> ? T : Item, Nullish>\n  : never;\n\ntype ConcatResult<T> = ConcatResult_<T> extends never\n  ? undefined\n  : ConcatResult_<T>[];\n\ntype FinalIteratorItem<\n  T,\n  ArraysOnly = false,\n  MaxDepth extends number = -1\n> = MaxDepth extends 0\n  ? T\n  : T extends string\n  ? string\n  : T extends (\n      [ArraysOnly] extends [true]\n        ? readonly (infer T)[]\n        : IterableOrArrayLike<infer T>\n    )\n  ? FinalIteratorItem<\n      T,\n      ArraysOnly,\n      -1 extends MaxDepth ? -1 : Minus<MaxDepth, 1>\n    >\n  : T;\n\nexport const unnest = <\n  T extends readonly any[],\n  ArraysOnly extends boolean = false,\n  Depth extends number = -1\n>(\n  items: T,\n  arraysOnly: ArraysOnly,\n  depth: Depth = -1 as any\n): FinalIteratorItem<T, ArraysOnly>[] => {\n  if (!depth) return items as any;\n\n  const results: any[] = [];\n  const test = arraysOnly ? isArray : isIterable;\n  forEach(items, (item) =>\n    test(item)\n      ? results.push(...unnest(item, arraysOnly, depth - 1))\n      : item != null && results.push(item)\n  );\n  return results;\n};\n\nexport const unarray: {\n  <T extends readonly any[], Depth extends number = -1>(\n    items: T\n  ): FinalIteratorItem<T, true>[];\n  <T extends readonly any[]>(...items: T): FinalIteratorItem<T, true>[];\n} = (...items: any[]) => unnest(items.length === 1 ? items[0] : items, true);\n\nexport const concat: {\n  <T extends readonly any[]>(items: T):\n    | ConcatResult<T>\n    | IfNot<AnyAll<ArraysAsEmpty<T[number]>, false>>;\n  <T extends readonly any[]>(...items: T):\n    | ConcatResult<T>\n    | IfNot<AnyAll<ArraysAsEmpty<T[number]>, false>>;\n} = (...items: any[]) => {\n  let merged: any[] | undefined;\n  forEach(\n    items.length === 1 ? items[0] : items,\n    (item) => item != null && (merged ??= []).push(...(array(item) as any))\n  );\n  return merged as any;\n};\n\nexport const expand = <T>(\n  root: T | T[],\n  selector: (\n    current: Exclude<T, Nullish>\n  ) => Iterable<T | undefined> | undefined,\n  includeSelf = true\n): T extends undefined ? undefined : Exclude<T, Nullish>[] =>\n  traverseInternal(root, selector, includeSelf, [], new Set()) as any;\n\nconst forEachArray = (\n  source: readonly any[],\n  action: any,\n  start: any,\n  end: any\n) => {\n  let returnValue: any;\n  let i = 0;\n  start = start! < 0 ? source.length + start! : start ?? 0;\n  end = end! < 0 ? source.length + end! : end ?? source.length;\n  for (; start < end; start++) {\n    if (\n      source[start] != null &&\n      ((returnValue = action(source[start], i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachIterable = (source: Iterable<any>, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let value of source as any) {\n    if (\n      value != null &&\n      ((returnValue = action(value, i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachObject = (source: any, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let key in source) {\n    if (\n      ((returnValue = action([key, source[key]], i++) ?? returnValue),\n      stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nexport const apply: <S, R, Args extends readonly any[]>(\n  source: S,\n  action: (\n    item: S extends IteratorSource ? IteratorItem<S> : OmitNullish<S>,\n    ...args: Args\n  ) => R,\n  ...args: Args\n) => S extends undefined ? undefined : Exclude<R, Nullish>[] = (\n  source,\n  action,\n  ...args\n) =>\n  source == null\n    ? undefined\n    : isIterable(source)\n    ? map(source, (item) => action(item as any, ...args))\n    : (action(source as any, ...args) as any);\n\nexport const applyAsync: <\n  S extends IteratorSource,\n  R extends PromiseLike<any>,\n  Args extends readonly any[]\n>(\n  source: S,\n  action: (item: IteratorItem<S>, ...args: Args) => R,\n  ...args: Args\n) => Promise<S extends undefined ? undefined : Exclude<R, Nullish>[]> = (\n  source,\n  action,\n  ...args\n) => mapAsync(source, (item) => action(item, ...args)) as any;\n\nconst forEachInternal: <S extends IteratorSource, R>(\n  source: S,\n  action?: IteratorAction<S, R>,\n  start?: any,\n  end?: any\n) => R | undefined = (source, action, start?: any, end?: any) => {\n  if (source == null) return;\n\n  if (isArray(source)) return forEachArray(source, action, start, end);\n  if (start === undefined) {\n    if (source[symbolIterator]) return forEachIterable(source as any, action);\n    if (typeof source === \"object\") return forEachObject(source, action);\n  }\n  let returnValue: any;\n  for (const value of createIterator(source, action, start, end)) {\n    value != null && (returnValue = value);\n  }\n\n  return returnValue;\n};\n\nexport const forEach = forEachInternal as {\n  <S extends IteratorSource, R>(\n    source: S,\n    action: FunctionalIteratorAction<S, R>,\n    ...rest: StartEndArgs<S>\n  ): R | undefined;\n};\n\nexport const forEachAsync: <\n  S extends IteratorSource,\n  R extends PromiseLike<any>\n>(\n  source: S,\n  action: IteratorAction<S, R>,\n  ...rest: StartEndArgs<S>\n) => Promise<R | undefined> = async (\n  source: any,\n  action: any,\n  start?: any,\n  end?: any\n) => {\n  if (source == null) return undefined;\n  let returnValue: any;\n  for (let item of project(source, action, start, end)) {\n    (item = (await item) as any) != null && (returnValue = item);\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nexport const flatForEach = <\n  S extends IteratorSource,\n  R,\n  P,\n  Depth extends number,\n  O extends boolean = false\n>(\n  source: S,\n  action: IteratorAction<S, R> | P,\n  depth: Depth = 1 as any,\n  expandObjects: O = false as any,\n  ...rest: StartEndArgs<S>\n): FlatIteratorItem<IteratorProjection<S, R, P>, Depth, O> | undefined =>\n  forEachInternal(\n    flatten(source, undefined, depth, expandObjects, ...(rest as any)),\n    action as any\n  ) as any;\n\ntype KeyValueParts<T> = T extends readonly [infer Key, infer Value]\n  ? [Key, Value]\n  : [undefined, undefined];\n\nconst fromEntries = Object.fromEntries;\n\n/**\n * Like Object.fromEntries, but accepts any iterable source and a projection instead of just key/value pairs.\n * Properties with undefined values are not included in the resulting object.\n */\nexport const obj: {\n  <S extends KeyValueSource | Nullish>(source: S): MaybeUndefined<\n    S,\n    KeyValuePairsToObject<IteratorItem<S>>\n  >;\n  <S extends Iterable<KeyValueSource> | Nullish, G extends boolean>(\n    source: S,\n    group: G\n  ): S extends Nullish\n    ? undefined\n    : KeyValueSourcesToObject<IteratorItem<S>, G>;\n\n  <S extends IteratorSource | Nullish, R extends readonly [any, any], P>(\n    source: S,\n    selector: IteratorAction<S, R> | P,\n    merge?: (\n      current: KeyValueParts<IteratorProjection<S, R, P>>[1] | undefined,\n      value: KeyValueParts<IteratorProjection<S, R, P>>[1]\n    ) => KeyValueParts<IteratorProjection<S, R, P>>[1] | Nullish\n  ): KeyValuePairsToObject<IteratorProjection<S, R, P>>;\n} = ((source: any, selector?: any, merge?: any) => {\n  if (source == null) return undefined;\n\n  if (isBoolean(selector) || merge) {\n    let result = {} as any;\n    forEach(\n      source,\n      merge\n        ? (item, i) =>\n            (item = selector(item, i)) != null &&\n            (item[1] = merge(result[item[0]], item[1])) != null &&\n            (result[item[0]] = item[1])\n        : (source) =>\n            forEach(\n              source,\n              selector\n                ? (item) =>\n                    item?.[1] != null &&\n                    ((result[item[0]] ??= []).push(item[1]), result)\n                : (item) =>\n                    item?.[1] != null && ((result[item[0]] = item[1]), result)\n            )\n    );\n    return result;\n  }\n  return fromEntries(\n    map(\n      source,\n      selector\n        ? (item, index) => ifDefined(selector(item, index), 1)\n        : (item) => ifDefined(item, 1)\n    )!\n  );\n}) as any;\n\nexport const groupReduce: <\n  S extends IteratorSource,\n  Key,\n  Accumulator = unknown\n>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  reducer: (\n    accumulator: GeneralizeConstants<Accumulator>,\n    item: IteratorItem<S>,\n    index: number\n  ) => Accumulator,\n  seed?: Accumulator | (() => Accumulator),\n  ...reset: StartEndArgs<S>\n) => Map<Key, Accumulator> = (\n  source,\n  keySelector,\n  reducer,\n  seed,\n  start?: any,\n  end?: any\n) => {\n  const groups = new Map<any, any>();\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  const action: IteratorAction<any, any> = (item, index) => {\n    const key = keySelector(item, index);\n    let acc = groups.get(key) ?? seedFactory();\n    const value = reducer(acc, item, index);\n    if (value != null) {\n      groups.set(key, value);\n    }\n  };\n  forEachInternal(source, action, start, end);\n  return groups as any;\n};\n\nexport const group: <S extends IteratorSource, Key, R = IteratorItem<S>>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  valueSelector?: (item: IteratorItem<S>, index: number) => R,\n  ...rest: StartEndArgs<S>\n) => S extends undefined ? undefined : Map<Key, R[]> = (\n  source,\n  keySelector,\n  valueSelector = (item: any) => item,\n  start?: any,\n  end?: any\n) => {\n  if (source == null) return undefined as any;\n  const groups = new Map<any, any[]>();\n  (forEachInternal as any)(\n    source,\n    (item: any, index: number) => {\n      const key = keySelector(item, index);\n      const value = valueSelector(item, index);\n      get(groups, key as any, () => []).push(value);\n    },\n    start,\n    end\n  );\n  return groups as any;\n};\n\nexport const reduce: <\n  S extends IteratorSource,\n  Reducer extends (\n    ...args: [\n      accumulator: unknown extends Accumulator\n        ? any\n        : GeneralizeConstants<Accumulator>,\n      item: IteratorItem<S>,\n      index: number\n    ]\n  ) => GeneralizeConstants<Accumulator>,\n  Accumulator\n>(\n  source: S,\n  reducer: Reducer,\n  seed?: Accumulator | (() => Accumulator),\n  ...rest: StartEndArgs<S>\n) => Reducer extends (...args: any) => infer R\n  ? R | (unknown extends Accumulator ? undefined : never)\n  : never = (source, reducer, seed, start?: any, end?: any) => {\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  return (\n    forEachInternal(\n      source,\n      (value, index) =>\n        (seed =\n          ((reducer as any)(seed as any, value, index) as any) ??\n          seedFactory()),\n      start,\n      end\n    ) ?? (seedFactory() as any)\n  );\n};\n\ntype FilterItem<S extends IteratorSource, F> = F extends (\n  value: any,\n  ...args: any\n) => value is infer T\n  ? T\n  : IteratorItem<S>;\n\nexport const filter: {\n  <\n    S extends IteratorSource,\n    MapToArray extends boolean = S extends Nullish | readonly any[]\n      ? true\n      : false,\n    P extends IteratorFilter<S> = IteratorFilter<S>\n  >(\n    source: S,\n    predicate?: P,\n    map?: MapToArray,\n    ...rest: StartEndArgs<S>\n  ): MapToArray extends true\n    ? MaybeUndefined<S, FilterItem<S, P>[]>\n    : Iterable<FilterItem<S, P>>;\n} = (\n  source: IteratorSource,\n  predicate: IteratorFilter<any> = (item: any) => item != null,\n  map = isArray(source) as any,\n  start?: any,\n  end?: any\n) =>\n  mapToArray(\n    createIterator(\n      source,\n      (item, index) => (predicate(item, index) ? item : undefined),\n      start,\n      end\n    ),\n    map\n  ) as any;\n\nlet filterInternal = filter;\n\nexport const count: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, number> = (\n  source: IteratorSource,\n  filter?: IteratorFilter<IteratorSource>,\n  start?: any,\n  end?: any\n) => {\n  if (source == null) return undefined as any;\n\n  let n: number;\n  if (filter) {\n    source = filterInternal(source, filter, false, start, end) as any;\n  } else {\n    if ((n = source![\"length\"] ?? source![\"size\"]) != null) {\n      return n;\n    }\n    if (!source[symbolIterator]) {\n      return Object.keys(source).length;\n    }\n  }\n  n = 0;\n  return forEachInternal(source, () => ++n) ?? (0 as any);\n};\n\nexport const sum: {\n  <S extends IteratorSourceOf<number>>(\n    source: S,\n    selector?: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n  <S extends IteratorSource>(\n    source: S,\n    selector: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n} = (\n  source: any,\n  selector: any = (item: any) => item,\n  start?: any,\n  end?: any\n) =>\n  reduce(\n    source,\n    (sum, value, index) => sum + (selector(value, index) ?? 0),\n    0,\n    start,\n    end\n  );\n\ntype CanBeEmptySource<S extends IteratorSource> = any[] extends S\n  ? true\n  : S extends { length: 0 } | 0 // Zero length range.\n  ? true\n  : S extends readonly any[] | number\n  ? false\n  : true;\n\ntype MinMaxFunction = {\n  <S extends readonly number[]>(...numbers: S | readonly [number]):\n    | (S extends readonly [] ? undefined : number)\n    | UndefinedIfEmpty<S>;\n  <S extends IteratorSource, R, P>(\n    source: S | readonly [number],\n    selector?: IteratorAction<S, R> | P,\n    ...rest: StartEndArgs<S>\n  ): true extends CanBeEmptySource<S>\n    ? number | undefined\n    : If<\n        Extends<IteratorProjectionWithUndefined<S, R, P>, number>,\n        number,\n        undefined\n      >;\n};\n\nexport const min: MinMaxFunction = (source: any, ...args: any[]) =>\n  source == null\n    ? undefined\n    : isNumber(source)\n    ? Math.min(source, ...args)\n    : reduce(\n        source,\n        (\n          min,\n          value,\n          index,\n          projected = args[1] ? args[1](value, index) : value\n        ) =>\n          min == null || (isNumber(project) && projected < min)\n            ? projected\n            : max,\n        undefined,\n        args[2],\n        args[3]\n      );\n\nexport const max: MinMaxFunction = (source: any, ...args: any[]) =>\n  source == null\n    ? undefined\n    : isNumber(source)\n    ? Math.max(source, ...args)\n    : reduce(\n        source,\n        (\n          max,\n          value,\n          index,\n          projected = args[1] ? args[1](value, index) : value\n        ) =>\n          max == null || (isNumber(projected) && projected > max)\n            ? projected\n            : max,\n        undefined,\n        args[2],\n        args[3]\n      );\n\nexport const values: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<\n  S,\n  IteratorItem<S> extends readonly [any, infer Item] ? Item : IteratorItem<S>\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isPlainObject(source) ? (item: any) => item[1] : (item: any) => item,\n    start,\n    end\n  );\n\nexport const entries: <S extends Iterable<any> | RecordType>(\n  target: S\n) => Entries<S> = (target) =>\n  !isArray(target) && isIterable(target)\n    ? map(\n        target,\n        isMap(target)\n          ? (value) => value\n          : isSet(target)\n          ? (value) => [value, true]\n          : (value, index) => [index, value]\n      )\n    : isObject(target)\n    ? (Object.entries(target) as any)\n    : undefined;\n\nexport const keys: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<\n  S,\n  IteratorItem<S> extends readonly [infer Key, any] ? Key : number\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isPlainObject(source)\n      ? (item: any) => item[0]\n      : (_item: any, i: number) => i,\n    start,\n    end\n  );\n\nexport const mapFirst: <S extends IteratorSource, R, P>(\n  source: S,\n  projection: IteratorAction<S, R> | P,\n  ...rest: StartEndArgs<S>\n) => IteratorProjection<S, R, P> | undefined = (\n  source,\n  projection,\n  start?: any,\n  end?: any\n) =>\n  source == null\n    ? undefined\n    : ((projection = wrapProjection(projection)!),\n      forEachInternal(\n        source,\n        (value, i) =>\n          !projection || (value = (projection as any)(value, i))\n            ? stop(value)\n            : undefined,\n        start,\n        end\n      ));\n\nexport const first: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: IteratorFilter<any>,\n  start?: any,\n  end?: any\n) =>\n  source == null\n    ? undefined\n    : forEachInternal(\n        source,\n        (value, i) =>\n          !predicate || predicate(value, i) ? stop(value) : undefined,\n        start,\n        end\n      );\n\nexport const last: <S extends IteratorSource | undefined>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: any,\n  start?: any,\n  end?: any\n) =>\n  source == null\n    ? undefined\n    : isArray(source) || isString(source)\n    ? source[source.length - 1]\n    : forEachInternal(\n        source,\n        (item, i) => (!predicate || predicate(item, i) ? item : undefined),\n        start,\n        end\n      );\n\nexport const find: <S extends IteratorSource>(\n  source: S,\n  predicate: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, IteratorItem<S>> = (\n  source,\n  predicate,\n  start?: any,\n  end?: any\n) =>\n  source == null\n    ? undefined\n    : (source as any).find\n    ? (source as any).find(predicate)\n    : first(filterInternal(source as any, predicate, false, start, end));\n\nexport const rank = <S extends IteratorSource>(source: S) =>\n  createIterator(source, (item, i) => [item, i] as const);\n\nexport const some: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, boolean> = (source, predicate, start?: any, end?: any) =>\n  source == null\n    ? undefined\n    : isPlainObject(source) && !predicate\n    ? Object.keys(source).length > 0\n    : (source as any).some?.(predicate ?? isTruish) ??\n      forEachInternal<any, boolean>(\n        source,\n        predicate\n          ? (item, index) => (predicate(item, index) ? stop(true) : false)\n          : () => stop(true),\n        start,\n        end\n      ) ??\n      false;\n\nexport const every: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, boolean> = (source, predicate, start?: any, end?: any) =>\n  source == null\n    ? undefined\n    : (!(some as any)(\n        source,\n        predicate\n          ? (item: any, index: number) => !predicate(item, index)\n          : isFalsish,\n        start,\n        end\n      ) as any);\n\n/**\n * Array's `sort` function that offers a single function that is applied on each element instead of having to do it twice (`[...].sort(x,y)=>f(x)-f(y)`).\n * Default is to use the value directly.\n */\nexport const sort = <T extends any[] | Nullish, Item extends IteratorItem<T>>(\n  items: T,\n  rank: (item: Item) => number = (item) => item as any\n): MaybeUndefined<T, Item[]> =>\n  (items?.sort((lhs, rhs) => rank(lhs) - rank(rhs)), items) as any;\n\nexport const binarySearch: {\n  (arr: Array<number>, find: number): number;\n  <T = number>(arr: Array<T>, find: T, compare: (x: T, y: T) => number): number;\n} = <T = number>(\n  arr: Array<T>,\n  find: T,\n  compare: (x: T, y: T) => number = ((x: any, y: any) => x - y) as any\n) => {\n  let m = 0;\n  let n = arr.length - 1;\n  let cmp: number;\n  let k: number;\n  while (m <= n) {\n    k = (n + m) >> 1;\n    cmp = compare(find, arr[k]);\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return k;\n    }\n  }\n  return ~m;\n};\n","import {\n  And,\n  Extends,\n  GeneralizeConstants,\n  If,\n  IsAny,\n  IteratorItem,\n  IteratorSourceOf,\n  KeyValuePairsToObject,\n  MaybeUndefined,\n  MethodOverloads,\n  Minus,\n  NotFunction,\n  Nullish,\n  PrettifyIntersection,\n  Primitives,\n  RecordType,\n  UnionToIntersection,\n  count,\n  forEach,\n  hasMethod,\n  isArray,\n  isFunction,\n  isMap,\n  isNumber,\n  isObject,\n  isPlainObject,\n  isSet,\n  map,\n  obj,\n  throwError,\n} from \".\";\n\ntype ReadonlyMapLike<K = any, V = any> = {\n  has?(key: K): boolean;\n  get(key: K): V | undefined;\n};\n\n// #region Shared types\ntype MapLike<K = any, V = any> = ReadonlyMapLike<K, V> & {\n  set(key: K, value: V): any;\n  delete(key: K): any;\n  clear(): any;\n};\n\ntype ReadonlySetLike<K = any> = {\n  has(key: K): boolean;\n};\ntype SetLike<K = any> = ReadonlySetLike<K> & {\n  add(key: K): any;\n  delete(key: K): any;\n  clear(): any;\n};\n\ntype ReadonlyPropertyContainer<K extends any = any, V extends any = any> =\n  | RecordType\n  | readonly any[]\n  | ReadonlyMapLike<K, V>\n  | ReadonlySetLike<K>;\n\ntype PropertyContainer<K extends any = any, V extends any = any> =\n  | ReadonlyPropertyContainer<K, V>\n  | MapLike<K, V>\n  | SetLike<K>;\n\nexport type TupleIndices<T extends readonly any[]> = T extends readonly []\n  ? never\n  : number extends T[\"length\"]\n  ? number\n  : T extends readonly [any, ...infer Rest]\n  ? TupleIndices<Rest> | Rest[\"length\"]\n  : never;\n\nexport type KeyType<T extends ReadonlyPropertyContainer | Nullish> =\n  T extends Primitives\n    ? never\n    : T extends ReadonlyMapLike<infer K, any> | ReadonlySetLike<infer K>\n    ? K\n    : T extends readonly any[]\n    ? TupleIndices<T>\n    : keyof T;\n\nexport type ValueType<\n  T extends ReadonlyPropertyContainer | Nullish,\n  K = KeyType<T>,\n  Context extends undefined | \"get\" | \"set\" = undefined\n> = IsAny<T> extends true\n  ? any\n  : T extends Nullish\n  ? never\n  : K extends KeyType<T>\n  ? T extends ReadonlyMapLike<K, infer V>\n    ? V | If<Extends<Context, \"get\" | \"set\">, undefined>\n    : T extends ReadonlySetLike<K>\n    ? boolean\n    : T[K] | If<And<Extends<T, RecordType>, Extends<Context, \"set\">>, undefined>\n  : never;\n\n// #endregion\n\n// #region get\n\nconst updateSingle = (target: any, key: any, value: any) =>\n  setSingle(target, key, isFunction(value) ? value(get(target, key)) : value);\n\nconst setSingle = (target: any, key: any, value: any) => {\n  if (target.constructor === Object || isArray(target)) {\n    value === undefined ? delete target[key] : (target[key] = value);\n    return value;\n  }\n\n  value === undefined\n    ? target.delete\n      ? target.delete(key)\n      : delete target[key]\n    : target.set\n    ? target.set(key, value)\n    : target.add\n    ? value\n      ? target.add(key)\n      : target.delete(key)\n    : (target[key] = value);\n\n  return value;\n};\n\nexport const setSingleIfNotDefined = (\n  target: any,\n  key: any,\n  value: any,\n  error: (\n    key: string,\n    currentValue: any,\n    newValue: any,\n    target: any\n  ) => string | Error\n) => {\n  const currentValue = get(target, key);\n  if (currentValue != null) {\n    throwError(error(key, currentValue, value, target));\n  }\n  return setSingle(target, key, value);\n};\n\nexport const get: {\n  <T extends ReadonlyPropertyContainer | Nullish, K extends KeyType<T>>(\n    target: T,\n    key: K\n  ): ValueType<T, K, \"get\">;\n  <\n    T extends ReadonlyPropertyContainer | Nullish,\n    K extends KeyType<T>,\n    R extends\n      | ValueType<T, K>\n      | (() => ValueType<T, K>)\n      | undefined\n      | (() => ValueType<T, K> | undefined)\n  >(\n    target: T,\n    key: K,\n    init: R\n  ): ValueType<\n    T,\n    K,\n    R extends ValueType<T, K> | (() => ValueType<T, K>) ? undefined : \"get\"\n  >;\n} = <\n  T extends ReadonlyPropertyContainer | Nullish,\n  K extends KeyType<T>,\n  R extends ValueType<T, K> | undefined = undefined\n>(\n  target: T,\n  key: K | undefined,\n  init?: Wrapped<R>\n) => {\n  if (!target) return undefined as any;\n  if (target.constructor === Object && init == null) return target[key as any];\n\n  let value = (target as any).get\n    ? (target as any).get(key)\n    : (target as any).has\n    ? (target as any).has(key)\n    : target[key as any];\n\n  if (value === undefined && init != null) {\n    (value = isFunction(init) ? (init as any)() : init) != null &&\n      setSingle(target, key, value);\n  }\n  return value;\n};\n\n// #endregion\n\n// #region set and update\n\ntype UpdateFunction<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current,\n  Factory\n> = Factory extends false\n  ? (\n      current: Current,\n      key: Key,\n      target: T\n    ) => GeneralizeConstants<ValueType<T, Key>> | undefined\n  : (key: Key, target: T) => GeneralizeConstants<ValueType<T, Key>>;\n\ntype Updater<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current = ValueType<T, Key>,\n  SettersOnly = false,\n  Factory = false\n> = SettersOnly extends true\n  ? ValueType<T, Key> | (Factory extends true ? never : undefined)\n  : IsAny<T> extends true\n  ? NotFunction | UpdateFunction<any, any, any, Factory>\n  :\n      | (ValueType<T, Key> extends Function\n          ? never\n          : ValueType<T, Key> | (Factory extends true ? never : undefined))\n      | UpdateFunction<T, Key, Current, Factory>;\n\ntype UpdaterType<T, SettersOnly = false> = SettersOnly extends true\n  ? T\n  : T extends (...args: any) => infer T\n  ? T\n  : T;\n\ntype BulkUpdateObject<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> = T extends MapLike | SetLike | any[]\n  ? {\n      [P in KeyType<T>]: Updater<T, P, ValueType<T, P>, SettersOnly, Factory>;\n    }\n  : { [P in keyof T & KeyType<T>]?: Updater<T, P, T[P], SettersOnly, Factory> };\n\ntype BulkUpdateKeyValue<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false,\n  K extends keyof T = keyof T\n> = IsAny<T> extends true\n  ? readonly [any, Updater<T, any, any, SettersOnly, Factory>]\n  : T extends MapLike | SetLike | any[]\n  ? readonly [\n      KeyType<T>,\n      Updater<T, KeyType<T>, ValueType<T, KeyType<T>>, SettersOnly, Factory>\n    ]\n  : K extends any\n  ? readonly [K, Updater<T, KeyType<T>, any, SettersOnly, Factory>]\n  : never;\n\ntype BulkUpdates<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> =\n  | BulkUpdateObject<T, SettersOnly, Factory>\n  | Iterable<\n      | BulkUpdateKeyValue<T, SettersOnly, Factory>\n      | BulkUpdateObject<T, SettersOnly, Factory>\n    >\n  | readonly (readonly BulkUpdateKeyValue<T, SettersOnly, Factory>[])[];\n\ntype MergeResult_<Updates> = Updates extends Iterable<\n  infer Item extends readonly [keyof any, any]\n>\n  ? KeyValuePairsToObject<Item>\n  : Updates;\n\ntype MergeResult<T, Updates> = T extends RecordType\n  ? PrettifyIntersection<\n      T &\n        UnionToIntersection<\n          MergeResult_<\n            Updates extends Iterable<infer Updates> ? Updates : Updates\n          >\n        >\n    >\n  : T &\n      UnionToIntersection<\n        MergeResult_<\n          Updates extends Iterable<infer Updates> ? Updates : Updates\n        >\n      >;\n\ntype SetErrorHandler<T extends ReadonlyPropertyContainer | Nullish> = (\n  key: KeyType<T>,\n  currentValue: ValueType<T>,\n  newValue: ValueType<T>,\n  target: T\n) => string | Error;\n\ntype SettableKeyType<T extends PropertyContainer> = T extends readonly any[]\n  ? // `KeyType<T>` won't do.\n    // If this `keyof` constraint is not set TypeScript will only constrain values for readonly tuple items to T[number] and not T[K].\n    keyof T\n  : T extends RecordType\n  ? keyof any\n  : KeyType<T>;\n\ntype SettableValueType<T extends PropertyContainer, K> = K extends KeyType<T>\n  ?\n      | ValueType<T, K>\n      // `undefined` removes elements from maps and sets so also allowed.\n      | (T extends MapLike | SetLike ? undefined : never)\n  : T extends RecordType\n  ? any\n  : never;\n\ntype IsGeneralKey<T, S = keyof any> = S extends T ? true : false;\n\n/** List of keys in T that has undefined values. If Template does not allow undefined values for a key it is excluded from the results. */\ntype UndefinedKeys<\n  T,\n  Template = {},\n  K extends keyof T = keyof T\n> = K extends keyof T\n  ? T[K] extends undefined\n    ? K extends keyof Template\n      ? undefined extends Template[K]\n        ? K\n        : never\n      : K\n    : never\n  : never;\n\ntype AllKeys<T> = T extends infer T ? keyof T : never;\n\ntype AnyValue<T, K> = T extends infer T\n  ? K extends keyof T\n    ? T[K]\n    : never\n  : never;\n\ntype MergeObjects<T> = {\n  [P in AllKeys<T>]: AnyValue<T, P>;\n};\n\ntype KeyValueTupleToRecord<Item> = Item extends readonly [infer K, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : Item extends readonly (infer KV)[]\n  ? { [P in KV & keyof any]: KV }\n  : Item extends RecordType\n  ? Item\n  : never;\n\ntype AssignRecord<T, S> = {\n  [P in Exclude<\n    keyof T | keyof S,\n    IsGeneralKey<keyof T | keyof S> extends true ? never : UndefinedKeys<S, T>\n  >]: P extends keyof S\n    ? IsGeneralKey<P> extends true\n      ? AnyValue<S | T, P>\n      : P extends keyof T\n      ? S[P] extends T[P]\n        ? GeneralizeConstants<S[P]> extends T[P]\n          ? GeneralizeConstants<S[P]>\n          : S[P]\n        : never\n      : GeneralizeConstants<S[P]>\n    : P extends keyof T\n    ? T[P]\n    : never;\n};\n\ntype SetOrUpdateFunction<\n  SettersOnly,\n  ErrorHandler = false,\n  Readonly = false\n> = {\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined,\n    U extends Updater<\n      T extends Nullish ? never : T,\n      K,\n      ValueType<T, K>,\n      SettersOnly\n    >,\n    K extends KeyType<T>\n  >(\n    target: T,\n    key: K,\n    value: U,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): UpdaterType<U>;\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined,\n    U\n  >(\n    target: T,\n    values: BulkUpdates<T extends Nullish ? never : T, SettersOnly> & U,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): T;\n};\n\nexport const merge = <\n  Target,\n  Values extends readonly IteratorSourceOf<readonly [keyof any, any]>[]\n>(\n  target: Target,\n  ...values: Values\n): MaybeUndefined<Target, MergeResult<Target, Values>> => (\n  forEach(values, (values) =>\n    forEach(values, ([key, value]) => {\n      if (value != null) {\n        if (isPlainObject(target[key]) && isPlainObject(value)) {\n          merge(target[key], value);\n        } else {\n          target[key] = value;\n        }\n      }\n    })\n  ),\n  target as any\n);\n\nconst createSetOrUpdateFunction =\n  <SettersOnly, Error>(\n    setter: (target: any, key: any, value: any, error?: any) => any\n  ): SetOrUpdateFunction<SettersOnly, Error> =>\n  (target: PropertyContainer, key: any, value?: any, error?: any) => {\n    if (!target) return undefined;\n    if (value != undefined) {\n      return setter(target, key, value, error);\n    }\n\n    forEach(key, (item) =>\n      isArray(item)\n        ? setter(target, item[0], item[1])\n        : forEach(item, ([key, value]) => setter(target, key, value))\n    );\n\n    return target;\n  };\n\nexport const assign = createSetOrUpdateFunction<true, false>(setSingle);\nexport const update = createSetOrUpdateFunction<false, false>(updateSingle);\nexport const assignIfUndefined = createSetOrUpdateFunction<false, true>(\n  setSingleIfNotDefined\n);\n\nexport const swap = <T extends PropertyContainer, K extends KeyType<T>>(\n  target: T,\n  key: K,\n  value: ValueType<T, K>\n): ValueType<T, K, \"get\"> => {\n  const current = get(target, key) as any;\n  if (value !== current) setSingle(target, key, value);\n  return current as any;\n};\n\n// #endregion\n\nexport const add = <T extends PropertyContainer<any, boolean>>(\n  target: T,\n  key: KeyType<T>\n) =>\n  target instanceof Set || target instanceof WeakSet\n    ? target.has(key)\n      ? false\n      : (target.add(key), true)\n    : get(target, key) !== assign(target, key, true as any);\n\nexport const has = <T extends ReadonlyPropertyContainer>(\n  target: T,\n  key: KeyType<T>\n) =>\n  hasMethod(target, \"has\")\n    ? target.has(key)\n    : ((target as any).get?.(key) ?? (target as any)[key]) != null;\n\ntype RemoveDeepArgs<\n  T,\n  Current extends any[] = [],\n  Depth extends number = 20\n> = T extends PropertyContainer\n  ? Depth extends 0\n    ? Current\n    :\n        | (Depth extends 20 ? never : Current)\n        | RemoveDeepArgs<\n            ValueType<T>,\n            [...Current, KeyType<T>[] | KeyType<T>],\n            Minus<Depth, 1>\n          >\n  : Current;\n\ntype RemoveDeepValue<\n  T,\n  Args extends any[],\n  ArrayIt = false\n> = T extends PropertyContainer\n  ? ArrayIt extends true\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>[]]\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>]\n    ? ValueType<T> | undefined\n    : Args extends [infer R, ...infer Rest]\n    ? RemoveDeepValue<ValueType<T>, Rest, R extends any[] ? true : ArrayIt>\n    : never\n  : never;\n\ntype KeysArg<T extends PropertyContainer | Nullish> = T extends RecordType\n  ? readonly (keyof T | undefined)[]\n  : readonly (KeyType<T> | undefined)[];\n\nconst clearSingle = (target: any, key: any) => {\n  if ((target ?? key) == null) return undefined;\n\n  let current = get(target, key);\n\n  if (hasMethod(target, \"delete\")) {\n    target.delete(key);\n  } else {\n    delete target[key];\n  }\n  return current;\n};\n\n/**\n * Deletes the specified keys from the target and returns the target.\n */\nexport const del: {\n  <T extends PropertyContainer | undefined, K extends KeysArg<T>>(\n    target: T,\n    ...keys: K\n  ): T extends RecordType ? { [P in Exclude<keyof T, K[number]>]: T[P] } : T;\n} = (target: any, ...keys: any) =>\n  target &&\n  (assign(target, map(keys, (key) => [key, undefined]) as any) as any);\n\n/**\n * Removes one or more values from a property container specified by the provided key or array of keys.\n *\n * If more than one level of key arguments are specified, values will be removed from the property container at the deepest level.\n * If a property container becomes empty along the path of keys, it will be removed from its parent.\n *\n */\nexport const clear = <\n  T extends PropertyContainer | Nullish,\n  Args extends RemoveDeepArgs<T>\n>(\n  target: T,\n  ...keys: Args\n): RemoveDeepValue<T, Args> => {\n  const removed: any[] = [];\n  let array = false;\n\n  const clearStep = (\n    target: any,\n    index: number,\n    parent?: any,\n    parentKey?: any\n  ) => {\n    if (!target) return;\n    const targetKeys = keys[index];\n    if (index === keys.length - 1) {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) => removed.push(clearSingle(target, key)));\n      } else {\n        removed.push(clearSingle(target, targetKeys));\n      }\n    } else {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) =>\n          clearStep(get(target, key), index + 1, target, key)\n        );\n      } else {\n        clearStep(get(target, targetKeys), index + 1, target, targetKeys);\n      }\n      if (!count(target) && parent) {\n        remove(parent, parentKey);\n      }\n    }\n  };\n  clearStep(target, 0);\n  return array ? removed : removed[0];\n};\n\n/** Removes all entries from a set or map, and returns them. */\nexport const empty = <S extends SetLike | MapLike | undefined>(\n  target: S\n): MaybeUndefined<S, IteratorItem<S>[]> => {\n  if (!target) return undefined as any;\n\n  const entries = map(target);\n  target.clear();\n  return entries as any;\n};\n\n/**\n * Removes the specified key(s) from a property container and returns their value, or undefined if the container did not have the specified key.\n *\n * The difference between {@link clear} and this function is that it does not consider nested property containers and that arrays will be spliced (as opposed to `clear` where the index will be set to `undefined`).\n */\nexport const remove: {\n  <T extends PropertyContainer | Nullish, K extends KeyType<T> | undefined>(\n    target: T,\n    key: K\n  ): T extends Nullish ? T : ValueType<T, K, \"get\">;\n  <T extends PropertyContainer | Nullish, K extends KeysArg<T>>(\n    target: T,\n    keys: K\n  ): (T extends Nullish ? T : ValueType<T, K[number], \"get\">)[];\n} = (target: PropertyContainer, keys: any) => {\n  if (!target) return undefined;\n\n  if (isArray(keys)) {\n    // Sort array keys descending as they would otherwise not match their offset as the array is spliced along the way.\n    return (\n      isArray(target) && target.length > 1 ? keys.sort((x, y) => y - x) : keys\n    ).map((key) => remove(target, key));\n  }\n\n  return isArray(target)\n    ? keys < target.length\n      ? (target as any[]).splice(keys, 1)[0]\n      : undefined\n    : clearSingle(target, keys);\n};\n\ntype EntryToObject<Item> = Item extends readonly [infer K & keyof any, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : never;\n\ntype EntriesToObject<Entries> = UnionToIntersection<\n  InlinePropertyDescriptors<\n    Entries extends Nullish | boolean\n      ? {}\n      : Entries extends readonly [\n          Partial<Readonly<PropertyDescriptor>>,\n          ...infer Rest\n        ]\n      ? EntriesToObject<Rest[number]>\n      : Entries extends readonly [infer Item, ...infer Rest]\n      ? EntryToObject<Item> & EntriesToObject<Rest>\n      : Entries extends readonly (infer Items)[]\n      ? EntryToObject<Items>\n      : Entries\n  >\n>;\n\ntype InlinePropertyDescriptors<T> = {\n  [P in keyof T]: T[P] extends () => infer V | { value: infer V }\n    ? V\n    : T[P] extends { get(): infer V }\n    ? V\n    : T[P];\n};\n\ntype PropertyList =\n  | boolean\n  | null\n  | undefined\n  | readonly [defaults: Partial<PropertyDescriptor>, ...items: PropertyList[]]\n  | readonly (readonly [key: keyof any, value: any])[]\n  | RecordType;\n\nexport const define: {\n  <T, P extends readonly PropertyList[]>(\n    target: T,\n    ...properties: P\n  ): (T extends Function ? T : {}) &\n    PrettifyIntersection<T & EntriesToObject<P[number]>>;\n} = (target: any, ...args: readonly any[]) => {\n  const add = (arg: any, defaults?: any) => {\n    if (!arg) return;\n    let properties: readonly any[];\n    if (isArray(arg)) {\n      if (isPlainObject(arg[0])) {\n        // Tuple with the first item the defaults and the next the definitions with those defaults,\n        // ([{enumerable: false, ...}, ...])\n        (arg as any[]).splice(1).forEach((items) => add(items, arg[0]));\n        return;\n      }\n      // ([[key1, value1], [key2, value2], ...])\n      properties = arg;\n    } else {\n      // An object.\n      properties = map(arg)!;\n    }\n\n    properties.forEach(([key, value]) =>\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        writable: false,\n        ...defaults,\n        ...(isPlainObject(value) && (\"get\" in value || \"value\" in value)\n          ? value\n          : isFunction(value) && !value.length\n          ? { get: value }\n          : { value }),\n      })\n    );\n  };\n\n  args.forEach((arg) => add(arg));\n  return target as any;\n};\n\ntype PropertySelector<T> =\n  | keyof T\n  | {\n      [P in keyof T]?: PropertySelector<T[P]>;\n    }\n  | readonly (keyof T)[];\n\ntype SinglePickResult<T, Selected> = Selected extends\n  | (string & infer K)\n  | (infer K)[]\n  ? unknown extends K\n    ? T\n    : { [P in keyof T & K]: T[P] }\n  : keyof Selected extends infer Keys\n  ? {\n      [P in Keys & keyof any & keyof Selected]: P extends keyof T\n        ? Selected[P] extends true\n          ? T[P]\n          : SinglePickResult<T[P], Selected[P]>\n        : never;\n    }\n  : never;\n\ntype PickResults<T, Selectors> = PrettifyIntersection<\n  Selectors extends [infer Item, ...infer Rest]\n    ? unknown extends Item\n      ? T\n      : SinglePickResult<T, Item> & SinglePickResult<T, Rest>\n    : never\n>;\n\nexport const pick = <T, Selectors extends PropertySelector<T>[], U>(\n  source: T | (null | (undefined & U)),\n  ...args: Selectors\n): U extends undefined ? undefined : PickResults<T, Selectors> => {\n  if (source === undefined) return undefined as any;\n\n  return Object.fromEntries(\n    args\n      .flatMap((arg) =>\n        isObject(arg)\n          ? isArray(arg)\n            ? arg.map((args) =>\n                isArray(args)\n                  ? args.length === 1\n                    ? [args[0], source![args[0]]]\n                    : pick(source![args[0]], ...(args[1] as any[]))\n                  : [args, source![args]]\n              )\n            : Object.entries(args).map(([key, value]) => [\n                key,\n                value === true ? source![key] : pick(source![key], value),\n              ])\n          : ([[arg, source![arg]]] as any)\n      )\n      .filter((arg) => arg[1] != null)\n  ) as any;\n};\n\nexport type Wrapped<T> = T | (() => T);\n\nexport type Unwrap<T> = T extends () => infer R ? R : T;\n\nexport const unwrap: {\n  <T>(value: Wrapped<T>): T;\n} = (value: Wrapped<any>): any => (isFunction(value) ? value() : value);\n\nexport const unlock = <T extends ReadonlyPropertyContainer>(\n  readonly: T\n): T extends ReadonlyMapLike<infer K, infer V>\n  ? MapLike<K, V>\n  : T extends ReadonlySetLike<infer T>\n  ? SetLike<T>\n  : T => readonly as any;\n\nexport const wrap = <T>(\n  original: T,\n  wrap: (\n    original: T extends (...args: any) => any ? T : () => T,\n    ...args: T extends (...args: infer Args) => any ? Args : []\n  ) => T extends (...args: any) => infer R ? R : T\n): T =>\n  original == null\n    ? original\n    : isFunction(original)\n    ? (...args: any) => wrap(original as any, ...args)\n    : (wrap as any)(() => original as any);\n\n/** Creates a clone of an object (including arrays, sets and maps) at the specified depth. -1 means \"any depth\". */\nexport const clone = <T>(value: T, depth = -1): T =>\n  isArray(value)\n    ? depth\n      ? value.map((value) => clone(value, depth - 1))\n      : [...value]\n    : isPlainObject(value)\n    ? depth\n      ? obj(value as any, ([k, v]) => [k, clone(v, depth - 1)])\n      : { ...value }\n    : isSet(value)\n    ? new Set<any>(\n        depth\n          ? (map as any)(value, (value: any) => clone(value, depth - 1))\n          : value\n      )\n    : isMap(value)\n    ? new Map<any, any>(\n        depth\n          ? (map as any)(value, (value: any) =>\n              // Does not clone keys.\n              [value[0], clone(value[1], depth - 1)]\n            )\n          : value\n      )\n    : (value as any);\n\n/**\n * Very much like `Array.push` except it accepts anything with a `push ` method  (including non-generic overloads),\n * and returns the target so chaining is easier. Suitable for tight minification.\n */\nexport const push = <T extends { push: (...args: any) => any } | Nullish>(\n  target: T,\n  ...items: MethodOverloads<T, \"push\">[0]\n): T => target?.push(...(items as any))!;\n\n/**\n * Very much like `Array.pop` except it accepts anything with a `pop` method.\n * (Included or the sake of generality since we have {@link push}). Suitable for tight minification.\n */\nexport const pop = <T extends { pop(): R } | undefined, R>(\n  target: T\n): MaybeUndefined<T, R> => target?.pop() as any;\n\n/**\n * Very much like `Array.unshift` except it accepts anything with a `push ` method  (including non-generic overloads),\n * and returns the target so chaining is easier. Suitable for tight minification\n */\nexport const unshift = <T extends { unshift: (...args: any) => any } | Nullish>(\n  target: T,\n  ...items: MethodOverloads<T, \"unshift\">[0]\n): T => target?.unshift(...(items as any))!;\n\n/**\n * Very much like `Array.shift` except it accepts anything with a `shift` method.\n * (Included or the sake of generality since we have {@link unshift}). Suitable for tight minification. */\nexport const shift = <T extends { shift(): R } | undefined, R>(\n  target: T\n): MaybeUndefined<T, R> => target?.shift() as any;\n\n/**\n * Calculates the difference between the current version of an object, and the changed values specified.\n * If an updated property is numeric, the delta will be the difference between the updated and current number.\n * If an updated property is the same as the current value, it will not be included in the diff result,\n * otherwise this algorithm is no more sophisticated than just returning the new value in the diff (e.g. nothing special about strings).\n *\n * @returns A tuple with the first element being the differences between the updates and the current version,\n *  and the second element a clone of the current value with the changes applied.\n *  The latter should be passed as the second argument, next time the diff is calculated.\n */\nexport const diff = <T>(\n  updated: T,\n  previous: T | undefined\n): [delta: T, current: T] | undefined => {\n  if (!updated) return undefined;\n  if (!isPlainObject(previous)) return [updated, updated];\n\n  const delta: any = {};\n  let patchedValue: any;\n  let previousValue: number | undefined;\n\n  // If there are changes, this will be a clone of the previous value with the delta changes applied.\n  let patched: any;\n\n  if (isPlainObject(updated)) {\n    forEach(updated, ([key, value]) => {\n      if (value === previous[key]) {\n        // No changes.\n        return;\n      }\n\n      if (isPlainObject((patchedValue = value))) {\n        // deltaValue will be undefined if there are no changed in the child object.\n        if (!(value = diff(value, previous[key]))) {\n          return;\n        }\n        [value, patchedValue] = value;\n      } else if (isNumber(value) && isNumber(previousValue)) {\n        value = (patchedValue = value) - previousValue;\n      }\n\n      delta[key] = value;\n      (patched ??= clone(previous))[key] = patchedValue;\n    });\n    return patched ? [delta, patched] : undefined;\n  }\n\n  return undefined;\n};\n","import {\n  F,\n  MAX_SAFE_INTEGER,\n  MaybePromise,\n  T,\n  isBoolean,\n  isFunction,\n  isNotFalse,\n  isTrue,\n  promise,\n  tryCatchAsync,\n} from \".\";\n\nexport const MILLISECOND = 1;\nexport const SECOND = MILLISECOND * 1000;\nexport const MINUTE = SECOND * 60;\nexport const HOUR = MINUTE * 60;\nexport const DAY = HOUR * 24;\nexport const FOREVER = MAX_SAFE_INTEGER;\n\nexport let now: (round?: boolean) => number =\n  typeof performance !== \"undefined\"\n    ? (round = T) =>\n        round ? Math.trunc(now(F)) : performance.timeOrigin + performance.now()\n    : Date.now;\n\nexport type Timer = {\n  (toggle?: boolean, reset?: boolean): number;\n};\n\nexport const reset = Symbol();\n\nexport const createTimer = (\n  started = true,\n  timeReference = () => now()\n): Timer => {\n  let t0: number = +started * timeReference();\n  let elapsed = 0;\n  let capturedElapsed: number;\n  return (toggle = started, reset?: boolean) => {\n    capturedElapsed = started\n      ? (elapsed += -t0 + (t0 = timeReference()))\n      : elapsed;\n    reset && (elapsed = 0);\n\n    (started = toggle) && (t0 = timeReference());\n\n    return capturedElapsed;\n  };\n};\n\n/**\n * The callback invoked when a {@link Clock} ticks.\n * If it returns `false` the clock will stop. Any other return value has no effect.\n */\nexport type ClockCallback = (\n  elapsed: number,\n  delta: number\n) => MaybePromise<any>;\n\nexport interface Clock {\n  readonly active: boolean;\n  readonly busy: boolean;\n  restart(frequency?: number, callback?: ClockCallback): Clock;\n  toggle(start: boolean, trigger?: boolean): Clock;\n  trigger(skipQueue?: boolean): Promise<boolean>;\n}\n\nexport interface ClockSettings {\n  frequency?: number;\n  queue?: boolean;\n  paused?: boolean;\n  trigger?: boolean;\n  once?: boolean;\n  callback?: ClockCallback;\n  raf?: boolean;\n}\n\n/** Light-weight version of {@link clock}. The trigger and cancel overloads returns true to enable chaining like `timeout(false)&&...` */\nexport const createTimeout = (\n  defaultTimeout = 0\n): {\n  (callback: () => void, timeout?: number): void;\n  (cancel: false): true;\n  (trigger: true): true;\n  (): boolean;\n} => {\n  let handle: number;\n  let currentCallback: (() => void) | undefined;\n\n  const stickyTimeout = (arg?: any, timeout = defaultTimeout) => {\n    if (arg === undefined) {\n      return !!currentCallback;\n    }\n    clearTimeout(handle);\n    if (isBoolean(arg)) {\n      arg && (timeout < 0 ? isNotFalse : isTrue)(currentCallback?.())\n        ? stickyTimeout(currentCallback)\n        : (currentCallback = undefined);\n    } else {\n      currentCallback = arg;\n      handle = setTimeout(\n        () => stickyTimeout(true, timeout),\n        timeout < 0 ? -timeout : timeout\n      );\n    }\n  };\n  return stickyTimeout as any;\n};\n\nexport const clock: {\n  (callback: ClockCallback, frequency: number): Clock;\n  (settings: ClockSettings): Clock;\n} = (\n  callbackOrSettings: ClockCallback | ClockSettings,\n  frequency = 0\n): Clock => {\n  const settings = isFunction(callbackOrSettings)\n    ? {\n        frequency,\n        callback: callbackOrSettings,\n      }\n    : callbackOrSettings;\n\n  let {\n    queue = true,\n    paused = false,\n    trigger = false,\n    once = false,\n    callback = () => {},\n    raf,\n  } = settings;\n  frequency = settings.frequency ?? 0;\n\n  let timeoutId = 0;\n  const mutex = promise(true).resolve();\n  const timer = createTimer(!paused);\n  let delta = timer();\n\n  const outerCallback = async (skipQueue?: boolean) => {\n    if (!timeoutId || (!queue && mutex.pending && skipQueue !== true)) {\n      return false;\n    }\n    (instance as any).busy = true;\n    if (skipQueue !== true) {\n      while (mutex.pending) {\n        await mutex;\n      }\n    }\n\n    !skipQueue && mutex.reset();\n\n    if (\n      (await tryCatchAsync(\n        () => callback!(timer(), -delta + (delta = timer())),\n        false,\n        () => !skipQueue && mutex.resolve()\n      )) === false ||\n      frequency <= 0 ||\n      once\n    ) {\n      reset(false);\n    }\n\n    return !((instance as any).busy = false);\n  };\n\n  const updateTimeout = () =>\n    (timeoutId = setTimeout(\n      () => (raf ? requestAnimationFrame(timeoutCallback) : timeoutCallback()),\n      frequency < 0 ? -frequency : frequency\n    ) as any);\n\n  const timeoutCallback = () => {\n    instance.active && outerCallback();\n    instance.active && updateTimeout();\n  };\n\n  const reset = (start: boolean, resetTimer = !start) => {\n    timer(start, resetTimer);\n    clearTimeout(timeoutId);\n    (instance as any).active = !!(timeoutId = start ? updateTimeout() : 0);\n    return instance;\n  };\n\n  const instance: Clock = {\n    active: false,\n    busy: false,\n    restart: (newFrequency, newCallback) => {\n      frequency = newFrequency ?? frequency;\n      callback = newCallback ?? callback;\n      return reset(true, true);\n    },\n    toggle: (start, trigger) =>\n      start !== instance.active\n        ? start\n          ? trigger\n            ? (reset(true), instance.trigger(), instance)\n            : reset(true)\n          : reset(false)\n        : instance,\n    trigger: async (skipQueue) =>\n      (await outerCallback(skipQueue)) && (reset(instance.active), true),\n  };\n\n  return instance.toggle(!paused, trigger);\n};\n","import {\n  If,\n  MaybePromise,\n  MaybeUndefined,\n  Nullish,\n  TogglePromise,\n  Unwrap,\n  Wrapped,\n  createTimer,\n  isFunction,\n  now,\n  throwError,\n  tryCatchAsync,\n  undefined,\n  unwrap,\n} from \".\";\n\nexport class ResettablePromise<T = void, E = any> implements PromiseLike<T> {\n  private _promise: OpenPromise<T>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public get value() {\n    return this._promise.value;\n  }\n  public get error() {\n    return this._promise.error;\n  }\n  public get pending() {\n    return this._promise.pending;\n  }\n\n  public resolve(value: T, ifPending = false) {\n    this._promise.resolve(value, ifPending);\n    return this;\n  }\n\n  public reject(value?: E, ifPending = false) {\n    this._promise.reject(value, ifPending);\n    return this;\n  }\n\n  public reset() {\n    this._promise = new OpenPromise<T>();\n    return this;\n  }\n\n  public signal(value: T) {\n    this.resolve(value);\n    this.reset();\n    return this;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): PromiseLike<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport class OpenPromise<T = void, E = any> implements PromiseLike<T> {\n  private readonly _promise: Promise<T>;\n\n  public readonly resolve: (value: T, ifPending?: boolean) => this;\n  public readonly reject: (reason: E | undefined, ifPending?: boolean) => this;\n  public readonly value: (T extends void ? true : T) | undefined;\n  public readonly error: E | true;\n  public pending = true;\n\n  constructor() {\n    let captured: any[];\n    this._promise = new Promise((...args: any[]) => {\n      captured = args.map((inner, i) => (value: any, ifPending: boolean) => {\n        if (!this.pending) {\n          if (ifPending) return this;\n          throw new TypeError(\"Promise already resolved/rejected.\");\n        }\n\n        (this as any).pending = false;\n        (this as any)[i ? \"error\" : \"value\"] = value === undefined || value;\n        inner(value);\n        return this;\n      });\n    });\n\n    [this.resolve, this.reject] = captured!;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | null\n      | undefined,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | null\n      | undefined\n  ): Promise<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport interface Lock {\n  /**\n   * Wait until the lock is available. If a timeout is not specified or negative, the calling thread will wait indefinitely.\n   * If a owner ID is specified the lock will be reentrant for that ID.\n   */\n  <Ms extends number | undefined = undefined>(\n    timeout?: Ms,\n    ownerId?: string\n  ): Promise<(() => void) | If<Ms, undefined>>;\n\n  /**\n   * Performs the specified action when the lock becomes available.\n   * If a timeout is not specified or negative, the calling thread will wait indefinitely.\n   * If a owner ID is specified the lock will be reentrant for that ID.\n   */\n  <T, Ms extends number | undefined = undefined>(\n    action: () => MaybePromise<T>,\n    timeout?: Ms,\n    ownerId?: string\n  ): Promise<T | If<Ms, undefined>>;\n}\n\nexport type LockState = [owner: string | boolean, expires?: number];\n\nexport const createLock = (timeout?: number): Lock => {\n  const semaphore = promise<LockState | boolean>(true);\n  let state: LockState | undefined;\n\n  const wait = async (\n    arg1?: (() => any) | number,\n    arg2?: number | string,\n    arg3?: string\n  ) => {\n    if (isFunction(arg1)) {\n      const release = await wait(arg2 as number, arg3);\n      return release ? await tryCatchAsync(arg1, true, release) : undefined;\n    }\n    const ownerId = arg2 as string;\n\n    let ms = arg1 as number;\n    let renewInterval = 0;\n    while (state && ownerId !== state[0] && (state[1] ?? 0)! < now()) {\n      if (\n        (await (ms >= 0 ? race(delay(ms), semaphore) : semaphore)) === undefined\n      ) {\n        return undefined;\n      }\n      // If the above did not return undefined we got the semaphore.\n    }\n\n    const release = () => {\n      clearTimeout(renewInterval);\n      state = undefined;\n      semaphore.signal(false);\n    };\n\n    const renew = () => {\n      state = [ownerId ?? true, timeout ? now() - timeout : undefined];\n      timeout &&\n        (renewInterval = setTimeout(() => state && renew(), timeout / 2));\n    };\n    renew();\n\n    return release;\n  };\n  return wait;\n};\n\nexport const defer = (f: VoidFunction, ms = 0) =>\n  ms > 0 ? setTimeout(f, ms) : window.queueMicrotask(f);\n\nexport const delay = <\n  Delay extends number | Nullish,\n  T extends Wrapped<any> = void\n>(\n  ms: Delay,\n  value?: T\n): MaybeUndefined<Delay, TogglePromise<Unwrap<T>, true>> =>\n  ms == null || isFinite(ms)\n    ? !ms || ms <= 0\n      ? unwrap(value)!\n      : new Promise<any>((resolve) =>\n          setTimeout(async () => resolve(await unwrap(value)), ms)\n        )\n    : (throwError(`Invalid delay ${ms}.`) as any);\n\nexport const promise: {\n  <T = void>(resettable?: false): OpenPromise<T>;\n  <T = void>(resettable: true): ResettablePromise<T>;\n} = (resettable?: boolean) =>\n  resettable ? new ResettablePromise() : (new OpenPromise() as any);\n\ntype UnwrapPromiseArg<T> = T extends () => infer T ? Awaited<T> : Awaited<T>;\ntype UnwrapPromiseArgs<T extends any[]> = T extends readonly [infer Arg]\n  ? [UnwrapPromiseArg<Arg>]\n  : T extends readonly [infer Arg, ...infer Rest]\n  ? [UnwrapPromiseArg<Arg>, ...UnwrapPromiseArgs<Rest>]\n  : [];\n\nexport type AsyncValue<T> =\n  | undefined\n  | T\n  | PromiseLike<T>\n  | (() => T)\n  | (() => PromiseLike<T>);\n\nexport const waitAll = <Args extends AsyncValue<any>[]>(\n  ...args: Args\n): Promise<UnwrapPromiseArgs<Args>> =>\n  Promise.all(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n\nexport const race = <Args extends AsyncValue<any>[]>(\n  ...args: Args\n): Promise<UnwrapPromiseArgs<Args>[number]> =>\n  Promise.race(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n","import {\r\n  IteratorAction,\r\n  IteratorSource,\r\n  MINUTE,\r\n  MaybeUndefined,\r\n  Nullish,\r\n  filter,\r\n  forEach,\r\n  isArray,\r\n  isBoolean,\r\n  isFunction,\r\n  isIterable,\r\n  isNumber,\r\n  isObject,\r\n  isString,\r\n  map,\r\n  push,\r\n  replace,\r\n  round,\r\n  undefined,\r\n} from \".\";\r\n\r\nexport const changeCase = <S extends string | null | undefined>(\r\n  s: S,\r\n  upper: boolean\r\n): S => (s == null ? s : upper ? s.toUpperCase() : s.toLowerCase()) as S;\r\n\r\nexport const changeIdentifierCaseStyle = (\r\n  identifier: string,\r\n  type: \"camel\" | \"pascal\" | \"kebab\" | \"snake\"\r\n) =>\r\n  identifier.replace(\r\n    /([_-]*)(\\$*(?:[A-Z]+|[a-z]))([a-z0-9]*)/g,\r\n    (_, underscores, initial, rest, index) =>\r\n      (underscores && (!index || type === \"kebab\" || type === \"snake\")\r\n        ? underscores.replace(/./g, type === \"snake\" ? \"-\" : \"_\")\r\n        : \"\") +\r\n      ((index && (type === \"kebab\" || type === \"snake\") && !underscores\r\n        ? type === \"snake\"\r\n          ? \"-\"\r\n          : \"_\"\r\n        : \"\") +\r\n        changeCase(initial, type === \"pascal\" || (type === \"camel\" && index)) +\r\n        changeCase(\r\n          type === \"kebab\" || type === \"snake\"\r\n            ? rest.replace(\r\n                /(?<=\\D)\\d|(?<=\\d)\\D/g,\r\n                type === \"kebab\" ? \"_$&\" : \"-$&\"\r\n              )\r\n            : rest,\r\n          false\r\n        ))\r\n  );\r\n\r\nexport type EnumerationSeparators = string | [last: string, other?: string];\r\n\r\n/**\r\n * Creates a string enumerating a list of value given a separator, optionally using a different separator between the last two items.\r\n *\r\n * @param values - The list of items to enumerator.\r\n * @param separator - The separator to use (defaults to \", \"). If given a tuple, the first item is the last separator without spaces.\r\n * The second item may optionally specify another separator than the default (\", \").\r\n *\r\n *\r\n * Useful for enumerations like \"item1, item2 and item 3\" (`separate([\"item1\", \"item2\", \"item3\"], [\"and\"])`).\r\n */\r\nexport const enumerate = (\r\n  values: any[] | undefined,\r\n  separator: EnumerationSeparators = [\"and\", \", \"]\r\n) =>\r\n  !values\r\n    ? undefined\r\n    : (values = map(values)).length === 1\r\n    ? values[0]\r\n    : isArray(separator)\r\n    ? [\r\n        values.slice(0, -1).join(separator[1] ?? \", \"),\r\n        \" \",\r\n        separator[0],\r\n        \" \",\r\n        values[values.length - 1],\r\n      ].join(\"\")\r\n    : values.join(separator ?? \", \");\r\n\r\n/**\r\n * Pluralizes a noun using standard English rules.\r\n * It is not very smart, so if the plural form is not just adding an \"s\" in the end unless the singular form already ends with \"s\",\r\n * it must be specified manually.\r\n *\r\n * @param singular - The singular form of the noun\r\n * @param n - The number of items that decides if the noun should be pluralized. If given an array the number will be postfixed.\r\n * @param plural - The plural form if it is different from adding an \"s\" to the singular form.\r\n * @returns The noun, pluralized if needed.\r\n */\r\nexport const pluralize = <\r\n  T extends string | Nullish,\r\n  N extends number | Nullish,\r\n  Plural extends string = string\r\n>(\r\n  singular: T,\r\n  n: N | [count: N],\r\n  plural?: Plural\r\n): T extends Nullish ? undefined : N extends Nullish ? undefined : string =>\r\n  singular == null\r\n    ? (undefined as any)\r\n    : isArray(n)\r\n    ? (n = n[0]) == null\r\n      ? undefined\r\n      : n + \" \" + pluralize(singular, n, plural)\r\n    : n == null\r\n    ? undefined!\r\n    : n === 1\r\n    ? singular\r\n    : plural ?? singular + \"s\";\r\n\r\nlet ansiSupported = true;\r\n\r\n/** Enables or disables ANSI formatting in console output. */\r\nexport const toggleAnsi = (toggle = true) => (ansiSupported = toggle);\r\n\r\n/**\r\n * Can colorize text using ANSI escape sequences.\r\n * See e.g. https://developer.chrome.com/docs/devtools/console/format-style for options.\r\n */\r\nexport const ansi = <Buffer extends string[] | undefined = undefined>(\r\n  value: string | string[],\r\n  ps: string | number,\r\n  buffer?: Buffer\r\n): Buffer extends undefined ? string : string[] =>\r\n  buffer\r\n    ? (ansiSupported && push(buffer, \"\\x1B[\", ps, \"m\"),\r\n      isArray(value) ? push(buffer, ...value) : push(buffer, value),\r\n      ansiSupported && push(buffer, \"\\x1B[m\"),\r\n      buffer)\r\n    : (ansi(value, ps, []).join(\"\") as any);\r\n\r\nconst indent = (buffer: string[], n: number, ...values: string[]) => (\r\n  push(buffer, \"  \".repeat(n), ...values), buffer\r\n);\r\nconst br = (buffer: string[], indents = 0) => (\r\n  indents > 0 && indent(buffer, indents), push(buffer, \"\\n\"), buffer\r\n);\r\n\r\nconst prettyPrint = (\r\n  value: any,\r\n  buffer: string[] = [],\r\n  indents = 0,\r\n  terminator = \"\"\r\n) => {\r\n  const wrap = (\r\n    start: string,\r\n    end: string,\r\n    content: (buffer: string[]) => void\r\n  ) => {\r\n    ansi(start, 90, buffer);\r\n    const subBuffer: string[] = [];\r\n    content(subBuffer);\r\n    subBuffer.length &&\r\n      (br(buffer, indents), push(buffer, ...subBuffer)) &&\r\n      indent(buffer, indents);\r\n\r\n    ansi(end, 90, buffer);\r\n  };\r\n\r\n  if (value == null) {\r\n    ansi(value === undefined ? \"(undefined)\" : \"(null)\", \"37;2\", buffer);\r\n  } else if (isIterable(value)) {\r\n    wrap(\"[\", \"]\", (buffer) =>\r\n      forEach(\r\n        value,\r\n        (value) => (\r\n          indent(buffer, indents),\r\n          prettyPrint(value, buffer, indents + 1, \",\\n\")\r\n        )\r\n      )\r\n    );\r\n  } else if (isObject(value)) {\r\n    wrap(\"{\", \"}\", (buffer) =>\r\n      forEach(\r\n        value,\r\n        ([key, value]) => (\r\n          indent(buffer, indents + 1),\r\n          ansi([\"\" + (key as any), \":\"], \"90;3\", buffer),\r\n          push(buffer, \" \"),\r\n          prettyPrint(value, buffer, indents + 1, \",\\n\")\r\n        )\r\n      )\r\n    );\r\n  } else if (isString(value)) {\r\n    ansi(value, 36, buffer);\r\n  } else if (isNumber(value) || isBoolean(value)) {\r\n    ansi(\"\" + value, 33, buffer);\r\n  } else {\r\n    push(buffer, value);\r\n  }\r\n  terminator && push(buffer, terminator);\r\n  return buffer;\r\n};\r\n\r\ntype UppercaseLetter =\r\n  | \"A\"\r\n  | \"B\"\r\n  | \"C\"\r\n  | \"D\"\r\n  | \"E\"\r\n  | \"F\"\r\n  | \"G\"\r\n  | \"H\"\r\n  | \"I\"\r\n  | \"J\"\r\n  | \"K\"\r\n  | \"L\"\r\n  | \"M\"\r\n  | \"N\"\r\n  | \"O\"\r\n  | \"P\"\r\n  | \"Q\"\r\n  | \"R\"\r\n  | \"S\"\r\n  | \"T\"\r\n  | \"U\"\r\n  | \"V\"\r\n  | \"W\"\r\n  | \"X\"\r\n  | \"Y\"\r\n  | \"Z\";\r\n\r\n/**\r\n * This is intended for prettifying enum names (like ServerWrite becomes 'server-write'), alas it does currently not work with\r\n * ts-json-schema-generator. Kept in the hope this will be supported one day.\r\n */\r\nexport type SnakeCase<\r\n  S extends string | Nullish,\r\n  First = true\r\n> = S extends Nullish\r\n  ? undefined\r\n  : S extends `${infer P}${infer Rest}`\r\n  ? [P, First] extends [UppercaseLetter, false]\r\n    ? `-${Lowercase<P>}${SnakeCase<Rest, false>}`\r\n    : `${Lowercase<P>}${SnakeCase<Rest, false>}`\r\n  : S extends string\r\n  ? Lowercase<S>\r\n  : undefined;\r\n\r\nexport const snakeCase = <S extends string | Nullish>(\r\n  s: S\r\n): MaybeUndefined<S, SnakeCase<S>> =>\r\n  replace(s, /(.)?([A-Z])/g, (_, prev, p) =>\r\n    ((prev ? prev + \"-\" : \"\") + p).toLowerCase()\r\n  ) as any;\r\n\r\nexport const quote = <T>(item: T, quoteChar = \"'\"): MaybeUndefined<T, string> =>\r\n  item == null ? (undefined as any) : quoteChar + item + quoteChar;\r\n\r\nexport const ellipsis = <T extends string | Nullish>(\r\n  text: T,\r\n  maxLength: number\r\n): T =>\r\n  text && ((text.length > maxLength ? text.slice(0, -1) + \"…\" : text) as any);\r\n\r\nexport const join: {\r\n  /**\r\n   *  Joins the specified items with a separator (default is \"\").\r\n   *  If the source is a string it will be returned as is.\r\n   *\r\n   *  The value `false` will be omitted to help syntax like `[condition && \"yes\"]`.   .\r\n   */\r\n  <S extends IteratorSource | string>(\r\n    source: S,\r\n    separator?: string | readonly [string, string]\r\n  ): MaybeUndefined<S, string>;\r\n\r\n  /**\r\n   * Joins the projection of the specified items with a separator (default is \"\").\r\n   * If the source is a string it will be considered an array with the string as its single element.\r\n   */\r\n  <S extends IteratorSource | string>(\r\n    source: S,\r\n    projection: IteratorAction<S extends string ? [string] : S>,\r\n    separator?: EnumerationSeparators\r\n  ): MaybeUndefined<S, string>;\r\n} = (source: any, projection: any, sep?: any) =>\r\n  source == null\r\n    ? undefined\r\n    : isFunction(projection)\r\n    ? enumerate(\r\n        map(isString(source) ? [source] : source, projection),\r\n        sep ?? \"\"\r\n      )\r\n    : isString(source)\r\n    ? source\r\n    : enumerate(\r\n        map(source, (item) => (item === false ? undefined : item)),\r\n        projection ?? \"\"\r\n      );\r\n\r\n/** Word statistics for a text. */\r\nexport type TextStats = {\r\n  /** The source text. */\r\n  text: string;\r\n\r\n  /** The number of characters in the text. */\r\n  length: number;\r\n\r\n  /** The number of word characters (a letter or number followed by any number of letters, numbers or apostrophes) in the text. */\r\n  characters: number;\r\n\r\n  /** The number of words in the text. A word is defined as a group of consecutive word characters. */\r\n  words: number;\r\n\r\n  /**\r\n   * The number of sentences in the text.\r\n   * A sentence is defined as any group of characters where at least one of them is a word character\r\n   * terminated by `.`, `!`, `?` or the end of the text.\r\n   */\r\n  sentences: number;\r\n\r\n  /**\r\n   * The LIX index for the text. The measure gives an indication of how difficult it is to read.\r\n   * (https://en.wikipedia.org/wiki/Lix_(readability_test))\r\n   */\r\n  lix: number;\r\n\r\n  /**\r\n   * The estimated time it will take for an average user to read all the text.\r\n   * The duration is in milliseconds since that is the time precision for ECMAScript timestamps.\r\n   *\r\n   * The estimate is assuming \"Silent reading time\" which seems to be 238 words per minute according\r\n   * to [Marc Brysbaert's research] (https://www.sciencedirect.com/science/article/abs/pii/S0749596X19300786?via%3Dihub)\r\n   *\r\n   */\r\n  readTime: number;\r\n\r\n  /**\r\n   * The character indices in the source text that demarcates specific fractions of the total numbers of word characters.\r\n   *\r\n   * Defaults to 0 %, 25 %, 50 %, 75 % and 100 % of the total number of letters respectively.\r\n   * The index is for the character after the last letter that that does not exceed the boundary.\r\n   * For example, the 25 % boundary of \"abcd\" is 1 (between a and b).\r\n   */\r\n  boundaries: { offset: number; wordsBefore: number; readTime: number }[];\r\n};\r\n\r\nexport const getTextStats = (\r\n  text: string,\r\n  boundaryLimits = [0, 0.25, 0.5, 0.75, 1]\r\n): TextStats => {\r\n  let charMatcher = /[\\p{L}\\p{N}][\\p{L}\\p{N}'’]*|([.!?]+)/gu;\r\n  let match: RegExpMatchArray | null;\r\n  let chars = 0;\r\n  let words = 0;\r\n  let longWords = 0;\r\n  let sentences = 0;\r\n\r\n  let hasWord = false;\r\n  while ((match = charMatcher.exec(text))) {\r\n    if (match[1]) {\r\n      hasWord && ++sentences;\r\n      hasWord = false;\r\n    } else {\r\n      hasWord = true;\r\n      chars += match[0].length;\r\n      match[0].length > 6 && ++longWords;\r\n      ++words;\r\n    }\r\n  }\r\n  hasWord && ++sentences;\r\n  charMatcher = /[\\p{L}\\p{N}]|([^\\p{L}\\p{N}]+)/gu;\r\n\r\n  const limits = boundaryLimits.map((boundary) => (boundary * chars) | 0);\r\n  const boundaries: TextStats[\"boundaries\"] = [];\r\n\r\n  let index = 0;\r\n  let prevIndex: number | undefined;\r\n  let wordsBefore = 0;\r\n  let inSentence = false;\r\n\r\n  do {\r\n    match = charMatcher.exec(text)!;\r\n    if (match?.[1]) {\r\n      // Word delimiter\r\n      inSentence && ++wordsBefore;\r\n    } else {\r\n      index = match?.index!;\r\n      let wasBoundary = false;\r\n      for (let i = 0; i < limits.length; i++) {\r\n        if (!limits[i]--) {\r\n          boundaries[i] = {\r\n            offset: prevIndex ?? index,\r\n            wordsBefore,\r\n            readTime: round(MINUTE * (wordsBefore / 238)),\r\n          };\r\n          wasBoundary = true;\r\n        }\r\n      }\r\n      (inSentence = !wasBoundary) || (wordsBefore = 0);\r\n      prevIndex = index + 1;\r\n    }\r\n  } while (match);\r\n\r\n  return {\r\n    text,\r\n    length: text.length,\r\n    characters: chars,\r\n    words,\r\n    sentences,\r\n    lix: round(words / sentences + (100 * longWords) / words),\r\n    readTime: round(MINUTE * (words / 238)),\r\n    boundaries,\r\n  };\r\n};\r\n","import { filter, reduce } from \".\";\n\nexport type Rebinder = () => boolean;\nexport type Unbinder = () => boolean;\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\n\nexport type SourceListener<Args extends readonly any[]> = (\n  ...args: Args\n) => void;\nexport type Listener<Args extends readonly any[]> = (\n  ...args: [...args: Args, unbind: Unbinder]\n) => void;\n\nexport const createEventBinders = <Args extends any[]>(\n  listener: Listener<Args>,\n  attach: (listener: SourceListener<Args>) => void,\n  detach: (listener: SourceListener<Args>) => void\n): Binders => {\n  let bound = false;\n\n  const outerListener = (...args: Args) => listener(...args, unbind);\n\n  const unbind = () =>\n    bound !== (bound = false) && (detach(outerListener), true);\n\n  const rebind = () =>\n    bound !== (bound = true) && (attach(outerListener), true);\n\n  rebind();\n  return [unbind, rebind];\n};\n\nexport const joinEventBinders = (\n  ...binders: (Binders | undefined)[]\n): Binders => (\n  (binders = filter(binders)),\n  [\n    () => reduce(binders, (changed, binder) => binder![0]() || changed, false),\n    () => reduce(binders, (changed, binder) => binder![1]() || changed, false),\n  ]\n);\n\nexport type EventHandler<Args extends readonly any[]> = (\n  ...payload: Args\n) => void;\n\nexport const createEvent = <Args extends readonly any[]>(): [\n  listen: (listener: Listener<Args>, triggerCurrent?: boolean) => Binders,\n  dispatch: (...payload: Args) => void\n] => {\n  const listeners = new Set<SourceListener<Args>>();\n  let dispatchedArgs: Args | undefined;\n  return [\n    (handler, trigger) => {\n      const binders = createEventBinders(\n        handler as any,\n        (handler) => listeners.add(handler as any),\n        (handler) => listeners.delete(handler as any)\n      );\n      trigger &&\n        dispatchedArgs &&\n        (handler as any)(...dispatchedArgs, binders[0]);\n      return binders;\n    },\n    (...payload) => (\n      (dispatchedArgs = payload),\n      listeners.forEach((handler) => handler(...payload))\n    ),\n  ];\n};\n\nexport type ChainedEventHandler<Args extends any[], T> = (\n  ...args: [\n    ...args: Args,\n    next: {\n      (): T;\n      (...args: Args): T;\n    },\n    unbind: Unbinder\n  ]\n) => T;\n\ntype LinkedNode<T> = [\n  prev: LinkedNode<T> | undefined,\n  item: T,\n  next: LinkedNode<T> | undefined\n];\n\nexport const createChainedEvent = <T = void, Args extends any[] = []>(): [\n  register: (\n    handler: ChainedEventHandler<Args, T>,\n    priority?: number\n  ) => Binders,\n  invoke: (...args: Args) => T | undefined\n] => {\n  type Item = [\n    handler: ChainedEventHandler<Args, T>,\n    priority: number,\n    binders: Binders\n  ];\n  type Node = LinkedNode<Item>;\n  let head: Node | undefined;\n  let tail: Node | undefined;\n  let next: Node | undefined;\n\n  const register = (\n    handler: ChainedEventHandler<Args, T>,\n    // Make sure that handler gets rebound at their previous priority without jumping discrete increments.\n    // (It is deseriable to be able to specfiy priority 0 or  10 without having to think about how many 0s there are)\n    priority = (tail?.[1][1] ?? 0) + 0.000001\n  ) => {\n    const registerNode = (node?: Node) => {\n      let bound = true;\n      node ??= [\n        undefined,\n        [\n          handler,\n          priority,\n          [\n            () => {\n              if (!bound) return false;\n              node![0] ? (node![0][2] = node![2]) : (head = node![2]);\n              node![2] ? (node![2][0] = node![0]) : (tail = node![0]);\n              node![0] = node![2] = undefined;\n              return !(bound = false);\n            },\n            () => (bound ? false : (registerNode(node), (bound = true))),\n          ],\n        ],\n        undefined,\n      ];\n      next = head;\n      if (!next) {\n        head = tail = node;\n      } else if (priority >= tail![1][1]) {\n        node[0] = tail;\n        tail = tail![2] = node;\n      } else {\n        // INV: priority < tail.priority, so next will be non-null after loop;\n        while (next![1][1]! <= priority) {\n          next = next[2]!;\n        }\n\n        (node[0] = (node[2] = next)[0]) ? (node[0][2] = node) : (head = node);\n        next[0] = node;\n      }\n\n      return node[1][2];\n    };\n    return registerNode();\n  };\n\n  const invoke = (node: Node | undefined, args: Args) => (\n    (next = node?.[2]),\n    node\n      ? node[1][0](\n          ...args,\n          (...nextArgs: Args) =>\n            invoke(next!, nextArgs.length ? nextArgs : args),\n          node[1][2][0]\n        )\n      : undefined\n  );\n\n  return [register, (...args) => invoke(head, args)];\n};\n","import {\n  AllKeys,\n  Entries,\n  Extends,\n  Nullish,\n  Property,\n  define,\n  entries,\n  isArray,\n  isNumber,\n  isObject,\n  isString,\n  obj,\n  throwError,\n  undefined,\n  quote,\n  enumerate,\n  array,\n  map,\n  isInteger,\n} from \".\";\n\nexport type ParsedValue<\n  T extends EnumHelper<any, any, any>,\n  V\n> = V extends Nullish\n  ? V\n  : T extends EnumHelper<infer T, infer Flags & boolean, any>\n  ? V extends keyof T\n    ? T[V]\n    : V extends T[keyof T]\n    ? V\n    : Flags extends true\n    ? number\n    : never\n  : never;\n\ntype EnumValue_<\n  Names extends string,\n  Enum,\n  Flags extends boolean,\n  Numeric\n> = boolean extends Numeric\n  ? Names | Enum | (Flags extends true ? (Names | Enum)[] : never)\n  : Numeric extends true\n  ? Enum\n  : Names | (Flags extends true ? Names[] : never);\n\nexport type EnumValueOf<\n  Helper extends EnumHelper<any, any, any>,\n  Numeric = boolean\n> = Helper extends EnumHelper<infer T, infer Flags & boolean, any>\n  ? EnumValue_<keyof T & string, T[keyof T], Flags & boolean, Numeric>\n  : never;\n\nexport type EnumValue<\n  Names extends Record<string, any>,\n  Enum,\n  Flags extends boolean,\n  Numeric\n> = EnumValue_<\n  Lowercase<keyof Names extends string ? keyof Names : never>,\n  Flags extends true ? Enum | (number & {}) : Enum,\n  Flags,\n  Numeric\n>;\n\nexport type EnumHelper<\n  T extends EnumSource,\n  Flags extends boolean,\n  PureFlags extends number\n> = ParseFunction<T, Flags, \"numeric\", never, true> &\n  Readonly<\n    {\n      /**\n       * The number of possible unique values in the enumeration.\n       */\n      length: number;\n      /**\n       * Converts the provided value to its numeric value or throws an exception if it does not match a value in the enumeration.\n       */\n      parse: ParseFunction<T, Flags, \"numeric\">;\n\n      /**\n       * Converts the provided value to its numeric value or returns `undefined` if it does not match a value in the enumeration.\n       */\n      tryParse: ParseFunction<T, Flags, \"numeric\", undefined>;\n\n      /**\n       * All values of the enumeration.\n       */\n      values: T[keyof T][];\n\n      /**\n       * All names and values of the enumeration.\n       */\n      entries: string extends keyof T\n        ? readonly [string, T[keyof T]][]\n        : Entries<T>;\n\n      /**\n       * Looks up a value and returns its name or array of names if the enumeration represents flags.\n       */\n      lookup: ParseFunction<T, Flags, \"lookup\">;\n\n      /**\n       * Looks up a value and returns its name if it matches a single value in the enumeration ,\n       * or an array of names if the enumeration represents flags and the value matches more than one.\n       */\n      format: ParseFunction<T, Flags, \"format\">;\n\n      /**\n       * Pretty prints an enumeration value with its name and values suitable for logging and error messages.\n       * For example \"The values 'test 1' or 'test 2'\".\n       */\n      logFormat(value: ParsableArg<T, Flags>, conjunction?: string): string;\n    } & (Flags extends true\n      ? {\n          /** Flag values that are not a combination of other flags (that is, a single bit). */\n          pure: readonly EntriesByValue<T, PureFlags>[];\n          map<R = T[keyof T]>(\n            flags: ParsableEnumTypeValue<T, boolean | undefined, Flags>,\n            map?: (entry: EntriesByValue<T, PureFlags>, index: number) => R\n          ): R[];\n        }\n      : {})\n  >;\n\ntype EnumSource = Record<string, string | number>;\n\ntype MaybeArray<T, Flags, ArrayIfArray = false> = Flags extends true\n  ? (ArrayIfArray extends true ? never : T) | T[]\n  : T;\n\ntype Lowercased<T extends EnumSource> = {\n  [P in keyof T & string as Lowercase<P>]: T[P];\n};\n\ntype Lookup<T extends EnumSource, V, Name extends boolean> = V extends never\n  ? never\n  : {\n      [P in keyof T]: V extends T[P] ? (Name extends true ? P : T[P]) : never;\n    } extends infer T\n  ? T[keyof T]\n  : never;\n\ntype ParsedValueInternal<T extends EnumSource, V, Flags> = V extends keyof T\n  ? T[V]\n  : V extends T[keyof T]\n  ? Lookup<T, V, false>\n  : [Flags, V] extends [true, number]\n  ? T[keyof T]\n  : never;\n\nexport type ParsableEnumTypeValue<\n  T extends EnumSource,\n  Numeric,\n  Flags extends boolean,\n  Enum extends number = T[keyof T] & number\n> =\n  | (boolean extends Numeric\n      ? MaybeArray<\n          | (Flags extends true ? number | Enum : Enum)\n          | keyof T\n          | (Flags extends true ? \"any\" | \"none\" : never),\n          Flags\n        >\n      : Numeric extends true\n      ? Flags extends true\n        ? Enum | (number & {})\n        : Enum\n      : Flags extends true\n      ? keyof T | readonly (keyof T)[]\n      : keyof T)\n  | (undefined extends Numeric ? undefined : never);\n\ntype ParsableArg<\n  T extends EnumSource,\n  Flags extends boolean\n> = ParsableEnumTypeValue<T, boolean | undefined, Flags>;\n\ntype ParseFunction<\n  T extends EnumSource,\n  Flags extends boolean,\n  Type extends \"numeric\" | \"lookup\" | \"format\",\n  InvalidValue extends undefined | never = never,\n  MainFunction = false\n> = {\n  <V extends string | number | symbol | null | undefined>(\n    value:\n      | V\n      | ParsableArg<T, Flags>\n      | (Flags extends true ? V[] | ParsableArg<T, Flags>[] : never),\n    ...args: MainFunction extends true ? [] : [validateNumbers?: boolean]\n  ): V extends null | undefined\n    ? undefined\n    : Type extends \"lookup\" | \"format\"\n    ? MaybeArray<\n        | (ParsedValueInternal<T, V, Flags> extends never\n            ? V extends string | number\n              ? keyof T | \"any\" | \"none\" | InvalidValue\n              : InvalidValue\n            : Lookup<T, ParsedValueInternal<T, V, Flags>, true>)\n        | (Type extends \"format\"\n            ? V extends keyof T | T[keyof T]\n              ? never\n              : \"any\" | \"none\"\n            : never),\n        Flags,\n        Type extends \"lookup\" ? true : false\n      >\n    : ParsedValueInternal<T, V, Flags> extends never\n    ? keyof any extends infer K\n      ? K extends V\n        ? T[keyof T] | InvalidValue\n        : never\n      : InvalidValue\n    : ParsedValueInternal<T, V, Flags>;\n};\n\ntype EntriesByValue<T extends Record<keyof any, any>, V extends keyof any> = {\n  [P in keyof T as T[P]]: readonly [P, T[P]];\n}[V] extends infer T // Use the infer trick to make vscode intellisense expand the values.\n  ? T\n  : never;\n\nconst isBit = (n: number) => ((n = Math.log2(n)), n === (n | 0));\n\nexport const createEnumAccessor = <\n  T extends EnumSource,\n  Flags extends boolean,\n  PureFlags extends number = 0\n>(\n  sourceEnum: T,\n  flags: Flags,\n  enumName: string,\n  pureFlags?: PureFlags\n): EnumHelper<Lowercased<T>, Flags, PureFlags> => {\n  const names: Record<string, number> = Object.fromEntries(\n    Object.entries(sourceEnum as any)\n      .filter(([key, value]) => isString(key) && isNumber(value))\n      .map(([key, value]) => [key.toLowerCase(), value])\n  ) as any;\n\n  const entries = Object.entries(names);\n  const values = Object.values(names);\n\n  const any = names[\"any\"] ?? values.reduce((any, flag) => any | flag, 0);\n\n  const nameLookup: Record<string, number> = flags\n    ? { ...names, any, none: 0 }\n    : names;\n\n  const valueLookup = Object.fromEntries(\n    Object.entries(nameLookup).map(([key, value]) => [value, key])\n  );\n\n  const parseValue = (value: any, validateNumbers?: boolean) =>\n    isInteger(value)\n      ? !flags && validateNumbers\n        ? valueLookup[value] != null\n          ? value\n          : undefined\n        : Number.isSafeInteger(value)\n        ? value\n        : undefined\n      : isString(value)\n      ? nameLookup[value] ??\n        nameLookup[value.toLowerCase()] ??\n        // Sometimes a number may have been stored as a string.\n        // Let's see if that is the case.\n        parseValue(parseInt(value), validateNumbers)\n      : undefined;\n\n  let invalid = false;\n  let carry: any;\n  let carry2: any;\n\n  const [tryParse, lookup] = flags\n    ? [\n        (value: any, validateNumbers?: boolean) =>\n          Array.isArray(value)\n            ? value.reduce(\n                (flags, flag) =>\n                  flag == null || invalid\n                    ? flags\n                    : (flag = parseValue(flag, validateNumbers)) == null\n                    ? ((invalid = true), undefined)\n                    : (flags ?? 0) | flag,\n                ((invalid = false), undefined as number | undefined)\n              )\n            : parseValue(value),\n        (value: any, format: boolean) =>\n          (value = tryParse(value, false)) == null\n            ? undefined\n            : format && (carry2 = valueLookup[value & any])\n            ? (carry = lookup(value & ~(value & any), false)).length\n              ? [carry2, ...carry]\n              : carry2\n            : ((value = entries\n                .filter(([, flag]) => flag && value & flag && isBit(flag))\n                .map(([name]) => name)),\n              format\n                ? value.length\n                  ? value.length === 1\n                    ? value[0]\n                    : value\n                  : \"none\"\n                : value),\n      ]\n    : [\n        parseValue,\n        (value: any) =>\n          (value = parseValue(value)) != null ? valueLookup[value] : undefined,\n      ];\n\n  let originalValue: any;\n  const parse = (value: any, validateNumbers?: boolean) =>\n    value == null\n      ? undefined\n      : (value = tryParse((originalValue = value), validateNumbers)) == null\n      ? throwError(\n          new TypeError(\n            `${JSON.stringify(originalValue)} is not a valid ${enumName} value.`\n          )\n        )\n      : value;\n\n  const pure = entries.filter(\n    ([, value]) => !pureFlags || ((pureFlags & value) === value && isBit(value))\n  );\n\n  return define(\n    (value: any) => parse(value),\n    [\n      { configurable: false, enumerable: false },\n      {\n        parse,\n        tryParse,\n        entries,\n        values,\n        lookup,\n        length: entries.length,\n        format: (value: any) => lookup(value, true),\n        logFormat: (value: any, c = \"or\") => (\n          (value = lookup(value, true)),\n          value === \"any\"\n            ? \"any \" + enumName\n            : `the ${enumName} ${enumerate(\n                map(array(value), (value) => quote(value)),\n                [c]\n              )}`\n        ),\n      } as const,\n      flags &&\n        ({\n          pure,\n          map: (flags: any, map?: (flag: any, index: number) => any) => (\n            (flags = parse(flags)),\n            pure\n              .filter(([, flag]) => flag & flags)\n              .map(map ?? (([, flag]) => flag))\n          ),\n        } as const),\n    ]\n  ) as any;\n};\n\ntype NumericValues<T, Flags> = Flags extends true ? number : T[keyof T];\n\ntype EnumPropertyType<Helper, Value> = Helper extends EnumHelper<\n  infer T,\n  infer Flags extends boolean,\n  any\n>\n  ? Extends<number | string, Value> extends true\n    ? NumericValues<T, Flags>\n    : Value extends infer Keys extends keyof T\n    ? T[Keys]\n    : Value extends NumericValues<T, Flags>\n    ? Value\n    : never\n  : never;\n\nexport type ParsedEnumResult<\n  T,\n  EnumProps extends readonly Record<string, EnumHelper<any, any, any>>[]\n> = T extends Nullish\n  ? T\n  : T extends readonly []\n  ? []\n  : T extends readonly [infer Item, ...infer Rest]\n  ? [\n      ParsedEnumResult<Item, EnumProps>,\n      ...(Rest extends readonly any[] ? ParsedEnumResult<Rest, EnumProps> : [])\n    ]\n  : T extends readonly (infer Item)[]\n  ? ParsedEnumResult<Item, EnumProps>[]\n  : T extends infer T\n  ? {\n      [P in keyof T]: P extends AllKeys<EnumProps[number]>\n        ? EnumPropertyType<Property<EnumProps[number], P>, T[P]>\n        : T[P];\n    }\n  : never;\n\n/**\n * Creates a function that parses the specified enum properties to their numeric values on the object provided.\n * Note that it does the parsing directly on the provided object and does not create a copy.\n */\nexport const createEnumPropertyParser: <\n  EnumProps extends readonly Record<string, EnumHelper<any, any, any>>[]\n>(\n  ...props: EnumProps\n) => <T>(value: T) => ParsedEnumResult<T, EnumProps> = ((\n  ...props: Record<string, EnumHelper<any, any, any>>[]\n) => {\n  const parsers = entries(obj(props, true));\n\n  const parse = (source: any) => (\n    isObject(source) &&\n      (isArray(source)\n        ? source.forEach((sourceItem, i) => (source[i] = parse(sourceItem)))\n        : parsers.forEach(([prop, parsers]) => {\n            let parsed = undefined;\n            let value: any;\n            if ((value = source[prop]) == null) return;\n            parsers.length === 1\n              ? (source[prop] = parsers[0].parse(value))\n              : parsers.forEach(\n                  (parser, i) =>\n                    !parsed &&\n                    (parsed =\n                      i === parsers.length - 1\n                        ? parser.parse(value)\n                        : parser.tryParse(value)) != null &&\n                    (source[prop] = parsed)\n                );\n          })),\n    source\n  );\n\n  return parse;\n}) as any;\n","import {\n  MaybeUndefined,\n  Nullish,\n  PickRequired,\n  PrettifyIntersection,\n  RecordType,\n  concat,\n  forEach,\n  isArray,\n  isString,\n  join,\n  map,\n  mapFirst,\n  match,\n  nil,\n  obj,\n  undefined,\n} from \".\";\n\ntype QueryStringDelimiterValue = boolean | readonly string[] | readonly [];\n\nexport type ParsedUri<\n  QueryStringDelimiters extends QueryStringDelimiterValue = QueryStringDelimiterValue\n> = {\n  /** The original URI that was parsed. */\n  source: string;\n  /** The name of the scheme excluding colon and slashes. */\n  scheme?: string;\n\n  /**\n   * Whether the scheme includes two slashes or not (in which case it is a urn).\n   * Slashes are only included when formatting the URI if this value is explicity `false`,\n   * or {@link scheme} has a value and it is not explicitly `true`.\n   *\n   * @default false\n   */\n  urn?: boolean;\n\n  /**\n   * User name, password, host and port as much as any of these are part of the URI.\n   * When formatting a parsed URI, this is not used, but rather the individual parts.\n   */\n  authority?: string;\n\n  user?: string;\n  password?: string;\n  host?: string;\n  port?: number;\n  path?: string;\n  query?: QueryStringDelimiters extends false\n    ? string\n    : ParsedQueryString<Exclude<QueryStringDelimiters, null>>;\n  fragment?: string;\n};\n\nexport const parameterList = Symbol();\nexport type ParsedQueryString<Delimiters extends QueryStringDelimiterValue> =\n  Record<\n    string,\n    Delimiters extends null | readonly [] | false ? string : string | string[]\n  > & {\n    [parameterList]: [\n      string,\n      Delimiters extends null | readonly [] | false ? string : string | string[]\n    ];\n  };\n\nexport const uriEncode = (value: any) =>\n  value != nil ? encodeURIComponent(value) : undefined;\n\nexport const parseKeyValue = (\n  value: string | Nullish,\n  arrayDelimiters: readonly string[] | readonly [] = [\"|\", \";\", \",\"],\n  decode = true\n):\n  | readonly [key: string, value: string | undefined, values: string[]]\n  | undefined => {\n  if (!value) return undefined;\n  const parts: [string, string, string[]] = value\n    .split(\"=\")\n    .map((v) =>\n      decode ? decodeURIComponent(v.trim()).replaceAll(\"+\", \" \") : v.trim()\n    ) as any;\n  parts[1] ??= \"\";\n  parts[2] =\n    (parts[1] &&\n      arrayDelimiters?.length &&\n      mapFirst(arrayDelimiters, (delim, _, split = parts[1]!.split(delim)) =>\n        split.length > 1 ? split : undefined\n      )) ||\n    (parts[1] ? [parts[1]] : []);\n  return parts;\n};\n\n// // Browsers accepts `//` as \"whatever the protocol is\" is links.\n// // A scheme can only be letters, digits, `+`, `-` and `.`.\n// // The slashes are captured so we can put the parsed URI correctly back together.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1\n// Scheme (group 1 and 2) = `//` or `name:` or `name://` = (?:(?:([\\w+.-]+):)?(\\/\\/)?)\n\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.1\n// User Information (groups 4 and 5) = `user@` or `user:password@` = (?:([^:@]+)(?:\\:([^@]*))?@)\n\n// // If an IPv6 address is used with a port it is wrapped in square brackets.\n// // Otherwise a host is anything until port, path or query string.\n// // Se also https://serverfault.com/questions/205793/how-can-one-distinguish-the-host-and-the-port-in-an-ipv6-url about the brackets.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2\n// Host (group 6 or 7) = `[ IPv6 or IPvFuture ]:port` or IPv6 or `IPv4:port` or `domain:port`  = (?:\\[([^\\]]+)\\]|([0-9:]+|[^/+]+?))\n\n// //Port is included in the optional host group to separate `about:blank` like schemes from `localhost:1337` like hosts\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.3\n// Port (group 8) = (?::(\\d*))?\n\n// Authority (group 3) = User Information + Host + Port\n\n// // Anything until an optional query or fragment\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3\n// Path and  (group 9) = (\\/[^#?]*)\n\n// // Anything following a `?` until an optional fragment.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.4\n// Query (group 10) = (?:\\?([^#]*))\n\n// // Anything following a pound sign until end.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\n// Fragment (group 11) = (?:#.*)\n\n// Everything put together\n// ^(?:(?:([\\w+.-]+):)?(?:\\/\\/)?)?((?:([^:@]+)(?:\\:([^@]*))?@)?(?:\\[([^\\]]+)\\]|([0-9:]+|[^/+]+?))?(?::(\\d*))?)?(\\/[^#?]*)?(?:\\?([^#]*))?(?:#(.*))?$\n\n/**\n * Parses an URI according to https://www.rfc-editor.org/rfc/rfc3986#section-2.1.\n * The parser is not pedantic about the allowed characters in each group\n *\n * @param uri The URI to parse\n * @param query Whether to parse the query into a record with each parameter and its value(s) or just the string.\n *  If an array is provided these are the characters that are used to split query string values. If this is empty, arrays are not parsed.\n * @returns A record with the different parts of the URI.\n */\nexport const parseUri = <\n  Uri extends string | Nullish,\n  QueryString extends QueryStringDelimiterValue = true,\n  RequireAuthority extends boolean = false\n>(\n  uri: Uri,\n  query: QueryString = true as any,\n  requireAuthority?: RequireAuthority\n): PrettifyIntersection<\n  RequireAuthority extends true\n    ? PickRequired<ParsedUri<QueryString>, \"scheme\" | \"host\" | \"urn\" | \"path\">\n    : ParsedUri<QueryString>,\n  true\n> =>\n  uri == nil\n    ? undefined\n    : (match(\n        uri,\n        /^(?:(?:([\\w+.-]+):)?(\\/\\/)?)?((?:([^:@]+)(?:\\:([^@]*))?@)?(?:\\[([^\\]]+)\\]|([0-9:]+|[^/+]+?))?(?::(\\d*))?)?(\\/[^#?]*)?(?:\\?([^#]*))?(?:#(.*))?$/g,\n        (\n          source: string,\n          scheme,\n          slashes,\n          authority,\n          user,\n          password,\n          bracketHost,\n          host,\n          port,\n          path,\n          queryString,\n          fragment\n        ) => {\n          const parsed: ParsedUri = {\n            source,\n            scheme,\n            urn: scheme ? !slashes : slashes ? false : undefined,\n            authority,\n            user,\n            password,\n            host: bracketHost ?? host,\n            port: port != null ? parseInt(port) : undefined,\n            path,\n            query:\n              query === false\n                ? queryString\n                : parseQueryString(queryString, query),\n            fragment,\n          };\n          parsed.path =\n            parsed.path ||\n            (parsed.authority ? (parsed.urn ? \"\" : \"/\") : undefined);\n          return parsed;\n        }\n      ) as any);\n\nexport const parseHttpHeader = <\n  V extends string | Nullish,\n  Delimiters extends QueryStringDelimiterValue = [\",\"]\n>(\n  query: V,\n  arrayDelimiters: Delimiters = [\",\"] as any,\n  decode = true\n): PrettifyIntersection<ParsedQueryString<Delimiters>> =>\n  parseParameters(query, \"; \", arrayDelimiters, decode);\n\nexport const parseQueryString = <\n  V extends string | Nullish,\n  Delimiters extends QueryStringDelimiterValue = true\n>(\n  query: V,\n  arrayDelimiters?: Delimiters,\n  decode = true\n): PrettifyIntersection<ParsedQueryString<Delimiters>> =>\n  parseParameters(query, \"&\", arrayDelimiters, decode);\n\nexport const parseParameters = <\n  V extends string | Nullish,\n  Delimiters extends QueryStringDelimiterValue = true\n>(\n  query: V,\n  separator: string,\n  arrayDelimiters?: Delimiters,\n  decode = true\n): PrettifyIntersection<ParsedQueryString<Delimiters>> => {\n  const list: [string, any][] = [];\n\n  const results =\n    query == nil\n      ? undefined\n      : (obj(\n          query?.match(/(?:^.*?\\?|^)([^#]*)/)?.[1]?.split(separator),\n          (\n            part,\n            _,\n            [key, value, values] = parseKeyValue(\n              part,\n              arrayDelimiters === false\n                ? []\n                : arrayDelimiters === true\n                ? undefined\n                : arrayDelimiters,\n              decode\n            ) ?? [],\n            kv: any\n          ) => (\n            (kv =\n              (key = key?.replace(/\\[\\]$/, \"\")) != null\n                ? arrayDelimiters !== false\n                  ? [key, values!.length > 1 ? values! : (value! as any)]\n                  : [key, value!]\n                : undefined),\n            list.push(kv),\n            kv\n          ),\n          (current, value) =>\n            current\n              ? arrayDelimiters !== false\n                ? concat(current, value)\n                : (current ? current + \",\" : \"\") + value\n              : value\n        ) as any);\n\n  results && (results[parameterList] = list);\n\n  return results;\n};\n\nexport const toQueryString = <\n  P extends\n    | Iterable<readonly [string, any]>\n    | RecordType<string, any>\n    | undefined\n>(\n  parameters: P,\n  delimiter = \",\"\n): MaybeUndefined<P, string> =>\n  parameters == nil\n    ? undefined\n    : (map(parameters, ([key, value]) =>\n        isString(key)\n          ? key +\n              \"=\" +\n              (isArray(value)\n                ? map(value, uriEncode).join(delimiter)\n                : uriEncode(value)) ?? \"\"\n          : undefined\n      )?.join(\"&\") as any);\n\nexport const appendQueryString = <Uri extends string | undefined>(\n  baseUri: Uri,\n  parameters:\n    | Record<string, any>\n    | Iterable<readonly [key: string, value: any]>\n    | undefined\n): MaybeUndefined<Uri, string> => {\n  if (!baseUri) return undefined!;\n  const qs = toQueryString(parameters);\n  return (baseUri.match(/^[^?]*/)![0] + (qs ? \"?\" + qs : \"\")) as any;\n};\n\nexport const mergeQueryString = <Uri extends string | undefined>(\n  currentUri: Uri,\n  parameters:\n    | Record<string, any>\n    | Iterable<readonly [key: string, value: any]>\n    | undefined\n): MaybeUndefined<Uri, string> => {\n  if (!currentUri) return undefined!;\n  const current = parseQueryString(currentUri);\n  forEach(parameters, ([key, value]) => (current[key] = current[key] ?? value));\n  return appendQueryString(currentUri, current) as any;\n};\n\nexport const formatUri = <Uri extends Omit<ParsedUri, \"source\">>(\n  uri: Uri\n): MaybeUndefined<Uri, string> =>\n  uri == nil\n    ? (undefined as any)\n    : join([\n        uri.scheme || uri.urn === false\n          ? (uri.scheme ? uri.scheme + \":\" : \"\") + (!uri.urn ? \"//\" : \"\")\n          : \"\",\n        uri.user,\n        uri.password ? \":\" + uri.password : undefined,\n        uri.user && \"@\",\n        uri.host,\n        uri.port ? \":\" + uri.port : undefined,\n        uri.path === \"/\" ? \"\" : uri.path,\n        uri.query &&\n          \"?\" + (isString(uri.query) ? uri.query : toQueryString(uri.query)),\n        uri.fragment && \"#\" + uri.fragment,\n      ]) || undefined!;\n","import { assign, forEach, some, sum } from \".\";\r\n\r\nexport type Interval<T> = [start: T, end: T];\r\nexport type Intervals<T = number> = ReadonlyArray<[start: T, end: T]> & {\r\n  /**\r\n   * Updates the intervals to include the specified start and end,\r\n   * and returns the updated total width.\r\n   *\r\n   */\r\n  push: (start: T, end: T) => number;\r\n\r\n  /** The total width of the intervals. */\r\n  width: number;\r\n};\r\n\r\nexport const createIntervals = <T = number>(\r\n  cmp: (x: T, y: T) => number = (x: any, y: any) => (x - y) as any,\r\n  width: (interval: Interval<T>) => number = (interval: any) =>\r\n    (interval[1] - interval[0]) as any\r\n): Intervals<T> => {\r\n  const ranges: Interval<T>[] = [];\r\n\r\n  return assign(ranges, {\r\n    push(start: T, end: T) {\r\n      let pending: Interval<T> | undefined = [start, end];\r\n\r\n      const finalize = (update: any = true) =>\r\n        update\r\n          ? ((ranges as any).width = ranges.reduce(\r\n              (sum, interval) => sum + width(interval),\r\n              0\r\n            ))\r\n          : (ranges as any).width;\r\n\r\n      let changed: any;\r\n      for (let i = 0; i < ranges.length; i++) {\r\n        let current = ranges[i];\r\n        if (cmp(pending[1], current[0]) < 0) {\r\n          // Ends before next start. Insert before.\r\n          return finalize(ranges.splice(i, 0, pending));\r\n        } else if (cmp(pending[0], current[1]) <= 0) {\r\n          if (cmp(pending[0], current[0]) < 0) {\r\n            // Expand left (changed).\r\n            changed = current[0] = pending[0];\r\n          }\r\n          if (cmp(pending[1], current[1]) > 0) {\r\n            // Expand right (changed).\r\n            changed = current[1] = pending[1];\r\n          }\r\n          if (ranges[i + 1]?.[0] < current[1]) {\r\n            // Detach the current range since it is to be merged with the next.\r\n            changed = pending = ranges.splice(i--, 1)[0];\r\n          } else {\r\n            // Only update the total width if the current range was expanded or merged.\r\n            return finalize(changed != null);\r\n          }\r\n        }\r\n      }\r\n\r\n      // If there still is a pending range it means its start comes after the current end.\r\n      // Only update width in that case.\r\n      return finalize(pending && (ranges[ranges.length] = pending));\r\n    },\r\n    width: 0,\r\n  }) as any;\r\n};\r\n","import { CLIENT_STORAGE_PREFIX } from \"@constants\";\n\nimport { TrackedEvent } from \"@tailjs/types\";\nimport { Nullish, throwError } from \"@tailjs/util\";\n\nexport const DEBUG = true;\nexport const HEARTBEAT_FREQUENCY = 5_000;\nexport const REQUEST_LOCK_KEY = CLIENT_STORAGE_PREFIX + \"rq\";\nexport const VARIABLE_POLL_FREQUENCY = 3_000;\nexport const VARIABLE_CACHE_DURATION = 3_000;\nexport const EVENT_POST_FREQUENCY = 5000;\n\nexport const NOT_INITIALIZED = () => () => throwError(\"Not initialized.\");\n\nexport type TrackerContext = {\n  deviceSessionId?: string;\n\n  applyEventExtensions(event: TrackedEvent): TrackedEvent | undefined;\n\n  validateKey: {\n    (key: string | Nullish, throwIfInvalid?: true): true;\n    (key: string | Nullish, throwIfInvalid: false): boolean;\n  };\n};\n","import { toggleAnsi, type Nullish } from \"@tailjs/util\";\n\nexport const SSR = typeof window === \"undefined\";\n\nconst win = window;\nconst doc = document;\nconst nav = navigator;\nconst body = doc.body;\nconst loc = location;\nconst perf = performance;\nconst hist = win.history;\nexport {\n  body,\n  doc as document,\n  hist as history,\n  loc as location,\n  nav as navigator,\n  perf as performance,\n  win as window,\n};\n\nexport const createElement = (tagName: string) => doc.createElement(tagName);\n\nexport const matchSelector = (node: Element | Nullish, selector: string) =>\n  !!node?.matches(selector);\n\ntoggleAnsi(!!(win as any).chrome);\n","import { EnumValue, Nullish, createEnumAccessor, isNumber } from \"@tailjs/util\";\nimport { DataPurposeFlags, DataPurposeValue, dataPurposes } from \".\";\n\n/**\n * Defines to which extend a piece of information relates to a natural person (user of your app or website).\n *\n * Tail.js requires all data points (data types and their properties) to be classified to prevent any data from being stored or otherwise used beyond a user's consent.\n *\n * YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with its default settings, intended design or implementation.\n *\n */\nexport enum DataClassification {\n  /**\n   * The data cannot reasonably be linked to a specific user after the user leaves the website or app, and their session ends.\n   *\n   * Tail.js will collect this kind of data in a way that does not use cookies or rely on other information persisted in the user's device.\n   *\n   * Identifying returning visitors will not be possible at this level.\n   * In-session personalization will be possible based on the actions a user has taken such as adding or removing things to a shopping basket, or reading an article.\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with its default settings, intended design or implementation.\n   */\n  Anonymous = 0,\n\n  /**\n   * The data may possibly identify the user if put into context with other data, yet not specifically on its own.\n   *\n   * Examples of data you should classify as at least indirect personal data are IP addresses, detailed location data, and randomly generated device IDs persisted over time to track returning visitors.\n   *\n   * Identifying returning visitors will be possible at this level of consent, but not across devices.\n   * Some level of personalization to returning visitors will be possible without knowing their specific preferences with certainty.\n   *\n   * This level is the default when a user has consented to necessary information being collected via a  cookie disclaimer or similar.\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with its default settings, intended design or implementation.\n   */\n  Indirect = 1,\n\n  /**\n   * The data directly identifies the user on its own.\n   *\n   * Examples are name, username, street address and email address.\n   *\n   * Identifying returning visitors across devices will be possible at this level of consent.\n   * Personalization based on past actions such as purchases will also be possible.\n   *\n   * This level is the default should be considered the default level if users are offered an option to create a user profile or link an existing user profile from an external identity provider (Google, GitHub, Microsoft etc.).\n   *\n   * Please note it is possible to access user data even when nothing is tracked beyond the bla... level\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with default settings.\n   */\n  Direct = 2,\n\n  /**\n   * Sensitive data about a user.\n   *\n   * Examples are data related to health, financial matters, race, political and religious views, and union membership.\n   * If the user is given the option to consent at this level, it should be very clear, and you must make sure that all levels of your tail.js implementation and connected services meets the necessary levels of compliance for this in your infrastructure.\n   *\n   * Identifying returning visitors across devices will be possible at this level of consent.\n   * and so will advanced personalization.\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with default settings.\n   */\n  Sensitive = 3,\n}\n\nexport const dataClassification = createEnumAccessor(\n  DataClassification,\n  false,\n  \"data classification\"\n);\n\nexport type DataClassificationValue<Numeric = boolean> = EnumValue<\n  typeof DataClassification,\n  DataClassification,\n  false,\n  Numeric\n> extends infer T\n  ? T\n  : never;\n\nexport type DataUsageAttributes<NumericEnums = true> = {\n  classification: DataClassificationValue<NumericEnums>;\n  purposes: DataPurposeValue<NumericEnums>;\n};\n\nexport type ParsableDataUsageAttributes = {\n  classification?: DataClassificationValue;\n  level?: DataClassificationValue;\n  purpose?: DataPurposeValue;\n  purposes?: DataPurposeValue;\n};\n\nexport const dataUsageEquals = (\n  lhs: ParsableDataUsageAttributes | Nullish,\n  rhs: ParsableDataUsageAttributes | Nullish\n) =>\n  dataClassification.parse(lhs?.classification ?? lhs?.level) ===\n    dataClassification.parse(rhs?.classification ?? rhs?.level) &&\n  dataPurposes.parse(lhs?.purposes ?? lhs?.purposes) ===\n    dataPurposes.parse(rhs?.purposes ?? rhs?.purposes);\n\nexport const parseDataUsage = <T extends ParsableDataUsageAttributes | Nullish>(\n  classificationOrConsent: T,\n  defaults?: Partial<DataUsageAttributes<boolean>>\n): T extends {}\n  ? DataUsageAttributes<true> & Omit<T, keyof ParsableDataUsageAttributes>\n  : undefined =>\n  classificationOrConsent == null\n    ? (undefined as any)\n    : isNumber(classificationOrConsent.classification) &&\n      isNumber(classificationOrConsent.purposes)\n    ? classificationOrConsent\n    : {\n        ...classificationOrConsent,\n        level: undefined,\n        purpose: undefined,\n        classification: dataClassification.parse(\n          classificationOrConsent.classification ??\n            classificationOrConsent.level ??\n            defaults?.classification ??\n            DataClassification.Anonymous\n        ),\n        purposes: dataPurposes.parse(\n          classificationOrConsent.purposes ??\n            classificationOrConsent.purpose ??\n            defaults?.purposes ??\n            DataPurposeFlags.Necessary\n        ),\n      };\n","import { EnumValue, createEnumAccessor } from \"@tailjs/util\";\r\n\r\n/** Data purposes are flags that can be combined, so if multiple are needed you can combine them with bitwise OR (the `|` operator).  */\r\nexport type DataPurposesFlagHint = number & {};\r\n\r\n// Grr... We need to write out the calculated numbers for each enum value. Otherwise stupid JSON schema generator won't work.\r\n// Also ts-json-schema-generator does not support template literals, hence automatic PascalCase to snake-case doesn't work.\r\n// This is why non-standard the syntax convention with underscores in enum names are used, since \"serverwrite\" looks horrible,\r\n// but \"server_write\" is acceptable.\r\n\r\n/** Purposes data can be used for, including combinations of {@link DataPurpose} */\r\nexport enum DataPurposeFlags {\r\n  /** Data without a purpose will not get stored and cannot be used for any reason. This can be used to disable parts of a schema. */\r\n  None = 0,\r\n\r\n  /**\r\n   * Data stored for this purpose is vital for the system, website or app to function.\r\n   */\r\n  Necessary = 1,\r\n\r\n  /**\r\n   * Data stored for this purpose is used for personalization or otherwise adjust the appearance of a website or app\r\n   * according to a user's preferences.\r\n   *\r\n   * DO NOT use this category if the data may be shared with third parties or otherwise used for targeted marketing outside the scope\r\n   * of the website or app. Use {@link DataPurposeFlags.Targeting} instead.\r\n   *\r\n   * It may be okay if the data is only used for different website and apps that relate to the same product or service.\r\n   * This would be the case if a user is able to use an app and website interchangeably for the same service. Different areas of a brand may\r\n   * also be distributed across multiple domain names.\r\n   *\r\n   */\r\n  Functionality = 2,\r\n\r\n  /**\r\n   * Data stored for this purpose is used to gain insights on how users interact with a website or app optionally including\r\n   * demographics and similar traits with the purpose of optimizing the website or app.\r\n   *\r\n   * DO NOT use this category if the data may be shared with third parties or otherwise used for targeted marketing outside the scope\r\n   * of the website or app. Use {@link DataPurposeFlags.Targeting} instead.\r\n   *\r\n   * It may be okay if the data is only used for different website and apps that relate to the same product or service.\r\n   * This would be the case if a user is able to use an app and website interchangeably for the same service. Different areas of a brand may\r\n   * also be distributed across multiple domain names.\r\n   *\r\n   */\r\n  Performance = 4,\r\n\r\n  /**\r\n   * Data stored for this purpose may be similar to both functionality and performance data, however it may be shared with third parties\r\n   * or otherwise used to perform marketing outside the scope of the specific website or app.\r\n   *\r\n   * If the data is only used for different website and apps that relate to the same product or service, it might not be necessary\r\n   * to use this category.\r\n   * This would be the case if a user is able to use an app and website interchangeably for the same service. Different areas of a brand may\r\n   * also be distributed across multiple domain names.\r\n   */\r\n  Targeting = 8,\r\n\r\n  /**\r\n   * Data stored for this purpose is used for security purposes. As examples, this can both be data related to securing an authenticated user's session,\r\n   * or for a website to guard itself against various kinds of attacks.\r\n   *\r\n   * This is implicitly also `Necessary`.\r\n   */\r\n  Security = 16,\r\n\r\n  /**\r\n   * Data stored for this purpose may be similar to the performance category, however it is specifically\r\n   * only used for things such as health monitoring, system performance and error logging and unrelated to user behavior.\r\n   *\r\n   * This is implicitly also `Necessary`.\r\n   */\r\n  Infrastructure = 32,\r\n\r\n  /**\r\n   * Any purposes that is permissable for anonymous users.\r\n   */\r\n  Any_Anonymous = 49, // DataPurposes.Necessary | DataPurposes.Infrastructure | DataPurposes.Security,\r\n\r\n  /**\r\n   * Data can be used for any purpose.\r\n   *\r\n   * Flags with a higher value than this are used for restrictions on who can access the data rather what it is used for.\r\n   */\r\n  Any = 63,\r\n\r\n  /**\r\n   * The data is not available client-side.\r\n   * Note that this is a special flag that is not included in \"Any\"\r\n   */\r\n  Server = 2048,\r\n\r\n  /**\r\n   * The data can only be updated server-side and is read-only client-side.\r\n   *\r\n   * Note that this is a special flag that is not included in \"Any\".\r\n   */\r\n  Server_Write = 4096,\r\n}\r\n\r\nexport type DataPurpose =\r\n  | DataPurposeFlags.Necessary\r\n  | DataPurposeFlags.Functionality\r\n  | DataPurposeFlags.Performance\r\n  | DataPurposeFlags.Targeting\r\n  | DataPurposeFlags.Security\r\n  | DataPurposeFlags.Infrastructure\r\n  | DataPurposeFlags.Server\r\n  | DataPurposeFlags.Server_Write;\r\n\r\nconst purePurposes: DataPurpose =\r\n  DataPurposeFlags.Necessary |\r\n  DataPurposeFlags.Functionality |\r\n  DataPurposeFlags.Performance |\r\n  DataPurposeFlags.Targeting |\r\n  DataPurposeFlags.Security |\r\n  DataPurposeFlags.Infrastructure |\r\n  DataPurposeFlags.Server;\r\n\r\nexport const dataPurposes = createEnumAccessor(\r\n  DataPurposeFlags as typeof DataPurposeFlags,\r\n  true,\r\n  \"data purpose\",\r\n  purePurposes\r\n);\r\n\r\nexport const singleDataPurpose = createEnumAccessor(\r\n  DataPurposeFlags as typeof DataPurposeFlags,\r\n  false,\r\n  \"data purpose\",\r\n  0\r\n);\r\n\r\nexport type DataPurposeValue<Numeric = boolean> = EnumValue<\r\n  typeof DataPurposeFlags,\r\n  DataPurposeFlags,\r\n  true,\r\n  Numeric\r\n>;\r\n","import type { TrackedEvent } from \".\";\n\n/** The shape of the patch data for a {@link TrackedEvent} */\nexport type EventPatch<T extends TrackedEvent = TrackedEvent> = Partial<\n  Omit<T, \"type\">\n> & {\n  type: `${T[\"type\"]}_patch`;\n} & Required<Pick<TrackedEvent, \"patchTargetId\">>;\n\nexport const isEventPatch = (value: any): value is EventPatch =>\n  !!value?.patchTargetId;\n","import {\n  EnumValue,\n  FILTER_NULLISH,\n  MaybePick,\n  MaybeUndefined,\n  Nullish,\n  ParsedEnumResult,\n  PartialExcept,\n  PrettifyIntersection,\n  createEnumAccessor,\n  createEnumPropertyParser,\n  isArray,\n} from \"@tailjs/util\";\nimport {\n  DataClassification,\n  DataClassificationValue,\n  DataPurposeFlags,\n  DataPurposeValue,\n  Timestamp,\n  dataClassification,\n  dataPurposes,\n  singleDataPurpose,\n} from \"..\";\n\nexport enum VariableScope {\n  /** Global variables. */\n  Global = 0,\n\n  /**\n   * Variables related to an external identity.\n   * One use case could be used to augment data a CMS with real-time data related to personalization or testing.\n   */\n  Entity = 1,\n\n  /** Variables related to sessions. */\n  Session = 2,\n\n  /** Variables related to a device (browser or app). */\n  Device = 3,\n\n  /** Variables related to an identified user. */\n  User = 4,\n}\n\nexport const variableScope = createEnumAccessor(\n  VariableScope as typeof VariableScope,\n  false,\n  \"variable scope\"\n);\n\nexport type VariableScopeValue<Numeric extends boolean | undefined = boolean> =\n  EnumValue<typeof VariableScope, VariableScope, false, Numeric> extends infer T\n    ? T\n    : never;\n\n/** Transforms properties with known enum types to their parsable counterparts. */\nexport type Parsable<T, Numeric extends boolean | undefined = boolean> = {\n  [P in keyof T]: T[P] extends DataClassification | undefined | null\n    ? DataClassificationValue<MaybeUndefined<T[P], Numeric>>\n    : T[P] extends DataPurposeFlags | undefined | null\n    ? DataPurposeValue<MaybeUndefined<T[P], Numeric>>\n    : T[P] extends VariableScope | undefined | null\n    ? VariableScopeValue<MaybeUndefined<T[P], Numeric>>\n    : Parsable<T[P], Numeric>;\n};\n\n/**\n * Uniquely addresses a variable by scope, target and key name.\n */\nexport interface VariableKey<NumericEnums extends boolean = boolean> {\n  /** The scope the variable belongs to. */\n  scope: VariableScopeValue<NumericEnums>;\n\n  /**\n   * The name of the variable.\n   *\n   * A key may have a prefix that decides which variable storage it is routed to.\n   * The prefix and the key are separated by colon (`prefix:key`). Additional colons will be considered part of the variable name.\n   * To address a variable with a colon in its name without prefix use `:key`, for example `:colon:in:my:name`.\n   */\n  key: string;\n\n  /**\n   * The ID of the entity in the scope the variable belongs to.\n   * This is ignored for global variables, and can be set to `\"\"`.\n   */\n  targetId?: string;\n}\n\nexport type RestrictedVariable<\n  T = any,\n  NumericEnums extends boolean = true,\n  TrackerScoped extends boolean = true\n> = RestrictVariableTargets<Variable<T, NumericEnums>, TrackerScoped>;\n\ntype RestrictVariableItemTargets<\n  T extends readonly any[],\n  TrackerScoped extends boolean\n> = T extends readonly []\n  ? []\n  : T extends [infer Item, ...infer Rest]\n  ? [\n      RestrictVariableTargets<Item, TrackerScoped>,\n      ...RestrictVariableItemTargets<Rest, TrackerScoped>\n    ]\n  : T extends readonly (infer T)[]\n  ? RestrictVariableTargets<T, TrackerScoped>[]\n  : never;\n\ntype TrackerScopeValue =\n  | VariableScope.User\n  | \"user\"\n  | VariableScope.Device\n  | \"device\"\n  | VariableScope.Session\n  | \"session\";\n\nexport type RestrictVariableTargets<\n  T,\n  TrackerScoped extends boolean = true\n> = boolean extends TrackerScoped\n  ? T\n  : T extends readonly any[]\n  ? RestrictVariableItemTargets<T, TrackerScoped>\n  : T extends { current: infer C }\n  ? PrettifyIntersection<\n      Omit<T, \"current\"> & {\n        current: RestrictVariableTargets<C, TrackerScoped>;\n      }\n    >\n  : PrettifyIntersection<\n      T extends { scope: any; targetId?: any }\n        ? Omit<T, \"targetId\"> &\n            (\n              | {\n                  scope:\n                    | VariableScope.Global\n                    | \"global\"\n                    | (TrackerScoped extends true ? TrackerScopeValue : never);\n                  targetId?: undefined;\n                }\n              | {\n                  scope:\n                    | (TrackerScoped extends true ? never : TrackerScopeValue)\n                    | VariableScope.Entity\n                    | \"entity\";\n                  targetId: T[\"targetId\"] & string;\n                }\n            )\n        : T\n    >;\n\nexport const isTrackerScoped = (\n  value: any\n): value is { scope: TrackerScopeValue } =>\n  variableScope(value?.scope) >= VariableScope.Session;\n\n/** Removes target ID from tracker scoped variables and variable results. */\nexport const restrictTargets = <T>(value: T): RestrictVariableTargets<T> => (\n  isArray(value)\n    ? value.map(restrictTargets)\n    : isTrackerScoped(value) && delete (value as any).targetId,\n  (value as any)?.current && restrictTargets((value as any).current),\n  value as any\n);\n\n/**\n * A {@link VariableKey} that optionally includes the expected version of a variable value.\n * This is used for \"if none match\" queries to invalidate caches efficiently.\n */\nexport interface VersionedVariableKey<NumericEnums extends boolean = boolean>\n  extends VariableKey<NumericEnums> {\n  version?: string;\n}\n\n/**\n * Defines how the value of variable is classified and for which purposes it can be used.\n */\nexport interface VariableUsage<NumericEnums extends boolean = boolean> {\n  /**\n   * The legal classification of the kind of data a variable holds.\n   * This limits which data will be stored based on a user's consent.\n   */\n  classification: DataClassificationValue<NumericEnums>;\n\n  /**\n   * Optionally defines the possible uses of the data a variables holds (they are binary flags).\n   * When a variable is requested by some logic, it may be stated what the data is used for.\n   * If the user has not consented to data being used for this purpose the variable will not be avaiable.\n   */\n  purposes: DataPurposeValue<NumericEnums>;\n}\n\nexport const Necessary: VariableUsage<true> = {\n  classification: DataClassification.Anonymous,\n  purposes: DataPurposeFlags.Necessary,\n};\n\nexport interface VariableMetadata {\n  /**\n   * Optionally categorizes variables.\n   *\n   * For example, the tag `address` could be used for all variables related to a user's address,\n   * or `newsletter` for everything related to newsletter subscriptions.\n   */\n  tags?: string[];\n\n  /**\n   * This is a hint to variable storages that the variable should be deleted if it has not been\n   * accessed for this amount of time (time to live).\n   *\n   * Variable storages can decide how accurately they want to enforce this in the background,\n   * yet it will be accurate from a client perspective assuming the storage provides accurate access timestamps.\n   *\n   * Tail.js uses \"delete on read\" based on the time the variable was last accessed if its\n   * storage has not yet cleaned it.\n   */\n  ttl?: number;\n}\n\n/**\n * Information about when a variable's value was modified and a unique version (ETag) used for conflict resolution\n * in case multiple processes try to update it at the same time (optimistic concurrency).\n *\n * Only the version, and not the modified timestamp must be relied on during conflict resolution.\n */\nexport interface VariableVersion {\n  /**\n   * When the variable was created (Unix timestamp in milliseconds).\n   */\n  created: Timestamp;\n\n  /**\n   * When the variable was last modified. (Unix  ms).\n   */\n  modified: Timestamp;\n\n  /**\n   * When the variable was last accessed (Unix ms).\n   */\n  accessed: Timestamp;\n\n  /**\n   * A unique token that changes every time a variable is updated.\n   *\n   * It follows the semantics of a \"weak\" ETag in the HTTP protocol.\n   * How the value is generated is an internal implementation detail specific to the storage that manages the variable.\n   *\n   *\n   */\n  version: string;\n}\n\n/**\n * All data related to a variable except its value.\n */\nexport interface VariableHeader<NumericEnums extends boolean = true>\n  extends VariableKey<NumericEnums>,\n    VariableUsage<NumericEnums>,\n    VariableMetadata,\n    VariableVersion {}\n\n/**\n * A variable is a specific piece of information that can be classified and changed independently.\n * A variable can either be global or related to a specific entity or tracker scope.\n */\nexport interface Variable<T = any, NumericEnums extends boolean = true>\n  extends VariableHeader<NumericEnums> {\n  /**\n   * The value of the variable is read-only. Trying to update its value in its storage will result in an error.\n   */\n  readonly?: boolean;\n\n  /**\n   * The value of the variable. It must only be undefined in a set operation in which case it means \"delete\".\n   */\n  value: T;\n}\n\n/**\n * The information needed about a variable to validate whether it complies with a user's consents,\n * or meets other authorization based requirements.\n */\nexport type VariableValidationBasis<NumericEnums extends boolean = boolean> =\n  VariableKey<NumericEnums> & Partial<VariableUsage<NumericEnums>>;\n\n/** Returns a description of a key that can be used for logging and error messages.  */\nexport const formatKey = (key: VariableKey<true> | VariableKey) =>\n  `'${key.key}' in ${variableScope.format(key.scope)} scope`;\n\n/** The individual parts of a key specified as string. */\nexport type ParsedKey = {\n  /** The prefix of the key, or the empty string if none. */\n  prefix: string;\n\n  /** The excluding its prefix. */\n  key: string;\n\n  /** The original key string. */\n  sourceKey: string;\n\n  /** For queries. */\n  not?: boolean;\n};\n\nexport const stripPrefix = <T extends VariableKey | undefined>(key: T): T =>\n  key && { ...key, key: parseKey(key.key).key };\n\n/** Returns the individual parts of a key specified as a string.  */\nexport const parseKey = <T extends string | undefined>(\n  sourceKey: T\n): MaybeUndefined<T, ParsedKey> => {\n  if (sourceKey == null) return undefined as any;\n  const not = sourceKey[0] === \"!\";\n  if (not) {\n    sourceKey = (sourceKey.slice(1) as T)!;\n  }\n  const prefixIndex = sourceKey.indexOf(\":\");\n  const prefix = prefixIndex < 0 ? \"\" : sourceKey.substring(0, prefixIndex);\n  const key = prefixIndex > -1 ? sourceKey.slice(prefixIndex + 1) : sourceKey;\n\n  return {\n    prefix,\n    key,\n    sourceKey,\n    not,\n  } as any;\n};\n\nexport const VariableEnumProperties = {\n  scope: variableScope,\n  purpose: singleDataPurpose,\n  purposes: dataPurposes,\n  classification: dataClassification,\n} as const;\n\nexport const toNumericVariableEnums: <T>(\n  value: T\n) => ParsedEnumResult<T, [typeof VariableEnumProperties]> =\n  createEnumPropertyParser(VariableEnumProperties);\n\nexport const extractKey = <\n  T,\n  C extends undefined | Partial<VariableUsage> = undefined\n>(\n  variable: T & PartialExcept<VariableKey, \"key\">,\n  classificationSource?: C\n): T extends undefined\n  ? undefined\n  : T extends VariableKey\n  ? PrettifyIntersection<\n      MaybePick<T, keyof VariableKey> &\n        (\"scope\" extends keyof T\n          ? {\n              scope: VariableScope;\n            }\n          : never) &\n        (C extends undefined\n          ? {}\n          : MaybePick<C & Partial<VariableUsage<true>>, keyof VariableUsage>)\n    >\n  : never =>\n  variable\n    ? ({\n        scope: variableScope(variable.scope),\n        targetId: variable.targetId,\n        key: variable.key,\n        ...(classificationSource && {\n          classification: dataClassification(\n            classificationSource.classification\n          ),\n          purposes: dataPurposes(classificationSource.purposes),\n        }),\n      } as Required<VariableKey> as any)\n    : undefined;\n\nexport const sortVariables = <\n  T extends ({ scope: number; key: string } | Nullish)[] | Nullish\n>(\n  variables: T\n): T extends readonly any[] ? (T[number] & {})[] : undefined =>\n  variables\n    ?.filter(FILTER_NULLISH)\n    .sort((x, y) =>\n      x!.scope === y!.scope\n        ? x!.key.localeCompare(y!.key, \"en\")\n        : x!.scope - y!.scope\n    ) as any;\n","import {\n  AllKeys,\n  EnumValue,\n  Extends,\n  If,\n  IfNot,\n  IsAny,\n  MaybeArray,\n  MaybePick,\n  MaybeUndefined,\n  Nullish,\n  PrettifyIntersection,\n  array,\n  createEnumAccessor,\n  deferredPromise,\n  filter,\n  isArray,\n  map,\n  throwError,\n  tryCatchAsync,\n  undefined,\n} from \"@tailjs/util\";\nimport { Variable, VariableGetResult, VariableSetResult, formatKey } from \"..\";\n\ntype SuccessStatus<ChangedOnly = false> =\n  | VariableResultStatus.Success\n  | VariableResultStatus.Created\n  | IfNot<ChangedOnly, VariableResultStatus.Unchanged>;\n\ntype VariableSuccessResult<\n  R,\n  Filter extends VariableSuccessResultFilter = \"all\",\n  Return extends VariableResultType = \"result\"\n> = R extends {\n  current: infer V;\n  status: SuccessStatus<Extends<\"changed\", Filter>>;\n} // Set result\n  ? Return extends \"result\"\n    ? R\n    : Return extends \"variable\"\n    ? V\n    : V extends { value: infer V }\n    ? V\n    : never\n  : R extends {\n      value?: infer V;\n      status:\n        | SuccessStatus<Extends<\"changed\", Filter>>\n        | IfNot<\n            Extends<\"value\", Filter>,\n            VariableResultStatus.NotFound | VariableResultStatus.Unchanged\n          >;\n    } // Get result\n  ? Return extends \"result\"\n    ? R\n    : Return extends \"variable\"\n    ? MaybePick<R, keyof Variable>\n    : V\n  : never;\n\nexport type VariableSuccessResultFilter = \"value\" | \"changed\" | \"all\";\nexport type VariableResultType = \"value\" | \"variable\" | \"result\";\nexport type VariableSuccessResults<\n  Results,\n  Filter extends VariableSuccessResultFilter = \"all\",\n  Return extends VariableResultType = \"result\"\n> = Results extends undefined\n  ? undefined\n  : Results extends readonly []\n  ? []\n  : Results extends readonly [infer Item, ...infer Rest]\n  ? [\n      VariableSuccessResult<Item, Filter, Return>,\n      ...VariableSuccessResults<Rest, Filter, Return>\n    ]\n  : Results extends readonly (infer Item)[]\n  ? VariableSuccessResult<Item, Filter, Return>[]\n  : VariableSuccessResult<Results, Filter, Return>;\n\nexport type FilterVariableResults<\n  Results,\n  SuccessOnly extends boolean = false,\n  Filter extends VariableSuccessResultFilter = \"all\"\n> = If<SuccessOnly, Results, VariableSuccessResults<Results, Filter>>;\n\nexport type VariableResultPromise<\n  T extends readonly any[] = readonly any[],\n  Push = undefined\n> = T[number] extends never\n  ? never\n  : PromiseLike<VariableSuccessResults<T>> &\n      PrettifyIntersection<\n        {\n          all: PromiseLike<T>;\n          changed: PromiseLike<VariableSuccessResults<T, \"changed\">>;\n          values: PromiseLike<VariableSuccessResults<T, \"all\", \"value\">>;\n          variables: PromiseLike<VariableSuccessResults<T, \"all\", \"variable\">>;\n          /** Run the operation in the background, and handle errors without crashing the app. */\n        } & (Push extends true | ((arg: any) => void)\n          ? { push(): VariableResultPromise<T, false> }\n          : {}) &\n          (T[\"length\"] extends 1\n            ? {\n                value: PromiseLike<\n                  VariableSuccessResults<T, \"all\", \"value\">[0]\n                >;\n                result: PromiseLike<\n                  Exclude<VariableSuccessResults<T>[0], undefined>\n                >;\n                variable: PromiseLike<\n                  VariableSuccessResults<T, \"all\", \"variable\">[0]\n                >;\n              }\n            : {})\n      >;\n\nexport enum VariableResultStatus {\n  Success = 200,\n  Created = 201,\n  Unchanged = 304,\n  Denied = 403,\n  NotFound = 404,\n  ReadOnly = 405,\n  Conflict = 409,\n  Unsupported = 501,\n  Invalid = 400,\n  Error = 500,\n}\n\nexport const resultStatus = createEnumAccessor(\n  VariableResultStatus as typeof VariableResultStatus,\n  false,\n  \"variable set status\"\n);\n\nexport type ResultStatusValue<Numeric extends boolean | undefined = boolean> =\n  EnumValue<\n    typeof VariableResultStatus,\n    VariableResultStatus,\n    false,\n    Numeric\n  > extends infer T\n    ? T\n    : never;\n\nexport const toVariableResultPromise = <T extends readonly any[], Push>(\n  getResults: () => PromiseLike<T>,\n  errorHandlers?: ErrorHandlerParameter<T>,\n  push?: Push &\n    ((results: Exclude<VariableSuccessResult<T[number]>, undefined>[]) => void)\n): VariableResultPromise<T, Push> => {\n  const results = getResults();\n\n  let mapResults = (results: any): any[] => results;\n  let unwrappedResults: any;\n  const property = (\n    map: (\n      results: VariableSuccessResult<VariableGetResult | VariableSetResult>[]\n    ) => any,\n    errorHandler = handleResultErrors\n  ) =>\n    deferredPromise(\n      async () =>\n        (unwrappedResults = mapResults(\n          errorHandler(await results, errorHandlers)\n        )) && map(unwrappedResults)\n    );\n\n  const promise: Record<AllKeys<VariableResultPromise<any, true>>, any> = {\n    then: property((items) => items).then,\n    all: property(\n      (items) => items,\n      (items) => items\n    ),\n    changed: property((items) => filter(items, (item) => item.status < 300)),\n    variables: property((items) => map(items, getResultVariable)),\n    values: property((items) =>\n      map(items, (item) => getResultVariable(item)?.value)\n    ),\n    push: () => (\n      (mapResults = (results) => (\n        push?.(map(getSuccessResults(results) as any[])), results\n      )),\n      promise as any\n    ),\n\n    value: property((items) => getResultVariable(items[0])?.value),\n    variable: property((items) => getResultVariable(items[0])),\n    result: property((items) => items[0]),\n  };\n\n  return promise as any;\n};\n\ntype ValidatableResult<V = {}> =\n  | (V & {\n      status: VariableResultStatus;\n      error?: any;\n    } & (\n        | {\n            current?: V & { version?: string };\n            source?: KeyLike;\n          }\n        | KeyLike\n      ))\n  | Nullish;\n\nexport const getSuccessResults = <\n  R extends readonly ValidatableResult[] | undefined\n>(\n  results: R\n): VariableSuccessResults<R> =>\n  results?.map((result) => (result?.status! < 400 ? result : undefined)) as any;\n\ntype KeyLike = { scope: any; key: any; targetId?: any };\n\nexport const getResultKey = <R extends ValidatableResult>(\n  result: R\n): MaybeUndefined<\n  R,\n  R extends { source: KeyLike }\n    ? R[\"source\"]\n    : R extends KeyLike\n    ? R\n    : undefined\n> =>\n  (result as VariableSetResult)?.source?.key != null\n    ? (result as VariableSetResult).source\n    : (result as any)?.key != null\n    ? result\n    : (undefined as any);\n\nexport const getResultVariable = <R extends ValidatableResult>(\n  result: R\n): If<\n  IsAny<R>,\n  Variable<any, true>,\n  R extends undefined\n    ? undefined\n    : R extends { current: infer V }\n    ? V\n    : R extends { value: any }\n    ? R\n    : undefined\n> =>\n  isSuccessResult(result)\n    ? (result as VariableSetResult).current ?? (result as any)\n    : undefined;\n\nexport const isSuccessResult = <RequireValue extends boolean = false>(\n  result: any,\n  requireValue: RequireValue = false as any\n): result is\n  | ({ status: VariableResultStatus.Success | VariableResultStatus.Created } & (\n      | Variable<any, true>\n      | { current: Variable<any, true> }\n    ))\n  | (RequireValue extends true\n      ? never\n      : {\n          status:\n            | VariableResultStatus.Unchanged\n            | VariableResultStatus.NotFound;\n          value?: undefined;\n        }) =>\n  requireValue\n    ? result?.status! < 300\n    : result?.status! < 400 || result?.status === 404;\n\ntype ErrorHandler<Result = any> = Result extends undefined\n  ? undefined\n  : undefined | ((result: Result, errorMessage: string) => void | boolean);\n\ntype ErrorHandlerParameter<Results> = Results extends readonly []\n  ? readonly []\n  : Results extends readonly [infer Item, ...infer Rest]\n  ? readonly [ErrorHandler<Item>, ...ErrorHandlerParameter<Rest>]\n  : Results extends readonly (infer Item)[]\n  ? readonly ErrorHandler<Item>[]\n  : ErrorHandler<Results>;\n\nexport const handleResultErrors = <\n  Results extends MaybeArray<ValidatableResult, true>,\n  ErrorHandlers extends ErrorHandlerParameter<Results>,\n  RequireValue = false\n>(\n  results: Results,\n  errorHandlers?: ErrorHandlers,\n  requireValue?: RequireValue\n): FilterVariableResults<Results, true, If<RequireValue, \"value\", \"all\">> => {\n  const errors: string[] = [];\n  let errorHandler: ErrorHandler;\n  let errorMessage: string;\n  const successResults = map(\n    array(results),\n    (result, i) =>\n      result &&\n      (result.status < 400 || (!requireValue && result.status === 404) // Not found can only occur for get requests, and those are all right.\n        ? (result as any)\n        : ((errorMessage = `${formatKey(\n            (result as VariableSetResult).source ?? result\n          )} could not be ${\n            (result as VariableSetResult).status === 404\n              ? \"found.\"\n              : `${\n                  (result as VariableSetResult).source ||\n                  result.status !== VariableResultStatus.Error\n                    ? \"set\"\n                    : \"read\"\n                } because ${\n                  result.status === VariableResultStatus.Conflict\n                    ? `of a conflict. The expected version '${\n                        (result as VariableSetResult).source?.version\n                      }' did not match the current version '${\n                        (result as VariableSetResult).current?.version\n                      }'.`\n                    : result.status === VariableResultStatus.Denied\n                    ? result.error ?? \"the operation was denied.\"\n                    : result.status === VariableResultStatus.Invalid\n                    ? result.error ?? \"the value does not conform to the schema\"\n                    : result.status === VariableResultStatus.ReadOnly\n                    ? \"it is read only.\"\n                    : result.status === VariableResultStatus.Error\n                    ? `of an unexpected error: ${result.error}`\n                    : \"of an unknown reason.\"\n                }`\n          }`),\n          ((errorHandler = errorHandlers?.[i]) == null ||\n            errorHandler(result, errorMessage) !== false) &&\n            errors.push(errorMessage),\n          undefined))\n  );\n\n  if (errors.length) return throwError(errors.join(\"\\n\"));\n  return isArray(results) ? successResults : (successResults?.[0] as any);\n};\n\nexport const requireFound = <\n  T extends MaybeArray<VariableGetResult | undefined> | undefined\n>(\n  variable: T\n): VariableSuccessResult<T, \"value\"> =>\n  handleResultErrors(variable, undefined, true) as any;\n","import {\r\n  EnumValue,\r\n  If,\r\n  Json,\r\n  MaybeArray,\r\n  MaybePromise,\r\n  Nullish,\r\n  ParsedValue,\r\n  PartialExcept,\r\n  PickPartial,\r\n  PrettifyIntersection,\r\n  ReplaceProperties,\r\n  ToggleReadonly,\r\n  TupleOrArray,\r\n  createEnumAccessor,\r\n  isFunction,\r\n} from \"@tailjs/util\";\r\nimport {\r\n  Variable,\r\n  VariableGetter,\r\n  VariableKey,\r\n  VariableMetadata,\r\n  VariableResultStatus,\r\n  VariableUsage,\r\n  VariableVersion,\r\n  VersionedVariableKey,\r\n  variableScope,\r\n} from \"..\";\r\n\r\n/**\r\n * Defines options for creating, updating or deleting a variable.\r\n */\r\nexport type VariableSetter<\r\n  T = any,\r\n  K extends string = string,\r\n  Validated = boolean\r\n> = { key: K } & (\r\n  | (VariableValueSetter<T, Validated> & { patch?: undefined })\r\n  | VariablePatch<T, Validated>\r\n);\r\n\r\nexport type VariableSetters<\r\n  SetterType extends Partial<VariableSetter<any>> | boolean,\r\n  Inferred extends VariableSetters<SetterType> = never\r\n> =\r\n  | Inferred\r\n  | TupleOrArray<\r\n      | (SetterType extends boolean\r\n          ? VariableSetter<any, string, SetterType>\r\n          : SetterType)\r\n      | Nullish\r\n    >;\r\n\r\nexport type VariableSetResult<\r\n  T = any,\r\n  Source extends VariableSetter<T> = VariableSetter<T>\r\n> =\r\n  | VariableSetSuccessResult<T, Source>\r\n  | ({\r\n      source: Source;\r\n    } & (\r\n      | {\r\n          status: VariableResultStatus.Conflict;\r\n          current: VariableSetResultValue<Source>;\r\n        }\r\n      | ((\r\n          | {\r\n              status:\r\n                | VariableResultStatus.ReadOnly\r\n                | VariableResultStatus.Invalid\r\n                | VariableResultStatus.Denied\r\n                | VariableResultStatus.NotFound\r\n                | VariableResultStatus.Unsupported;\r\n\r\n              error?: any;\r\n            }\r\n          | {\r\n              status: VariableResultStatus.Error;\r\n              transient?: boolean;\r\n              error: any;\r\n            }\r\n        ) & { current?: never })\r\n    ));\r\n\r\nexport type VariableSetSuccessResult<\r\n  T = any,\r\n  Source extends VariableSetter<T> = VariableSetter<T>\r\n> = {\r\n  status:\r\n    | VariableResultStatus.Success\r\n    | VariableResultStatus.Unchanged\r\n    | (VariableSetResultValue<Source> extends undefined\r\n        ? never\r\n        : VariableResultStatus.Created);\r\n\r\n  current: VariableSetResultValue<Source>;\r\n\r\n  source: Source;\r\n};\r\n\r\nexport interface VariablePatchSource<T = any> extends Variable<T> {\r\n  value: T;\r\n}\r\n\r\nexport type VariablePatchResult<T = any, Validated = boolean> =\r\n  | (VariableMetadata &\r\n      (Partial<VariableUsage<If<Validated, true, boolean>>> & {\r\n        value: T | Nullish;\r\n      }))\r\n  | undefined;\r\n\r\nexport type VariablePatchAction<T = any, Validated = boolean> = (\r\n  current: VariablePatchSource<T> | undefined\r\n) => MaybePromise<VariablePatchResult<T, Validated> | Nullish>;\r\n\r\nexport enum VariablePatchType {\r\n  Add = 0,\r\n  Min = 1,\r\n  Max = 2,\r\n  IfMatch = 3,\r\n  IfNoneMatch = 4,\r\n}\r\n\r\nexport type VariablePatchTypeValue<\r\n  Numeric extends boolean | undefined = boolean\r\n> = EnumValue<\r\n  typeof VariablePatchType,\r\n  VariablePatchType,\r\n  false,\r\n  Numeric\r\n> extends infer T\r\n  ? T\r\n  : never;\r\n\r\nexport const patchType = createEnumAccessor(\r\n  VariablePatchType as typeof VariablePatchType,\r\n  false,\r\n  \"variable patch type\"\r\n);\r\n\r\nexport type VariableValueSetter<\r\n  T = any,\r\n  Validated = false\r\n> = (VersionedVariableKey<If<Validated, true, boolean>> &\r\n  Partial<VariableUsage<If<Validated, true, boolean>>> &\r\n  VariableMetadata & { value: T | undefined }) & {\r\n  /**\r\n   * Ignore versioning (optimistic concurrency), and save the value regardless.\r\n   * Consider your scenario before doing this.\r\n   */\r\n  force?: boolean;\r\n};\r\n\r\nexport type VariableValuePatchSetter<\r\n  T = any,\r\n  Validated = boolean\r\n> = VariableKey<If<Validated, true, boolean>> &\r\n  Partial<Variable<T, If<Validated, true, boolean>>> &\r\n  Partial<VariableUsage<If<Validated, true, boolean>>> &\r\n  ({\r\n    selector?: string;\r\n  } & (\r\n    | {\r\n        patch: VariablePatchType.Add | \"add\";\r\n        /**\r\n         * The amount to add (subtract if negative).\r\n         */\r\n        value: number;\r\n        /**\r\n         * The initial value if none exists.\r\n         * @default 0\r\n         */\r\n        seed?: number;\r\n      }\r\n    | {\r\n        patch: VariablePatchType.Min | VariablePatchType.Max | \"min\" | \"max\";\r\n        value: number;\r\n      }\r\n    | {\r\n        patch:\r\n          | VariablePatchType.IfMatch\r\n          | \"ifMatch\"\r\n          | VariablePatchType.IfNoneMatch\r\n          | \"ifNoneMatch\";\r\n        match: T | undefined;\r\n        value: T | undefined;\r\n      }\r\n  ));\r\n\r\nexport type VariablePatchActionSetter<\r\n  T = any,\r\n  Validated = boolean\r\n> = VariableKey<If<Validated, true, boolean>> &\r\n  VariableKey &\r\n  Partial<Variable<T, If<Validated, true, boolean>>> & {\r\n    patch: VariablePatchAction<T, Validated>;\r\n    value?: undefined;\r\n  };\r\n\r\nexport type VariablePatch<T = any, Validated = boolean> =\r\n  | VariablePatchActionSetter<T, Validated>\r\n  | VariableValuePatchSetter<T, Validated>;\r\n\r\nexport type StripPatchFunctions<\r\n  T extends MaybeArray<VariableGetter | VariableSetter | Nullish, true>\r\n> = T extends Nullish\r\n  ? T\r\n  : T extends readonly any[]\r\n  ? StripPatchFunctionItems<T>\r\n  : T extends VariableGetter\r\n  ? T & { init?: Json }\r\n  : Exclude<VariableSetter, VariablePatchActionSetter>;\r\n\r\nexport const isVariablePatchAction = (\r\n  setter: any\r\n): setter is { patch: VariablePatchAction } => isFunction(setter?.[\"patch\"]);\r\n\r\n/**\r\n * Any variable setter that only has numeric enum values.\r\n */\r\nexport type ValidatedVariableSetter = VariableSetter<any, string, true>;\r\n\r\nexport type MapVariableSetResult<Source> = Source extends VariableSetter<\r\n  infer T\r\n>\r\n  ? VariableSetResult<T, Source>\r\n  : never;\r\n\r\nexport type VariableSetResults<K extends readonly any[] = any[]> =\r\n  K extends readonly []\r\n    ? []\r\n    : K extends readonly [infer Item, ...infer Rest]\r\n    ? [MapVariableSetResult<Item>, ...VariableSetResults<Rest>]\r\n    : K extends readonly (infer T)[]\r\n    ? MapVariableSetResult<T>[]\r\n    : unknown extends K\r\n    ? any\r\n    : never;\r\n\r\ntype StripPatchFunctionItems<\r\n  T extends readonly (VariableGetter | VariableSetter)[]\r\n> = T extends readonly []\r\n  ? []\r\n  : T extends readonly [infer T, ...infer Rest]\r\n  ? [\r\n      StripPatchFunctions<T & (VariableGetter | VariableSetter)>,\r\n      ...StripPatchFunctionItems<\r\n        Rest & readonly (VariableGetter | VariableSetter)[]\r\n      >\r\n    ]\r\n  : T extends readonly any[]\r\n  ? ToggleReadonly<StripPatchFunctions<T[number]>[], T>\r\n  : never;\r\n\r\ntype PickScopeAndTarget<T> = T extends { scope: infer Scope }\r\n  ? T extends { targetId: infer Target }\r\n    ? { scope: ParsedValue<typeof variableScope, Scope>; targetId: Target }\r\n    : { scope: ParsedValue<typeof variableScope, Scope> }\r\n  : {};\r\n\r\ntype KeepVariableTarget<Source extends VariableSetter, T> = T extends undefined\r\n  ? undefined\r\n  : ReplaceProperties<Variable<T, true>, PickScopeAndTarget<Source>>;\r\n\r\ntype VariableSetResultValue<Source extends VariableSetter> =\r\n  PrettifyIntersection<\r\n    KeepVariableTarget<Source, VariableSetResultValue_<Source>>\r\n  >;\r\n\r\ntype VariableSetResultValue_<Source extends VariableSetter> = Source extends {\r\n  patch: infer R & {};\r\n}\r\n  ? R extends (current: any) => infer R | { value: infer T }\r\n    ?\r\n        | (T extends undefined ? undefined : T)\r\n        | (R extends undefined ? undefined : never)\r\n    : R extends { match: any; value: infer T }\r\n    ? T extends undefined\r\n      ? undefined\r\n      : T\r\n    : R extends { type: VariablePatchTypeValue }\r\n    ? number\r\n    : never\r\n  : Source extends { value: infer T }\r\n  ? T extends undefined\r\n    ? undefined\r\n    : T\r\n  : never;\r\n","import type {\n  CartUpdatedEvent,\n  ComponentClickEvent,\n  EventMetadata,\n  LocalID,\n  Session,\n  Tagged,\n  Timestamp,\n  Uuid,\n  ViewEvent,\n} from \"..\";\n\n/**\n * The base type for all events that are tracked.\n *\n * The naming convention is:\n * - If the event represents something that can also be considered an entity like \"a page view\", \"a user location\" etc. the name should be a (deverbal) noun.\n * - If the event only indicates something that happened, like \"session started\", \"view ended\" etc. the name should be a verb in the past tense.\n *\n * @id urn:tailjs:core:event\n * @privacy censor-ignore anonymous necessary\n */\nexport interface TrackedEvent extends Tagged {\n  /**\n   * The type name of the event.\n   *\n   * This MUST be set to a constant value in extending interfaces and implementing classes for the event to be registered.\n   * */\n  type: string;\n\n  /**\n   * The ID of the schema the event comes from. It is suggested that the schema ID includes a SemVer version number in the end. (e.g. urn:tailjs:0.9.0 or https://www.blah.ge/schema/3.21.0)\n   */\n  schema?: string;\n\n  /**\n   * This is assigned by the server. Only use {@link clientId} client-side.\n   *\n   */\n  id?: Uuid;\n\n  /**\n   * This is set by the client and used to when events reference each other.\n   */\n  clientId?: LocalID;\n\n  /** These properties are used to track the state of the event as it gets collected, and is not persisted. */\n  metadata?: EventMetadata;\n\n  /**\n   * If set, it means this event contains updates to an existing event with this {@link clientId}, and should not be considered a separate event.\n   * It must have the target event's {@link TrackedEvent.type} postfixed with \"_patch\" (for example \"view_patch\").\n   *\n   * Numbers in patches are considered incremental which means the patch will include the amount to add to an existing number (or zero if it does not yet have a value).\n   * All other values are just overwritten with the patch values.\n   *\n   * Please pay attention to this property when doing analytics lest you may over count otherwise.\n   *\n   * Patches are always considered passive, cf. {@link EventMetadata.passive}.\n   */\n  patchTargetId?: LocalID;\n\n  /**\n   * The client ID of the event that caused this event to be triggered or got triggered in the same context.\n   * For example, a {@link NavigationEvent} may trigger a {@link ViewEvent},\n   * or a {@link CartUpdatedEvent} may be triggered with a {@link ComponentClickEvent}.\n   *\n   */\n  relatedEventId?: LocalID;\n\n  /**\n   * The session associated with the event.\n   */\n  session?: Session;\n\n  /**\n   * When applicable, the view where the event happened (related by {@link ViewEvent}).\n   */\n  view?: LocalID;\n\n  /**\n   * This timestamp will always have a value before it reaches a backend.\n   * If specified, it must be a negative number when sent from the client (difference between when the event was generated and when is was posted in milliseconds).\n   *\n   * @default now\n   */\n  timestamp?: Timestamp;\n}\n\nexport const isTrackedEvent = (ev: any): ev is TrackedEvent =>\n  ev && typeof ev.type === \"string\";\n","import type {\n  Domain,\n  Integer,\n  LocalID,\n  TrackedEvent,\n  View,\n  ViewTimingData,\n  Viewport,\n} from \"..\";\nimport { typeTest } from \"../util/type-test\";\n\nexport interface ClickIds {\n  google?: string;\n  googleDoubleClick?: string;\n  facebook?: string;\n  microsoft?: string;\n  googleAnalytics?: string;\n}\n\n/**\n * This event is sent a user navigates between views. (page, screen or similar).\n *\n * This event does not\n *\n */\nexport interface ViewEvent extends TrackedEvent {\n  type: \"view\";\n\n  /**\n   * @inheritdoc\n   */\n  clientId: LocalID;\n\n  /**\n   * The primary content used to generate the view including the personalization that led to the decision, if any.\n   * If views are loaded asynchronously in a way where they are not available immediately after a user navigates to a URL\n   * on the website, the view definition may follow from a separate patch event.\n   */\n  definition?: View;\n\n  /**\n   * The tab where the view was shown.\n   */\n  tab?: LocalID;\n\n  /**\n   * The fully qualified URL as shown in the address line of the browser excluding the domain.\n   */\n  href: string;\n\n  /**\n   * The hash part of the URL (/about-us#address).\n   */\n  hash?: string;\n\n  /**\n   * The path portion of the URL.\n   */\n  path?: string;\n\n  /** For how long the view was active. This is set via patches */\n  duration?: ViewTimingData;\n\n  /**\n   * Urchin Tracking Module (UTM) parameters as defined by (Wikipedia)[https://en.wikipedia.org/wiki/UTM_parameters].\n   */\n  utm?: {\n    source?: string;\n    medium?: string;\n    campaign?: string;\n    term?: string;\n    content?: string;\n  };\n  /**\n   * The query string parameters in the URL, e.g. utm_campaign.\n   * Each parameter can have multiple values, for example If the parameter is specified more than once.\n   * If the parameter is only specified once pipes, semicolons and commas are assumed to separate values (in that order).\n   * A parameter without a value will get recorded as an empty string.\n   * @example The URL https://www.foo.com/?utm_source=bar&utm_campaign=campaign1,campaign2&flag&gclid=123xyz&p1=a&p1=b&p2=a;b,c;d has these parameters:\n   *  utm_source = [\"bar\"] \\\n   *  utm_campaign = [\"campaign1\", \"campaign2\"] \\\n   *  gclid = [\"123xyz\"] \\\n   *  flag = [\"\"] \\\n   *  gclid=[\"123xyz\"] \\\n   *  p1=[\"a\", \"b\"] \\\n   *  p2=[\"a\", \"b,c\", \"d\"]\n   */\n  queryString?: Record<string, string[]>;\n\n  // queryString?: {\n  //   source: Record<string, string>;\n  //   parsed: Record<string, string[]>;\n  // };\n\n  /**\n   * The domain part of the href, if any.\n   */\n  domain?: Domain;\n\n  /**\n   * Indicates that this was the first view in the first tab the user opened.\n   * Note that this is NOT tied to the session. If a user closes all tabs and windows for the site and then later navigates back to the site in the same session this flag will be set again.\n   * @default false\n   */\n  landingPage?: boolean;\n\n  /**\n   * Indicates that no other tabs were open when the view happened.\n   * This flag allows a backend to extend the definition of a session that can last indefinitely but still restart after inactivity.\n   * By measuring the time between a view with this flag and the previous event from the same device, it is possible to see for how long the device has been away from the site.\n   * @default false\n   */\n  firstTab?: boolean;\n\n  /**\n   * The tab number in the current session.\n   */\n  tabNumber?: Integer;\n\n  /**\n   * The view number in the current tab.\n   * This is kept as a convenience, yet technically redundant since it follows from timestamps and context.\n   * @default 1\n   */\n  tabViewNumber?: Integer;\n\n  /**\n   * Number of redirects that happened during navigation to this view.*/\n  redirects?: Integer;\n\n  /**\n   * Navigation type.\n   */\n  navigationType?: \"navigate\" | \"back-forward\" | \"prerender\" | \"reload\";\n\n  /**\n   * Indicates whether the event was manually triggered through a tracker command, or happened automatically by the tracker's ability to infer navigation.\n   *\n   * @default \"automatic\"\n   */\n  mode?: \"manual\" | \"automatic\";\n\n  /**\n   * External referrer. Internal referrers follows from the event's {@link TrackedEvent[\"relatedView\"]} field.\n   */\n  externalReferrer?: {\n    href?: string;\n    domain?: Domain;\n  };\n\n  /**\n   * The size of the user's viewport (e.g. browser window) and how much it was scrolled when the page was opened.\n   */\n  viewport?: Viewport;\n\n  /**\n   * The type of view, e.g. \"page\" or \"screen\".\n   *\n   * @default \"page\"\n   */\n  viewType?: string;\n}\n\nexport const isViewEvent = typeTest<ViewEvent>(\"view\");\n","import type { TrackedEvent } from \"..\";\n\nexport const typeTest =\n  <T extends TrackedEvent>(...types: string[]) =>\n  (ev: any): ev is T =>\n    ev?.type && types.some((type) => type === ev?.type);\n","import type { TrackerClientConfiguration } from \"..\";\n\nexport const isTracker = \"__isTracker\";\n\nexport const trackerConfig: Required<TrackerClientConfiguration> = {\n  name: \"tail\",\n  src: \"/_t.js\",\n  disabled: false,\n  postEvents: true,\n  postFrequency: 2000,\n  requestTimeout: 5000,\n  encryptionKey: null,\n  key: null,\n  apiKey: null,\n\n  /**\n   * Log events to the browser's developer console.\n   */\n  impressionThreshold: 1000,\n  captureContextMenu: true,\n  defaultActivationTracking: \"auto\",\n  tags: { default: [\"data-id\", \"data-name\"] },\n};\n","const codes: number[] = [];\nconst chars: number[] = [];\nexport const charCode = (s: string, index = 0) => s.charCodeAt(index);\nexport const fromCharCodes = (chars: number[]) => String.fromCharCode(...chars);\n\n[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"].forEach(\n  (p, i) => (codes[(chars[i] = p.charCodeAt(0))] = i)\n);\n\n/**\n * Encodes an array of bytes to Base64URL without padding (URL safe Base64 using `-` and `_` instead of `+` and `/`).\n *\n * (thanks to Jon Leighton at https://gist.github.com/jonleighton/958841).\n */\nexport const to64u = (bytes: Uint8Array) => {\n  let i = 0;\n  let chunk: number;\n  const n = bytes.length;\n\n  const base64: number[] = [];\n  while (i < n) {\n    chunk = (bytes[i++] << 16) | (bytes[i++] << 8) | bytes[i++];\n    base64.push(\n      chars[(chunk & 16515072) >> 18],\n      chars[(chunk & 258048) >> 12],\n      chars[(chunk & 4032) >> 6],\n      chars[chunk & 63]\n    );\n  }\n  base64.length += n - i;\n\n  return fromCharCodes(base64);\n};\n\n/**\n * Decodes a BaseURL encoded string (without padding).\n */\nexport const from64u = (encoded: string) => {\n  let i = 0;\n  let j = 0;\n  let p: number;\n  const n = encoded.length;\n  const bytes = new Uint8Array(3 * ((n / 4) | 0) + (((n + 3) & 3) % 3));\n  while (i < n) {\n    bytes[j++] =\n      (codes[charCode(encoded, i++)] << 2) |\n      ((p = codes[charCode(encoded, i++)]) >> 4);\n    if (i < n) {\n      bytes[j++] = ((p & 15) << 4) | ((p = codes[charCode(encoded, i++)]) >> 2);\n      if (i < n) {\n        bytes[j++] = ((p & 3) << 6) | codes[charCode(encoded, i++)];\n      }\n    }\n  }\n  return bytes;\n};\n\n/**\n * Decodes the specified UTF8 bytes to a string.\n *\n * [Thanks!](https://gist.github.com/Yaffle/5458286)\n */\nexport const decodeUtf8 = <T extends Uint8Array | string | null | undefined>(\n  octets: T\n): T extends null | undefined ? undefined : string => {\n  if (octets == null) return undefined as any;\n  if (typeof octets === \"string\") return octets as any;\n\n  const chars: number[] = [];\n  let i = 0;\n  while (i < octets.length) {\n    let octet = octets[i];\n    let bytesNeeded = 0;\n    let codePoint = 0;\n    if (octet <= 0x7f) {\n      bytesNeeded = 0;\n      codePoint = octet & 0xff;\n    } else if (octet <= 0xdf) {\n      bytesNeeded = 1;\n      codePoint = octet & 0x1f;\n    } else if (octet <= 0xef) {\n      bytesNeeded = 2;\n      codePoint = octet & 0x0f;\n    } else if (octet <= 0xf4) {\n      bytesNeeded = 3;\n      codePoint = octet & 0x07;\n    }\n    if (octets.length - i - bytesNeeded > 0) {\n      var k = 0;\n      while (k < bytesNeeded) {\n        octet = octets[i + k + 1];\n        codePoint = (codePoint << 6) | (octet & 0x3f);\n        k += 1;\n      }\n    } else {\n      codePoint = 0xfffd;\n      bytesNeeded = octets.length - i;\n    }\n    chars.push(codePoint);\n    i += bytesNeeded + 1;\n  }\n\n  return String.fromCodePoint(...chars) as any;\n};\n","import { Nullish, isBoolean } from \"@tailjs/util\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  (value: T, bits?: 32 | 64 | 128): string;\n  <B extends boolean>(value: T, numeric: B): B extends true ? number : string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key?: string | Nullish): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (\n    iw = 0;\n    iw < key?.length!;\n    mixer0 += window0[iw] = key!.charCodeAt(iw++)\n  );\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero, all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: Uint8Array, numericOrBits: any = 64) => {\n      if (source == null) return null;\n      bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n","﻿(function () {\r\n\t\"use strict\";\r\n\r\n\t// Serializes a value to a MessagePack byte array.\r\n\t//\r\n\t// data: The value to serialize. This can be a scalar, array or object.\r\n\t// options: An object that defines additional options.\r\n\t// - multiple: (boolean) Indicates whether multiple values in data are concatenated to multiple MessagePack arrays. Default: false.\r\n\t// - invalidTypeReplacement:\r\n\t//   (any) The value that is used to replace values of unsupported types.\r\n\t//   (function) A function that returns such a value, given the original value as parameter.\r\n\tfunction serialize(data, options) {\r\n\t\tif (options && options.multiple && !Array.isArray(data)) {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\r\n\t\t}\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet floatBuffer, floatView;\r\n\t\tlet array = new Uint8Array(128);\r\n\t\tlet length = 0;\r\n\t\tif (options && options.multiple) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tappend(data[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tappend(data);\r\n\t\t}\r\n\t\treturn array.subarray(0, length);\r\n\r\n\t\tfunction append(data, isReplacement) {\r\n\t\t\tswitch (typeof data) {\r\n\t\t\t\tcase \"undefined\":\r\n\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\tappendBoolean(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tappendNumber(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tappendString(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif (data === null)\r\n\t\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\telse if (data instanceof Date)\r\n\t\t\t\t\t\tappendDate(data);\r\n\t\t\t\t\telse if (Array.isArray(data))\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\r\n\t\t\t\t\t\tappendBinArray(data);\r\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\r\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\r\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tappendObject(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\r\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendNull(data) {\r\n\t\t\tappendByte(0xc0);\r\n\t\t}\r\n\r\n\t\tfunction appendBoolean(data) {\r\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\r\n\t\t}\r\n\r\n\t\tfunction appendNumber(data) {\r\n\t\t\tif (isFinite(data) && Number.isSafeInteger(data)) {\r\n\t\t\t\t// Integer\r\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0 && data >= -0x20) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\r\n\t\t\t\t\tappendBytes([0xcc, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\r\n\t\t\t\t\tappendBytes([0xd0, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\r\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\r\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\r\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\r\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\r\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\r\n\t\t\t\t\t// 32 bits for bitwise operations.\r\n\t\t\t\t\tlet hi = data / pow32;\r\n\t\t\t\t\tlet lo = data % pow32;\r\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\r\n\t\t\t\t\tappendByte(0xd3);\r\n\t\t\t\t\tappendInt64(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0) {   // below int64\r\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t\telse {   // above uint64\r\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Float\r\n\t\t\t\tif (!floatView) {\r\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\r\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\r\n\t\t\t\t}\r\n\t\t\t\tfloatView.setFloat64(0, data);\r\n\t\t\t\tappendByte(0xcb);\r\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendString(data) {\r\n\t\t\tlet bytes = encodeUtf8(data);\r\n\t\t\tlet length = bytes.length;\r\n\r\n\t\t\tif (length <= 0x1f)\r\n\t\t\t\tappendByte(0xa0 + length);\r\n\t\t\telse if (length <= 0xff)\r\n\t\t\t\tappendBytes([0xd9, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(bytes);\r\n\t\t}\r\n\r\n\t\tfunction appendArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x90 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let index = 0; index < length; index++) {\r\n\t\t\t\tappend(data[index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendBinArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xff)\r\n\t\t\t\tappendBytes([0xc4, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(data);\r\n\t\t}\r\n\r\n\t\tfunction appendObject(data) {\r\n\t\t\tlet length = 0;\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tif (data[key] !== undefined) {\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x80 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tlet value = data[key];\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tappend(key);\r\n\t\t\t\t\tappend(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendDate(data) {\r\n\t\t\tlet sec = data.getTime() / 1000;\r\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\r\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\r\n\t\t\t\tappendInt64(sec);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendByte(byte) {\r\n\t\t\tif (array.length < length + 1) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + 1)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray[length] = byte;\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\tfunction appendBytes(bytes) {\r\n\t\t\tif (array.length < length + bytes.length) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + bytes.length)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray.set(bytes, length);\r\n\t\t\tlength += bytes.length;\r\n\t\t}\r\n\r\n\t\tfunction appendInt64(value) {\r\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\r\n\t\t\t// bitwise operations.\r\n\t\t\tlet hi, lo;\r\n\t\t\tif (value >= 0) {\r\n\t\t\t\t// Same as uint64\r\n\t\t\t\thi = value / pow32;\r\n\t\t\t\tlo = value % pow32;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\r\n\t\t\t\tvalue++;\r\n\t\t\t\thi = Math.abs(value) / pow32;\r\n\t\t\t\tlo = Math.abs(value) % pow32;\r\n\t\t\t\thi = ~hi;\r\n\t\t\t\tlo = ~lo;\r\n\t\t\t}\r\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deserializes a MessagePack byte array to a value.\r\n\t//\r\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\r\n\t// options: An object that defines additional options.\r\n\t// - multiple: (boolean) Indicates whether multiple concatenated MessagePack arrays are returned as an array. Default: false.\r\n\tfunction deserialize(array, options) {\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet pos = 0;\r\n\t\tif (array instanceof ArrayBuffer) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\r\n\t\t}\r\n\t\tif (!array.length) {\r\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\r\n\t\t}\r\n\t\tif (!(array instanceof Uint8Array)) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tlet data;\r\n\t\tif (options && options.multiple) {\r\n\t\t\t// Read as many messages as are available\r\n\t\t\tdata = [];\r\n\t\t\twhile (pos < array.length) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Read only one message and ignore additional data\r\n\t\t\tdata = read();\r\n\t\t}\r\n\t\treturn data;\r\n\r\n\t\tfunction read() {\r\n\t\t\tconst byte = array[pos++];\r\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\r\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\r\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\r\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\r\n\t\t\tif (byte === 0xc0) return null;   // nil\r\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\r\n\t\t\tif (byte === 0xc2) return false;   // false\r\n\t\t\tif (byte === 0xc3) return true;   // true\r\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\r\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\r\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\r\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\r\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\r\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\r\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\r\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\r\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\r\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\r\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\r\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\r\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\r\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\r\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\r\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\r\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\r\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\r\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\r\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\r\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\r\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\r\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\r\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\r\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\r\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\r\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\r\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\r\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\r\n\t\t\tconsole.debug(\"msgpack array:\", array);\r\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\r\n\t\t}\r\n\r\n\t\tfunction readInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\tlet first = true;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tlet byte = array[pos++];\r\n\t\t\t\t\tvalue += byte & 0x7f;\r\n\t\t\t\t\tif (byte & 0x80) {\r\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvalue *= 256;\r\n\t\t\t\t\tvalue += array[pos++];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readUInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tvalue *= 256;\r\n\t\t\t\tvalue += array[pos++];\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readFloat(size) {\r\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\r\n\t\t\tpos += size;\r\n\t\t\tif (size === 4)\r\n\t\t\t\treturn view.getFloat32(0, false);\r\n\t\t\tif (size === 8)\r\n\t\t\t\treturn view.getFloat64(0, false);\r\n\t\t}\r\n\r\n\t\tfunction readBin(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = array.subarray(pos, pos + size);\r\n\t\t\tpos += size;\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readMap(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = {};\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tlet key = read();\r\n\t\t\t\tdata[key] = read();\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readArray(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = [];\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readStr(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet start = pos;\r\n\t\t\tpos += size;\r\n\t\t\treturn decodeUtf8(array, start, size);\r\n\t\t}\r\n\r\n\t\tfunction readExt(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet type = readUInt(1);\r\n\t\t\tlet data = readBin(size);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 255:\r\n\t\t\t\t\treturn readExtDate(data);\r\n\t\t\t}\r\n\t\t\treturn { type: type, data: data };\r\n\t\t}\r\n\r\n\t\tfunction readExtDate(data) {\r\n\t\t\tif (data.length === 4) {\r\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\treturn new Date(sec * 1000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 8) {\r\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\r\n\t\t\t\t\t((data[1] << 14) >>> 0) +\r\n\t\t\t\t\t((data[2] << 6) >>> 0) +\r\n\t\t\t\t\t(data[3] >>> 2);\r\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\r\n\t\t\t\t\t((data[4] << 24) >>> 0) +\r\n\t\t\t\t\t((data[5] << 16) >>> 0) +\r\n\t\t\t\t\t((data[6] << 8) >>> 0) +\r\n\t\t\t\t\tdata[7];\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 12) {\r\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\tpos -= 8;\r\n\t\t\t\tlet sec = readInt(8);\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Encodes a string to UTF-8 bytes.\r\n\tfunction encodeUtf8(str) {\r\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\r\n\t\tlet ascii = true, length = str.length;\r\n\t\tfor (let x = 0; x < length; x++) {\r\n\t\t\tif (str.charCodeAt(x) > 127) {\r\n\t\t\t\tascii = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\r\n\t\tfor (let ci = 0; ci !== length; ci++) {\r\n\t\t\tlet c = str.charCodeAt(ci);\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tbytes[i++] = c;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c < 2048) {\r\n\t\t\t\tbytes[i++] = c >> 6 | 192;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\r\n\t\t\t\t\tif (++ci >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\r\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\r\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\r\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\r\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\r\n\t\t\t\t}\r\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\r\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\r\n\t\t\t}\r\n\t\t\tbytes[i++] = c & 63 | 128;\r\n\t\t}\r\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\r\n\t}\r\n\r\n\t// Decodes a string from UTF-8 bytes.\r\n\tfunction decodeUtf8(bytes, start, length) {\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = start, str = \"\";\r\n\t\tlength += start;\r\n\t\twhile (i < length) {\r\n\t\t\tlet c = bytes[i++];\r\n\t\t\tif (c > 127) {\r\n\t\t\t\tif (c > 191 && c < 224) {\r\n\t\t\t\t\tif (i >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\r\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 223 && c < 240) {\r\n\t\t\t\t\tif (i + 1 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\r\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 239 && c < 248) {\r\n\t\t\t\t\tif (i + 2 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\r\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\r\n\t\t\t}\r\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\r\n\t\t\telse if (c <= 0x10ffff) {\r\n\t\t\t\tc -= 0x10000;\r\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\r\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\r\n\t\t\t}\r\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\r\n\t// The exported functions\r\n\tlet msgpack = {\r\n\t\tserialize: serialize,\r\n\t\tdeserialize: deserialize,\r\n\r\n\t\t// Compatibility with other libraries\r\n\t\tencode: serialize,\r\n\t\tdecode: deserialize\r\n\t};\r\n\r\n\t// Environment detection\r\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\r\n\t\t// Node.js\r\n\t\tmodule.exports = msgpack;\r\n\t}\r\n\telse {\r\n\t\t// Global object\r\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\r\n\t}\r\n\r\n})();\r\n","import {\n  CONTEXT_NAV_QUERY,\n  EVENT_HUB_QUERY,\n  VARIABLES_QUERY,\n} from \"@constants\";\n\nimport {\n  F,\n  T,\n  ansi,\n  isFunction,\n  isObject,\n  join,\n  parseUri,\n  replace,\n  split,\n  type Nullish,\n} from \"@tailjs/util\";\nimport { jsonEncode } from \"@tailjs/transport\";\nimport { document } from \".\";\n\nexport const ERR_BUFFER_OVERFLOW = \"buffer-overflow\";\nexport const ERR_POST_FAILED = \"post-failed\";\nexport const ERR_INVALID_COMMAND = \"invalid-command\";\nexport const ERR_INTERNAL_ERROR = \"internal-error\";\nexport const ERR_ARGUMENT_ERROR = \"invalid-argument\";\nexport const ERR_RESERVED = \"reserved\";\nexport const ERR_CONFIG_LOCKED = \"config-locked\";\nexport const ERR_DUPLICATE_KEY = \"key\";\n\nconst src = split(\"\" + document.currentScript![\"src\"], \"#\");\nconst args = split(\"\" + (src[1] || \"\"), \";\");\n\nexport const SCRIPT_SRC = src[0];\nexport const TRACKER_DOMAIN = args[1] || parseUri(SCRIPT_SRC, false)?.host!;\n\nexport const isInternalUrl = (url: string | Nullish) =>\n  !!(\n    TRACKER_DOMAIN && parseUri(url, false)?.host?.endsWith(TRACKER_DOMAIN) === T\n  );\n\nexport const mapUrl = (...urlParts: string[]) =>\n  replace(join(urlParts), /(^(?=\\?))|(^\\.(?=\\/))/, SCRIPT_SRC.split(\"?\")[0]);\n\nexport const VAR_URL = mapUrl(\"?\", EVENT_HUB_QUERY);\nexport const MNT_URL = mapUrl(\"?\", CONTEXT_NAV_QUERY);\nexport const USR_URL = mapUrl(\"?\", VARIABLES_QUERY);\n\nexport const groupValue = Symbol();\nexport const childGroups = Symbol();\n\nexport const debug = (\n  value: any,\n  group?: string,\n  collapsed = T,\n  nested = F\n) => {\n  group &&\n    (collapsed ? console.groupCollapsed : console.group)(\n      (nested ? \"\" : ansi(\"tail.js: \", \"90;3\")) + group\n    );\n  const children = value?.[childGroups];\n  children && (value = value[groupValue]);\n  value != null &&\n    console.log(\n      isObject(value)\n        ? ansi(jsonEncode(value), \"94\")\n        : // ? window[\"chrome\"]\n        //   ? prettyPrint(value).join(\"\")\n        //   : JSON.stringify(value, null, 2)\n        isFunction(value)\n        ? \"\" + value\n        : value\n    );\n  children &&\n    children.forEach(([value, group, collapsed]) =>\n      debug(value, group, collapsed, true)\n    );\n\n  group && console.groupEnd();\n};\n","import { createEvent, type Nullish } from \"@tailjs/util\";\nimport { Decoder, Encoder, createTransport } from \"@tailjs/transport\";\nimport { DEBUG, NOT_INITIALIZED } from \".\";\n\nexport const [httpEncode, httpDecode] = createTransport();\n\nexport let [httpEncrypt, httpDecrypt] = [\n  NOT_INITIALIZED,\n  NOT_INITIALIZED,\n] as any as [Encoder, Decoder];\n\nexport const [addEncryptionNegotiatedListener, dispatchEncryptionNegotiated] =\n  createEvent<[httpEncrypt: Encoder, httpDecrypt: Decoder]>();\n\nexport const setStorageKey = (key: string | Nullish) => {\n  if (httpDecrypt !== NOT_INITIALIZED) return;\n\n  [httpEncrypt, httpDecrypt] = createTransport(key);\n\n  dispatchEncryptionNegotiated(httpEncrypt, httpDecrypt);\n};\n","import { NonAsync, isString } from \"@tailjs/util\";\r\n\r\nexport const errorLogger = (source: any) => (error: any) =>\r\n  logError(source, error);\r\n\r\nexport const logError: {\r\n  (source: any, message: string | undefined, ...args: any[]): void;\r\n  (source: any, arg1: Exclude<NonAsync, string>, ...args: any[]): void;\r\n} = (...args: any[]) => {\r\n  let source = args.shift();\r\n  let message = isString(args[1])\r\n    ? args.shift()\r\n    : args[1]?.message ?? \"An error occurred\";\r\n  console.error(message, source.id ?? source, ...args);\r\n};\r\n","import { clock, createEvent, createTimer } from \"@tailjs/util\";\nimport { listen } from \".\";\n\ntype PageLoadListenerArgs = [loaded: boolean, stateDuration: number];\nconst [addPageLoadedListener, dispatchPageLoaded] =\n  createEvent<PageLoadListenerArgs>();\n\nconst [addPageVisibleListener, dispatchPageVisible] =\n  createEvent<[visible: boolean, unloading: boolean, delta: number]>();\n\nconst maybeDispatchPageLoaded = (newLoaded: boolean) =>\n  loaded !== (loaded = newLoaded) &&\n  dispatchPageLoaded((loaded = false), sleepTimer(true, true));\n\nconst maybeDispatchPageVisible = (loaded: boolean) =>\n  visible !==\n    (visible = loaded ? document.visibilityState === \"visible\" : false) &&\n  dispatchPageVisible(visible, !loaded, visibleTimer(true, true));\n\n// A visibilitychange event may not be triggered if the page BF cache loads/unloads.\naddPageLoadedListener(maybeDispatchPageVisible);\n\nlet loaded = true;\nlet visible = false;\nlet visibleTimer = createTimer(false);\nlet sleepTimer = createTimer(false);\nlisten(window, [\"pagehide\", \"freeze\"], () => maybeDispatchPageLoaded(false));\nlisten(window, [\"pageshow\", \"resume\"], () => maybeDispatchPageLoaded(true));\nlisten(\n  document,\n  \"visibilitychange\",\n  () => (\n    maybeDispatchPageVisible(true), visible && maybeDispatchPageLoaded(true)\n  )\n);\n\ndispatchPageLoaded(loaded, sleepTimer(true, true));\n\ntype PageActivatedListenerArgs = [activated: boolean, totalDuration: number];\nlet activated = false;\nlet activeTime = createTimer(false);\n\nconst [addPageActivatedListener, dispatchPageActivated] =\n  createEvent<PageActivatedListenerArgs>();\n\nconst activationTimeout = clock({\n  callback: () =>\n    activated && dispatchPageActivated((activated = false), activeTime(false)),\n  frequency: 20000,\n  once: true,\n  paused: true,\n});\nconst setActivated = () =>\n  !activated &&\n  (dispatchPageActivated((activated = true), activeTime(true)),\n  activationTimeout.restart());\n\nlisten(window, [\"focus\", \"scroll\"], setActivated);\nlisten(window, \"blur\", () => activationTimeout.trigger());\n\nlisten(\n  document.body,\n  [\"keydown\", \"pointerdown\", \"pointermove\", \"scroll\"],\n  setActivated\n);\n\nsetActivated();\n\nexport const getActiveTime = () => activeTime();\nexport {\n  addPageActivatedListener,\n  addPageLoadedListener,\n  addPageVisibleListener,\n};\n","import {\n  DataClassification,\n  DataPurposeFlags,\n  MapVariableGetResult,\n  MapVariableSetResult,\n  RestrictVariableTargets,\n  StripPatchFunctions,\n  Variable,\n  VariableEnumProperties,\n  VariableGetResult,\n  VariableGetter,\n  VariableKey,\n  VariableResultStatus,\n  VariableSetResult,\n  VariableSetter,\n  variableScope,\n} from \"@tailjs/types\";\nimport {\n  EnumValue,\n  GeneralizeConstants,\n  If,\n  IfNot,\n  IsAny,\n  MaybeUndefined,\n  Nullish,\n  PrettifyIntersection,\n  ToggleArray,\n  UnknownIsAny,\n  createEnumAccessor,\n  createEnumPropertyParser,\n  isString,\n} from \"@tailjs/util\";\n\nimport type { LocalID, VariableScopeValue, View } from \"@tailjs/types\";\n\nexport type ReferringViewData = [\n  viewId: LocalID,\n  relatedEventId: LocalID | undefined\n];\n\ntype ReservedVariableDefinitions = {\n  view: View;\n  tags: string[];\n  rendered: boolean;\n  loaded: boolean;\n  tabIndex: number;\n  viewIndex: number;\n  scripts: Record<string, \"pending\" | \"loaded\" | \"failed\">;\n  referrer: ReferringViewData;\n};\n\nexport type ReservedVariableType<\n  K,\n  Default = any\n> = K extends ReservedVariableKey\n  ? ReservedVariableDefinitions[K]\n  : UnknownIsAny<Default>;\n\nexport type ReservedVariableKey = keyof ReservedVariableDefinitions;\n\nexport type LocalVariableKey = ReservedVariableKey | (string & {});\n\nexport enum LocalVariableScope {\n  /** Variables are only available in memory in the current view. */\n  View = -3,\n\n  /** Variables are only available in memory in the current tab, including between views in the same tab as navigation occurs. */\n  Tab = -2,\n\n  /** Variables are only available in memory and shared between all tabs. */\n  Shared = -1,\n}\n\nexport const localVariableScope = createEnumAccessor(\n  LocalVariableScope as typeof LocalVariableScope,\n  false,\n  \"local variable scope\"\n);\n\nexport const anyVariableScope = (scope: string | number) =>\n  localVariableScope.tryParse(scope) ?? variableScope(scope);\n\nexport const formatAnyVariableScope = (scope: string | number) =>\n  localVariableScope.format(scope) ?? variableScope.format(scope);\n\nexport type LocalVariableScopeValue<\n  Numeric extends boolean | undefined = boolean\n> = EnumValue<\n  typeof LocalVariableScope,\n  LocalVariableScope,\n  false,\n  Numeric\n> extends infer T\n  ? T\n  : never;\n\nexport type LocalVariableHeader<NumericEnums extends boolean = boolean> = {\n  key: LocalVariableKey;\n  scope: LocalVariableScopeValue<NumericEnums>;\n  targetId?: undefined;\n  classification?: DataClassification.Anonymous;\n  purposes?: DataPurposeFlags.Necessary;\n  version?: string;\n};\n\nexport type ReservedVariables<\n  K extends ReservedVariableKey = ReservedVariableKey\n> = K extends infer K\n  ? LocalVariable<\n      ReservedVariableDefinitions[K & ReservedVariableKey],\n      K & string\n    >\n  : never;\n\ntype LocalVariable<\n  T = unknown,\n  K extends string = LocalVariableKey,\n  NumericEnums extends boolean = true\n> = PrettifyIntersection<\n  {\n    key: K;\n    value: T;\n  } & LocalVariableHeader<NumericEnums>\n>;\n\ntype LocalVariableGetResult<\n  T = any,\n  K = LocalVariableKey,\n  Patched = false\n> = PrettifyIntersection<\n  (\n    | ({\n        status:\n          | VariableResultStatus.Success\n          | VariableResultStatus.Unchanged\n          | VariableResultStatus.Created;\n      } & LocalVariable<T, K & string>)\n    | IfNot<\n        Patched,\n        {\n          status: VariableResultStatus.NotFound;\n          value?: undefined;\n        }\n      >\n  ) &\n    LocalVariableHeader<true> & { key: K }\n>;\n\ntype LocalVariableSetResult<T, Source> = PrettifyIntersection<{\n  source: Source;\n  status:\n    | VariableResultStatus.Success\n    | VariableResultStatus.Unchanged\n    | VariableResultStatus.Created;\n  current: Source extends { value: infer Value }\n    ? Value extends undefined\n      ? undefined\n      : LocalVariable<T, Source extends { key: infer K } ? K & string : string>\n    : never;\n}>;\nexport type ClientVariable<\n  T = any,\n  K extends string = string,\n  Local = boolean,\n  NumericEnums extends boolean = true\n> = Local extends true\n  ? LocalVariable<T, K, NumericEnums>\n  : { key: K } & Omit<\n      RestrictVariableTargets<Variable<T, NumericEnums>>,\n      \"key\"\n    >;\n\nexport type VariableCacheSettings = {\n  /**\n   * The maximum number of milliseconds the value of this variable can be cached.\n   * If omitted or `true` the default value of 3 seconds will be used.\n   * `false` or 0 means the variable will not be cached.\n   */\n  cache?: number | boolean;\n};\n\nexport type ClientVariableCallback<\n  T = any,\n  K extends string = string & {},\n  Local = boolean\n> = (\n  value: ClientVariable<T, K, Local> | undefined,\n  previous: ClientVariable<T, K, Local> | undefined,\n  poll: () => void\n) => void;\n\nexport type ClientVariableGetter<\n  T = any,\n  K extends string = string & {},\n  Local = boolean\n> = PrettifyIntersection<\n  (Local extends true\n    ? { key: K } & LocalVariableHeader & {\n          init?: { value: GeneralizeConstants<T> | undefined };\n        }\n    : StripPatchFunctions<\n        RestrictVariableTargets<VariableGetter<T, K, false>, true>\n      >) & {\n    /**\n     * A callback to do something with the result.\n     * If the second function is invoked the variable will be polled for changes, and the callback will be invoked\n     * next time the value changes. To keep polling, keep calling the poll function every time the callback is invoked.\n     */\n    result?: ToggleArray<ClientVariableCallback<T, K, Local>>;\n\n    /**\n     * If the get requests fails this callback will be called instead of the entire operation throwing an error.\n     * If it returns `false` an error will still be thrown.\n     */\n    error?: (\n      result: ClientVariableGetResult<T, K, boolean, Local>,\n      error: string\n    ) => void | boolean;\n\n    /**\n     * Do not accept a cached version of the variable.\n     */\n    refresh?: boolean;\n  } & VariableCacheSettings\n>;\n\nexport type ClientVariableSetter<\n  T = any,\n  K extends string = string,\n  Local extends boolean = boolean,\n  HasResultHandler extends boolean = true\n> = PrettifyIntersection<\n  (Local extends true\n    ? LocalVariable<GeneralizeConstants<T> | undefined, K, boolean> & {\n        patch?: undefined;\n      }\n    : StripPatchFunctions<\n        RestrictVariableTargets<VariableSetter<T, K, false>, true>\n      >) & {\n    /** A callback that will get invoked when the set operation has completed. */\n    result?: HasResultHandler extends true\n      ? (\n          result: ClientVariableSetResult<\n            T,\n            ClientVariableSetter<T, K, Local, false>\n          >\n        ) => void\n      : undefined;\n\n    /**\n     * If the get requests fails this callback will be called instead of the entire operation throwing an error.\n     * If it returns `false` an error will still be thrown.\n     */\n    error?: (\n      result: ClientVariableSetResult<\n        any,\n        Local extends true\n          ? ClientVariableSetter<any, any, true>\n          : ClientVariableSetter<any, any, false>\n      >,\n      error: string\n    ) => void | boolean;\n  } & VariableCacheSettings\n>;\n\nexport type ClientScopeValue<\n  NumericEnums extends boolean = boolean,\n  Local extends boolean = boolean\n> = Local extends true\n  ? LocalVariableScopeValue<NumericEnums>\n  : VariableScopeValue<NumericEnums>;\n\nexport type ClientVariableKey<\n  NumericEnums extends boolean = boolean,\n  Local extends boolean = boolean\n> = Local extends false\n  ? VariableKey<NumericEnums>\n  : { key: string; scope: LocalVariableScopeValue<NumericEnums> };\n\ntype MapLocalGetResult<Getter> = Getter extends ClientVariableGetter<\n  infer T,\n  infer K & string,\n  true\n>\n  ? LocalVariableGetResult<\n      ReservedVariableType<K, T>,\n      K,\n      Getter extends { init: { value?: infer V } }\n        ? If<IsAny<V>, false, undefined extends V ? false : true>\n        : false\n    >\n  : Getter extends Nullish\n  ? undefined\n  : never;\n\ntype MapLocalSetResult<Setter> = Setter extends ClientVariableSetter<\n  infer T,\n  infer K & string,\n  true\n>\n  ? LocalVariableSetResult<\n      T extends undefined ? undefined : ReservedVariableType<K, T>,\n      Setter\n    >\n  : Setter extends Nullish\n  ? undefined\n  : never;\n\ntype MapClientVariableResult<P, Getter> = P extends {\n  scope: LocalVariableScopeValue;\n}\n  ? If<Getter, MapLocalGetResult<P>, MapLocalSetResult<P>>\n  : RestrictVariableTargets<\n      If<Getter, MapVariableGetResult<P>, MapVariableSetResult<P>>\n    >;\n\nexport type ClientVariableGetResult<\n  T = any,\n  K extends string = string,\n  Patched = boolean,\n  Local = boolean\n> = Local extends true\n  ? LocalVariableGetResult<T, K, Patched>\n  : RestrictVariableTargets<VariableGetResult<T, K, Patched>>;\n\nexport type ClientVariableSetResult<\n  T = any,\n  Source extends ClientVariableSetter = ClientVariableSetter<\n    any,\n    string,\n    boolean\n  >\n> = Source extends ClientVariableSetter<any, any, true>\n  ? LocalVariableSetResult<T, Source>\n  : Source extends ClientVariableSetter<any, any, false>\n  ? RestrictVariableTargets<VariableSetResult<T, Source>>\n  : any;\n\nexport type ClientVariableResults<\n  P extends readonly any[],\n  Getters\n> = P extends readonly []\n  ? []\n  : P extends readonly [infer Result, ...infer Rest]\n  ? readonly [\n      MapClientVariableResult<Result, Getters>,\n      ...ClientVariableResults<Rest, Getters>\n    ]\n  : P extends readonly (infer Result)[]\n  ? readonly MapClientVariableResult<Result, Getters>[]\n  : never;\n\nexport const isLocalScopeKey = (\n  key: any\n): key is {\n  scope: LocalVariableScopeValue;\n} => !!localVariableScope.tryParse(key?.scope);\n\nexport const toNumericVariableEnums = createEnumPropertyParser(\n  { scope: localVariableScope },\n  VariableEnumProperties\n);\n\nexport const variableKeyToString: <\n  S extends\n    | ClientVariableKey\n    | { source?: ClientVariableKey }\n    | string\n    | Nullish\n>(\n  key: S\n) => MaybeUndefined<S, string> = (key: any): any =>\n  key == null\n    ? undefined\n    : isString(key)\n    ? key\n    : key.source\n    ? variableKeyToString(key.source)!\n    : `${anyVariableScope(key.scope)}\\0${key.key}\\0${key.targetId ?? \"\"}`;\n\nexport const stringToVariableKey = (key: string): ClientVariableKey => {\n  const parts = key.split(\"\\0\");\n  return {\n    scope: +parts[0],\n    key: parts[1],\n    targetId: parts[2],\n  } as any;\n};\n","import { CLIENT_STATE_CHANNEL_ID } from \"@constants\";\n\nimport { Uuid } from \"@tailjs/types\";\nimport {\n  MaybeUndefined,\n  Nullish,\n  assign,\n  clear,\n  clock,\n  concat,\n  createEvent,\n  filter,\n  forEach,\n  map,\n  now,\n  obj,\n  replace,\n} from \"@tailjs/util\";\nimport {\n  ClientVariable,\n  ClientVariableGetter,\n  ClientVariableResults,\n  GetterIntellisense,\n  HEARTBEAT_FREQUENCY,\n  LocalVariableScope,\n  NOT_INITIALIZED,\n  VARIABLE_CACHE_DURATION,\n  addEncryptionNegotiatedListener,\n  addPageLoadedListener,\n  listen,\n  toNumericVariableEnums,\n  variableKeyToString,\n} from \".\";\n\nexport interface TabState {\n  id: string;\n  heartbeat: number;\n  viewId?: string;\n}\n\ninterface StateVariableMetadata {\n  cache: [timestamp: number, expires: number];\n}\n\nexport type StateVariable = ClientVariable & StateVariableMetadata;\n\nexport interface State {\n  knownTabs: Record<string, TabState>;\n  /** All variables except local. */\n  variables: Record<string, StateVariable>;\n}\n\nlet localId = 0;\n\nexport let TAB_ID: string = undefined as any;\nexport const nextId = () => (TAB_ID ?? NOT_INITIALIZED()) + \"_\" + nextLocalId();\nexport const nextLocalId = () =>\n  (now(true) - (parseInt(TAB_ID.slice(0, -2), 36) || 0)).toString(36) +\n  \"_\" +\n  (++localId).toString(36);\n\nconst randomValues = (arg: any) => crypto.getRandomValues(arg);\nexport const uuidv4 = (): Uuid =>\n  replace(\n    ([1e7] as any) + -1e3 + -4e3 + -8e3 + -1e11,\n    /[018]/g,\n    (c: any) => (\n      (c *= 1),\n      (c ^ (randomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)\n    )\n  );\n\n/** All variables, both local and others. */\nlet tabVariables: Record<string, StateVariable> = {};\n\nconst tabState: TabState = {\n  id: TAB_ID,\n  heartbeat: now(),\n};\n\nconst state: State = {\n  knownTabs: {\n    [TAB_ID]: tabState,\n  },\n  variables: {},\n};\n\ntype StateMessage =\n  | { type: \"query\"; payload?: undefined }\n  | {\n      type: \"set\";\n      payload: State;\n    }\n  | {\n      type: \"patch\";\n      payload: Record<string, StateVariable | undefined>;\n    }\n  | {\n      type: \"tab\";\n      payload: TabState | undefined;\n    };\n\nconst [addStateListener, dispatchState] = createEvent<\n  | [event: \"ready\", state: State, self: boolean]\n  | [event: \"tab\", tab: TabState, self: boolean]\n>();\n\nconst [addVariablesChangedListener, dispatchVariablesChanged] =\n  createEvent<\n    [\n      changes: [current: StateVariable, previous: StateVariable | undefined][],\n      all: Readonly<typeof tabVariables>,\n      local: boolean\n    ]\n  >();\n\nexport { addVariablesChangedListener };\n\nlet post: (message: StateMessage, target?: string) => void = NOT_INITIALIZED;\n\nexport const tryGetVariable: {\n  <K extends ClientVariableGetter>(key: K | GetterIntellisense[0]):\n    | (ClientVariableResults<[K], true>[0] & StateVariableMetadata)\n    | undefined;\n  <K extends string | Nullish>(key: K): MaybeUndefined<K, StateVariable>;\n} = (key: any) => tabVariables[variableKeyToString(key)!] as any;\n\nexport const setLocalVariables = (\n  ...variables: ClientVariable<any, string, true, boolean>[]\n) =>\n  updateVariableState(\n    (variables as StateVariable[]).map(\n      (variable: StateVariable) => (\n        (variable.cache = [now(), VARIABLE_CACHE_DURATION]),\n        toNumericVariableEnums(variable)\n      )\n    )\n  );\n\nconst getVariableChanges = (variables: (StateVariable | undefined)[]) =>\n  map(\n    variables,\n    (current) =>\n      current && [current, tabVariables[variableKeyToString(current)]]\n  );\n\nexport const updateVariableState = (\n  updates: (StateVariable | undefined)[] | undefined\n) => {\n  const changes = map(\n    updates,\n    (variable) => variable && [variableKeyToString(variable), variable]\n  );\n  if (!changes?.length) return;\n\n  // Collect now before updating the state, but dispatch after the state has changed.\n  const changedEventData = getVariableChanges(updates!);\n\n  assign(tabVariables, changes);\n  const sharedChanges = filter(\n    changes,\n    (variable) => variable[1].scope > LocalVariableScope.Tab\n  );\n\n  if (sharedChanges.length) {\n    assign(state.variables, sharedChanges);\n    post({ type: \"patch\", payload: obj(sharedChanges) });\n  }\n\n  dispatchVariablesChanged(changedEventData, tabVariables, true);\n};\n\naddEncryptionNegotiatedListener((httpEncrypt, httpDecrypt) => {\n  // Keep tab ID and variables between pages in the same tab.\n  addPageLoadedListener((loaded) => {\n    if (loaded) {\n      const localState = httpDecrypt(\n        sessionStorage.getItem(CLIENT_STATE_CHANNEL_ID)\n      ) as [tabId: string, variables: StateVariable[]];\n      sessionStorage.removeItem(CLIENT_STATE_CHANNEL_ID);\n\n      TAB_ID =\n        localState?.[0] ??\n        now(true).toString(36) +\n          Math.trunc(1296 * Math.random())\n            .toString(36)\n            .padStart(2, \"0\");\n\n      tabVariables = obj(\n        concat(\n          // Whatever view variables we already had in case of bf navigation.\n          filter(\n            tabVariables,\n            ([, variable]) => variable.scope === LocalVariableScope.View\n          ),\n          map(localState?.[1], (variable) => [\n            variableKeyToString(variable),\n            variable,\n          ])\n        )\n      )!;\n    } else {\n      sessionStorage.setItem(\n        CLIENT_STATE_CHANNEL_ID,\n        httpEncrypt([\n          TAB_ID,\n          map(tabVariables, ([, variable]) =>\n            variable.scope !== LocalVariableScope.View ? variable : undefined\n          ),\n        ])\n      );\n    }\n  }, true);\n\n  post = (message: StateMessage, target?: string) => {\n    if (!httpEncrypt) return;\n    localStorage.setItem(\n      CLIENT_STATE_CHANNEL_ID,\n      httpEncrypt([TAB_ID, message, target])\n    );\n    localStorage.removeItem(CLIENT_STATE_CHANNEL_ID);\n  };\n\n  listen(window, \"storage\", (ev) => {\n    if (ev.key === CLIENT_STATE_CHANNEL_ID) {\n      const message = httpDecrypt?.(ev.newValue) as [\n        sender: string,\n        message: StateMessage,\n        target?: string\n      ];\n      if (!message || (message[2] && message[2] !== TAB_ID)) return;\n      const [sender, { type, payload }] = message;\n\n      if (type === \"query\") {\n        !initTimeout.active && post({ type: \"set\", payload: state }, sender);\n      } else if (type === \"set\" && initTimeout.active) {\n        assign(state, payload);\n        assign(tabVariables, payload.variables);\n        initTimeout.trigger();\n      } else if (type === \"patch\") {\n        // Collect now before updating the state, but dispatch after the state has changed.\n        const changedEventData = getVariableChanges(map(payload, 1));\n\n        assign(state.variables, payload);\n        assign(tabVariables, payload);\n\n        dispatchVariablesChanged(changedEventData, tabVariables, false);\n      } else if (type === \"tab\") {\n        assign(state.knownTabs, sender, payload);\n        payload && dispatchState(\"tab\", payload, false);\n      }\n    }\n  });\n\n  const initTimeout = clock(() => dispatchState(\"ready\", state, true), -25);\n\n  const heartbeat = clock({\n    callback: () => {\n      const timeout = now() - HEARTBEAT_FREQUENCY * 2;\n      forEach(\n        state?.knownTabs,\n        // Remove tabs that no longer responds (presumably closed but may also have been frozen).\n        ([tabId, tabState]) =>\n          tabState[0] < timeout && clear(state!.knownTabs, tabId)\n      );\n      tabState.heartbeat = now();\n      post({ type: \"tab\", payload: tabState });\n    },\n    frequency: HEARTBEAT_FREQUENCY,\n    paused: true,\n  });\n\n  const toggleTab = (loading: boolean) => {\n    post({ type: \"tab\", payload: loading ? tabState : undefined });\n    if (loading) {\n      initTimeout.restart();\n      post({ type: \"query\" });\n    } else {\n      initTimeout.toggle(false);\n    }\n    heartbeat.toggle(loading);\n  };\n\n  addPageLoadedListener((loaded) => toggleTab(loaded), true);\n}, true);\nexport { addStateListener };\n","import {\n  PrettifyIntersection,\n  createEvent,\n  delay,\n  forEachAsync,\n  isFunction,\n  stop,\n  throwError,\n  undefined,\n} from \"@tailjs/util\";\nimport { REQUEST_LOCK_KEY, httpDecrypt, httpEncrypt, sharedLock } from \".\";\n\nexport type RequestOptions<Beacon extends boolean = false> =\n  PrettifyIntersection<\n    {\n      encrypt?: boolean;\n    } & (Beacon extends true ? { beacon: true } : { beacon?: false })\n  >;\n\nconst [addRequestHandler, dispatchRequest] =\n  createEvent<\n    [url: string, data: any, retry: number, update: (data: any) => void]\n  >();\nconst [addResponseHandler, dispatchResponse] = createEvent<[response: any]>();\nexport { addRequestHandler, addResponseHandler };\n\nconst requestLock = sharedLock(REQUEST_LOCK_KEY);\n\n/**\n * If a function, this is run before a request is made (including retries). It is run within the lock, and allows the requested data to be modified.\n * If it returns false, the request is aborted and if it returns `undefined` or `true` the existing data is used.\n */\ntype RequestData<T> =\n  | T\n  | ((data: T | undefined, retry: number) => T | boolean | undefined);\n\nexport const request: {\n  <Data = any, Response = any>(\n    url: string,\n    data: RequestData<Data>,\n    options?: RequestOptions<false>\n  ): Promise<Response>;\n  <Data = any>(\n    url: string,\n    data: RequestData<Data>,\n    options: RequestOptions<true>\n  ): void;\n} = async (\n  url: string,\n  data: any,\n  { beacon = false, encrypt = true }: RequestOptions<boolean> = {}\n) => {\n  let cancel = false;\n  let currentData: any;\n  let serialized: any;\n\n  const prepareRequestData = (retry: number) => {\n    const prepareResult = isFunction(data) ? data?.(currentData, retry) : data;\n    if (prepareResult === false) {\n      return false;\n    }\n\n    prepareResult != null &&\n      prepareResult !== true &&\n      (currentData = prepareResult);\n\n    dispatchRequest(\n      url,\n      currentData,\n      retry,\n      (newData) => (\n        (cancel = currentData === undefined), (currentData = newData)\n      )\n    );\n\n    return cancel\n      ? false\n      : (serialized = encrypt\n          ? httpEncrypt(currentData, true)\n          : JSON.stringify(currentData));\n  };\n\n  if (beacon) {\n    if (!prepareRequestData(0)) return;\n\n    !navigator.sendBeacon(\n      url,\n      new Blob(currentData != null ? [serialized] : [], {\n        // This content type avoids the overhead of the \"preflight\" request that is otherwise made by browsers in cross-domain scenarios.\n        // (application/x-www-form-urlencoded could also work).\n        type: \"text/plain\",\n      })\n    ) && throwError(\"Beacon send failed.\");\n  } else {\n    let retries = 1;\n    return await requestLock(() =>\n      forEachAsync(1, async (retry) => {\n        if (!prepareRequestData(retry)) return stop();\n\n        const response = await fetch(url, {\n          method: currentData != null ? \"POST\" : \"GET\",\n          cache: \"no-cache\",\n          credentials: \"include\",\n          mode: \"cors\",\n          headers: {\n            \"Content-Type\": \"text/plain\",\n          },\n          body: serialized,\n        });\n\n        if (response.status >= 400) {\n          return retry === retries - 1\n            ? stop(throwError(`Invalid response: ${await response.text()}`))\n            : (console.warn(\n                `Request to ${url} failed on attempt ${retry + 1}/${3}.`\n              ),\n              await delay((1 + retry) * 200));\n        }\n\n        const body = encrypt\n          ? new Uint8Array(await response.arrayBuffer())\n          : await response.text();\n\n        const parsed = body?.length\n          ? (encrypt ? httpDecrypt : JSON.parse)?.(body as any)\n          : undefined;\n\n        if (parsed != null) {\n          dispatchResponse(parsed);\n        }\n        return stop(parsed);\n      })\n    );\n  }\n};\n","import {\n  delay,\n  now,\n  promise,\n  race,\n  throwError,\n  tryCatchAsync,\n} from \"@tailjs/util\";\nimport {\n  TAB_ID,\n  httpDecode,\n  httpDecrypt,\n  httpEncode,\n  httpEncrypt,\n  listen,\n} from \".\";\n\n/**\n *  A lock that is shared between all tabs.\n * It would seem tempting to use the browser's native LockManager, yet that disables bf_cache, so we don't.\n */\nexport const sharedLock = (\n  lockId: string,\n  { timeout = 1000, encrypt = true, retries: defaultRetries = 10 } = {}\n): (<R, TO extends number | undefined = undefined>(\n  action: () => PromiseLike<R>,\n  timeout?: TO,\n  retries?: number\n) => Promise<TO extends number ? undefined | R : R>) => {\n  type LockState = [owner: string, expires: number];\n  const get = () =>\n    (encrypt ? httpDecrypt<LockState> : httpDecode<LockState>)(\n      localStorage.getItem(lockId)\n    );\n\n  let intervalId = 0;\n  const renew = () =>\n    localStorage.setItem(\n      lockId,\n      (encrypt ? httpEncrypt : httpEncode)([TAB_ID, now() + timeout])\n    );\n\n  return (async (\n    action: any,\n    localTimeout?: number,\n    retries = localTimeout != null ? 1 : defaultRetries\n  ) => {\n    while (retries--) {\n      let current = get();\n      if (!current || current[1] < now()) {\n        renew();\n        if (get()?.[0] === TAB_ID) {\n          // Keep lock alive while the action executes.\n          timeout > 0 && (intervalId = setInterval(() => renew(), timeout / 2));\n          return await tryCatchAsync(action, true, () => {\n            clearInterval(intervalId);\n            localStorage.removeItem(lockId);\n          });\n        }\n      }\n      let waitHandle = promise();\n      const [unbind] = listen(window, \"storage\", (ev) => {\n        if (ev.key === lockId && !ev.newValue) {\n          waitHandle.resolve();\n        }\n      });\n      await race(delay(localTimeout ?? timeout), waitHandle);\n      unbind();\n    }\n    localTimeout == null && throwError(lockId + \" could not be acquired.\");\n  }) as any;\n};\n","import {\n  DataClassification,\n  DataPurposeFlags,\n  PostRequest,\n  PostResponse,\n  VariableResultPromise,\n  VariableResultStatus,\n  dataPurposes,\n  getResultVariable,\n  toVariableResultPromise,\n} from \"@tailjs/types\";\nimport {\n  If,\n  MaybeArray,\n  Nullish,\n  apply,\n  assign,\n  clock,\n  concat,\n  forEach,\n  get,\n  isBoolean,\n  isPlainObject,\n  isString,\n  map,\n  now,\n  pick,\n  push,\n  remove,\n  required,\n  structuralEquals,\n  throwError,\n} from \"@tailjs/util\";\nimport {\n  ClientVariable,\n  ClientVariableCallback,\n  ClientVariableGetResult,\n  ClientVariableGetter,\n  ClientVariableResults,\n  ClientVariableSetResult,\n  ClientVariableSetter,\n  LocalVariableScopeValue,\n  ReservedVariableKey,\n  ReservedVariableType,\n  StateVariable,\n  TrackerContext,\n  VARIABLE_CACHE_DURATION,\n  VARIABLE_POLL_FREQUENCY,\n  addPageLoadedListener,\n  addResponseHandler,\n  addVariablesChangedListener,\n  isLocalScopeKey,\n  localVariableScope,\n  request,\n  stringToVariableKey,\n  toNumericVariableEnums,\n  tryGetVariable,\n  updateVariableState,\n  variableKeyToString,\n} from \".\";\n\nconst KEY_PROPS: any[] = [\"scope\", \"key\", \"targetId\", \"version\"];\nconst VARIABLE_PROPS: any[] = [\n  ...KEY_PROPS,\n  \"created\",\n  \"modified\",\n  \"classification\",\n  \"purposes\",\n  \"tags\",\n  \"readonly\",\n  \"value\",\n];\nconst GETTER_PROPS: any[] = [...KEY_PROPS, \"init\", \"purpose\", \"refresh\"];\nconst SETTER_PROPS: any[] = [...VARIABLE_PROPS, \"value\", \"force\", \"patch\"];\n\nexport interface TrackerVariableStorage {\n  // Omit `init` to allow intellisense to suggest the actual type for reserved keys.\n  get<K extends readonly Omit<ClientVariableGetter, \"init\">[]>(\n    ...getters:\n      | [\n          key: string,\n          ...getters: (K & ValidateParameters<K, true>) | GetterIntellisense\n        ]\n      | (K & ValidateParameters<K, true>)\n      | GetterIntellisense\n  ): VariableResultPromise<ClientVariableResults<K, true>>;\n  // Omit `value` to allow intellisense to suggest the actual type for reserved keys.\n  set<V extends readonly Omit<ClientVariableSetter, \"value\">[]>(\n    ...setters:\n      | [\n          key: string,\n          ...setters: (V & ValidateParameters<V, false>) | SetterIntellisense\n        ]\n      | (V & ValidateParameters<V, false>)\n      | SetterIntellisense\n  ): VariableResultPromise<ClientVariableResults<V, false>>;\n}\nconst activeCallbacks = new Map<string, Set<ClientVariableCallback>>();\n\nexport const createVariableStorage = (\n  endpoint: string,\n  context?: TrackerContext\n): TrackerVariableStorage => {\n  const pollVariables = clock(async () => {\n    const getters: ClientVariableGetter[] = map(\n      activeCallbacks,\n      ([key, callbacks]) => ({\n        ...stringToVariableKey(key),\n        result: [...callbacks],\n      })\n    ) as any;\n\n    getters.length && (await vars.get(...(getters as any)));\n  }, VARIABLE_POLL_FREQUENCY);\n\n  const registerCallbacks = (\n    mappedKey: string,\n    callbacks?: MaybeArray<ClientVariableCallback>\n  ) =>\n    callbacks &&\n    apply(callbacks, (callback) =>\n      get(activeCallbacks, mappedKey, () => new Set()).add(callback)\n    );\n\n  const invokeCallbacks = (\n    variable: ClientVariable | Nullish,\n    previous?: ClientVariable\n  ) => {\n    if (!variable) return;\n\n    const key = variableKeyToString(variable);\n\n    const callbacks = remove(activeCallbacks, key);\n    if (!callbacks?.size) return;\n\n    let poll: boolean;\n\n    if (\n      variable?.purposes === previous?.purposes &&\n      variable?.classification == previous?.classification &&\n      structuralEquals(variable?.value, previous?.value)\n    ) {\n      // No change.\n      return;\n    }\n\n    forEach(callbacks, (callback) => {\n      poll = false;\n      callback?.(variable, previous, (toggle = true) => (poll = toggle));\n      poll && registerCallbacks(key, callback);\n    });\n  };\n\n  addPageLoadedListener(\n    (loaded, stateDuration) =>\n      pollVariables.toggle(\n        loaded,\n        loaded && stateDuration >= VARIABLE_POLL_FREQUENCY\n      ),\n    true\n  );\n\n  addVariablesChangedListener((changes) =>\n    forEach(changes, ([current, previous]) =>\n      invokeCallbacks(current, previous)\n    )\n  );\n\n  const cacheDurations = new Map<string, number>();\n  const updateCacheDuration = (\n    key: string,\n    duration: undefined | number | boolean\n  ) =>\n    assign(\n      cacheDurations,\n      key,\n      isBoolean(duration) ? (duration ? undefined : 0) : duration\n    );\n\n  const vars = {\n    get: (\n      ...getters: ClientVariableGetter[]\n    ): VariableResultPromise<ClientVariableResults<any, true>> =>\n      toVariableResultPromise(async () => {\n        let key: string | Nullish;\n        if (!getters[0] || isString(getters[0])) {\n          key = getters[0];\n          getters = getters.slice(1) as any;\n        }\n        context?.validateKey(key);\n\n        const results: [ClientVariableGetResult, number][] = [];\n\n        let requestGetters = map(getters, (getter, sourceIndex) => [\n          getter,\n          sourceIndex,\n        ]);\n\n        const newLocal: StateVariable[] = [];\n        const response =\n          (\n            await request<PostRequest, PostResponse>(endpoint, () => {\n              requestGetters = map(requestGetters, ([getter, sourceIndex]) => {\n                if (!getter) return undefined;\n\n                const key = variableKeyToString(getter);\n                registerCallbacks(key, getter.result);\n\n                const current = tryGetVariable(key);\n\n                getter.init && updateCacheDuration(key, getter.cache);\n                const purposes = (getter as any).purposes;\n                if (!((purposes ?? ~0) & (current?.purposes ?? ~0))) {\n                  push(results, [\n                    {\n                      ...getter,\n                      status: VariableResultStatus.Denied,\n                      error:\n                        \"No consent for \" + dataPurposes.logFormat(purposes),\n                    } as any,\n                    sourceIndex,\n                  ]);\n                } else if (!getter.refresh && current?.[1]! < now()) {\n                  push(results, [\n                    {\n                      ...current,\n                      status: VariableResultStatus.Success,\n                    } as any,\n                    sourceIndex,\n                  ]);\n                } else if (isLocalScopeKey(getter)) {\n                  if (isPlainObject(getter.init)) {\n                    const local: ClientVariableGetResult<any, any, any, true> =\n                      {\n                        ...toNumericVariableEnums(getter),\n                        status: VariableResultStatus.Created,\n                        ...getter.init,\n                      };\n                    if (local.value != null) {\n                      push(newLocal, setResultExpiration(local));\n                      push(results, [local, sourceIndex]);\n                    }\n                  }\n                } else {\n                  return [pick(getter, GETTER_PROPS), sourceIndex];\n                }\n              });\n\n              return requestGetters.length\n                ? {\n                    variables: { get: map(requestGetters, 0) as any },\n                    deviceSessionId: context?.deviceSessionId,\n                  }\n                : false;\n            })\n          )?.variables?.get ?? [];\n\n        push(\n          results,\n          ...map(\n            response,\n            (response, i) => response && [response, requestGetters[i][1]]\n          )\n        );\n\n        if (newLocal.length) {\n          updateVariableState(newLocal);\n        }\n\n        return results.map(([result]) => result);\n      }, map(getters, (getter) => getter?.error) as any) as any,\n\n    set: (\n      ...setters: ClientVariableSetter[]\n    ): ClientVariableResults<any, false> =>\n      toVariableResultPromise(async () => {\n        let key: string | Nullish;\n        if (!setters[0] || isString(setters[0])) {\n          key = setters[0];\n          setters = setters.slice(1) as any;\n        }\n        context?.validateKey(key);\n\n        const localResults: StateVariable[] = [];\n        const results: ClientVariableSetResult[] = [];\n\n        // Only request non-null setters, and use the most recent version we have already read, if any.\n        const requestVariables = map(setters, (setter, sourceIndex) => {\n          if (!setter) return undefined;\n          const key = variableKeyToString(setter);\n          const current = tryGetVariable(key);\n          updateCacheDuration(key, setter.cache);\n          if (isLocalScopeKey(setter)) {\n            if (setter.patch != null)\n              return throwError(\"Local patching is not supported.\");\n            const local: ClientVariable<any, any, true> = {\n              value: setter.value,\n              classification: DataClassification.Anonymous,\n              purposes: DataPurposeFlags.Necessary,\n              scope: localVariableScope(setter.scope),\n              key: setter.key,\n            };\n\n            results[sourceIndex] = {\n              status: current\n                ? VariableResultStatus.Success\n                : VariableResultStatus.Created,\n              source: setter as any,\n              current: local,\n            };\n            push(localResults, setResultExpiration(local));\n            return undefined;\n          }\n          if (setter.patch == null && setter?.version === undefined) {\n            setter.version = current?.version;\n            // Force the first set, we do not have any cached version to validate against.\n            setter.force ??= !!setter.version;\n          }\n          return [\n            pick(setter, SETTER_PROPS as any) as ClientVariableSetter,\n            sourceIndex,\n          ];\n        });\n\n        const response = !requestVariables.length\n          ? []\n          : required(\n              (\n                await request<PostRequest, PostResponse>(endpoint, {\n                  variables: {\n                    set: requestVariables.map((variable) => variable[0] as any),\n                  },\n                  deviceSessionId: context?.deviceSessionId,\n                })\n              ).variables?.set,\n              \"No result.\"\n            );\n\n        if (localResults.length) {\n          updateVariableState(localResults);\n        }\n\n        forEach(response, (result, index) => {\n          const [setter, sourceIndex] = requestVariables[index];\n          (result as any).source = setter;\n          setter.result?.(result as any);\n          results[sourceIndex] = result as any;\n        });\n\n        return results as any;\n      }, map(setters, (setter) => setter?.error) as any) as any,\n  };\n\n  const setResultExpiration = (\n    variable: ClientVariable,\n    timestamp = now()\n  ): StateVariable => ({\n    ...pick(variable, VARIABLE_PROPS),\n    cache: [\n      timestamp,\n      timestamp +\n        (remove(cacheDurations, variableKeyToString(variable)) ??\n          VARIABLE_CACHE_DURATION),\n    ],\n  });\n  addResponseHandler(({ variables }) => {\n    if (!variables) return;\n    const timestamp = now();\n    const changed = concat(\n      map(variables.get, (result) => getResultVariable(result)),\n      map(variables.set, (result) => getResultVariable(result))\n    );\n\n    changed?.length &&\n      updateVariableState(apply(changed, setResultExpiration, timestamp));\n  });\n\n  return vars as any;\n};\n\n/** Suggests the reserved names and their corresponding values for local variables, and helps autocomplete string enums (purpose etc.). */\nexport type GetterIntellisense<\n  K extends string = ReservedVariableKey | \"(any)\"\n> = readonly (\n  | ClientVariableGetter<any, \"(any)\" | (string & {}), false>\n  | (K extends infer K\n      ? ClientVariableGetter<ReservedVariableType<K>, K & string, true>\n      : // Only suggest reserved local names when local is true. This does that trick.\n\n        never)\n)[];\n\n/** Suggests the reserved names and their corresponding values for local variables, and helps autocomplete string enums (purpose etc.). */\ntype SetterIntellisense<K extends string = ReservedVariableKey | \"(any)\"> =\n  readonly (\n    | ClientVariableSetter<any, \"(any)\" | (string & {}), false>\n    | (K extends infer K\n        ? ClientVariableSetter<ReservedVariableType<K>, K & string, true>\n        : // Only suggest reserved local names when local is true. This does that trick.\n\n          never)\n  )[];\n\ntype ValidateParameter<P, Getters> = P extends {\n  key: infer K & string;\n  scope: LocalVariableScopeValue;\n}\n  ? If<\n      Getters,\n      ClientVariableGetter<ReservedVariableType<K>, K & string, true>,\n      ClientVariableSetter<ReservedVariableType<K>, K & string, true>\n    >\n  : P extends { key: infer K & string }\n  ? If<\n      Getters,\n      ClientVariableGetter<any, K & string, false>,\n      ClientVariableSetter<any, K & string, false>\n    >\n  : never;\n\ntype ValidateParameters<P, Getters> = P extends readonly []\n  ? []\n  : P extends readonly [infer Item, ...infer Rest]\n  ? readonly [\n      ValidateParameter<Item, Getters>,\n      ...ValidateParameters<Rest, Getters>\n    ]\n  : P extends readonly (infer Item)[]\n  ? readonly ValidateParameter<Item, Getters>[]\n  : never;\n","import {\n  ConfiguredComponent,\n  ImpressionEvent,\n  ImpressionRegionStats,\n  ImpressionTextStats,\n} from \"@tailjs/types\";\nimport {\n  F,\n  Intervals,\n  NoOpFunction,\n  T,\n  TextStats,\n  Timer,\n  assign,\n  clock,\n  count,\n  createIntervals,\n  createTimer,\n  filter,\n  forEach,\n  getTextStats,\n  map,\n  nil,\n  push,\n  restrict,\n} from \"@tailjs/util\";\nimport {\n  document,\n  getActiveTime,\n  getScreenPos,\n  getViewport,\n  trackerConfig,\n  trackerFlag,\n} from \".\";\nimport {\n  BoundaryData,\n  Tracker,\n  createViewDurationTimer,\n  getComponentContext,\n  getViewTimeOffset,\n} from \"..\";\n\nconst intersectionHandler = Symbol();\n\nconst INTERSECTION_POLL_INTERVAL = 250;\n\ntype ImpressionThreshold = [ownRatio: number, viewportRatio: number];\n\n/** The amount of the component that must be visible for the impression to count. */\nconst IMPRESSION_START = [0.75, 0.33];\n\n/** The impression stops when only this amount of the component is visible. */\nconst IMPRESSION_STOP = [0.25, 0.33];\n\n/** The percentage of the total number of characters contained in the top region. */\nconst TEXT_REGION_TOP = 0.25;\n\n/* The percentage of the total number of characters before the bottom region. */\nconst TEXT_REGION_BOTTOM = 0.75;\n\nexport const createImpressionObserver = (tracker: Tracker) => {\n  const observer = new IntersectionObserver(\n    (els) => forEach(els, (args) => args.target[intersectionHandler]?.(args))\n    // Low thresholds used to be able to handle components larger than view ports.\n  );\n\n  const currentIntersections = new Set<() => void>();\n\n  const monitor = clock({\n    callback: () => forEach(currentIntersections, (handler) => handler()),\n    frequency: INTERSECTION_POLL_INTERVAL,\n    raf: true,\n  });\n\n  const constrain = (point: number, max: number, min = 0) =>\n    point < min ? min : point > max ? max : point;\n\n  const probeRange = document.createRange();\n\n  return (el: Element, boundaryData: BoundaryData<true> | undefined) => {\n    if (!boundaryData) return;\n\n    let components: ConfiguredComponent[] | undefined;\n    if (\n      (components = filter(\n        boundaryData?.component,\n        (cmp) =>\n          // Impression settings from the DOM/CSS are ignored for secondary and inferred components (performance thing)\n          cmp!.track?.impressions ||\n          (cmp.track?.secondary ?? cmp.inferred) !== T\n      ))\n    ) {\n      if (!count(components)) return;\n\n      let active = F;\n      let pendingActive = F;\n      let impressions = 0;\n      let visiblePercentage = 0;\n      let regions:\n        | [\n            data: ImpressionRegionStats,\n            timer: Timer,\n            pending: boolean,\n            active: boolean,\n            top: number,\n            bottom: number,\n            readTime: number,\n            intervals: Intervals\n          ][]\n        | undefined;\n\n      const updateRegion = (\n        index: number,\n        top: number,\n        bottom: number,\n        readTime: number\n      ) => {\n        const region = ((regions ??= [])[index] ??= [\n          { duration: 0, impressions: 0 },\n          createTimer(false, getActiveTime),\n          false,\n          false,\n          0,\n          0,\n          0,\n          createIntervals(),\n        ]);\n        region[4] = top;\n        region[5] = bottom;\n        region[6] = readTime;\n      };\n\n      const visible = [createIntervals(), createIntervals()];\n\n      const viewDuration = createViewDurationTimer(false);\n      const activeTime = createTimer(false, getActiveTime);\n\n      let impressionEvents: ImpressionEvent[] | undefined;\n      let unbindPassiveEventSources: NoOpFunction[] | undefined;\n      // let overlays = map(2, (i) => {\n      //   const overlay = document.createElement(\"div\");\n      //   overlay.style.cssText = `position:absolute;${i ? \"bottom\" : \"top\"}:0;${\n      //     i ? \"right\" : \"left\"\n      //   }:0;background-color:blue`;\n      //   el.appendChild(overlay);\n      //   return overlay;\n      // });\n\n      // (el as any).style.border = \"1px solid blue\";\n      // (el as any).style.position = \"relative\";\n\n      let prevHeight = -1;\n      let boundaries: TextStats[\"boundaries\"] | undefined;\n      let stats: ImpressionTextStats | undefined;\n\n      const poll = () => {\n        const rect = el.getBoundingClientRect();\n        const viewWidth = window.innerWidth;\n        const viewHeight = window.innerHeight;\n\n        const intersection = [\n          constrain(rect.top, viewHeight),\n          constrain(rect.right, viewWidth),\n          constrain(rect.bottom, viewHeight),\n          constrain(rect.left, viewWidth),\n        ];\n\n        const intersectionHeight = intersection[2] - intersection[0];\n        const intersectionWidth = intersection[1] - intersection[3];\n\n        const verticalIntersection = intersectionHeight / rect.height || 0;\n        const horizontalIntersection = intersectionWidth / rect.width || 0;\n\n        /**\n         * The threshold for when an impression becomes active/inactive.\n         * They depend on whether the impression is currently active.\n         */\n        const thresholds = active ? IMPRESSION_STOP : IMPRESSION_START;\n\n        /**\n         * The smallest of the horizontal and vertical intersection percentage. If this is smaller than the threshold,\n         * the component is intuitively not visible (or \"impressed\", lol).\n         */\n        const qualified =\n          (intersectionHeight > thresholds[0] * viewHeight ||\n            verticalIntersection > thresholds[0]) &&\n          (intersectionWidth > thresholds[0] * viewWidth ||\n            horizontalIntersection > thresholds[0]);\n\n        if (pendingActive !== qualified) {\n          activeTime((pendingActive = qualified), true);\n        }\n        if (\n          active !==\n          (active =\n            pendingActive &&\n            activeTime() >=\n              trackerConfig.impressionThreshold - INTERSECTION_POLL_INTERVAL)\n        ) {\n          ++impressions;\n          viewDuration(active);\n          if (!impressionEvents) {\n            impressionEvents = filter(\n              map(\n                components,\n                (cmp) =>\n                  ((cmp!.track?.impressions ||\n                    trackerFlag(\n                      el,\n                      \"impressions\",\n                      T,\n                      (data) => data.track?.impressions\n                    )) &&\n                    restrict<ImpressionEvent>({\n                      type: \"impression\",\n                      pos: getScreenPos(el),\n                      viewport: getViewport(),\n                      timeOffset: getViewTimeOffset(),\n                      impressions,\n                      ...getComponentContext(el, T),\n                    })) ||\n                  nil\n              )\n            );\n            tracker(impressionEvents);\n          }\n\n          if (impressionEvents?.length) {\n            const duration = viewDuration();\n            unbindPassiveEventSources = map(impressionEvents, (event) =>\n              tracker.events.registerEventPatchSource(event, () => ({\n                relatedEventId: event.clientId!,\n                duration,\n                impressions: impressions,\n                regions: regions && {\n                  top: regions[0][0],\n                  middle: regions[1][0],\n                  bottom: regions[2][0],\n                },\n                seen: visiblePercentage,\n                text: stats,\n                read:\n                  duration.activeTime &&\n                  stats &&\n                  constrain(\n                    duration.activeTime / stats.readTime,\n                    visiblePercentage\n                  ),\n              }))\n            );\n          }\n        }\n\n        if (rect.height !== prevHeight) {\n          prevHeight = rect.height;\n          const text = (el as HTMLElement).textContent;\n          ({ boundaries, ...stats } = getTextStats(\n            text ?? \"\",\n            [0, 0.25, 0.75, 1]\n          ));\n\n          if (regions || rect.height >= 1.25 * viewHeight) {\n            const nodes = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);\n            let node: Node | null;\n            let length = 0;\n\n            let boundaryIndex = 0;\n            regions ??= [];\n            while (\n              boundaryIndex < boundaries.length &&\n              (node = nodes.nextNode())\n            ) {\n              let nodeLength = node.textContent?.length ?? 0;\n              length += nodeLength;\n              while (length >= boundaries[boundaryIndex]?.offset) {\n                // While loop because two boundaries may have the same offset.\n                probeRange[boundaryIndex % 2 ? \"setEnd\" : \"setStart\"](\n                  node,\n                  boundaries[boundaryIndex].offset - length + nodeLength\n                );\n\n                if (boundaryIndex++ % 2) {\n                  const { top, bottom } = probeRange.getBoundingClientRect();\n                  const offset = rect.top;\n\n                  if (boundaryIndex < 3) {\n                    updateRegion(\n                      0,\n                      top - offset,\n                      bottom - offset,\n                      boundaries[1].readTime\n                    );\n                  } else {\n                    updateRegion(\n                      1,\n                      regions[0][4],\n                      top - offset,\n                      boundaries[2].readTime\n                    );\n                    updateRegion(\n                      2,\n                      top - offset,\n                      bottom - offset,\n                      boundaries[3].readTime\n                    );\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        let horizontalOffset = rect.left < 0 ? -rect.left : 0;\n        let verticalOffset = rect.top < 0 ? -rect.top : 0;\n        const area = rect.width * rect.height;\n\n        if (active) {\n          visiblePercentage =\n            (visible[0].push(\n              verticalOffset,\n              verticalOffset + intersectionHeight\n            ) *\n              visible[1].push(\n                horizontalOffset,\n                horizontalOffset + intersectionWidth\n              )) /\n            area;\n        }\n\n        if (regions) {\n          forEach(regions, (region) => {\n            const intersectionTop = constrain(\n              rect.top < 0 ? -rect.top : 0,\n              region[5],\n              region[4]\n            );\n            const intersectionBottom = constrain(\n              rect.bottom > viewHeight ? viewHeight : rect.bottom,\n              region[5],\n              region[4]\n            );\n\n            // Zero height, nothing to do.\n            let qualified = active && intersectionBottom - intersectionTop > 0;\n\n            const data = region[0];\n            data.duration = region[1](qualified);\n\n            if (qualified) {\n              region[3] !== (region[3] = qualified) && ++region[0].impressions!;\n\n              data.seen =\n                region[7].push(intersectionTop, intersectionBottom) /\n                (region[5] - region[4]);\n              data.read = constrain(data.duration / region[6], data.seen);\n            }\n          });\n        }\n      };\n\n      el[intersectionHandler] = ({\n        isIntersecting,\n      }: IntersectionObserverEntry) => {\n        assign(currentIntersections, poll, isIntersecting);\n        !isIntersecting &&\n          (forEach(unbindPassiveEventSources, (unbind) => unbind()), poll());\n      };\n      observer.observe(el);\n    }\n  };\n};\n","import type { UserAgentEvent } from \"@tailjs/types\";\nimport { window } from \"../lib\";\n\nexport const detectDeviceType = (): Pick<\n  UserAgentEvent,\n  \"deviceType\" | \"screen\"\n> => {\n  // Common thresholds based on https://yesviz.com/viewport/\n  const screen = window?.screen;\n  if (!screen) return {};\n\n  let { width: w, height: h, orientation: o } = screen; // Get's the resolution in logical (CSS) pixels.\n  const landscape = w < h;\n  const angle = o?.angle ?? window[\"orientation\"] ?? 0;\n  (angle === -90 || angle === 90) && ([w, h] = [h, w]);\n\n  return {\n    deviceType: w < 480 ? \"mobile\" : w <= 1024 ? \"tablet\" : \"desktop\",\n    screen: { dpr: window.devicePixelRatio, width: w, height: h, landscape },\n  };\n};\n","import { map, push, restrict } from \"@tailjs/util\";\r\nimport { Tracker, currentViewEvent, detectDeviceType } from \"..\";\r\nimport { UserAgentEvent, UserAgentLanguage } from \"@tailjs/types\";\r\n\r\nexport const postUserAgentEvent = (tracker: Tracker) =>\r\n  tracker(\r\n    restrict<UserAgentEvent>({\r\n      type: \"user_agent\",\r\n      hasTouch: navigator.maxTouchPoints > 0,\r\n      userAgent: navigator.userAgent,\r\n      view: currentViewEvent?.clientId,\r\n      languages: map(navigator.languages, (id, i, parts = id.split(\"-\")) =>\r\n        restrict<UserAgentLanguage>({\r\n          id,\r\n          language: parts[0],\r\n          region: parts[1],\r\n          primary: i === 0,\r\n          preference: i + 1,\r\n        })\r\n      ),\r\n      timezone: {\r\n        iana: Intl.DateTimeFormat().resolvedOptions().timeZone,\r\n        offset: new Date().getTimezoneOffset(),\r\n      },\r\n      ...detectDeviceType(),\r\n    })\r\n  );\r\n","import { CLIENT_CALLBACK_CHANNEL_ID } from \"@constants\";\n\nimport {\n  AnchorNavigationEvent,\n  CartUpdatedEvent,\n  ComponentClickEvent,\n  ComponentClickIntentEvent,\n  ComponentElementInfo,\n  NavigationEvent,\n  ScreenPosition,\n  UserInteractionEvent,\n} from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  createTimeout,\n  ellipsis,\n  equalsAny,\n  forEach,\n  get,\n  isObject,\n  map,\n  nil,\n  parseUri,\n  push,\n  remove,\n  restrict,\n  some,\n  stop,\n  update,\n  type Nullish,\n} from \"@tailjs/util\";\nimport {\n  TrackerExtensionFactory,\n  getComponentContext,\n  getViewTimeOffset,\n  onFrame,\n  parseActivationTags,\n  pushNavigationSource,\n  tryGetCartEventData,\n} from \"..\";\nimport {\n  MNT_URL,\n  attr,\n  forAncestorsOrSelf,\n  getBoundaryData,\n  getPos,\n  getRect,\n  getScreenPos,\n  getViewport,\n  isInternalUrl,\n  listen,\n  matchExHash,\n  nextId,\n  normalizedAttribute,\n  overlay,\n  tagName,\n  trackerConfig,\n  trackerFlag,\n} from \"../lib\";\n\nconst isLinkElement = (\n  el: Element,\n  href: any = tagName(el) === \"A\" && attr(el, \"href\")\n): el is HTMLAnchorElement =>\n  href && href != \"#\" && !href.startsWith(\"javascript:\");\n\nconst isClickable = (\n  el: Element,\n  t = tagName(el),\n  attr = trackerFlag(el, \"button\")\n): el is HTMLElement =>\n  attr !== F &&\n  (equalsAny(t, \"A\", \"BUTTON\") ||\n    (t === \"INPUT\" &&\n      equalsAny(normalizedAttribute(el, \"type\"), \"button\", \"submit\")) ||\n    attr === T);\n\nconst getElementInfo = (el: Element, includeRect = false) => ({\n  tagName: el.tagName,\n  text: ellipsis(\n    attr(el, \"title\")?.trim() ||\n      attr(el, \"alt\")?.trim() ||\n      (el as HTMLElement).innerText?.trim(),\n    100\n  ),\n  href: (el as any).href?.toString(),\n  rect: includeRect ? getRect(el) : undefined,\n});\nconst getElementLabel = (\n  el: Element | EventTarget | null,\n  container: Element,\n  includeRect = false\n) => {\n  let info: Pick<UserInteractionEvent, \"element\"> | undefined;\n  forAncestorsOrSelf(el ?? container, (el) =>\n    tagName(el) === \"IMG\" || el === container\n      ? ((info = {\n          element: getElementInfo(el, includeRect),\n        }),\n        F)\n      : T\n  );\n  return info;\n};\nexport const userInteraction: TrackerExtensionFactory = {\n  id: \"navigation\",\n\n  setup(tracker) {\n    // The tracked click positions for click events that has already been posted once.\n    const activeEventClicks = new WeakMap<Node, ScreenPosition[]>();\n\n    const stripPositions = <T = any>(el: any, hitTest: boolean): T =>\n      hitTest\n        ? el\n        : (map(el, ([key]) =>\n            key === \"rect\" ||\n            //key === \"pos\"  Changed so pos is always included.\n            key === \"viewport\"\n              ? remove(el, key)\n              : isObject(el[key]) &&\n                map(el[key], (item) => stripPositions(item, hitTest))\n          ),\n          el);\n    const trackDocument = (document: Document) => {\n      listen(\n        document,\n        [\"click\", \"contextmenu\", \"auxclick\"],\n        (ev: MouseEvent) => {\n          let trackClicks: boolean | Nullish;\n          let trackRegion: boolean | Nullish;\n          let clickableElement: HTMLElement | undefined;\n          let containerElement: Element | undefined;\n\n          let nav = F;\n\n          let clickables: ComponentElementInfo[] | undefined;\n\n          forAncestorsOrSelf<boolean>(ev.target, (el) => {\n            isClickable(el) && (clickableElement ??= el);\n            nav = nav || tagName(el) === \"NAV\";\n\n            const boundary = getBoundaryData(el);\n            const components = boundary?.component;\n            if (!ev.button && components?.length && !clickables) {\n              forEach(\n                el.querySelectorAll(\"a,button\"),\n                (clickable) =>\n                  isClickable(clickable) &&\n                  ((clickables ??= []).length > 3\n                    ? stop() // If there are more than two clickables, there is presumably not any missed click intent.\n                    : clickables.push({\n                        ...getElementInfo(clickable, true),\n                        component: forAncestorsOrSelf(\n                          clickable,\n                          (\n                            child,\n                            r,\n                            _,\n                            childComponents = getBoundaryData(child)?.component\n                          ) => childComponents && r(childComponents[0]),\n                          (child) => child === el\n                        ),\n                      }))\n              );\n\n              if (clickables) {\n                containerElement ??= el;\n              }\n            }\n\n            trackClicks ??=\n              trackerFlag(el, \"clicks\", T, (data) => data.track?.clicks) ??\n              (components &&\n                some(components, (cmp) => cmp.track?.clicks !== F));\n            trackRegion ??=\n              trackerFlag(el, \"region\", T, (data) => data.track?.region) ??\n              (components && some(components, (cmp) => cmp.track?.region));\n          });\n\n          if (!(containerElement ??= clickableElement)) {\n            return;\n          }\n          const clickIntent = clickables && !clickableElement && trackClicks;\n\n          const componentContext = getComponentContext(\n            containerElement,\n            false,\n            clickIntent\n          );\n          const tags = parseActivationTags(containerElement);\n          trackClicks ??= !nav;\n          trackRegion ??= T;\n\n          const sharedEventProperties = {\n            ...(trackRegion\n              ? {\n                  pos: getScreenPos(clickableElement, ev),\n                  viewport: getViewport(),\n                }\n              : nil),\n            ...getElementLabel(ev.target, containerElement),\n            ...componentContext,\n            timeOffset: getViewTimeOffset(),\n            ...tags,\n          };\n          if (!clickableElement) {\n            clickIntent &&\n              update(activeEventClicks, containerElement, (current) => {\n                const pos = getPos(containerElement!, ev);\n                if (!current) {\n                  // Reuse the same event and only add the new click coordinates\n                  // if the element is clicked again to reduce data.\n                  const intentEvent = restrict<ComponentClickIntentEvent>({\n                    type: \"component_click_intent\",\n                    ...sharedEventProperties,\n                    clicks: (current = [pos]),\n\n                    clickables,\n                  });\n\n                  tracker.events.registerEventPatchSource(\n                    intentEvent,\n                    () => ({\n                      clicks: get(activeEventClicks, containerElement!),\n                    }),\n                    true,\n                    containerElement\n                  );\n                } else {\n                  push(current, pos);\n                }\n\n                return current;\n              });\n            //  ,              overlay(containerElement, \"Click intent\", true)\n\n            return;\n          }\n\n          if (isLinkElement(clickableElement!)) {\n            const link = clickableElement;\n            const external = link.hostname !== location.hostname;\n\n            const {\n              host,\n              scheme,\n              source: href,\n            } = parseUri(link.href, false, true);\n            if (\n              link.host === location.host &&\n              link.pathname === location.pathname &&\n              link.search === location.search\n            ) {\n              if (link.hash === \"#\") {\n                // Don't care about that one.\n                return;\n              }\n              if (link.hash !== location.hash) {\n                if (ev.button === 0)\n                  tracker(\n                    restrict<AnchorNavigationEvent>({\n                      type: \"anchor_navigation\",\n                      anchor: link.hash,\n                      ...sharedEventProperties,\n                    })\n                  );\n              }\n              return;\n            }\n\n            const navigationEvent: NavigationEvent = restrict<NavigationEvent>({\n              clientId: nextId(),\n              type: \"navigation\",\n              href: external ? link.href : href,\n              external,\n              domain: { host, scheme },\n              self: T,\n              anchor: link.hash,\n              ...sharedEventProperties,\n            });\n\n            // There does not seem to be any way to detect when the user clicks\n            // \"Open link in new tab/window\", so we need to do a little extra gymnastics to capture it.\n            if (ev.type === \"contextmenu\") {\n              const originalUrl = link.href;\n              const internalUrl = isInternalUrl(originalUrl);\n              if (internalUrl) {\n                // Detecting internal navigation is not that hard.\n                // If the page loads in a new tab, it will pick up this value as the referrer,\n                //   and we will know navigation happened.\n                pushNavigationSource(navigationEvent.clientId, () =>\n                  tracker(navigationEvent)\n                );\n                return;\n              }\n\n              // Detecting external navigation is _much_ harder.\n              // Unfortunately we need to rewrite the URL to redirect via the request handler, and poll for a local storage key.\n              // This is only a problem if the user decides to copy the link from the context menu and share it,\n              // since some may argue the link looks \"obscure\".\n              var requestId = (\"\" + Math.random())\n                .replace(\".\", \"\")\n                .substring(1, 8);\n              if (!internalUrl) {\n                if (!trackerConfig.captureContextMenu) return;\n                link.href =\n                  MNT_URL + \"=\" + requestId + encodeURIComponent(originalUrl);\n\n                // Poll for the storage key where the request handler will write the request ID before it redirects\n                // the user if the link is opened.\n                listen(\n                  window,\n                  \"storage\",\n                  (ev, unbind) =>\n                    ev.key === CLIENT_CALLBACK_CHANNEL_ID &&\n                    (ev.newValue &&\n                      JSON.parse(ev.newValue)?.requestId === requestId &&\n                      tracker(navigationEvent),\n                    unbind())\n                );\n\n                createTimeout;\n                // Switch the link back when the context menu closes.\n                listen(\n                  document,\n                  [\"keydown\", \"keyup\", \"visibilitychange\", \"pointermove\"],\n                  (_, unbind) => {\n                    unbind();\n\n                    link.href = originalUrl;\n                  }\n                );\n              }\n              return;\n            }\n\n            if (ev.button <= 1) {\n              if (\n                ev.button === 1 || //Middle-click: new tab.\n                ev.ctrlKey || // New tab\n                ev.shiftKey || // New window\n                ev.altKey || // Download\n                attr(link, \"target\") !== window.name\n              ) {\n                pushNavigationSource(navigationEvent.clientId);\n                navigationEvent.self = F;\n                // Fire immediately, we are staying on the page.\n                tracker(navigationEvent);\n                return;\n              } else if (!matchExHash(location.href, link.href)) {\n                navigationEvent.exit = navigationEvent.external;\n                // No \"real\" navigation will happen if it is only the hash changing.\n                pushNavigationSource(navigationEvent.clientId);\n              }\n\n              // // If it so happened that navigation happened we will send it on VIEW_END.\n              // pendingNavigationEvent = registerViewEndAction(() =>\n              //   tracker(navigationEvent)\n              // );\n            }\n            return;\n          }\n\n          const cart = tryGetCartEventData(ev.target as Element);\n          (cart || trackClicks) &&\n            tracker(\n              cart\n                ? restrict<CartUpdatedEvent>({\n                    type: \"cart_updated\",\n                    ...sharedEventProperties,\n                    ...cart,\n                  })\n                : restrict<ComponentClickEvent>({\n                    type: \"component_click\",\n                    ...sharedEventProperties,\n                  })\n            );\n          return;\n        }\n      );\n    };\n\n    trackDocument(document);\n    onFrame(\n      (frame) => frame.contentDocument && trackDocument(frame.contentDocument)\n    );\n  },\n};\n","import { PATCH_EVENT_POSTFIX } from \"@constants\";\n\nimport {\n  EventPatch,\n  PostRequest,\n  PostResponse,\n  TrackedEvent,\n  clearMetadata,\n  isEventPatch,\n} from \"@tailjs/types\";\nimport {\n  F,\n  Nullish,\n  ToggleArray,\n  array,\n  clock,\n  clone,\n  concat,\n  count,\n  diff,\n  forEach,\n  isString,\n  map,\n  merge,\n  now,\n  pluralize,\n  push,\n  enumerate,\n  structuralEquals,\n  throwError,\n  unshift,\n} from \"@tailjs/util\";\nimport {\n  EVENT_POST_FREQUENCY,\n  TrackerContext,\n  addPageVisibleListener,\n  childGroups,\n  debug,\n  request,\n} from \".\";\nimport { UnlockApiCommand } from \"..\";\n\nexport interface EventQueuePostOptions {\n  flush?: boolean;\n  async?: boolean;\n  variables?: PostRequest[\"variables\"];\n}\n\nexport type ProtectedEvent = TrackedEvent & UnlockApiCommand;\n\nexport interface EventQueue {\n  /**\n   * Posts events to the server. Do not post event patches using this method. Use {@link postPatch} instead.\n   * If flush is not explicitly requested, the event will eventually get posted, either by the configured post frequency, or when the user leaves the tab.\n   */\n  post<\n    T extends ToggleArray<ProtectedEvent[]>,\n    Options extends EventQueuePostOptions | undefined\n  >(\n    events: T,\n    options?: Options\n  ): Promise<Options extends { async: false } ? PostResponse : void>;\n\n  /**\n   *  Posts a patch to an existing event.\n   */\n  postPatch<T extends ProtectedEvent>(\n    target: T,\n    patch: EventPatchData<T>,\n    flush?: boolean\n  ): Promise<void>;\n\n  /**\n   * Registers a passive event.\n   *\n   * The source will get invoked whenever the tab becomes deactivated. If the source returns undefined or false, the source is unregistered.\n   * The return value is a function to manually unregister the source.\n   */\n  registerEventPatchSource<T extends ProtectedEvent>(\n    sourceEvent: T,\n    source: EventPatchSource<T>,\n    initialPost?: boolean,\n    relatedNode?: Node\n  ): () => undefined;\n}\n\nexport type EventPatchData<T extends ProtectedEvent> = Omit<\n  EventPatch<T>,\n  \"patchTargetId\" | \"metadata\" | \"type\"\n> & { type?: undefined };\n\nexport type EventPatchSource<T extends ProtectedEvent = ProtectedEvent> = (\n  current: EventPatchData<T>,\n  unbind: () => undefined\n) => EventPatchData<T> | undefined;\n\nexport const createEventQueue = (\n  url: string,\n  context: TrackerContext,\n  postFrequency = EVENT_POST_FREQUENCY\n): EventQueue => {\n  type Factory = () => [event: EventPatch | undefined, unbinding: boolean];\n  const queue: ProtectedEvent[] = [];\n\n  const snapshots = new WeakMap<ProtectedEvent, any>();\n  const sources = new Map<ProtectedEvent, Factory>();\n\n  const mapPatchTarget = <T extends ProtectedEvent>(\n    sourceEvent: T,\n    patch: EventPatchData<T> | undefined\n  ): EventPatch<T> =>\n    !sourceEvent.metadata?.queued\n      ? throwError(\"Source event not queued.\")\n      : (merge(patch, {\n          type: sourceEvent.type + PATCH_EVENT_POSTFIX,\n          patchTargetId: sourceEvent.clientId,\n        }) as any);\n\n  const registerEventPatchSource = <T extends ProtectedEvent>(\n    sourceEvent: ProtectedEvent,\n    source: EventPatchSource<T>,\n    initialPost = false,\n    relatedNode?: Node\n  ) => {\n    let unbinding = false;\n    const unbind = (): undefined => {\n      unbinding = true;\n    };\n    snapshots.set(sourceEvent, clone(sourceEvent));\n    const factory: Factory = () => {\n      if (relatedNode?.isConnected === false) {\n        unbind();\n      } else {\n        const snapshot = snapshots.get(sourceEvent);\n        let [delta, current] = diff(source(snapshot, unbind), snapshot) ?? [];\n\n        if (delta && !structuralEquals(current, snapshot)) {\n          // The new \"current\" differs from the previous.\n          snapshots.set(sourceEvent, clone(current));\n          // Add patch target ID and the correct event type to the delta data before we return it.\n          return [mapPatchTarget(sourceEvent, delta) as any, unbinding];\n        }\n      }\n\n      return [undefined, unbinding];\n    };\n    sources.set(sourceEvent, factory);\n    if (initialPost) {\n      post(sourceEvent);\n    }\n    return unbind;\n  };\n\n  const postEvents = async <Beacon>(\n    events:\n      | ProtectedEvent[]\n      | [apiKey: string | Nullish, events: ProtectedEvent[]],\n    beacon: Beacon = true as any,\n    variables: any\n  ): Promise<Beacon extends true ? void : PostResponse> => {\n    let key: string | Nullish;\n    if (!events[0] || isString(events[0])) {\n      key = events[0];\n      events = events.slice(1) as any;\n    }\n    events = events.map(\n      (ev: any) => (\n        context?.validateKey(key ?? ev.key),\n        // Update metadata in the source event,\n        // and send a clone of the event without client metadata, and its timestamp in relative time\n        // (the server expects this, and will adjust accordingly to its own time).\n        merge(ev, { metadata: { posted: true } }),\n        merge(clearMetadata(clone(ev), true), {\n          timestamp: ev.timestamp! - now(),\n        })\n      )\n    );\n\n    debug(\n      { [childGroups]: map(events, (ev) => [ev, ev.type, F]) },\n      \"Posting \" +\n        enumerate([\n          pluralize(\"new event\", [\n            count(events, (ev) => !isEventPatch(ev)) || undefined,\n          ]),\n          pluralize(\"event patch\", [\n            count(events, (ev) => isEventPatch(ev)) || undefined,\n          ]),\n        ]) +\n        (beacon ? \" asynchronously\" : \" synchronously\") +\n        \".\"\n    );\n\n    return request<PostRequest>(\n      url,\n      {\n        events,\n        variables,\n        deviceSessionId: context?.deviceSessionId,\n      },\n      { beacon: beacon as any }\n    ) as any;\n  };\n\n  const post = async (\n    events: ToggleArray<ProtectedEvent[]>,\n    { flush = false, async = true, variables }: EventQueuePostOptions = {}\n  ): Promise<any> => {\n    events = map(array(events), (event) =>\n      merge(context.applyEventExtensions(event), { metadata: { queued: true } })\n    );\n\n    if (events.length) {\n      forEach(events, (event) => debug(event, event.type));\n    }\n    if (!async) {\n      return postEvents(events, false, variables);\n    }\n    if (!flush) {\n      events.length && push(queue, ...events);\n      return;\n    }\n\n    if (queue.length) {\n      unshift(events as any, ...queue.splice(0));\n    }\n\n    if (!events.length) return;\n\n    await postEvents(events, true, variables);\n  };\n\n  postFrequency > 0 && clock(() => post([], { flush: true }), postFrequency);\n\n  addPageVisibleListener((visible, unloading, delta) => {\n    // Don't do anything if the tab has only been visible for less than a second and a half.\n    // More than that the user is probably just switching between tabs moving past this one.\n    // NOTE: (This number should preferably be better qualified. We could also look into user activation events).\n    if (!visible && (queue.length || unloading || delta > 1500)) {\n      const updatedEvents = map(sources, ([sourceEvent, source]) => {\n        const [event, unbinding] = source();\n        unbinding &&\n          (sources.delete(sourceEvent), snapshots.delete(sourceEvent));\n        return event;\n      });\n\n      if (queue.length || updatedEvents.length) {\n        post(concat(queue.splice(0), updatedEvents)!, { flush: true });\n      }\n    }\n  });\n\n  return {\n    post,\n    postPatch: (target, patch, flush) =>\n      post(mapPatchTarget(target, patch), { flush: true }),\n    registerEventPatchSource,\n  };\n};\n","import { dataPurposes, sortVariables } from \"@tailjs/types\";\r\nimport { F, T, ansi, concat, count, map } from \"@tailjs/util\";\r\nimport {\r\n  addVariablesChangedListener,\r\n  childGroups,\r\n  debug,\r\n  formatAnyVariableScope,\r\n} from \".\";\r\n\r\nexport const addDebugListeners = __DEBUG__\r\n  ? () => {\r\n      addVariablesChangedListener((changes, all, local) => {\r\n        const variables = concat(\r\n          sortVariables(map(changes, 1))?.map((variable) => [\r\n            variable,\r\n            `${variable.key} (${formatAnyVariableScope(variable.scope)}, ${\r\n              variable.scope < 0\r\n                ? \"client-side memory only\"\r\n                : dataPurposes.format(variable.purposes)\r\n            })`,\r\n            F,\r\n          ]),\r\n          [\r\n            [\r\n              {\r\n                [childGroups]: sortVariables(map(all, 1))?.map((variable) => [\r\n                  variable,\r\n                  `${variable.key} (${formatAnyVariableScope(\r\n                    variable.scope\r\n                  )}, ${\r\n                    variable.scope < 0\r\n                      ? \"client-side memory only\"\r\n                      : dataPurposes.format(variable.purposes)\r\n                  })`,\r\n                  F,\r\n                ]),\r\n              },\r\n              \"All variables\",\r\n              T,\r\n            ],\r\n          ]\r\n        )!;\r\n\r\n        debug(\r\n          { [childGroups]: variables },\r\n          ansi(\r\n            `Variables changed${\r\n              !local ? \" - merging changes from another tab\" : \"\"\r\n            } (${changes.length} changed, ${count(all)} in total).`,\r\n            \"2;3\"\r\n          )\r\n        );\r\n      });\r\n    }\r\n  : () => {};\r\n","import {\n  type CartAction,\n  type CartEventData,\n  type CartUpdatedEvent,\n  type OrderEvent,\n} from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  equalsAny,\n  isObject,\n  isString,\n  last,\n  nil,\n  push,\n  type Nullish,\n} from \"@tailjs/util\";\nimport { TrackerExtensionFactory, isCartCommand, isOrderCommand } from \"..\";\nimport { forAncestorsOrSelf, getBoundaryData, trackerProperty } from \"../lib\";\n\nexport const parseCartEventData = (\n  data: boolean | string | CartEventData | Nullish\n): CartEventData | undefined => (\n  data == nil ? undefined : (data === T || data === \"\") && (data = \"add\"),\n  isString(data) && equalsAny(data, \"add\", \"remove\", \"update\", \"clear\")\n    ? { action: data as CartAction }\n    : isObject(data)\n    ? data\n    : undefined\n);\n\nfunction normalizeCartEventData(data: CartEventData | Nullish) {\n  if (!data) return undefined;\n\n  if (data.units != nil && equalsAny(data.action, nil, \"add\", \"remove\")) {\n    if (data.units === 0) return undefined;\n    data.action = data.units > 0 ? \"add\" : \"remove\";\n  }\n  return data;\n}\n\nexport function tryGetCartEventData(sourceElement: Element) {\n  // Find cart. Look for cart attributes and/or data until the first content is met.\n  let contextCart: CartEventData | Nullish;\n  forAncestorsOrSelf(\n    sourceElement,\n    (el, r) =>\n      !!(contextCart ??= parseCartEventData(\n        getBoundaryData(el)?.cart ?? trackerProperty(el, \"cart\")\n      )) &&\n      !contextCart.item &&\n      (contextCart.item = last(getBoundaryData(el)?.content)) &&\n      r(contextCart)\n  );\n\n  return normalizeCartEventData(contextCart);\n}\n\nexport const commerce: TrackerExtensionFactory = {\n  id: \"cart\",\n  setup(tracker) {\n    return {\n      processCommand(command) {\n        if (isCartCommand(command)) {\n          let cart = command.cart;\n          cart === \"clear\"\n            ? tracker({\n                type: \"cart_updated\",\n                action: \"clear\",\n              } as CartUpdatedEvent)\n            : (cart = normalizeCartEventData(cart)!) &&\n              tracker({\n                ...cart,\n                type: \"cart_updated\",\n              } as CartUpdatedEvent);\n\n          return T;\n        }\n        if (isOrderCommand(command)) {\n          tracker({\n            type: \"order\",\n            ...command.order,\n          } as OrderEvent);\n\n          return T;\n        }\n        return F;\n      },\n    };\n  },\n};\n","import { FormEvent, FormField, Timestamp } from \"@tailjs/types\";\nimport {\n  T,\n  createTimeout,\n  ellipsis,\n  forEach,\n  get,\n  map,\n  nil,\n  now,\n  parseBoolean,\n  replace,\n  type Nullish,\n} from \"@tailjs/util\";\nimport {\n  TrackerExtensionFactory,\n  getComponentContext,\n  getViewTimeOffset,\n  getVisibleDuration,\n  onFrame,\n} from \"..\";\nimport {\n  NodeWithParentElement,\n  attr,\n  getRect,\n  listen,\n  scopeAttribute,\n  trackerFlag,\n  trackerPropertyName,\n  uuidv4,\n} from \"../lib\";\n\ntype FormElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\n\nconst enum FormFillState {\n  None = 0,\n  Submitted = 1,\n  Pending = 2,\n  Submitting = 3,\n}\n\ntype FormState = [\n  event: FormEvent,\n  fields: WeakMap<Element, FormFieldState>,\n  element: HTMLFormElement,\n  fillState: FormFillState,\n  started: Timestamp,\n  nextFillOrder: number\n];\n\nconst currentValue = Symbol();\ntype FormFieldState = FormField & {\n  [currentValue]: string;\n};\n\nexport const forms: TrackerExtensionFactory = {\n  id: \"forms\",\n  setup(tracker) {\n    const formEvents = new Map<HTMLFormElement, FormState>();\n\n    const getFormFieldValue = (element: any, tracked = false): string => {\n      let include =\n        !tracked || scopeAttribute(element, trackerPropertyName(\"form-value\"));\n\n      tracked &&\n        (include = include\n          ? parseBoolean(include)\n          : element.type === \"checkbox\");\n\n      let value = element.selectedOptions\n        ? [...element.selectedOptions].map((option) => option.value).join(\",\")\n        : element.type === \"checkbox\"\n        ? element.checked\n          ? \"true\"\n          : \"false\"\n        : element.value;\n\n      if (tracked && value) {\n        value = ellipsis(value, 200);\n      }\n      return include ? value : undefined;\n    };\n\n    const getFormState = (\n      el: FormElement\n    ): [input: FormElement, state: FormState] | undefined => {\n      const formElement = el.form;\n      if (!formElement) return; // Don't care if we started with an element that didn't map to a field.\n\n      const refName =\n        scopeAttribute(formElement, trackerPropertyName(\"ref\")) || \"track_ref\";\n\n      const parseElements = () => {\n        map(\n          formElement.querySelectorAll(\n            \"INPUT,SELECT,TEXTAREA\"\n          ) as any as Iterable<FormElement>,\n          (el, i) => {\n            if (!el.name || el.type === \"hidden\") {\n              if (\n                el.type === \"hidden\" &&\n                (el.name === refName || trackerFlag(el, \"ref\"))\n              ) {\n                !el.value && (el.value = uuidv4());\n                state[0].ref = el.value;\n              }\n              return;\n            }\n            const name = el.name;\n            const field = (state[0].fields![name] ??= {\n              id: el.id || name,\n              name,\n              label: replace(\n                el.labels?.[0]?.innerText ?? el.name,\n                /^\\s*(.*?)\\s*\\*?\\s*$/g,\n                \"$1\"\n              ),\n              activeTime: 0,\n              totalTime: 0,\n              type: el.type ?? \"unknown\",\n              [currentValue as any]: getFormFieldValue(el),\n              value: getFormFieldValue(el, true),\n            }) as FormFieldState;\n\n            state[0].fields![field.name] = field;\n            state[1].set(el, field);\n          }\n        );\n      };\n\n      let capturedContext: ReturnType<typeof getComponentContext>;\n\n      const isFormVisible = () =>\n        formElement.isConnected && getRect(formElement).width;\n\n      const state = get(formEvents, formElement, () => {\n        const fieldMap = new Map<Element, FormFieldState>();\n        const ev: FormEvent = {\n          type: \"form\",\n          name:\n            scopeAttribute(formElement, trackerPropertyName(\"form-name\")) ||\n            attr(formElement, \"name\") ||\n            formElement.id ||\n            undefined,\n          activeTime: 0,\n          totalTime: 0,\n          fields: {},\n        };\n\n        tracker.events.post(ev);\n\n        tracker.events.registerEventPatchSource(\n          ev,\n          () => ({ ...ev, timeOffset: getViewTimeOffset() } as any)\n        );\n\n        let state: FormState;\n        const commitEvent = () => {\n          handleLostFocus(); // focusout or change events may not be called when the user leaves the page while a field has focus.\n\n          // If the form has disappeared it is heuristically assumed it was submitted successfully.\n          state[3] >= FormFillState.Pending &&\n            (ev.completed =\n              state[3] === FormFillState.Submitting || !isFormVisible());\n          tracker.events.postPatch(ev, {\n            ...capturedContext,\n            totalTime: now(T) - state[4],\n          });\n\n          state[3] = FormFillState.Submitted;\n        };\n\n        const commitTimeout = createTimeout();\n\n        listen(formElement, \"submit\", () => {\n          capturedContext = getComponentContext(formElement);\n          state[3] = FormFillState.Submitting;\n\n          commitTimeout(() => {\n            // If the form disappears within 750 ms but no navigation happens it is assumed that it was \"submitted\" somehow, e.g. via AJAX.\n            // This heuristic may result in false positives if the user clicks submit, gets validation errors and then leaves the site instantly.\n            //\n            // If the server is aggressively slow to respond to a post and the for goes back into pending state,\n            // it is undefined whether the submit happened or not, if the user leaves the site before the server responds.\n            // In this case it will count as abandonment.\n\n            if (formElement.isConnected && getRect(formElement).width > 0) {\n              state[3] = FormFillState.Pending;\n              commitTimeout();\n            } else {\n              commitEvent();\n            }\n          }, 750);\n        });\n\n        return (state = [\n          ev,\n          fieldMap,\n          formElement,\n          FormFillState.None,\n          now(T),\n          1,\n        ]);\n      });\n      if (!get(state[1], el)) {\n        // This will also be the case if a new field was added to the DOM.\n        parseElements();\n      }\n      return [el!, state];\n    };\n\n    const getFieldInfo = (\n      el: NodeWithParentElement,\n      [formElement, state] = getFormState(el as any) ?? [],\n      field = state?.[1].get(formElement as Element)\n    ) => field && ([state![0], field, formElement!, state!] as const);\n\n    let currentField: ReturnType<typeof getFieldInfo> | null = nil;\n    const handleLostFocus = () => {\n      if (!currentField) return;\n\n      const [form, field, el, state] = currentField;\n      const active = -(tv0 - (tv0 = getVisibleDuration()));\n      const total = -(t0 - (t0 = now(T)));\n\n      const previousValue = field[currentValue];\n      const newValue = (field[currentValue] = getFormFieldValue(el));\n\n      if (newValue !== previousValue) {\n        field.fillOrder ??= state[5]++;\n        if (field.filled) {\n          field.corrections = (field.corrections ?? 0) + 1;\n        }\n        field.filled = T;\n\n        state[3] = FormFillState.Pending;\n        forEach(\n          form.fields!,\n          ([name, value]) => (value.lastField = name === field.name)\n        );\n      }\n      field.value = getFormFieldValue(el, true);\n\n      field.activeTime! += active;\n      field.totalTime! += total;\n      form.activeTime! += active;\n      form.totalTime! += total;\n      currentField = nil;\n    };\n\n    let tv0 = 0;\n    let t0 = 0;\n    const wireFormFields = (document: Document | Nullish) =>\n      document &&\n      listen(\n        document,\n        [\"focusin\", \"focusout\", \"change\"],\n        (ev, _, current = ev.target && getFieldInfo(ev.target)) =>\n          current &&\n          ((currentField = current),\n          ev.type === \"focusin\"\n            ? ((t0 = now(T)), (tv0 = getVisibleDuration()))\n            : handleLostFocus())\n      );\n\n    wireFormFields(document);\n    onFrame(\n      (frame) => frame.contentDocument && wireFormFields(frame.contentDocument),\n      true\n    );\n  },\n};\n","import { CONSENT_INFO_KEY } from \"@constants\";\r\n\r\nimport {\r\n  ConsentEvent,\r\n  DataUsageAttributes,\r\n  ParsableDataUsageAttributes,\r\n  UserConsent,\r\n  dataClassification,\r\n  dataPurposes,\r\n  dataUsageEquals,\r\n  parseDataUsage,\r\n} from \"@tailjs/types\";\r\nimport { Clock, F, Nullish, T, clock, restrict } from \"@tailjs/util\";\r\nimport {\r\n  ConsentCommand,\r\n  TrackerExtensionFactory,\r\n  isUpdateConsentCommand,\r\n} from \"..\";\r\nimport { debug, document } from \"../lib\";\r\n\r\nexport const consent: TrackerExtensionFactory = {\r\n  id: \"consent\",\r\n  setup(tracker) {\r\n    const getCurrentConsent = async (result?: any) =>\r\n      (await tracker.variables.get({\r\n        scope: \"session\",\r\n        key: CONSENT_INFO_KEY,\r\n        result,\r\n      }).value) as UserConsent | undefined;\r\n\r\n    const updateConsent = async <\r\n      C extends ParsableDataUsageAttributes | Nullish\r\n    >(\r\n      consent: C\r\n    ): Promise<\r\n      C extends Nullish\r\n        ? undefined\r\n        : [updated: boolean, current: UserConsent | undefined]\r\n    > => {\r\n      if (!consent) return undefined as any;\r\n\r\n      let current = await getCurrentConsent();\r\n      if (\r\n        !current ||\r\n        dataUsageEquals(current, (consent = parseDataUsage(consent) as any))\r\n      ) {\r\n        return [false, current] as any;\r\n      }\r\n\r\n      const userConsent = {\r\n        level: dataClassification.lookup(consent!.classification)!,\r\n        purposes: dataPurposes.lookup(consent!.purposes)!,\r\n      };\r\n      const result = await tracker.events.post(\r\n        restrict<ConsentEvent>({\r\n          type: \"consent\",\r\n          consent: userConsent,\r\n        }),\r\n        {\r\n          async: false,\r\n          variables: {\r\n            get: [{ scope: \"session\", key: CONSENT_INFO_KEY }],\r\n          },\r\n        }\r\n      );\r\n      return [true, userConsent] as any;\r\n    };\r\n\r\n    const externalSources: Record<string, Clock> = {};\r\n\r\n    return {\r\n      processCommand(command) {\r\n        if (isUpdateConsentCommand(command)) {\r\n          const getter = command.consent.get;\r\n          if (getter) {\r\n            getCurrentConsent(getter);\r\n          }\r\n\r\n          const setter = parseDataUsage(command.consent.set);\r\n          setter &&\r\n            (async () => setter.callback?.(...(await updateConsent(setter))))();\r\n\r\n          const externalSource = command.consent.externalSource;\r\n          if (externalSource) {\r\n            const key = externalSource.key;\r\n            const poller = (externalSources[key] ??= clock({\r\n              frequency: externalSource.pollFrequency ?? 1000,\r\n            }));\r\n            let previousConsent: DataUsageAttributes | undefined;\r\n\r\n            const pollConsent = async () => {\r\n              if (!document.hasFocus()) return;\r\n\r\n              const externalConsent = externalSource.poll();\r\n\r\n              if (!externalConsent) return;\r\n\r\n              const consent = parseDataUsage({\r\n                ...previousConsent,\r\n                ...externalConsent,\r\n              });\r\n              if (consent && !dataUsageEquals(previousConsent, consent)) {\r\n                const [updated, current] = await updateConsent(consent);\r\n                if (updated) {\r\n                  debug(current, \"Consent was updated from \" + key);\r\n                }\r\n                previousConsent = consent;\r\n              }\r\n            };\r\n            poller.restart(externalSource.pollFrequency, pollConsent).trigger();\r\n          }\r\n\r\n          return T;\r\n        }\r\n        return F;\r\n      },\r\n    };\r\n  },\r\n};\r\n(() => {\r\n  // Map CookieBot to tail.js purposes.\r\n  const purposeMappings = {\r\n    necessary: 1,\r\n    preferences: 2,\r\n    statistics: 4,\r\n    marketing: 8,\r\n  };\r\n\r\n  (window as any).tail({\r\n    consent: {\r\n      externalSource: {\r\n        key: \"Cookiebot\",\r\n        poll: () => {\r\n          const consentCookie = document.cookie.match(\r\n            /CookieConsent=([^;]*)/\r\n          )?.[1];\r\n          if (!consentCookie) return;\r\n\r\n          let mappedPurpose = 1;\r\n          consentCookie?.replace(\r\n            /([a-z]+):(true|false)/g,\r\n            (_, category, toggled) => (\r\n              toggled === \"true\" &&\r\n                (mappedPurpose |= purposeMappings[category] ?? 0),\r\n              \"\"\r\n            )\r\n          );\r\n\r\n          return {\r\n            level:\r\n              mappedPurpose > 1\r\n                ? 1 /* Indirect (using cookies). */\r\n                : 0 /* Anonymous (cookie-less). */,\r\n            purposes: mappedPurpose,\r\n          };\r\n        },\r\n      },\r\n    },\r\n  } as ConsentCommand);\r\n})();\r\n","import {\n  TrackerExtensionFactory,\n  commerce,\n  components,\n  context,\n  forms,\n  scroll,\n  userInteraction,\n  consent,\n} from \"..\";\n\nexport const defaultExtensions: TrackerExtensionFactory[] = [\n  context,\n  components,\n  userInteraction,\n  scroll,\n  commerce,\n  forms,\n  consent,\n];\n","import type { Component, ExternalReference } from \"@tailjs/types\";\nimport type { BoundaryCommand } from \"..\";\nimport { T, add, get, map, nil, push, split, toString } from \"@tailjs/util\";\nimport { attr } from \".\";\n\ntype MappedComponent = [\n  command: {\n    component?: Component;\n    content?: ExternalReference;\n    area?: string;\n  },\n  elements: HTMLElement[]\n];\nexport function scanAttributes(\n  attributeName: string,\n  references: MappedComponent[0][]\n): BoundaryCommand[] {\n  if (!references) return [];\n  const commands: BoundaryCommand[] = [];\n\n  const seen = new Set<any>();\n  document.querySelectorAll(`[${attributeName}]`).forEach((el) => {\n    if (get(seen, el)) {\n      return;\n    }\n\n    const stack: any[] = [];\n\n    while (attr(el, attributeName) != nil) {\n      add(seen, el);\n      const delta = split(attr(el, attributeName)!, \"|\");\n      attr(el, attributeName, nil);\n      for (let i = 0; i < delta.length; i++) {\n        let item: any = delta[i];\n        if (item === \"\") {\n          continue; // If the attribute starts with \"|\" it means \"keep stack\". Splitting the array on \"|\" will give an empty item.\n        }\n        const number = item === \"-\" ? -1 : parseInt(toString(item) ?? \"\", 36);\n        if (number < 0) {\n          stack.length += number;\n          continue;\n        } else if (i === 0) {\n          stack.length = 0; // The first item has an value to replace the stack since not preceded by neither \"|\" nor an negative number (pop).\n        }\n\n        if (isNaN(number) && /^[\"\\[{]/.test(item)) {\n          // Poor man's parser. If the JSON contains '|'s keep going until it works.\n          let json = \"\";\n          for (; i < delta.length; i++) {\n            try {\n              item = JSON.parse((json += delta[i]));\n              break;\n            } catch (e) {}\n          }\n        }\n\n        if (number >= 0 && references[number]) {\n          item = references[number];\n        }\n        push(stack, item);\n      }\n      push(\n        commands,\n        ...map(stack, (data) => ({ add: T, ...data, boundary: el }))\n      );\n      const next = el.nextElementSibling!; // Ignore TS null error.\n      if (el.tagName === \"WBR\") {\n        el.parentNode?.removeChild(el);\n      }\n      el = next;\n    }\n  });\n\n  return commands;\n}\n","import { ScrollEvent } from \"@tailjs/types\";\nimport { T, defer, map, push, restrict } from \"@tailjs/util\";\nimport { addViewChangedListener, type TrackerExtensionFactory } from \"..\";\nimport { listen, relativeScrollPos, scrollPos } from \"../lib\";\n\nexport const scroll: TrackerExtensionFactory = {\n  id: \"scroll\",\n  setup(tracker) {\n    let emitted: Partial<Record<Required<ScrollEvent>[\"scrollType\"], boolean>> =\n      {};\n    let initialScroll = scrollPos(T);\n\n    addViewChangedListener(() =>\n      defer(() => ((emitted = {}), (initialScroll = scrollPos(T))), 250)\n    );\n\n    listen(window, \"scroll\", () => {\n      const scroll = scrollPos();\n      const offset = relativeScrollPos();\n\n      if (scroll.y >= initialScroll.y) {\n        const types: (keyof typeof emitted)[] = [];\n\n        !emitted[\"fold\"] &&\n          scroll.y >= initialScroll.y + 200 &&\n          ((emitted[\"fold\"] = T), push(types, \"fold\"));\n\n        !emitted[\"page-middle\"] &&\n          offset.y >= 0.5 &&\n          ((emitted[\"page-middle\"] = T), push(types, \"page-middle\"));\n\n        !emitted[\"page-end\"] &&\n          offset.y >= 0.99 &&\n          ((emitted[\"page-end\"] = T), push(types, \"page-end\"));\n\n        const mapped = map(types, (scrollType) =>\n          restrict<ScrollEvent>({\n            type: \"scroll\",\n            scrollType,\n            offset,\n          })\n        );\n\n        mapped.length && tracker(mapped);\n      }\n    });\n  },\n};\n","export const commandTest =\n  <T = any>(...name: any[]) =>\n  (command: any): command is T =>\n    command === name[0] ||\n    name.some(\n      (name) => typeof name === \"string\" && command?.[name] !== undefined\n    );\n","import { CartEventData } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Triggers events related to a shopping cart.\n */\nexport interface CartCommand {\n  cart: \"clear\" | CartEventData;\n}\n\nexport const isCartCommand = commandTest<CartCommand>(\"cart\");\n","import type { Nullish } from \"@tailjs/util\";\nimport { commandTest } from \"./shared\";\n\nexport interface ChangeUserCommand {\n  username: string | Nullish;\n}\n\nexport const isChangeUserCommand = commandTest<ChangeUserCommand>(\"username\");\n","import type { TagMappings } from \"..\";\nimport { commandTest } from \"./shared\";\n\nexport type TagAttributesCommand = {\n  tagAttributes: TagMappings;\n};\nexport const isTagAttributesCommand =\n  commandTest<TagAttributesCommand>(\"tagAttributes\");\n","import { commandTest } from \"./shared\";\n\n/**\n * Enables or disables tracking.\n */\nexport type ToggleCommand = {\n  disable: boolean;\n};\nexport const isToggleCommand = commandTest<ToggleCommand>(\"disable\");\n","import type {\n  CartAction,\n  CartEventData,\n  ConfiguredComponent,\n  Content,\n  ParsableTags,\n  Tag,\n  TrackingSettings,\n} from \"@tailjs/types\";\n\nimport { commandTest } from \"./shared\";\nimport { MaybeArray, Nullish } from \"@tailjs/util\";\n\nexport interface BoundaryData<RequireArrays = false> {\n  /**\n   * The component definition(s) associated with the boundary element.\n   */\n  component?: MaybeArray<ConfiguredComponent, true, RequireArrays> | null;\n\n  /**\n   * The content definition(s) associated with the boundary element.\n   */\n  content?: MaybeArray<Content, true, RequireArrays> | null;\n\n  /**\n   * The name of the content area associated with the boundary element.\n   *\n   * A content area is used to indicate where activated components are used.\n   */\n  area?: string | null;\n\n  /**\n   *  These tags will be added to the components and content in user activations with the boundary element or any of its descendants.\n   */\n  tags?: RequireArrays extends true ? Tag[] : ParsableTags;\n\n  /**\n   * The element will include cart data when activated.\n   */\n  cart?: CartAction | CartEventData;\n\n  /**\n   * Settings that will apply to components contained by the boundary element including itself, similar to specifying \"track-*\" HMTL attributes on the element.\n   */\n  track?: TrackingSettings;\n}\n\n/**\n * Registers an element as the boundary for a component or similar tracking data. All events triggered from the element or its descendants will have this information attached.\n * In case of nested boundaries the closest one is used.\n */\nexport type BoundaryCommand = {\n  boundary: Element;\n} & (\n  | (BoundaryData & {\n      /**\n       * The content, tags and components will be added to the existing, if any.\n       */\n      add?: boolean;\n    })\n  | { update: (current?: BoundaryData<true>) => BoundaryData | Nullish }\n);\n\n// {\n//   /**\n//    * The component definition(s) associated with the boundary element.\n//    */\n//   component?: ConfiguredComponent | ConfiguredComponent[] | null;\n\n//   /**\n//    * The content definition(s) associated with the boundary element.\n//    */\n//   content?: Content | Content[] | null;\n\n//   /**\n//    * The name of the content area associated with the boundary element.\n//    *\n//    * A content area is used to indicate where activated components are used.\n//    */\n//   area?: string | string[] | null;\n\n//   /**\n//    *  These tags will be added to the components and content in user activations with the boundary element or any of its descendants.\n//    */\n//   tags?: Tag | Tag[] | null;\n\n//   /**\n//    * The element will include cart data when activated.\n//    */\n//   cart?: CartAction | CartEventData;\n\n//   /**\n//    * The element's component will be included in the stack even when the activation tracking level is `direct`.\n//    */\n//   promote?: boolean;\n\n//   /**\n//    * Specifies how the this command modifies the data associated with the boundary element.\n//    *\n//    * Only properties present in this command are affected (e.g. `component` or `content`) unless the action is `clear`.\n//    *\n//    * @default \"add\"\n//    */\n//   action?: \"add\" | \"remove\" | \"clear\";\n\n//   /**\n//    * The DOM element that gets this command's data associated.\n//    */\n//   boundary: Element;\n// }\n\nexport const isDataBoundaryCommand = commandTest<BoundaryCommand>(\"boundary\");\n","import type { TrackerExtensionFactory } from \"..\";\nimport { commandTest } from \"./shared\";\n\nexport interface ExtensionCommand {\n  extension: TrackerExtensionFactory;\n  priority?: number;\n}\nexport const isExtensionCommand = commandTest<ExtensionCommand>(\"extension\");\n","import { T } from \"@tailjs/util\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Causes all queued events to be posted to the server immediately.\n */\nexport type FlushCommand = { flush: boolean; force?: boolean; defer?: boolean };\nexport const isFlushCommand = commandTest<FlushCommand>(T, \"flush\");\n","import { MaybeArray, PickRequired } from \"@tailjs/util\";\nimport { ClientVariableGetter } from \"../lib\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Used to get variables (data) from the backend.\n */\nexport interface GetCommand {\n  get: MaybeArray<PickRequired<ClientVariableGetter, \"result\">, true>;\n}\n\nexport const isGetCommand = commandTest<GetCommand>(\"get\");\n","import type { Listener } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Registers a listener that will be invoked before and after events are flushed.\n * Useful for debugging or client-side integration with other tracker libraries (if one absolutely must).\n */\nexport interface ListenerCommand {\n  listener: Listener;\n}\nexport const isListenerCommand = commandTest<ListenerCommand>(\"listener\");\n","import { Order, OrderEvent } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Shorthand command to trigger an {@link OrderEvent} event.\n */\nexport interface OrderCommand {\n  /**\n   * The order that was completed or cancelled.\n   */\n  order: Order;\n}\n\nexport const isOrderCommand = commandTest<OrderCommand>(\"order\");\n","import type { Component, ExternalReference } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\nexport type ComponentOrContent =\n  | { component: Component }\n  | { content: ExternalReference };\n\n/**\n * Registers an element as the boundary for a component. All events triggered from the element or its descendants will have this information attached.\n * In case of nested boundaries the closest one is used.\n */\nexport interface ScanComponentsCommand {\n  scan: {\n    attribute: string;\n    components: ComponentOrContent[];\n  };\n}\n\nexport const isScanComponentsCommand =\n  commandTest<ScanComponentsCommand>(\"scan\");\n","import { MaybeArray } from \"@tailjs/util\";\nimport { ClientVariableSetter } from \"../lib\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Used to set variables (data) in the backend.\n */\nexport interface SetCommand {\n  /** An object where the names of the properties correspond to the variables set in the tracker. */\n  set: MaybeArray<ClientVariableSetter<any, string>>;\n}\n\nexport const isSetCommand = commandTest<SetCommand>(\"set\");\n","import type { Tracker, TrackerCommand } from \"..\";\n\nexport type UseTrackerCommand = (tracker: Tracker) => void;\nexport const isTrackerAvailableCommand = (\n  command: TrackerCommand\n): command is (tracker: Tracker) => void => typeof command === \"function\";\n","import { ParsableDataUsageAttributes, UserConsent } from \"@tailjs/types\";\r\nimport { commandTest } from \"./shared\";\r\n\r\nexport type ExternalConsentPoller = () =>\r\n  | ParsableDataUsageAttributes\r\n  | undefined;\r\n\r\n/** Gets or updates the user's consent. */\r\nexport interface ConsentCommand {\r\n  /**\r\n   * If a function, it will be invoked as a callback with the users current consent preferences.\r\n   * Otherwise it will update the user's consent with the values provided.\r\n   */\r\n  consent: {\r\n    get?: (\r\n      value: UserConsent | undefined,\r\n      previous: UserConsent | undefined,\r\n      poll: () => void\r\n    ) => void;\r\n    set?: ParsableDataUsageAttributes & {\r\n      callback?: (updated: boolean, current: UserConsent | undefined) => void;\r\n    };\r\n    /**\r\n     * This can be used to poll the client's browser environment for something that translates into a tail.js consent.\r\n     * The primary use case is to integrate with a CMP (e.g. Cookiebot).\r\n     *\r\n     * Please provide a unique key for the poll function to avoid unintended double polling if for some reason\r\n     * the command is unintentionally submitted more than once.\r\n     */\r\n    externalSource?: {\r\n      key: string;\r\n      poll: ExternalConsentPoller;\r\n      /** @default 1000 */\r\n      pollFrequency?: number;\r\n    };\r\n  };\r\n}\r\n\r\nexport const isUpdateConsentCommand = commandTest<ConsentCommand>(\"consent\");\r\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\n\nimport { initializeTracker } from \".\";\nimport { window } from \"./lib\";\n\n// This assumes the script is loaded from the RequestHandler's ?init route.\n\n// To prevent external scripts from eavesdropping by getting a hold of the encryption key, this is how initialization works:\n// 1: The configuration script appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overridden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nObject.defineProperty(window, INITIALIZE_TRACKER_FUNCTION, {\n  writable: false,\n  configurable: false,\n  value: (callback: any) => {\n    callback(initializeTracker);\n  },\n});\n"],"names":["matchProjection","collected","pos","screenPos","x","y","rect","metadata","key","current","cachedMappings","currentBoundaryData","propertyValue","_defaultTransports","tracker","currentViewEvent","pushPopNavigation","entry","content","throwError","error","transform","e","Error","message","isString","unwrap","structuralEquals","value1","value2","depth","isObject","length","n","Object","keys","equalsAny","target","singleValue","otherValues","some","t","value","required","TypeError","text","replace","tryCatch","expression","errorHandler","always","isFunction","isError","isBoolean","console","deferred","result","getter","r","initialized","then","resolved","resolvedValue","tryCatchAsync","async","await","isArray","restrict","item","undefined","MAX_SAFE_INTEGER","Number","F","T","NOOP","IDENTITY","FILTER_NULLISH","symbolIterator","Symbol","iterator","createTypeConverter","typeTester","parser","parse","ifDefined","resultOrProperty","parseBoolean","isTruish","isInteger","isSafeInteger","isNumber","toString","Array","array","clone","isIterable","objectPrototype","prototype","getPrototypeOf","isPlainObject","hasMethod","name","isSymbol","acceptStrings","isMap","Map","isSet","Set","round","number","decimals","Math","pow","stopInvoked","stop","yieldValue","wrapProjection","projection","sliceAction","action","start","end","index","filterArray","filter","createIterator","source","i","createObjectIterator","createNavigatingIterator","step","maxIterations","yield","createRangeIterator","offset","project","flatten","expandObjects","flattenInternal","nested","map","mapped","push","flatMap","concat","items","merged","forEach","apply","args","forEachInternal","returnValue","fromEntries","obj","selector","merge","predicate","projected","count","size","max","reducer","seed","seedFactory","sort","rank","lhs","rhs","setSingle","constructor","delete","set","add","get","init","has","values","createSetOrUpdateFunction","setter","assign","update","WeakSet","clearSingle","remove","splice","pick","arg","entries","k","v","unshift","diff","updated","previous","patchedValue","patched","delta","now","performance","trunc","timeOrigin","Date","createTimer","started","timeReference","capturedElapsed","t0","elapsed","toggle","reset","clock","callbackOrSettings","frequency","settings","callback","queue","paused","trigger","once","raf","timeoutId","mutex","ResettablePromise","resolve","timer","outerCallback","skipQueue","pending","instance","busy","updateTimeout","setTimeout","requestAnimationFrame","timeoutCallback","active","resetTimer","clearTimeout","restart","newFrequency","newCallback","_promise","this","ifPending","reject","OpenPromise","signal","onfulfilled","onrejected","captured","Promise","inner","ansiSupported","delay","ms","isFinite","createEventBinders","listener","attach","detach","bound","outerListener","unbind","rebind","createEvent","dispatchedArgs","listeners","handler","binders","payload","enumerate","separator","slice","join","pluralize","singular","plural","ansi","ps","buffer","ellipsis","maxLength","sep","getTextStats","isBit","log2","createEnumAccessor","sourceEnum","flags","enumName","pureFlags","carry","carry2","originalValue","names","toLowerCase","any","reduce","flag","nameLookup","none","valueLookup","parseValue","validateNumbers","parseInt","invalid","tryParse","lookup","format","JSON","stringify","pure","defaults","properties","defineProperty","configurable","enumerable","writable","define","logFormat","c","createEnumPropertyParser","props","parsers","sourceItem","prop","parsed","parameterList","parseKeyValue","arrayDelimiters","decode","parts","split","decodeURIComponent","trim","replaceAll","mapFirst","delim","_","parseUri","uri","query","requireAuthority","match","scheme","slashes","authority","user","password","bracketHost","host","port","path","queryString","fragment","urn","parseQueryString","parseParameters","list","results","part","kv","s","regex","collect","escapeRegEx","input","REGEX_NEVER","unionOrNever","joined","distinct","RegExp","stringRuleCache","isRegEx","parseRegex","separators","replaceValue","createIntervals","cmp","width","interval","ranges","changed","finalize","sum","NOT_INITIALIZED","win","window","doc","document","body","MAX_ANCESTOR_DISTANCE","chrome","forAncestorsOrSelf","el","stoppingCriterion","distance","nodeType","prev","parentElement","ownerDocument","defaultView","frameElement","parseAttributeValue","type","parseFloat","httpDecode","httpDecrypt","attr","node","getAttribute","scopeAttribute","normalizedAttribute","cssProperty","getComputedStyle","getPropertyValue","tagName","relativeScrollPos","scrollPos","offsetWidth","innerWidth","offsetHeight","innerHeight","scrollX","int","scrollY","matchExHash","href1","href2","getScreenPos","mouseEvent","includeFold","getPos","xpx","ypx","pageFolds","pointerType","pageY","pageX","getRect","getBoundingClientRect","left","top","height","listen","options","capture","passive","addEventListener","removeEventListener","getViewport","totalWidth","totalHeight","dataClassification","DataClassification","Anonymous","Indirect","Direct","Sensitive","dataUsageEquals","classification","level","dataPurposes","purposes","parseDataUsage","classificationOrConsent","purpose","DataPurposeFlags","Necessary","None","Functionality","Performance","Targeting","Security","Infrastructure","Any_Anonymous","Any","Server","Server_Write","singleDataPurpose","clearMetadata","event","client","posted","queued","isEventPatch","patchTargetId","variableScope","VariableScope","Global","Entity","Session","Device","User","VariableEnumProperties","scope","sortVariables","variables","localeCompare","toVariableResultPromise","VariablePatchType","VariableResultStatus","getResults","errorHandlers","unwrappedResults","mapResults","property","handleResultErrors","promise","onfullfilled","all","status","getResultVariable","variable","isSuccessResult","requireValue","errorMessage","errors","successResults","version","isTrackedEvent","ev","isViewEvent","types","typeTest","maybeDecode","test","tag","score","collectTags","tagString","prefix","ns","localName","quoted1","quoted2","unquoted","boundaryData","WeakMap","getBoundaryData","trackerPropertyName","css","matchAttributeNames","cached","tags","eligible","getAttributeNames","matches","toggleAnsi","cachedTagMapper","parseTagAttributes","trackerConfig","rule","cache","cssPropertyWithBase","parsedCssRules","parseCssMappingRules","rulesString","rule1","rule2","trackerProperty","inherit","trackerFlag","parseTags","sourceEl","elementTagData","src","disabled","postEvents","postFrequency","requestTimeout","encryptionKey","apiKey","impressionThreshold","captureContextMenu","defaultActivationTracking","default","codes","chars","charCode","charCodeAt","to64u","p","bytes","chunk","base64","String","fromCharCode","FNVs","32","64","128","entropy","random","deserialize","msgDeserialize","serialize","msgSerialize","data","multiple","floatBuffer","floatView","Uint8Array","append","subarray","isReplacement","appendByte","lo","appendBytes","hi","appendInt64","DataView","ArrayBuffer","setFloat64","str","ascii","ci","c2","sec","getTime","getMilliseconds","appendArray","Uint8ClampedArray","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","appendObject","invalidTypeReplacement","byte","newLength","newArray","abs","read","readMap","readArray","readStr","readBin","readExt","readFloat","readUInt","readInt","debug","first","view","byteOffset","getFloat32","getFloat64","lengthSize","decodeUtf8","msgpack","encode","exports","REF_PROP","includeValue","includeDefaultValues","defaultValues","prettify","cleaners","refs","refIndex","patchProperty","addCleaner","cleaner","toJSON","matchedRef","eg","createTransport","factory","json","serializeOptions","encrypt","decrypt","hash","fastStringHash","bitsOrNumeric","encoded","numericOrBits","j","pad","bits","prime","mixer","mixer255","iw","mixer0","window0","resetMixer","updateMixer","ENTROPY","cipher","BigInt","asUintN","MIN_SAFE_INTEGER","binary","jsonEncode","currentScript","SCRIPT_SRC","TRACKER_DOMAIN","isInternalUrl","url","endsWith","mapUrl","urlParts","VAR_URL","MNT_URL","groupValue","childGroups","group","collapsed","groupCollapsed","children","log","groupEnd","httpEncode","httpEncrypt","addEncryptionNegotiatedListener","dispatchEncryptionNegotiated","logError","shift","id","addPageLoadedListener","dispatchPageLoaded","addPageVisibleListener","dispatchPageVisible","maybeDispatchPageLoaded","loaded","newLoaded","sleepTimer","maybeDispatchPageVisible","visible","visibilityState","visibleTimer","activated","activeTime","dispatchPageActivated","activationTimeout","setActivated","getActiveTime","localVariableScope","LocalVariableScope","View","Tab","Shared","formatAnyVariableScope","isLocalScopeKey","toNumericVariableEnums","variableKeyToString","targetId","stringToVariableKey","localId","TAB_ID","nextId","nextLocalId","tabVariables","tabState","heartbeat","state","knownTabs","addStateListener","dispatchState","addVariablesChangedListener","dispatchVariablesChanged","post","tryGetVariable","setLocalVariables","updateVariableState","getVariableChanges","changes","updates","changedEventData","sharedChanges","dispatchRequest","localState","sessionStorage","getItem","CLIENT_STORAGE_PREFIX","CLIENT_STATE_CHANNEL_ID","removeItem","padStart","setItem","localStorage","newValue","sender","initTimeout","timeout","HEARTBEAT_FREQUENCY","tabId","removed","clearStep","parent","parentKey","targetKeys","clear","loading","addResponseHandler","dispatchResponse","requestLock","retries","defaultRetries","lockId","intervalId","renew","localTimeout","setInterval","clearInterval","waitHandle","race","request","beacon","currentData","serialized","cancel","prepareRequestData","prepareResult","retry","newData","forEachAsync","response","fetch","method","credentials","mode","headers","Content-Type","warn","arrayBuffer","navigator","sendBeacon","Blob","KEY_PROPS","VARIABLE_PROPS","GETTER_PROPS","SETTER_PROPS","activeCallbacks","createVariableStorage","endpoint","context","pollVariables","getters","callbacks","vars","VARIABLE_POLL_FREQUENCY","registerCallbacks","mappedKey","invokeCallbacks","cacheDurations","stateDuration","poll","updateCacheDuration","duration","validateKey","requestGetters","sourceIndex","newLocal","refresh","Success","local","Created","setResultExpiration","Denied","deviceSessionId","setters","localResults","requestVariables","patch","force","timestamp","intersectionHandler","IMPRESSION_START","IMPRESSION_STOP","detectDeviceType","h","landscape","angle","screen","w","orientation","o","deviceType","dpr","devicePixelRatio","postUserAgentEvent","hasTouch","maxTouchPoints","userAgent","clientId","languages","language","region","primary","preference","timezone","iana","Intl","DateTimeFormat","resolvedOptions","timeZone","getTimezoneOffset","isLinkElement","href","startsWith","isClickable","getElementInfo","includeRect","innerText","initializeTracker","config","clientEncryptionKey","extensions","callListeners","pendingStateCommands","trackerContext","events","mainArgs","currentArg","insertArgs","globalStateResolved","apiProtectionKey","queuedCommands","keep","unsubscribe","applyEventExtensions","skip","extension","decorate","throwIfInvalid","snapshots","sources","mapPatchTarget","sourceEvent","flush","unloading","updatedEvents","unbinding","postPatch","registerEventPatchSource","initialPost","relatedNode","isConnected","snapshot","commands","command","isTagAttributesCommand","tagAttributes","isToggleCommand","disable","isFlushCommand","isTrackerAvailableCommand","isListenerCommand","isExtensionCommand","expanded","cmd","isSetCommand","isGetCommand","setup","priority","success","processCommand","freeze","__isTracker","_1","_2","session","hasUserAgent","defaultExtensions","getCurrentViewId","referrerKey","pushNavigationSource","navigationEventId","consumed","totalDuration","visibleDuration","activations","addViewChangedListener","dispatchViewChanged","createViewDurationTimer","totalTime","visibleTime","activationsCounter","getViewTimeOffset","addFrameListenerInternal","callOnFrame","onFrame","triggerCurrent","frames","frame","knownFrames","getElementsByTagName","parseCartEventData","normalizeCartEventData","units","hasComponentOrContent","boundary","component","parseBoundaryTags","ancestor","stripRects","getComponentContext","directOnly","includeRegion","areaPath","components","collectedContent","includeState","area","track","secondary","promote","currentValue","purposeMappings","necessary","preferences","statistics","marketing","tail","consent","externalSource","mappedPurpose","consentCookie","cookie","category","toggled","definition","pendingViewDefinition","viewIndex","tabIndex","currentLocation","tabs","postView","qs","referrer","location","tab","pathname","domain","tabNumber","tabViewNumber","viewport","firstTab","landingPage","utm","navigationType","getEntriesByType","redirects","redirectCount","relatedEventId","externalReferrer","history","isChangeUserCommand","username","impressions","observer","IntersectionObserver","els","currentIntersections","constrain","point","min","probeRange","createRange","regions","impressionEvents","unbindPassiveEventSources","boundaries","stats","pendingActive","visiblePercentage","updateRegion","viewDuration","prevHeight","inferred","bottom","readTime","viewWidth","viewHeight","intersection","right","intersectionHeight","intersectionWidth","verticalIntersection","horizontalIntersection","thresholds","qualified","timeOffset","middle","seen","textContent","prevIndex","charMatcher","words","longWords","sentences","hasWord","exec","limits","wordsBefore","inSentence","wasBoundary","MINUTE","SECOND","characters","lix","nodes","createTreeWalker","NodeFilter","SHOW_TEXT","boundaryIndex","nextNode","nodeLength","horizontalOffset","verticalOffset","intersectionTop","intersectionBottom","isIntersecting","observe","normalizeBoundaryData","registerComponent","cart","eventData","isDataBoundaryCommand","isScanComponentsCommand","attributeName","references","querySelectorAll","a","stack","isNaN","next","nextElementSibling","parentNode","removeChild","scan","attribute","activeEventClicks","trackDocument","trackClicks","trackRegion","clickableElement","containerElement","clickables","nav","button","clickable","child","childComponents","clicks","contextCart","clickIntent","componentContext","sharedEventProperties","container","info","element","external","hostname","link","search","anchor","originalUrl","requestId","navigationEvent","self","ctrlKey","shiftKey","altKey","exit","internalUrl","substring","encodeURIComponent","last","intentEvent","contentDocument","emitted","initialScroll","defer","f","scroll","fold","scrollType","isCartCommand","a8","order","formEvents","getFormFieldValue","tracked","include","selectedOptions","option","checked","getFormState","capturedContext","refName","formElement","form","fieldMap","fields","commitTimeout","defaultTimeout","handle","currentCallback","stickyTimeout","createTimeout","handleLostFocus","completed","field","label","labels","crypto","getRandomValues","ref","getFieldInfo","currentField","total","previousValue","tv0","fillOrder","filled","corrections","lastField","wireFormFields","getCurrentConsent","updateConsent","userConsent","externalSources","previousConsent","isUpdateConsentCommand","pollFrequency","pollConsent","hasFocus","externalConsent","commandTest","isOrderCommand"],"mappings":"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","x_google_ignoreList":[35]}