{"version":3,"file":"tail.debug.js","sources":["../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/client/src/lib/objects.ts","../../../../../npm/packages/@tailjs/client/src/lib/regex.ts","../../../../../npm/packages/@tailjs/types/src/util/type-test.ts","../../../../../npm/packages/@tailjs/types/src/events/TrackedEvent.ts","../../../../../npm/packages/@tailjs/types/src/events/ViewEvent.ts","../../../../../npm/packages/@tailjs/types/src/events/ViewEndedEvent.ts","../../../../../npm/packages/@tailjs/types/src/events/ConsentEvent.ts","../../../../../npm/packages/@tailjs/types/src/util/parseTagString.ts","../../../../../npm/packages/@tailjs/client/src/lib/alias.ts","../../../../../npm/packages/@tailjs/client/src/lib/dom-alias.ts","../../../../../npm/packages/@tailjs/client/src/lib/util.ts","../../../../../npm/packages/@tailjs/client/src/lib/type-test.ts","../../../../../npm/packages/@tailjs/client/src/lib/iteration.ts","../../../../../npm/packages/@tailjs/client/src/lib/promise.ts","../../../../../npm/packages/@tailjs/util/src/types.ts","../../../../../npm/packages/@tailjs/util/src/base64.ts","../../../../../npm/packages/@tailjs/util/src/lfsr.ts","../../../../../npm/node_modules/.pnpm/@ygoe+msgpack@1.0.3/node_modules/@ygoe/msgpack/msgpack.js","../../../../../npm/packages/@tailjs/client/src/lib/dom.ts","../../../../../npm/packages/@tailjs/util/src/transport.ts","../../../../../npm/packages/@tailjs/client/src/lib/cipher.ts","../../../../../npm/packages/@tailjs/client/src/lib/time.ts","../../../../../npm/packages/@tailjs/client/src/lib/ids.ts","../../../../../npm/packages/@tailjs/client/src/lib/config.ts","../../../../../npm/packages/@tailjs/client/src/lib/env.ts","../../../../../npm/packages/@tailjs/client/src/lib/eventSet.ts","../../../../../npm/packages/@tailjs/client/src/lib/dom-data.ts","../../../../../npm/packages/@tailjs/client/src/lib/storage.ts","../../../../../npm/packages/@tailjs/client/src/lib/dependencyManager.ts","../../../../../npm/packages/@tailjs/client/src/lib/channel.ts","../../../../../npm/packages/@tailjs/client/src/lib/shared-state.ts","../../../../../npm/packages/@tailjs/client/src/lib/coordinate-commits.ts","../../../../../npm/packages/@tailjs/client/src/lib/requestMutex.ts","../../../../../npm/packages/@tailjs/client/src/lib/eventQueue.ts","../../../../../npm/packages/@tailjs/client/src/lib/registerViewEndAction.ts","../../../../../npm/packages/@tailjs/client/src/extensions/deviceDetection.ts","../../../../../npm/packages/@tailjs/client/src/extensions/context.ts","../../../../../npm/packages/@tailjs/client/src/extensions/userInteraction.ts","../../../../../npm/packages/@tailjs/client/src/extensions/commerce.ts","../../../../../npm/packages/@tailjs/client/src/extensions/components.ts","../../../../../npm/packages/@tailjs/client/src/initializeTracker.ts","../../../../../npm/packages/@tailjs/client/src/lib/scanComponents.ts","../../../../../npm/packages/@tailjs/client/src/extensions/scroll.ts","../../../../../npm/packages/@tailjs/client/src/extensions/forms.ts","../../../../../npm/packages/@tailjs/client/src/extensions/defaultExtensions.ts","../../../../../npm/packages/@tailjs/client/src/commands/shared.ts","../../../../../npm/packages/@tailjs/client/src/commands/CartCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ChangeUserCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ConfigCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ToggleCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/BoundaryCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ExtensionCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/FlushCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/GetCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ListenerCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/OrderCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ScanComponentsCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/SetCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/TrackerAvailableCommand.ts","../../../../../npm/packages/@tailjs/client/src/lib/variables.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["// MUST MATCH packages\\@tailjs\\engine\\src\\RequestHandler.ts\nexport const MUTEX_REQUEST_COOKIE = \".tail.rq\";\nexport const MUTEX_RESPONSE_COOKIE = \".tail.rs\";\nexport const CONTEXT_MENU_COOKIE = \".tail.cm\";\n\nexport const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_MENU_QUERY = \"mnt\";\n","// Utility functions for testing and manipulating values, sets and objects.\n\nimport type {\n  ArgNulls,\n  KeyValueProjection,\n  Nullish,\n  Nulls,\n  OmitNullish,\n} from \"@tailjs/util\";\nimport {\n  F,\n  T,\n  array,\n  assign,\n  entries,\n  filter,\n  forEach,\n  fromEntries,\n  fun,\n  keys,\n  nil,\n  obj,\n} from \".\";\n\n/**\n * Better minifyable way to instantiate a Set.\n */\nexport const hashSet = <T = any>(values?: readonly T[] | null) =>\n  new Set<T>(values);\n\n/**\n * Better minifyable way to instantiate a Map.\n */\nexport const hashMap = <K = any, V = any>(\n  entries?: readonly (readonly [K, V])[] | null\n) => new Map<K, V>(entries);\n\n/**\n * Better minifyable way to instantiate a WeakMap.\n */\nexport const weakMap = <K extends object = any, V = any>(\n  entries?: readonly (readonly [K, V])[] | null\n) => new WeakMap<K, V>(entries);\n\n/**\n * A common pattern used in the code base where something has a `clear` method.\n */\ntype Clearable<A extends any[]> = { clear(...args: A): any };\n\n/**\n *  General function to \"clear\" objects, arrays, sets and maps.\n */\nexport const clear: {\n  <T extends Clearable<A> | Nullish, A extends any[] = []>(\n    map: T,\n    ...args: A\n  ): T;\n  <T extends Record<keyof any, any>>(record: T): T;\n} = (clearable: any, ...args: any[]) => (\n  clearable != nil &&\n    (clearable.clear\n      ? clearable.clear(...args)\n      : array(clearable)\n      ? (clearable.length = 0)\n      : keys(clearable, (key) => del(clearable, key))),\n  clearable\n);\n\n/**\n * Test whether a set has a specified key, and if not, sets it and returns `true`. `false` otherwise.\n *\n * This is useful for recursive iteration where the same element must not be visited more than once (because infinite recursion sucks).\n */\nexport const mark = <K>(\n  set: { has(value: K): boolean; add(value: K): any },\n  value: K\n) => (set.has(value) ? F : (set.add(value), T));\n\n/**\n * A generalized function to get values from maps, test existence in sets and get properties on objects.\n */\nexport const get: {\n  <K, V, Arg>(\n    target: ArgNulls<{ get(key: K): V } | { has(key: K): V }, Arg>,\n    key: K\n  ): V | Nulls<Arg, undefined>;\n  <K extends keyof any, V, Arg>(target: ArgNulls<Record<K, V>, Arg>, key: K):\n    | V\n    | Nulls<Arg, undefined>;\n} = (target: any, key: any) =>\n  target.get?.(key) ?? target?.has(key) ?? target?.[key];\n\n/**\n * A generalized function to remove items from sets and maps, and delete properties from objects.\n * When only a single key/property is specified the deleted value is returned (`undefined` if not present).\n *\n * Multiple keys can be specified as once in which case the target will just be returned (like fluent API or whatever).\n */\n\nexport const del: {\n  (target: null | undefined, keys: string | string[]): undefined;\n  <K, V>(target: { get(key: K): V; delete(key: K): any }, item: K):\n    | V\n    | undefined;\n  <K, R>(\n    target: { has(key: K): boolean; delete(key: K): any },\n    item: K\n  ): boolean;\n  <T extends { delete(key: K): any }, K>(target: T, keys: K[]): T;\n  <T, K extends keyof T>(target: T, key: K): T[K] | undefined;\n  <T>(target: T, keys: (keyof T)[]): T;\n} = <T>(\n  target:\n    | { get?(item: T): any; has?(key: any): boolean; delete?(item: T): any }\n    | null\n    | undefined,\n  key: any\n) =>\n  !target\n    ? undefined\n    : array(key)\n    ? (forEach(key, (key) => target.delete?.(key) ?? delete target[key]),\n      target)\n    : (currentValue = target.has?.(key)) != null\n    ? !currentValue\n      ? undefined\n      : ((currentValue = target.get?.(key)),\n        target.delete!(key),\n        currentValue ?? T)\n    : ((currentValue = target[key]), delete target[key], currentValue);\n\n/**\n * Sets the value for the specified key in a map, toggles the item in a set, or sets the property on an object.\n *\n * The value `undefined` deletes the key/property from maps and objects.\n * For sets `undefined` corresponds to the default value `true`, so here it has the opposite effect.\n */\nlet currentValue: any;\nexport const set: {\n  <T>(\n    set: { add(key: T): void; delete(key: T): void },\n    item: T,\n    toggle?: boolean\n  ): boolean;\n  <K, V>(\n    map: {\n      get(key: K): V | null;\n      set(key: K, value: V): any;\n      delete(key: K): void;\n    },\n    key: K,\n    value: V | ((current: V | null) => V | null) | Nullish\n  ): boolean;\n} = (target: any, key: any, value: any = undefined) =>\n  !!target.add // It's a set\n    ? ((currentValue = target.has(key)),\n      currentValue === (value ??= T) // Toggle? (Default is `true` which we set here).\n        ? F\n        : (value ? target.add(key) : del(target, key), T))\n    : ((currentValue = target.get?.(key) ?? target[key]), // Get item from map / read property from object.\n      fun(value) && (value = value(currentValue)), // Apply optional projection on current value.\n      value === currentValue\n        ? F // No change\n        : (value === undefined // `undefined` means \"delete\".\n            ? del(target, key)\n            : target.set?.(key, value) ?? (target[key] = value),\n          // Return that the value was changed.\n          T));\n\n/**\n * Gets the current item for a key in a map, or a property on an object.\n * If no value is present, it is initialized with the `defaultValue` and then returned.\n */\nexport const getOrSet: {\n  <K, V, R extends V | Readonly<V>>(\n    map:\n      | {\n          has(key: K): boolean;\n          get(key: K): V | Nullish;\n          set(key: K, value: V): void;\n        }\n      | Record<keyof any, any>,\n    key: K,\n    defaultValue: (key: K) => R\n  ): V;\n  <\n    T extends Record<keyof any, any>,\n    K extends keyof T,\n    V,\n    R extends V | Readonly<V>\n  >(\n    target: T,\n    key: K,\n    defaultValue: (key: K) => R\n  ): V;\n} = (map: any, key: any, defaultValue: (key: any) => any) =>\n  map.has?.(key)\n    ? map.get?.(key)\n    : ((currentValue = defaultValue(key)),\n      map.set?.(key, currentValue)\n        ? currentValue\n        : (map[key] ??= defaultValue(key)));\n\n/**\n * Convenient way to use the values from a tuple.\n * If the tuple is null or undefined, that will be returned instead of applying the function.\n */\nexport const decompose = <Values extends any[] | Nullish, R>(\n  tuple: Values,\n  apply: (...values: OmitNullish<Values>) => R\n): R | Nulls<Values> => tuple && apply(...(tuple as any));\n\n/**\n * Creates a new object by projecting or excluding the properties of an existing one.\n */\nexport const transpose = <\n  K extends keyof any,\n  V,\n  KP extends keyof any = K,\n  VP = V\n>(\n  source: Record<K, V>,\n  projection?: KeyValueProjection<K, V, [KP, VP] | null>,\n  additionalEntries?: Record<KP, VP>\n): Record<KP, VP> =>\n  additionalEntries\n    ? assign(transpose(source, projection), additionalEntries)\n    : projection\n    ? (fromEntries(filter(entries(source, projection)) as any) as any)\n    : source;\n\n/** Removes null'ish properties from an object */\nexport const clean = <T extends object>(o: T): Required<T> => {\n  const inner = (o: object) =>\n    forEach(entries(o), ([key, value], F) =>\n      value == nil || (obj(value) && !inner(value)) ? (del(o, key), F) : T\n    );\n  inner(o);\n  return o as any;\n};\n","import type {\n  ConstToTuples,\n  IterableOrSelf,\n  Nullish,\n  Nulls,\n} from \"@tailjs/util\";\nimport {\n  REGEX,\n  TestOrConvertFunction,\n  array,\n  bool,\n  filter,\n  map,\n  str,\n  testOrConvertFunction,\n  undefined,\n  distinct,\n  size,\n  nil,\n  push,\n} from \".\";\n\n/**\n * Common definition of expresions that are used for string matching.\n *\n * If not already a regular expression, a string that starst with `/` and optionally ends with `/` is parsed as regular expressions with flags `gu` applied (global and Unicode).\n * This enables defining regular expression in text based configuration files that do not have native regular expressions.\n *\n * For convenience an asterisk (`*`) can be used to match any number of characters in strings, and  `,` and white-space ` ` are intepreted as list separators.\n * `\\` is used as the escape character so the string `\\/escaped\\*,and\\ this` will only match the strings, literally, `\\/escaped\\*` and `and this`.\n * This also means that intentional backslashes, commas and spaces must be escaped as `\\\\`, `\\,` and `\\ ` respectively.\n *\n * Arrays of strings and/or regular expressions are evaluated as unions (_string 1_ \"or\" _string 2_ \"or\" ...).\n *\n * The special values `null`, `undefined`, the empty string,  and `false` are interpreted as \"never\", and `true` is \"always\".\n *\n * Regarding separators, they may be different in specific contexts. If so, it will be mentioned there.\n */\nexport type ParsableRegExp =\n  | IterableOrSelf<null | undefined | boolean | string | RegExp>\n  | Iterable<ParsableRegExp>;\n\n/**\n * `Regex.test` optimized for minifying.\n */\nexport const test = (s: string | Nullish, match: RegExp | Nullish) =>\n  !!(s && match) && match.test(s);\n\nlet matchSelected: any;\n/**\n * Matches a regular expression against a string and projects the matched parts, if any.\n */\nexport const match: {\n  <R>(\n    s: string | Nullish,\n    match: RegExp | Nullish,\n    selector: (...args: string[]) => R | Nullish,\n    defaultValue: R[]\n  ): ConstToTuples<R>[];\n  <R>(\n    s: string | Nullish,\n    match: RegExp | Nullish,\n    selector: (...args: string[]) => R,\n    defaultValue?: R\n  ): ConstToTuples<R> | undefined;\n  (s: string | Nullish, match: RegExp | Nullish): RegExpMatchArray | null;\n} = <R>(\n  s: string,\n  regex: RegExp,\n  selector?: (...args: string[]) => R,\n  defaultValue?: R\n) =>\n  s &&\n  regex &&\n  (selector\n    ? (array(defaultValue)\n        ? match(\n            s,\n            regex,\n            (...args) =>\n              (matchSelected = selector(...args)) != nil &&\n              push(defaultValue as any, matchSelected)\n          )\n        : s.replace(\n            regex,\n            (...args) => ((defaultValue = selector(...args)), \"\")\n          ),\n      defaultValue)\n    : s.match(regex));\n\n/**\n * Replaces reserved characters to get a regular expression that matches the string.\n */\nexport const escapeRegEx = (input: string) =>\n  input.replace(/[\\^$\\\\.*+?()[\\]{}|]/g, \"\\\\$&\");\n\nconst REGEX_NEVER = /\\z./g;\nconst unionOrNever = (parts: (string | Nullish)[], joined?: string) =>\n  (joined = join(distinct(filter(parts, size)), \"|\"))\n    ? new RegExp(joined, \"gu\")\n    : REGEX_NEVER;\n\nconst stringRuleCache: { [pattern: string]: RegExp } = {};\n/**\n * Tests or parses a regular expression accepting the {@link ParsableRegExp} format.\n *\n * Strings are cached, so there is no need to do additional caching outside this function (as far as the caching would only concern strings).\n */\nexport const regex: TestOrConvertFunction<\n  RegExp,\n  ParsableRegExp,\n  [separators?: string[]]\n> = testOrConvertFunction(\n  REGEX,\n  (input: string | boolean | any[] | Nullish, separators = [\",\", \" \"]) =>\n    regex(input)\n      ? input\n      : array(input) // Parse individual specifiers, and join them into one long regex. An empty array is interpreted as \"never\".\n      ? unionOrNever(\n          map(input, (part) => regex(part, false, separators)?.source)\n        )\n      : bool(input)\n      ? input // `true` is \"always\", `false` is \"never\"\n        ? /./g\n        : REGEX_NEVER // Matches nothing. End of string followed by something is never the case.\n      : str(input)\n      ? (stringRuleCache[input] ??= match(\n          input || \"\",\n          /^(?:\\/(.+?)\\/?|(.*))$/gu,\n          (_, regex, text) =>\n            regex\n              ? new RegExp(regex, \"gu\")\n              : unionOrNever(\n                  map(\n                    split(\n                      text,\n                      new RegExp(\n                        `?<!(?<!\\\\)\\\\)[${join(map(separators, escapeRegEx))}]/`\n                      )\n                    ),\n                    (text) =>\n                      text &&\n                      `^${join(\n                        map(\n                          // Split on non-escaped asterisk (Characterized by a leading backslash that is not itself an escaped backslash).\n                          split(text, /(?<!(?<!\\\\)\\\\)\\*/),\n                          (part) =>\n                            escapeRegEx(\n                              // Remove backslashes used for escaping.\n                              replace(part, /\\\\(.)/g, \"$1\")\n                            )\n                        ),\n                        // Join the parts separated by non-escaped asterisks with the regex wildcard equivalent.\n                        \".*\"\n                      )}$`\n                  )\n                )\n        )!)\n      : undefined\n);\n\n/**\n * Better minifyable version of `String`'s `split` method that allows a null'ish parameter.\n */\nexport const split = <T extends string | Nullish>(\n  s: T,\n  separator: RegExp | string\n): T extends string ? string[] : string[] | Nulls<T> =>\n  s?.split(separator) ?? (s as any);\n\n/**\n * Better minifyable version of `String`'s `replace` method that allows a null'ish parameter.\n */\nexport const replace = <T extends string | Nullish>(\n  s: T,\n  match: RegExp,\n  replaceValue: string | ((...args: string[]) => string)\n): T => s?.replace(match, replaceValue as any) ?? (s as any);\n\n/**\n *  Better minifyable version of `String`'s `join` method that allows a null'ish parameter and removes empty.\n */\nexport const join = <T extends (string | Nullish)[] | Nullish>(\n  s: T,\n  separator = \"\"\n): string | Nulls<T> => (s?.join(separator) ?? s) as any;\n","import { TrackedEvent } from \"../events\";\n\nexport const typeTest =\n  <T extends TrackedEvent>(...types: string[]) =>\n  (ev: any): ev is T =>\n    ev?.type && types.some((type) => type === ev?.type);\n","import type {\n  CartUpdatedEvent,\n  ComponentClickEvent,\n  LocalID,\n  Session,\n  ViewEvent,\n  Tagged,\n  Timestamp,\n  Integer,\n} from \"..\";\n\n/**\n * The base type for all events that are tracked.\n *\n * The naming convention is:\n * - If the event represents something that can also be considered an entity like \"a page view\", \"a user location\" etc. the name should be a (deverbal) noun.\n * - If the event only indicates something that happend, like \"session started\", \"view ended\" etc. the name should be a verb in the past tense.\n *\n */\nexport interface TrackedEvent extends Tagged {\n  /**\n   * The type name of the event.\n   *\n   * This MUST be set to a constant value in extending interfaces and implementing classes for the event to be registered.\n   * */\n  type: string;\n\n  /**\n   * The ID of the schema the event comes from. It is suggested that the schema ID ends with a hash followed by a SemVer version number. (e.g. urn:tailjs#0.9.0)\n   */\n  schema?: string;\n\n  /**\n   * A token that may be included by the client to ensure that session state does not get lost if cookies are missing.\n   * It should only be included in the first event if multiple events are posted to avoid transmitting unnecessary data.\n   *\n   * It gets cleared by the request handler before sent to backends and should not be considered for analytics since it is an internal implementation detail.\n   */\n  affinity?: any;\n\n  /**\n   * This may be assigned or transformed by backends if needed.\n   * It is client-assigned for {@link ViewEvent}s\n   */\n  id?: LocalID;\n\n  /**\n   * This is set by the client and can be used to dedupplicate events sent multiple times if the endpoint timed out.\n   */\n  clientId?: LocalID;\n\n  /**\n   * The number of times the client tried to sent the event if the endpoint timed out\n   *\n   * @default 0\n   */\n  retry?: Integer;\n\n  /**\n   * The event that caused this event to be triggered or got triggered in the same context.\n   * For example a {@link NavigationEvent} may trigger a {@link ViewEvent},\n   * or a {@link CartUpdatedEvent} my be triggered with a {@link ComponentClickEvent}.\n   */\n  related?: LocalID;\n\n  /**\n   * The session associated with the event.\n   */\n  session?: Session;\n\n  /**\n   * When applicable, the view where the event happened (related by {@link ViewEvent}).\n   */\n  view?: LocalID;\n\n  /**\n   * This timestamp will always have a value before it reaches a backend.\n   * If specified, it must be a negative number when sent from the client (difference between when the event was generated and when is was posted in milliseconds).\n   *\n   * @default now\n   */\n  timestamp?: Timestamp;\n}\n\nexport const isTrackedEvent = (ev: any): ev is TrackedEvent =>\n  ev && typeof ev.type === \"string\";\n","import type { Domain, Integer, LocalID, Size, TrackedEvent, View } from \"..\";\nimport { typeTest } from \"../util/type-test\";\n\nexport interface ClickIds {\n  google?: string;\n  googleDoubleClick?: string;\n  facebook?: string;\n  microsoft?: string;\n  googleAnalytics?: string;\n}\n\nexport interface ViewEvent extends TrackedEvent {\n  type: \"VIEW\";\n\n  /**\n   * The ID of the view event that is referenced by {@link ViewContext}.\n   */\n  id: LocalID;\n\n  /**\n   * The primary content used to generate the view including the personalization that led to the decision, if any.\n   */\n  definition?: View;\n\n  /**\n   * The tab where the view was shown.\n   */\n  tab?: LocalID;\n\n  /**\n   * The fully qualified URL as shown in the address line of the browser excluding the domain.\n   */\n  href: string;\n\n  /**\n   * The hash part of the URL (/about-us#address).\n   */\n  hash?: string;\n\n  /**\n   * The path portion of the URL.\n   */\n  path?: string;\n\n  /**\n   * Urchin Tracking Module (UTM) parameters as defined by (Wikipedia)[https://en.wikipedia.org/wiki/UTM_parameters].\n   */\n  utm?: {\n    source?: string;\n    medium?: string;\n    campaign?: string;\n    term?: string;\n    content?: string;\n  };\n  /**\n   * The query string parameters in the URL, e.g. utm_campaign.\n   * Each parameter can have multiple values, for example If the parameter is specified more than once.\n   * If the parameter is only specified once pipes, semicolons and commas are assumed to separate values (in that order).\n   * A parameter without a value will get recorded as an empty string.\n   * @example The URL https://www.foo.com/?utm_source=bar&utm_campaign=campaign1,campaign2&flag&gclid=123xyz&p1=a&p1=b&p2=a;b,c;d has these parameters:\n   *  utm_source = [\"bar\"] \\\n   *  utm_campaign = [\"campaign1\", \"campaign2\"] \\\n   *  gclid = [\"123xyz\"] \\\n   *  flag = [\"\"] \\\n   *  gclid=[\"123xyz\"] \\\n   *  p1=[\"a\", \"b\"] \\\n   *  p2=[\"a\", \"b,c\", \"d\"]\n   */\n  queryString?: Record<string, string[]>;\n\n  // queryString?: {\n  //   source: Record<string, string>;\n  //   parsed: Record<string, string[]>;\n  // };\n\n  /**\n   * The domain part of the href, if any.\n   */\n  domain?: Domain;\n\n  /**\n   * Indicates that this was the first view in the first tab the user opened.\n   * Note that this is NOT tied to the session. If a user closes all tabs and windows for the site and then later navigates back to the site in the same session this flag will be set again.\n   * @default false\n   */\n  landingPage?: boolean;\n\n  /**\n   * Indicates that no other tabs were open when the view happened.\n   * This flag allows a backend to extend the definition of a session that can last indefinitely but still restart after inactivity.\n   * By measuring the time between a view with this flag and the previous event from the same device, it is possible to see for how long the device has been away from the site.\n   * @default false\n   */\n  firstTab?: boolean;\n\n  /**\n   * The 1-indexed view number in the current tab.\n   * This is kept as a convenience, yet technically redundant since it follows from timestamps and context.\n   * @default 1\n   */\n  tabIndex?: Integer;\n\n  /**\n   * Number of redirects that happened during navigation to this view.*/\n  redirects?: Integer;\n\n  /**\n   * Navigation type.\n   */\n  navigationType?: \"navigate\" | \"back-forward\" | \"prerender\" | \"reload\";\n\n  /**\n   * Indicates whether the event was manually triggered through a tracker command, or happened automatically by the tracker's ability to infer navigation.\n   *\n   * @default \"automatic\"\n   */\n  mode?: \"manual\" | \"automatic\";\n\n  /**\n   * External referrer. Internal referrers follows from the event's {@link TrackedEvent[\"relatedView\"]} field.\n   */\n  externalReferrer?: {\n    href?: string;\n    domain?: Domain;\n  };\n\n  /**\n   * The size of the user's view port (e.g. browser window) when the page was opened.\n   */\n  viewport?: Size;\n\n  /**\n   * The type of view, e.g. \"page\" or \"screen\".\n   *\n   * @default \"page\"\n   */\n  viewType?: string;\n}\n\nexport const isViewEvent = typeTest<ViewEvent>(\"VIEW\");\n","import type { TrackedEvent, ViewTimingEvent } from \"..\";\nimport { typeTest } from \"../util/type-test\";\n\nexport interface ViewEndedEvent extends TrackedEvent, ViewTimingEvent {\n  type: \"VIEW_ENDED\";\n  bounce?: boolean;\n}\n\nexport const isViewEndedEvent = typeTest<ViewEndedEvent>(\"VIEW_ENDED\");\n","import { TrackedEvent } from \"..\";\nimport { typeTest } from \"../util/type-test\";\n\n/**\n * The event that indicates whether a user has opted in to non-essential tracking used for purposes beyond non-personal, aggregated statistics or the storage of this consent itself.\n *\n * This event has a significant effect throughout the system since the lack of consent to non-essential tracking will prevent all non-essential cookies and identifiers to ever reach the user's device.\n * In the same way, such information is cleared if the user opts out.\n *\n * Backends are required to respect this consent, yet IT IS NOT THE RESPONSIBILITY OF tailjs.JS TO ENFORCE IT since it has no way to know the domain context of the data it relays.\n *\n * The user's decision is stored in an essential cookie and updated accordingly with this event. Sending the event with {@link nonEssentialTracking} `false` revokes the consent if already given.\n * The event should ideally be sent from a cookie disclaimer.\n *\n * Granular consents to email marketing, external advertising and the like must be handled by other mechanisms than tracking events.\n * This event only ensures that non-essential tracking information is not stored at the user unless consent is given.\n *\n * Also, \"consent\" and \"event\" rhymes.\n */\nexport interface ConsentEvent extends TrackedEvent {\n  type: \"CONSENT\";\n\n  /**\n   * Whether the user has consented to non-essential tracking.\n   */\n  nonEssentialTracking: boolean;\n}\n\nexport const isConsentEvent = typeTest<ConsentEvent>(\"CONSENT\");\n","export type ParsedTag = { ranks: string[]; value?: string };\n\nconst splitRanks = (ranks?: string) =>\n  ranks\n    ?.toLowerCase()\n    .replace(/[^a-zA-Z0-9:.-]/g, \"_\")\n    .split(\":\")\n    .filter((rank) => rank) ?? [];\n\n/**\n * Parses the tags out of a string\n */\nexport const parseTagString = (\n  input: string | string[] | null | undefined,\n  baseRank?: string,\n  target?: Set<string>\n) => {\n  if (!input) return [];\n  if (Array.isArray(input)) input = input.join(\",\");\n  // We have an unescaped percentage sign followed by an uppercase two-digit hexadecimal number. Smells like URI encoding!\n  if (/(?<!(?<!\\\\)\\\\)%[A-Z0-9]{2}/.test(input)) {\n    try {\n      input = decodeURIComponent(\n        input.replace(\n          // Change ampersands to commas (as they are value separators), and quote all values just to be sure nothing gets out of control.\n          // That is, `tag=test&tag2&tag3=Encoded%3A%20%22%F0%9F%A5%B3%22` becomes `tag=\"test\",tag2,tag3=\"Encoded: \\\"🥳\\\"\"\n          /([^=&]+)(?:\\=([^&]+))?(&|$)/g,\n          (_, name, value, sep) =>\n            [\n              name,\n              value && `=\"${value.replace(/(?<!(?<!\\\\)\\\\)(\"|%22)/g, '\\\\\"')}\"`, // Escape double quotes (both encoded `%22` and non-encoded `\"`\"), but ignore quotes that are already escaped (yes, why not?).\n              sep && \",\",\n            ].join(\"\")\n        )\n      );\n      // Need to catch exceptions. `decodeURIComponent` will fail on invalid surrogate code points. `%80` is one of those.\n    } catch {}\n  }\n\n  let tags: ParsedTag[] = [],\n    parsedTag: ParsedTag,\n    baseRanks = splitRanks(baseRank);\n\n  input.replace(\n    // Explained:\n    // 1. Tag (group 1): (\\s*(?=\\=)|(?:\\\\.|[^,=\\r\\n])+). It means \"skip leading white-space\", then either\"\n    //   1.1. \\s*(?=\\=) is \"nothing but a `=`\": a blank tag name causing the expression to skip to the actual value. (\"=80,=43\" are techincally supported but will get omitted unless the are base ranks (*))\n    //   2.1. (?:\\\\.|[^,=\\r\\n])+ is \"something not a linebreak including escaped characters such as \\=\":\n    // 2. Value: (?:\\=\\s*(?:\"((?:\\\\.|[^\"])*)\"|'((?:\\\\.|[^'])*)'|((?:\\\\.|\\s*[^,\\s])*)))?. Anything that starts with a `=` until we find a (non-escaped) comma\n    //  2.1: (group 2) \"((?:\\\\.|[^\"])*)\" is any double-quoted ()`\"`) value, can contain commas, anything escaped, or whatever. Goes well with JSON.\n    //  2.2: (group 3) is same as 2.1 just with a single quote (`'`).\n    //  2.3: (group 4) is anything but a non-escaped comma (`,`)\n    // 3. The end. (?:[,\\s]+|$). This is the tag separator or end of string.\n    //        Since tags cannot have line-breaks in them, this technically allows tags to be separated by line-breaks instead of comma.\n    //        This should not be documented as values can very much have line-breaks, and that syntax will then bite you in the money-maker at some point.\n    //        In the scary example below we get \"tag1\", \"tag21:tag22\" and then \"tag3\" with the value \"value\\tag4=value\"(!).\n    //        `tag1\n    //        tag21:tag22\n    //        tag3=value\n    //        tag4=value`\n    /\\s*(\\s*(?=\\=)|(?:\\\\.|[^,=\\r\\n])+)\\s*(?:\\=\\s*(?:\"((?:\\\\.|[^\"])*)\"|'((?:\\\\.|[^'])*)'|((?:\\\\.|[^,])*)))?\\s*(?:[,\\s]+|$)/g,\n    (_0, tag, quote1, quote2, unquoted) => {\n      let value = quote1 || quote2 || unquoted;\n      let ranks = splitRanks(tag);\n\n      baseRanks.length &&\n        // If we have base ranks (that, is a \"prefix\"), a single tag value is interpreted as a value. E.g. `<a data-name=\"foo\"...` becomes `data:name=foo`.\n        // We have this situation if there is exactly one rank, and no value.\n        // Other examples: `<a data-employee=\"foo:test\" ...` gives `data:employee:foo:test`. `data-employee=\"=test\"` gives us `data:employee=test`, and\n        //    `data-employee=\"id=80\"` gives us `data:employee:id=80`.\n        (ranks.length === 1 && !value && (value = ranks.pop()),\n        (ranks = baseRanks.concat(ranks))),\n        // If we don't have any ranks (only a value), we don't have a tag.\n        ranks.length && // * cf. expression explanition 1.1\n          (tags.push(\n            (parsedTag = {\n              ranks,\n              value: value || undefined,\n            })\n          ),\n          target?.add(encodeTag(parsedTag)));\n      return \"\"; // This is a trick. We are not really replacing anything, we are instead using replace as a for loop.\n    }\n  );\n  return tags;\n};\n\nexport const encodeTag = <T extends ParsedTag | null | undefined>(\n  tag: T\n): T extends ParsedTag ? string : null | undefined =>\n  tag == null\n    ? (tag as any)\n    : `${tag.ranks.join(\":\")}${\n        tag.value ? `=${tag.value.replace(/,/g, \"\\\\,\")}` : \"\"\n      }`;\n","// To let minifier shorten globals as normal variables.\nconst o = Object;\nconst s = Symbol;\nconst a = Array;\nconst undefined = void 0;\nconst nil = null;\nexport const T = true;\nexport const F = false;\n\nexport const fromEntries = Object.fromEntries;\nexport const assign = Object.assign;\nconst st = setTimeout;\nconst pi = parseInt;\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\nexport const random = Math.random;\n\nexport {\n  a as Array,\n  o as Object,\n  s as Symbol,\n  nil,\n  pi as parseInt,\n  st as setTimeout,\n  undefined,\n};\n","import type { Nullish } from \"@tailjs/util\";\n\nexport const SSR = typeof window === \"undefined\";\n\nconst win = window;\nconst doc = document;\nconst nav = navigator;\nconst body = doc.body;\nconst loc = location;\nconst perf = performance;\nconst hist = win.history;\nexport {\n  body,\n  doc as document,\n  hist as history,\n  loc as location,\n  nav as navigator,\n  perf as performance,\n  win as window,\n};\n\nexport const createElement = (tagName: string) => doc.createElement(tagName);\n\nexport const matches = (node: Element | Nullish, selector: string) =>\n  !!node?.matches(selector);\n","// General utility functions.\n\nimport type { ConstToTuples, Nullish } from \"@tailjs/util\";\nimport {\n  F,\n  bool,\n  filter,\n  keys,\n  match,\n  nil,\n  push,\n  size,\n  str,\n  undefined,\n  type Json,\n} from \".\";\n\n/**\n * Raises an error in the UI based on configuration and build settings.\n */\nexport const err = (code: string | Nullish, args?: any, error?: Error): void =>\n  console.error(\n    ...filter([code ?? error?.message ?? error ?? \"error\", args, error])\n  );\n\n/**\n * Applies a function to a value if it is not its types default value.\n * An object without properties and an empty array are considered the \"default\" for those types.\n */\nexport const ifNotDefault = <T, R = T>(\n  value: T,\n  action?: (value: T) => R\n): R | undefined =>\n  (typeof value === \"object\" && size(keys(value as any))) || value\n    ? action\n      ? action(value)\n      : value\n    : (undefined as any);\n\n/**\n * Round a number of to the specified number of decimals.\n */\nexport const round = (x: number, decimals: number | boolean = 0) =>\n  (bool(decimals) ? --(decimals as any) : decimals) < 0\n    ? x\n    : ((decimals = Math.pow(10, decimals as any)),\n      Math.round(x * decimals) / decimals);\n\n/**\n * `decodeURIComponent` for efficient minifying.\n */\nexport const decode = <T extends string | Nullish>(\n  value: T\n): T extends string ? string : null =>\n  value == nil ? nil : (decodeURIComponent(value) as any);\n\n/**\n * `encodeURIComponent` for efficient minifying.\n */\nexport const encode = <T extends string | Nullish>(\n  value: T\n): T extends string ? string : null =>\n  value == nil ? nil : (encodeURIComponent(value) as any);\n\nlet parameters = {};\n/**\n * Parses key/value pairs encoded as a URI query string (blah=foo&bar=gz%25nk).\n *\n * It supports that the same key can be specified multiple times.\n */\nexport const parseParameters = <T extends string | Nullish>(\n  query: T\n): T extends string ? Record<string, string[]> : T =>\n  query == nil\n    ? (query as any)\n    : ((parameters = {}),\n      match(query, /([^&=]+)(?:=([^&]+))?/g, (all, name, value) =>\n        push(\n          (parameters[lowerCase(decode(name))] ??= []),\n          decode(str(value, F))\n        )\n      ),\n      parameters);\n\n/**\n * Convenient way to compare a value against multiple others.\n */\nexport const equals = <T>(value: T, ...values: T[]) =>\n  values.some(value == nil ? (test) => test == nil : (test) => value === test);\n\n/**\n *  Better minifyable version of `String`'s `toLowerCase` method that allows a null'ish parameter.\n */\nexport const lowerCase = <T extends string | Nullish>(s: T): T =>\n  s?.toLowerCase() ?? (s as any);\n\n/**\n * `JSON.stringify` with default settings for pretty-printing any value.\n */\nexport const prettify = (value: any): string => stringify(value, nil, 2) ?? \"\";\n\n/**\n * `JSON.stringify` method for efficient minifying that also ignores null'ish values.\n */\nexport const stringify = <T>(\n  value: T,\n  replacer?: any,\n  space?: string | number\n): T extends Nullish ? null : string =>\n  value == nil ? nil : (JSON.stringify(value, replacer, space) as any);\n\n/**\n * `JSON.parse` method for efficient minifying that also gracefully handles null values.\n */\nexport const parse = <T extends Json = Json>(value: string | null): T =>\n  value == nil ? nil : JSON.parse(value);\n\n/**\n * Fast way to join two optional strings with a space.\n * If they are both nullish, nullish will be returned (unless `defaultValue`).\n */\nexport const concat2 = <\n  T1 extends string | Nullish,\n  T2 extends string | Nullish,\n  Default extends string | Nullish = null\n>(\n  value1: T1,\n  value2: T2,\n  defaultValue: Default = nil as any\n) =>\n  value1 && value2 ? value1 + \" \" + value2 : (value1 || value2) ?? defaultValue;\n","import type { IsAny, IterableOrArrayLike, Nullish } from \"@tailjs/util\";\nimport { F, T, nil } from \".\";\n\n/**\n * Converts various types' common representation of `true` and `false` to actual `true` and `false`.\n */\nexport const parseBoolean = (\n  value: string | boolean | null | number | undefined\n) =>\n  bool(value)\n    ? value\n    : value === 0\n    ? F\n    : value === 1\n    ? T\n    : value === \"false\"\n    ? F\n    : value === \"true\"\n    ? T\n    : undefined;\n\n/** Constants for type testing. */\nexport const STRING = 0,\n  BOOLEAN = 1,\n  NUMBER = 2,\n  FUNCTION = 3,\n  OBJECT = 4,\n  ARRAY = 5,\n  REGEX = 6;\n\n/**\n * When checking the string from `typeof blah`, no more than this is required for type tests.\n */\nconst typePrefixes = [\"s\", \"b\", \"n\", \"f\", \"o\"];\n\n/**\n * Tests whether a given value is of the desired type.\n */\nexport const is = <T extends number>(\n  type: T,\n  value: any\n): value is T extends typeof STRING\n  ? string\n  : T extends typeof BOOLEAN\n  ? boolean\n  : T extends typeof NUMBER\n  ? number\n  : T extends typeof FUNCTION\n  ? (...args: any) => any\n  : T extends typeof OBJECT\n  ? { [P in keyof any]: any }\n  : T extends typeof ARRAY\n  ? any[]\n  : T extends typeof REGEX\n  ? RegExp\n  : never =>\n  type === ARRAY\n    ? Array.isArray(value)\n    : (value != nil && typePrefixes[type] === (typeof value)[0]) ||\n      (type === REGEX && value.exec);\n\ntype UnwrapArray<T, V = any> = IsAny<V> extends true\n  ? T\n  : T extends IterableOrArrayLike<any>\n  ? V extends IterableOrArrayLike<infer V> & { toLowerCase?(): never }\n    ? V[]\n    : T\n  : T;\n\n/**\n * A general pattern used to type test or parse values of various types.\n */\nexport type TestOrConvertFunction<\n  T,\n  AllowParse = never,\n  ConvertArgs extends any[] = []\n> = {\n  <V>(value: V, parseStrict: false, ...args: ConvertArgs): V extends T\n    ? T extends V\n      ? UnwrapArray<T, V>\n      : V\n    : V extends AllowParse\n    ? UnwrapArray<T, V>\n    : T | undefined;\n  <V>(value: V, parseStrict: true): V extends T ? V : T;\n  <V extends T = T>(value: any): value is Exclude<V, Nullish>;\n};\n\n/**\n * Factory creating {@link TestOrConvertFunction}s.\n */\nexport const testOrConvertFunction: {\n  <T, AllowParse = never, ConvertArgs extends any[] = []>(\n    type: number,\n    convert: (value: any, ...args: ConvertArgs) => T | undefined\n  ): TestOrConvertFunction<T, AllowParse, ConvertArgs>;\n  <T>(type: number): <V extends T = T>(\n    value: any\n  ) => value is Exclude<V, Nullish>;\n} =\n  (\n    type: number,\n    convert?: (value: any, parse?: boolean, ...args: any[]) => any\n  ) =>\n  (value: any, parse?: boolean, ...args: any): value is any =>\n    parse === undefined\n      ? is(type, value)\n      : is(type, value)\n      ? value\n      : !parse\n      ? undefined\n      : convert?.(value, parse, ...args);\n\n/**\n * Tests or parses Boolean values.\n */\nexport const bool = testOrConvertFunction<boolean, any>(\n  BOOLEAN,\n  (value) => value !== \"0\" && value !== \"false\" && value !== \"no\" && !!value\n);\n\n/**\n * Tests or parses numerical values.\n */\nexport const num = testOrConvertFunction<number>(\n  NUMBER,\n  (value) => ((value = parseFloat(value)), isNaN(value) ? undefined : value)\n);\n\n/**\n * Tests if a value is a string, and if not, makes one by calling the value's `toString()` method.\n */\nexport const str = testOrConvertFunction<string>(STRING, (value) =>\n  value?.toString()\n);\n\n/**\n * Tests if a value can be invoked as a function.\n */\nexport const fun = testOrConvertFunction<(...args: any[]) => any>(\n  FUNCTION,\n  (_) => undefined\n);\n\n/**\n * Tests if a value is strictly an object (object but not array).\n */\nexport const obj = testOrConvertFunction<object>(OBJECT);\n\n/**\n * Tests if a value is an ECMAScript array (not TypedArray, those are too fancy).\n */\nexport const array = (() =>\n  // Needs wrapped in function, otherwise the multi-line type screws syntax highlighting.\n  testOrConvertFunction<\n    any[],\n    IterableOrArrayLike<any> & { toLowerCase?(): never }\n  >(ARRAY, (value) => (iterable(value) ? [...value] : undefined)))();\n\n/**\n * Utility type for {@link iterable} to help TypeScript know strings are not iterables.\n */\ntype IterableNotString<T> = T extends string\n  ? never\n  : T extends IterableOrArrayLike<any>\n  ? T\n  : never;\n\n/**\n * Tests if a value is an iterable collection of values (Iterable but not string).\n */\nexport const iterable = <T>(value: T): value is IterableNotString<T> =>\n  value && !str(value) && !!value[Symbol.iterator];\n","// Utility functions for arrays and iterables.\n\nimport type {\n  ArgNulls,\n  ConstToTuples,\n  IterableOrArrayLike,\n  IterableOrSelf,\n  KeyValueProjection,\n  Nullish,\n  Nulls,\n} from \"@tailjs/util\";\nimport { F, T, array, bool, fun, hashSet, iterable, nil, num, obj } from \".\";\n\n/**\n * Array's `sort` function that offers a single function that is applied on each element instead of having to do it twice (`[...].sort(x,y)=>f(x)-f(y)`).\n * Default is to use the value directly.\n */\nexport const sort = <T = number, Arg = any>(\n  items: ArgNulls<T[], Arg>,\n  sortKey: (item: T) => number = (item) => item as any\n): Nulls<Arg> =>\n  (items?.sort((lhs, rhs) => sortKey(lhs) - sortKey(rhs)), items) as any;\n\n/**\n * Array's `splice` method for efficient minifying.\n */\nexport const splice = <T, Arg>(\n  value: ArgNulls<T[], Arg>,\n  start: number,\n  deleteCount?: number,\n  ...values: T[]\n): T[] | Nulls<Arg> =>\n  value &&\n  (deleteCount != nil\n    ? (value.splice as any)(start, deleteCount, ...values)\n    : (value.splice as any)(start));\n\n/**\n * Array's `unshift` method for efficient minifying that also returns the array itself for fluent convenience.\n */\nexport const unshift = <T extends { unshift(...args: any): any }, Arg>(\n  target: ArgNulls<T, Arg>,\n  ...values: T[\"unshift\"] extends (...args: infer A) => any ? A : never\n): T | Nulls<Arg, undefined> => (target?.unshift(...values), target) as any;\n\n/**\n * Array's `shift` method for efficient minifying.\n */\nexport const shift = <T>(array: { shift(): T } | Nullish) => array?.shift();\n\n/**\n * Array's `push` method for efficient minifying that also returns the array itself for fluent convenience.\n */\nexport const push = <T extends { push(...args: any): any }, Arg>(\n  target: ArgNulls<T, Arg>,\n  ...values: T[\"push\"] extends (...args: infer A) => any ? A : never\n): T | Nulls<Arg, undefined> => (target?.push(...values), target) as any;\n\n/**\n * Array's `pop` method for efficient minifying.\n */\nexport const pop = <T>(array: { pop(): T } | Nullish) => array?.pop();\n\n/**\n * Like Array's `concat` but supports iterables.\n */\nexport const concat = <T>(...sources: (IterableOrSelf<T> | Nullish)[]): T[] =>\n  size((sources = filter(sources))) < 2\n    ? map(sources[0])\n    : [].concat(...(map(sources as any, map as any) as any));\n\n/**\n * Gives the distinct elements of the specified values. If a value is iterable it is expanded.\n */\nexport const distinct = <T>(\n  ...values: (IterableOrSelf<T | Nullish> | Nullish)[]\n): T[] => map(hashSet<T>(filter(concat(...values))));\n\n/**\n * Constructs a range (or empty array) with the given attributes.\n */\nexport const range: {\n  (length: number, empty?: false): number[];\n  (length: number, empty: true): undefined[];\n  <T = number>(length: number, project: (n: number) => T): T[];\n  (start: number, end: number): number[];\n} = (arg0: any, arg1: any) =>\n  arg1 === T\n    ? [...Array(arg0)]\n    : num(arg1)\n    ? range(arg1 - arg0, (n) => arg0 + n)\n    : (fun(arg1) || (arg1 = ((n: number) => n) as any),\n      map(range(arg0, T), (_, i) => (arg1 as any)(i)));\n\n/**\n * The length of an array and strings, size of sets and maps and the number of keys in an object.\n *\n * If the value is a primitive type (not string) the size is defined as 0.\n */\nexport const size = (\n  item:\n    | Iterable<any>\n    | Record<keyof any, any>\n    | { size: number }\n    | { length: number }\n    | Nullish\n) =>\n  item == nil\n    ? 0\n    : item[\"length\"] ?? item[\"size\"] ?? (obj(item) ? keys(item).length : 0);\n\n/**\n * An extended version of Object.entries that also supports maps, sets and arrays.\n */\nexport const entries: {\n  <K, V, P = [K, V]>(\n    map:\n      | {\n          entries(): Iterable<[K, V]>;\n        }\n      | Nullish,\n    project?: KeyValueProjection<K, V, P>\n  ): ConstToTuples<P>[];\n  <V, P = [number, V]>(\n    array: V[],\n    project?: KeyValueProjection<number, V, P>\n  ): ConstToTuples<P>[];\n  <K extends keyof any = keyof any, V = any, P = [K, V]>(\n    record: { [key in K]?: V },\n    project?: KeyValueProjection<K, V, P>\n  ): ConstToTuples<P>[];\n} = (mapOrRecord: any, project?: any) =>\n  !mapOrRecord\n    ? []\n    : array(mapOrRecord)\n    ? map(mapOrRecord, (value, index) =>\n        project ? project(index, value) : [index, value]\n      )\n    : map(mapOrRecord.entries?.() ?? Object.entries(mapOrRecord), project);\n\n/**\n * An extended version of Object.keys that also supports maps and sets.\n */\nexport const keys: {\n  <K = keyof any, P = K>(\n    map:\n      | {\n          keys(): Iterable<K>;\n        }\n      | Nullish,\n    project?: (key: K, index: number) => P\n  ): ConstToTuples<P>[];\n  <K extends keyof any = keyof any, P = K>(\n    record: { [key in K]?: any },\n    project?: (key: K, index: number) => P\n  ): ConstToTuples<P>[];\n} = (mapOrRecord: any, project?: any) =>\n  !mapOrRecord\n    ? []\n    : map(mapOrRecord.keys?.() ?? Object.keys(mapOrRecord), project);\n\n/**\n * An extended version of Object.values that also supports arrays and sets.\n */\nexport const values: {\n  <V, P = V>(\n    map:\n      | {\n          values(): Iterable<V>;\n        }\n      | Nullish,\n    project?: (value: V, index: number) => P\n  ): ConstToTuples<P>[];\n  <V = any, P = V>(\n    record: { [key in keyof any]?: V },\n    project?: (value: V, index: number) => P\n  ): ConstToTuples<P>[];\n} = (mapOrRecord: any, project?: any) =>\n  !mapOrRecord\n    ? []\n    : map(mapOrRecord.values?.() ?? Object.values(mapOrRecord), project);\n\n/**\n * Generalized version of Array's `forEach` method that enables breaking and a return value.\n * Non iterables are intepreted as an array with themselves as the only item.\n *\n * If the `breakSignal` is called, iteration will stop.\n * For convenience the break function can be called with a value that will then be passed through to combine breaking and returning a value.\n * This does not change the return value by itself.\n *\n * `const hasPositive = forEach(numbers, (x,_,stop)=>x > 0 && stop(true))`\n *\n * @returns The last returned value from the action.\n */\nexport const forEach = <T, R = void, InitialValue = undefined>(\n  items: IterableOrSelf<T> | Nullish,\n  action: (\n    item: T,\n    index: number,\n    breakSignal: <T>(passThroughValue?: T) => T,\n    currentValue: R | InitialValue\n  ) => R,\n  initialValue?: InitialValue\n): InitialValue | R => {\n  if (item == nil || !size(iterable(items) ? items : (items = [items] as any)))\n    return initialValue as any;\n\n  const breakSignal = (...args: any) => (\n    (index = 0), size(args) ? args[0] : initialValue\n  );\n\n  let index = 0;\n  for (const item of items as any)\n    if (\n      ((initialValue = action(\n        item,\n        index++,\n        breakSignal,\n        initialValue as any\n      ) as any),\n      !index) // Index is set to zero from the breakSignal\n    )\n      break;\n\n  return initialValue as any;\n};\n\n/**\n * Generalized version of Array's `map` method that also supports iterables and node lists.\n *\n * If called without a projection, it converts whatever is passed to it to an array.\n * When the value is already an array, the `clone` parameter decides whether the array itself or a clone should be returned.\n */\nexport const map: {\n  <T, P = T extends IterableOrArrayLike<infer T> ? T : T>(\n    value: IterableOrSelf<T> | Nullish,\n    projection: (item: T, index: number) => P\n  ): ConstToTuples<P>[];\n  <T, P = T extends IterableOrArrayLike<infer T> ? T : T>(\n    value: IterableOrSelf<T> | Nullish,\n    clone?: boolean\n  ): ConstToTuples<P>[];\n} = (value: any, cloneOrProject?: any): any[] =>\n  value == nil\n    ? []\n    : fun(cloneOrProject)\n    ? (map(value, F).map((value, index) => cloneOrProject(value, index)) as any)\n    : array(value) && !cloneOrProject\n    ? value\n    : (iterable(value) && [...value]) || [value];\n\n/**\n * A generalized version of Array's `flatMap` that also supports iterables and node lists.\n */\nexport const flatMap: {\n  <T, P = T extends Iterable<infer T> ? T : T>(\n    value: IterableOrArrayLike<T> | T | Nullish,\n    project: (item: T, index: number) => P | P[]\n  ): ConstToTuples<P>[];\n} = <T, P = T>(\n  value: T | Iterable<T | Nullish> | Nullish,\n  projection: (item: T, index: number) => P | P[] = (item) => item as any\n): ConstToTuples<P>[] =>\n  value == nil\n    ? []\n    : (filter(map(value, F)).flatMap((item, index) =>\n        projection(item as any, index)\n      ) as any);\n\n/**\n * A convenience method for returning the n'th item from an iterable or the n'th character from a string.\n *\n * If the source is not alrady an array (or indexable by an item method), it will be converted to one first.\n * The latter feature should be used with caution since it adds a terrible performance overhead if used from within a loop.\n */\nexport const item: {\n  <T>(\n    array:\n      | Iterable<T>\n      | T\n      | { [index: number]: T; length: number }\n      | string\n      | null\n      | undefined,\n    index?: number\n  ): T | undefined;\n  (text: string, index?: number): string | undefined;\n} = <T>(source: any, index = 0): T | undefined =>\n  source == nil\n    ? undefined\n    : (source.length == null && (source = map(source)),\n      source.item,\n      source[index < 0 ? (source as T[]).length + index : index]);\n\n/**\n * A generalized version of Array's `filter` that works on all the types supported by {@link map}.\n *\n * In addition it allows an empty result to be returned as `null`\n */\nexport const filter: {\n  <T, R extends T = T, B extends boolean = false>(\n    value: IterableOrSelf<T> | Nullish,\n    predicate: (item: R, index: number) => any,\n    emptyIsNull?: B\n  ): T[] | (B extends true ? null : never);\n  <T, B extends boolean = false>(\n    value: IterableOrSelf<T | Nullish> | Nullish,\n    emptyIsNull?: B\n  ): T[] | (B extends true ? null : never);\n} = <T>(\n  value: IterableOrSelf<T> | Nullish,\n  predicate?: boolean | ((item: T, index: number) => any),\n  emptyIsNull = bool(predicate) || F\n): T[] =>\n  ((value = (map(value) as any).filter((item: any, index: any) =>\n    (fun(predicate, true) ?? ((item: any) => item != nil))(item, index)\n  )),\n  emptyIsNull && !size(value!) ? nil : value) as any;\n\n/**\n * A convenience method to test whether an iterable has any element matching the predicate specified.\n *\n * If the parameter is not iterable is in interpreted as an array with itself as the only element.\n */\nexport const any = <T>(\n  value: IterableOrSelf<T>,\n  predicate: (item: T, index: number) => any = (item) =>\n    item != (nil as any) && item !== F\n): boolean =>\n  value != nil &&\n  (iterable(value) || (value = [value as any])) &&\n  (!predicate\n    ? !!size(value as any)\n    : forEach(value, (item, i, stop) => predicate(item, i) && stop(T), F));\n\n/**\n * Array's `reduce` method that also works for iterables.\n */\nexport const reduce = <T, V>(\n  items: IterableOrArrayLike<T>,\n  reducer: (previous: V, item: T) => V,\n  initialValue: V\n) =>\n  map(items).reduce(\n    (previous, current) => reducer(previous, current as any),\n    initialValue\n  );\n\n/**\n * Takes the sum of the items in an iterable.\n */\nexport const sum = <T, Arg>(\n  items: ArgNulls<IterableOrArrayLike<T>, Arg>,\n  selector?: (item: T) => number\n): number | Nulls<Arg> =>\n  items &&\n  (reduce(\n    items,\n    (sum, item) => (selector?.(item) ?? (item as number)) + sum,\n    0\n  ) as any);\n\n/**\n * Returns the highest value in a series of numbers.\n */\nexport const max: (typeof Math)[\"max\"] = (...values) => Math.max(...values);\n","import { T, assign, delay, nil, size, undefined } from \".\";\n\nexport const promise: {\n  <T>(): Promise<void>;\n  <T>(...args: ConstructorParameters<typeof Promise<T>>): Promise<T>;\n} = (...args: any[]) =>\n  !args.length ? Promise.resolve() : (new Promise(args[0]) as any);\n\n/**\n * Magic value to reset an  {@link OpenPromise}.\n */\nexport const Reset = Symbol();\n\nexport type OpenPromise<T = boolean> = PromiseLike<T> & {\n  /**\n   * Resolves the promise with the specified value.\n   */\n  (value: T): OpenPromise<T>;\n\n  /**\n   * Resets the promise, optionally only if completed\n   */\n  (reset: typeof Reset, ifCompleted?: boolean): OpenPromise<T>;\n\n  /**\n   * Tests whether the promise is resolved, optionally timed out.\n   */\n  (): T | undefined;\n};\n\n/**\n * Indicates that an {@link OpenPromiseWithTimeout} has timed out.\n */\nexport const Expired = Symbol();\nexport type OpenPromiseWithTimeout<T = boolean> = OpenPromise<\n  T | typeof Expired\n>;\n\n/**\n * Creates a new {@link OpenPromise} or {@link OpenPromiseWithTimeout} if a timeout is specified.\n */\nexport const openPromise: {\n  <T = boolean>(): OpenPromise<T>;\n  <T = boolean>(timeout: number): OpenPromiseWithTimeout<T>;\n} = (timeout?: number): OpenPromise<any> => {\n  let currentResolve: (value: any) => void = nil!;\n  let currentPromise: Promise<any> = nil!;\n  let resolved: any = undefined;\n\n  const reset = () => {\n    resolved = undefined;\n    let capturedResolve: ((value: any) => void) | null = nil;\n\n    currentPromise = promise((resolve) => {\n      currentResolve = capturedResolve = (value) =>\n        capturedResolve &&\n        ((capturedResolve = nil), resolve((resolved = value)));\n    });\n\n    if (timeout) {\n      delay(timeout).then(() => capturedResolve?.(Expired));\n    }\n  };\n  reset();\n  const p = assign(\n    (...args: any[]): any =>\n      !size(args)\n        ? resolved\n        : (args[0] === Reset\n            ? (args[1] !== T || resolved !== undefined) && reset()\n            : currentResolve(args[0]),\n          p),\n    {\n      then: (...args: any) => currentPromise.then(...args),\n    }\n  );\n\n  return p;\n};\n","export type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\ntype IsNever<T> = [T] extends [never] ? true : false;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the constract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properies that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Shorthand for a value that is optionally awaitable.\n */\nexport type MaybePromise<T> = PromiseLike<T> | T;\n\nexport type ValueOrDefault<T, R, D = undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? D\n  : R;\n\n/** Shorter than writing all this out, and slightly easier to read. */\nexport type Nullish = null | undefined;\n\n/**\n * Removes null'ish values from a union.\n */\nexport type OmitNullish<T> = T extends Nullish ? never : T;\n\n/**\n * Common function type used for projection of [key,value] entries.\n */\nexport type KeyValueProjection<K, V, R> = (\n  entry: [key: K, value: V],\n  index: number\n) => R;\n\n/**\n * Shorthand for a type that is inferred from a parameter and can either be the item in an iterable, or just the type itself.\n */\nexport type IterableOrSelf<T> = IterableOrArrayLike<T> | T;\n\n/**\n * Tests if a type is `any`. The test used is technically impossable to succeed unless the type is in fact `any`.\n */\nexport type IsAny<T> =\n  | [\n      {\n        d7d52e56b9c14b2b99c207f89f839630: T;\n      }\n    ]\n  | ((unlikely: { d7d52e56b9c14b2b99c207f89f839630: T }) => {\n      bd88181902d54401bb37e71194dd8b7d: T;\n    }) extends T\n  ? true\n  : false;\n\n/**\n * Utility type to allow `as const` to be used on tuples returned from functions without actually making them `readonly` (which is annoying).\n * Normally TypeScript considers the return value of a function like `x=>[10,\"four\"]` to be `(string|number)[]` (which is also annoying).\n */\nexport type ConstToTuples<T> = T extends readonly any[]\n  ? { -readonly [P in keyof T]: T[P] }\n  : Voidefined<T>;\n\n/**\n * Goes with {@link Nulls} to simplify the expression.\n */\nexport type ArgNulls<T, Arg> = (T | Nullish) & Arg;\n\n/**\n * Trick for having a function that returns a non-null value, if a formal paramter always has a non-null value.\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\n/**\n * Typescript has the distinction between `void` and `undefined`.\n * I'm sure there is a theorically sound explanation. Both that and the distinction are annoying so this little utility type maps `void` to `undefined`.\n *\n * The ampersand union trick makes TypeScript relax instead of the \"The type T could be instantiated etc...\" error.\n */\nexport type Voidefined<T> = T extends void ? T & undefined : T;\n\n/**\n * An extension to T[] and Iterable<T> that also correctly captures weird things like NodeListOf<T>\n */\nexport type IterableOrArrayLike<T> =\n  | Iterable<T>\n  | { [item: number]: T; length: number };\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = (value: any, parse?: boolean) => T | undefined;\n\nexport const undefined = void 0;\nexport const nil = null;\n\nconst createParser =\n  <T>(typeTester: TypeTester<T>, parser?: (value: any) => T | undefined) =>\n  (value: any, parse = true) =>\n    typeTester(value)\n      ? value\n      : parser && parse && isDefined((value = parser(value)))\n      ? value\n      : undefined;\n\nexport const tryCatch = <T, C = undefined>(\n  expression: () => T,\n  errorHandler?: (error: any) => C,\n  always?: () => void\n): T | C => {\n  try {\n    return expression();\n  } catch (e) {\n    return errorHandler?.(e) as any;\n  } finally {\n    always?.();\n  }\n};\n\nexport const tryCatchAsync = async <T, C = undefined>(\n  expression: () => Promise<T> | T,\n  errorHandler?: (error: any) => Promise<C> | C,\n  always?: () => void\n): Promise<T | C> => {\n  try {\n    return await expression();\n  } catch (e) {\n    return (await errorHandler?.(e)) as any;\n  } finally {\n    always?.();\n  }\n};\n\nexport const isNull = (value: any): value is null => value === nil;\nexport const isUndefined = (value: any): value is undefined | void =>\n  value === undefined;\nexport const isDefined = <T>(value: T): value is Exclude<T, undefined | void> =>\n  !isUndefined(value);\n\nexport const hasValue = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value != nil;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\nexport const parseBoolean = createParser(isBoolean, (value) => !!value);\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\nexport const parseNumber = createParser(isNumber, (value) => parseFloat(value));\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\nexport const parseBigInt = createParser(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\nexport const parseString = createParser(isString, (value) =>\n  hasValue(value) ? \"\" + value : value\n);\n\nexport const isArray = Array.isArray;\nexport const parseArray = createParser(isArray, (value) =>\n  isNull(value) ? [] : isIterable(value) ? [...value] : undefined\n);\n\nexport const isObject = (value: any): value is object =>\n  value && typeof value === \"object\";\nexport const parseObject = createParser(isObject);\n\n/** Tests whether a value is an object but not an array. */\nexport const isPureObject = (\n  value: any\n): value is object & { [Symbol.iterator]?: never } =>\n  isObject(value) && !isIterable(value);\nexport const parsePureObject = createParser(isPureObject);\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createParser(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\nexport const parseSymbol = createParser(isSymbol);\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\nexport const parseFunction = isFunction;\n\nexport const isIterable = (value: any): value is Iterable<any> =>\n  value?.[Symbol.iterator] && !isString(value);\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == nil\n    ? value === nil\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\nexport const identity = <T = any>(value: T) => value;\n\nexport const clone = <T>(value: T): T =>\n  isArray(value)\n    ? [...value]\n    : isPureObject(value)\n    ? { ...value }\n    : (value as any);\n","const codes: number[] = [];\nconst chars: number[] = [];\nexport const charCode = (s: string, index = 0) => s.charCodeAt(index);\nexport const fromCharCodes = (chars: number[]) => String.fromCharCode(...chars);\n\n[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"].forEach(\n  (p, i) => (codes[(chars[i] = p.charCodeAt(0))] = i)\n);\n\n/**\n * Encodes an array of bytes to Base64URL without padding (URL safe Base64 using `-` and `_` instead of `+` and `/`).\n *\n * (thanks to Jon Leighton at https://gist.github.com/jonleighton/958841).\n */\nexport const to64u = (bytes: Uint8Array) => {\n  let i = 0;\n  let chunk: number;\n  const n = bytes.length;\n\n  const base64: number[] = [];\n  while (i < n) {\n    chunk = (bytes[i++] << 16) | (bytes[i++] << 8) | bytes[i++];\n    base64.push(\n      chars[(chunk & 16515072) >> 18],\n      chars[(chunk & 258048) >> 12],\n      chars[(chunk & 4032) >> 6],\n      chars[chunk & 63]\n    );\n  }\n  base64.length += n - i;\n\n  return fromCharCodes(base64);\n};\n\n/**\n * Decodes a BaseURL encoded string (without padding).\n */\nexport const from64u = (encoded: string) => {\n  let i = 0;\n  let j = 0;\n  let p: number;\n  const n = encoded.length;\n  const bytes = new Uint8Array(3 * ((n / 4) | 0) + (((n + 3) & 3) % 3));\n  while (i < n) {\n    bytes[j++] =\n      (codes[charCode(encoded, i++)] << 2) |\n      ((p = codes[charCode(encoded, i++)]) >> 4);\n    if (i < n) {\n      bytes[j++] = ((p & 15) << 4) | ((p = codes[charCode(encoded, i++)]) >> 2);\n      if (i < n) {\n        bytes[j++] = ((p & 3) << 6) | codes[charCode(encoded, i++)];\n      }\n    }\n  }\n  return bytes;\n};\n","import { charCode, hasValue, isBoolean } from \".\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  <B extends boolean>(source: T, numeric: B): B extends true ? number : string;\n  (source: T, bits?: 32 | 64 | 128): string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key = \"\"): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (iw = 0; iw < key.length; mixer0 += window0[iw] = charCode(key, iw++));\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero it all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: any, numericOrBits: any = 64) => {\n      if (!hasValue(source)) return null;\n      let bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n","﻿(function () {\r\n\t\"use strict\";\r\n\r\n\t// Serializes a value to a MessagePack byte array.\r\n\t//\r\n\t// data: The value to serialize. This can be a scalar, array or object.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple values in data are concatenated to multiple MessagePack arrays.\r\n\t// - invalidTypeReplacement: The value that is used to replace values of unsupported types, or a function that returns such a value, given the original value as parameter.\r\n\tfunction serialize(data, options) {\r\n\t\tif (options && options.multiple && !Array.isArray(data)) {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\r\n\t\t}\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet floatBuffer, floatView;\r\n\t\tlet array = new Uint8Array(128);\r\n\t\tlet length = 0;\r\n\t\tif (options && options.multiple) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tappend(data[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tappend(data);\r\n\t\t}\r\n\t\treturn array.subarray(0, length);\r\n\r\n\t\tfunction append(data, isReplacement) {\r\n\t\t\tswitch (typeof data) {\r\n\t\t\t\tcase \"undefined\":\r\n\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\tappendBoolean(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tappendNumber(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tappendString(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif (data === null)\r\n\t\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\telse if (data instanceof Date)\r\n\t\t\t\t\t\tappendDate(data);\r\n\t\t\t\t\telse if (Array.isArray(data))\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\r\n\t\t\t\t\t\tappendBinArray(data);\r\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\r\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\r\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tappendObject(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\r\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendNull(data) {\r\n\t\t\tappendByte(0xc0);\r\n\t\t}\r\n\r\n\t\tfunction appendBoolean(data) {\r\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\r\n\t\t}\r\n\r\n\t\tfunction appendNumber(data) {\r\n\t\t\tif (isFinite(data) && Math.floor(data) === data) {\r\n\t\t\t\t// Integer\r\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0 && data >= -0x20) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\r\n\t\t\t\t\tappendBytes([0xcc, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\r\n\t\t\t\t\tappendBytes([0xd0, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\r\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\r\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\r\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\r\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\r\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\r\n\t\t\t\t\t// 32 bits for bitwise operations.\r\n\t\t\t\t\tlet hi = data / pow32;\r\n\t\t\t\t\tlet lo = data % pow32;\r\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\r\n\t\t\t\t\tappendByte(0xd3);\r\n\t\t\t\t\tappendInt64(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0) {   // below int64\r\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t\telse {   // above uint64\r\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Float\r\n\t\t\t\tif (!floatView) {\r\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\r\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\r\n\t\t\t\t}\r\n\t\t\t\tfloatView.setFloat64(0, data);\r\n\t\t\t\tappendByte(0xcb);\r\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendString(data) {\r\n\t\t\tlet bytes = encodeUtf8(data);\r\n\t\t\tlet length = bytes.length;\r\n\r\n\t\t\tif (length <= 0x1f)\r\n\t\t\t\tappendByte(0xa0 + length);\r\n\t\t\telse if (length <= 0xff)\r\n\t\t\t\tappendBytes([0xd9, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(bytes);\r\n\t\t}\r\n\r\n\t\tfunction appendArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x90 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let index = 0; index < length; index++) {\r\n\t\t\t\tappend(data[index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendBinArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendBytes([0xc4, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(data);\r\n\t\t}\r\n\r\n\t\tfunction appendObject(data) {\r\n\t\t\tlet length = 0;\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tif (data[key] !== undefined) {\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x80 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tlet value = data[key];\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tappend(key);\r\n\t\t\t\t\tappend(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendDate(data) {\r\n\t\t\tlet sec = data.getTime() / 1000;\r\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\r\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\r\n\t\t\t\tappendInt64(sec);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendByte(byte) {\r\n\t\t\tif (array.length < length + 1) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + 1)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray[length] = byte;\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\tfunction appendBytes(bytes) {\r\n\t\t\tif (array.length < length + bytes.length) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + bytes.length)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray.set(bytes, length);\r\n\t\t\tlength += bytes.length;\r\n\t\t}\r\n\r\n\t\tfunction appendInt64(value) {\r\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\r\n\t\t\t// bitwise operations.\r\n\t\t\tlet hi, lo;\r\n\t\t\tif (value >= 0) {\r\n\t\t\t\t// Same as uint64\r\n\t\t\t\thi = value / pow32;\r\n\t\t\t\tlo = value % pow32;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\r\n\t\t\t\tvalue++;\r\n\t\t\t\thi = Math.abs(value) / pow32;\r\n\t\t\t\tlo = Math.abs(value) % pow32;\r\n\t\t\t\thi = ~hi;\r\n\t\t\t\tlo = ~lo;\r\n\t\t\t}\r\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deserializes a MessagePack byte array to a value.\r\n\t//\r\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple concatenated MessagePack arrays are returned as an array.\r\n\tfunction deserialize(array, options) {\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet pos = 0;\r\n\t\tif (array instanceof ArrayBuffer) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\r\n\t\t}\r\n\t\tif (!array.length) {\r\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\r\n\t\t}\r\n\t\tif (!(array instanceof Uint8Array)) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tlet data;\r\n\t\tif (options && options.multiple) {\r\n\t\t\t// Read as many messages as are available\r\n\t\t\tdata = [];\r\n\t\t\twhile (pos < array.length) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Read only one message and ignore additional data\r\n\t\t\tdata = read();\r\n\t\t}\r\n\t\treturn data;\r\n\r\n\t\tfunction read() {\r\n\t\t\tconst byte = array[pos++];\r\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\r\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\r\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\r\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\r\n\t\t\tif (byte === 0xc0) return null;   // nil\r\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\r\n\t\t\tif (byte === 0xc2) return false;   // false\r\n\t\t\tif (byte === 0xc3) return true;   // true\r\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\r\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\r\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\r\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\r\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\r\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\r\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\r\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\r\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\r\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\r\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\r\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\r\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\r\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\r\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\r\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\r\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\r\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\r\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\r\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\r\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\r\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\r\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\r\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\r\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\r\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\r\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\r\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\r\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\r\n\t\t\tconsole.debug(\"msgpack array:\", array);\r\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\r\n\t\t}\r\n\r\n\t\tfunction readInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\tlet first = true;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tlet byte = array[pos++];\r\n\t\t\t\t\tvalue += byte & 0x7f;\r\n\t\t\t\t\tif (byte & 0x80) {\r\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvalue *= 256;\r\n\t\t\t\t\tvalue += array[pos++];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readUInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tvalue *= 256;\r\n\t\t\t\tvalue += array[pos++];\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readFloat(size) {\r\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\r\n\t\t\tpos += size;\r\n\t\t\tif (size === 4)\r\n\t\t\t\treturn view.getFloat32(0, false);\r\n\t\t\tif (size === 8)\r\n\t\t\t\treturn view.getFloat64(0, false);\r\n\t\t}\r\n\r\n\t\tfunction readBin(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = array.subarray(pos, pos + size);\r\n\t\t\tpos += size;\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readMap(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = {};\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tlet key = read();\r\n\t\t\t\tdata[key] = read();\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readArray(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = [];\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readStr(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet start = pos;\r\n\t\t\tpos += size;\r\n\t\t\treturn decodeUtf8(array, start, size);\r\n\t\t}\r\n\r\n\t\tfunction readExt(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet type = readUInt(1);\r\n\t\t\tlet data = readBin(size);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 255:\r\n\t\t\t\t\treturn readExtDate(data);\r\n\t\t\t}\r\n\t\t\treturn { type: type, data: data };\r\n\t\t}\r\n\r\n\t\tfunction readExtDate(data) {\r\n\t\t\tif (data.length === 4) {\r\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\treturn new Date(sec * 1000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 8) {\r\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\r\n\t\t\t\t\t((data[1] << 14) >>> 0) +\r\n\t\t\t\t\t((data[2] << 6) >>> 0) +\r\n\t\t\t\t\t(data[3] >>> 2);\r\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\r\n\t\t\t\t\t((data[4] << 24) >>> 0) +\r\n\t\t\t\t\t((data[5] << 16) >>> 0) +\r\n\t\t\t\t\t((data[6] << 8) >>> 0) +\r\n\t\t\t\t\tdata[7];\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 12) {\r\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\tpos -= 8;\r\n\t\t\t\tlet sec = readInt(8);\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Encodes a string to UTF-8 bytes.\r\n\tfunction encodeUtf8(str) {\r\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\r\n\t\tlet ascii = true, length = str.length;\r\n\t\tfor (let x = 0; x < length; x++) {\r\n\t\t\tif (str.charCodeAt(x) > 127) {\r\n\t\t\t\tascii = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\r\n\t\tfor (let ci = 0; ci !== length; ci++) {\r\n\t\t\tlet c = str.charCodeAt(ci);\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tbytes[i++] = c;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c < 2048) {\r\n\t\t\t\tbytes[i++] = c >> 6 | 192;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\r\n\t\t\t\t\tif (++ci >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\r\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\r\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\r\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\r\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\r\n\t\t\t\t}\r\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\r\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\r\n\t\t\t}\r\n\t\t\tbytes[i++] = c & 63 | 128;\r\n\t\t}\r\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\r\n\t}\r\n\r\n\t// Decodes a string from UTF-8 bytes.\r\n\tfunction decodeUtf8(bytes, start, length) {\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = start, str = \"\";\r\n\t\tlength += start;\r\n\t\twhile (i < length) {\r\n\t\t\tlet c = bytes[i++];\r\n\t\t\tif (c > 127) {\r\n\t\t\t\tif (c > 191 && c < 224) {\r\n\t\t\t\t\tif (i >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\r\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 223 && c < 240) {\r\n\t\t\t\t\tif (i + 1 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\r\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 239 && c < 248) {\r\n\t\t\t\t\tif (i + 2 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\r\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\r\n\t\t\t}\r\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\r\n\t\t\telse if (c <= 0x10ffff) {\r\n\t\t\t\tc -= 0x10000;\r\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\r\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\r\n\t\t\t}\r\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\r\n\t// The exported functions\r\n\tlet msgpack = {\r\n\t\tserialize: serialize,\r\n\t\tdeserialize: deserialize,\r\n\r\n\t\t// Compatibility with other libraries\r\n\t\tencode: serialize,\r\n\t\tdecode: deserialize\r\n\t};\r\n\r\n\t// Environment detection\r\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\r\n\t\t// Node.js\r\n\t\tmodule.exports = msgpack;\r\n\t}\r\n\telse {\r\n\t\t// Global object\r\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\r\n\t}\r\n\r\n})();\r\n","import {\n  cast,\n  type Domain,\n  type Position,\n  type Rectangle,\n  type ScreenPosition,\n  type Size,\n  type Viewport,\n} from \"@tailjs/types\";\nimport type {\n  ConstToTuples,\n  Nullish,\n  Nulls,\n  ValueOrDefault,\n} from \"@tailjs/util\";\nimport {\n  body,\n  document,\n  entries,\n  err,\n  F,\n  filter,\n  fun,\n  lowerCase,\n  map,\n  match,\n  MAX_SAFE_INTEGER,\n  nil,\n  parseBoolean,\n  push,\n  replace,\n  round,\n  T,\n  undefined,\n  window,\n} from \".\";\n\nexport type NodeWithParentElement = Node | EventTarget | Nullish;\n\nexport let MAX_ANCESTOR_DISTANCE = MAX_SAFE_INTEGER;\n\nexport const forAncestorsOrSelf = <T = any>(\n  el: NodeWithParentElement,\n  action: (\n    el: Element,\n    returnValue: (value: T, replace?: boolean) => void,\n    distance: number\n  ) => any,\n  stoppingCriterion: (el: Element, distance: number) => boolean = (\n    el,\n    distance\n  ) => distance >= MAX_ANCESTOR_DISTANCE\n): T | undefined => {\n  let i = 0,\n    returnValue: any,\n    stop = F;\n  while (\n    el?.[\"nodeType\"] === 1 &&\n    !stoppingCriterion(el as Element, i++) &&\n    action(\n      el as Element,\n      (value, replace) => (\n        value != nil &&\n          ((returnValue = value), (stop = replace !== T && returnValue != nil)),\n        T\n      ),\n      i - 1\n    ) !== F &&\n    !stop\n  ) {\n    const prev = el;\n    el = (el as Element).parentElement;\n    if (el === nil && (prev as Element)?.ownerDocument !== document) {\n      el = (prev as Element)?.ownerDocument.defaultView?.frameElement;\n    }\n  }\n\n  return returnValue;\n};\n\nexport const inElementScope = (node: NodeWithParentElement, name: string) =>\n  forAncestorsOrSelf(node, (el, value) =>\n    value(tagName(el) === name || undefined)\n  );\n\nexport const scopeAttr = (node: NodeWithParentElement, name: string) =>\n  forAncestorsOrSelf(node, (el, value) => value(attr(el, name)));\n\nexport const attrl = (node: NodeWithParentElement, name: string) =>\n  lowerCase(attr(node, name));\n\nlet value: string | null;\nexport const attrb = (node: NodeWithParentElement, name: string) =>\n  (value = attr(node, name)) === \"\" || parseBoolean(value);\n\nexport const attrn = (node: NodeWithParentElement, name: string) =>\n  parseFloat(\"\" + (value = attr(node, name))) ?? undefined;\n\nexport const attrs = <T extends NodeWithParentElement | Nullish>(\n  node: T\n): string[] | Nulls<T, undefined> => (node as any)?.getAttributeNames();\n\nexport const attr = (\n  node: NodeWithParentElement,\n  name: string,\n  value?: string | null\n): string | null =>\n  !(node as any)?.getAttribute\n    ? nil\n    : value === undefined\n    ? (node as Element).getAttribute(name)\n    : (value === nil\n        ? (node as any).removeAttribute(name)\n        : (node as any).setAttribute(name, value),\n      value);\n\nexport const cssProperty = (el: Element, name: string) =>\n  getComputedStyle(el).getPropertyValue(name) || nil;\n\nlet parameters: {};\nexport const define = <\n  T,\n  P extends Record<keyof any, [any, boolean?] | undefined>\n>(\n  target: T,\n  props: P\n): T & P =>\n  ((parameters = {}),\n  (map(\n    filter(entries(props), ([_, value]) => value != nil),\n    ([name, [value, writable = F] = []]) =>\n      (parameters[name] = {\n        writable,\n        configurable: writable,\n        value,\n      })\n  ),\n  Object.defineProperties(target, parameters))) as any;\n\nexport const tagName = <T extends Element | Nullish>(\n  el: T\n): T extends Nullish ? null : string => (el != nil ? (el.tagName as any) : nil);\n\nlet pos: Position;\nexport const relativeScrollPos = (): Position => (\n  (pos = scrollPos(F)),\n  {\n    x: pos.x / (body.offsetWidth - window.innerWidth) || 0,\n    y: pos.y / (body.offsetHeight - window.innerHeight) || 0,\n  }\n);\n\nexport const scrollPos = (int?: boolean): Position => ({\n  x: round(scrollX, int),\n  y: round(scrollY, int),\n});\n\nexport const matchExHash = (href1: string, href2: string) =>\n  replace(href1, /#.*$/, \"\") === replace(href2, /#.*$/, \"\");\n\nlet screenPos: Position | undefined;\nexport const getScreenPos = <T extends Element | Nullish>(\n  el: T,\n  mouseEvent?: MouseEvent,\n  includeFold = T\n): ScreenPosition | Nulls<T> =>\n  (screenPos = getPos(el, mouseEvent)) &&\n  (cast<ScreenPosition>({\n    xpx: screenPos.x,\n    ypx: screenPos.y,\n    x: round(screenPos.x / body.offsetWidth, 4),\n    y: round(screenPos.y / body.offsetHeight, 4),\n    pageFolds: includeFold ? screenPos.y / window.innerHeight : undefined,\n  }) as any);\n\nlet x: number, y: number;\nexport const getPos = <T extends Element | Nullish>(\n  el: T,\n  mouseEvent?: MouseEvent\n): ValueOrDefault<T, Position> =>\n  !!mouseEvent?.[\"pointerType\"] && mouseEvent?.pageY != nil\n    ? { x: mouseEvent.pageX, y: mouseEvent.pageY }\n    : el\n    ? (({ x, y } = getRect(el)), { x, y })\n    : (undefined as any);\n\nlet rect: DOMRect;\nexport const getRect = <T extends Element | Nullish>(\n  el: T\n): ValueOrDefault<T, Rectangle> =>\n  el\n    ? ((rect = el.getBoundingClientRect()),\n      (pos = scrollPos(F)),\n      {\n        x: round(rect.left + pos.x),\n        y: round(rect.top + pos.y),\n        width: round(rect.width),\n        height: round(rect.height),\n      })\n    : (undefined as any);\n\ntype AllMaps = WindowEventMap &\n  GlobalEventHandlersEventMap &\n  DocumentEventMap &\n  HTMLElementEventMap;\n\nexport const listen = <K extends keyof AllMaps>(\n  el: any,\n  names: K[] | K,\n  cb: (ev: AllMaps[K], unbind: () => void) => void,\n  capture = T,\n  passive = T\n) => {\n  let unbinders: any[] = [];\n\n  return (\n    map(names, (name, i) => {\n      const mapped = (ev: any) => {\n        cb(ev, unbinders[i]);\n      };\n      push(unbinders, () => el.removeEventListener(name, mapped, capture));\n      return el.addEventListener(name, mapped, { capture, passive });\n    }),\n    () =>\n      unbinders.length > 0 && map(unbinders, (unbind) => unbind())\n        ? ((unbinders = []), T)\n        : F\n  );\n};\n\nexport const listenOnce = <K extends keyof AllMaps>(\n  el: any,\n  names: K[] | K,\n  cb: (event: AllMaps[K], unbind: () => void) => void,\n  useCapture?: boolean\n) =>\n  listen(\n    el,\n    names,\n    (event, unbind) => (cb(event, unbind), unbind()),\n    useCapture\n  );\n\nexport const parseDomain = <T extends string | Nullish>(\n  href: T\n): T extends string ? { domain?: Domain; href: string } : undefined =>\n  href == nil\n    ? (undefined as any)\n    : match(\n        href,\n        /^(?:([a-zA-Z0-9]+):)?(?:\\/\\/)?([^\\s\\/]*)/,\n        (all, protocol, domainName) =>\n          domainName\n            ? {\n                href: href.substring(all.length),\n                domain: {\n                  protocol,\n                  domainName,\n                } as Domain,\n              }\n            : { href }\n      );\n\nexport const getViewportSize = (): Size => ({\n  width: window.innerWidth,\n  height: window.innerHeight,\n});\n\nexport const getViewport = (): Viewport => (\n  (pos = scrollPos(T)),\n  {\n    ...pos,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    totalWidth: body.offsetWidth,\n    totalHeight: body.offsetHeight,\n  }\n);\n\nexport const tryAsync = async <T, E = void>(\n  action: (() => Promise<T> | T) | Promise<T> | T,\n  error?: ((error: any) => Promise<E> | E) | Promise<E> | E,\n  always?: () => void | Promise<void>\n): Promise<T | E> => {\n  try {\n    return await (fun(action) ? action() : action);\n  } catch (e) {\n    console.error(e);\n    return await (fun(error) ? error(e) : e);\n  } finally {\n    await always?.();\n  }\n};\n\nexport const tryCatch = <T, R = undefined>(\n  action: () => T,\n  error: ((e: any) => R) | any[] | false = (e) => err(nil, nil, e) as R,\n  finallyCallback?: () => void\n): ConstToTuples<T | R | undefined> => {\n  const unbind = listen(window, \"error\", (ev) => ev.stopImmediatePropagation());\n  try {\n    return action() as any;\n  } catch (e) {\n    return error === F\n      ? undefined\n      : fun(error)\n      ? error(e)\n      : ((push(error, e) ?? err(nil, nil, e), undefined as R) as any);\n  } finally {\n    unbind();\n    finallyCallback?.();\n  }\n};\n","import { deserialize, serialize } from \"@ygoe/msgpack\";\n\n// Use below when ad-hoc testing with nodmon. It doesn't like the import above (probabaly because of mangling).\n//import msgpack from \"@ygoe/msgpack\";\n//const { serialize, deserialize } = msgpack;\n\nimport {\n  Encodable,\n  EncodableContract,\n  HashFunction,\n  Nullish,\n  from64u,\n  hasValue,\n  isArray,\n  isDefined,\n  isFunction,\n  isIterable,\n  isNull,\n  isNumber,\n  isObject,\n  isPureObject,\n  isSymbol,\n  isUndefined,\n  lfsr,\n  nil,\n  to64u,\n  tryCatch,\n} from \".\";\nimport { isFloat64Array } from \"util/types\";\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param validate This property has no effect other than letting TypeScript validate whether the value can be deserialized back to its original form without losing properties.\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  (value: any, validate?: false): string;\n  <T = Encodable>(value: T & EncodableContract<T>, validate: true): string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(encoded: string | Nullish) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\nconst floatBuffer = new ArrayBuffer(8);\nconst floatView = new DataView(floatBuffer);\n\n/**\n * Misc. fixes to the msgpack library. For example, it does not handle exponential numbers well.\n */\nconst patchSerialize = (value: any) => {\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number;\n  const patchProperty = (\n    value: any,\n    key: any,\n    val = value[key],\n    patched = inner(val)\n  ) => (\n    (val !== patched || isSymbol(key)) &&\n      ((value[key] = patched), addCleaner(() => (value[key] = val))),\n    val\n  );\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (isNull(value)) return nil;\n    if (isUndefined(value) || isFunction(value) || isSymbol(value)) {\n      return null;\n    }\n\n    if (Number.isFinite(value) && !Number.isSafeInteger(value)) {\n      floatView.setFloat64(0, value, true);\n\n      return { \"\": [...new Uint32Array(floatBuffer)] };\n    }\n\n    if (!isObject(value)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if (isDefined((refIndex = (refs ??= new Map()).get(value)))) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isPureObject(value)) {\n      refs.set(value, refs.size + 1);\n      Object.keys(value).forEach(\n        (k) =>\n          (isUndefined(patchProperty(value, k)) || isSymbol(k)) &&\n          delete value[k]\n      );\n    } else if (isIterable(value)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  const serialized = serialize(inner(value));\n  cleaners?.forEach((cleaner) => cleaner());\n  return serialized;\n};\n\nconst patchDeserialize = (value: Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value)) return value;\n\n    if (isArray(value[\"\"]) && (value = value[\"\"]).length === 2) {\n      return new DataView(new Uint32Array(value).buffer).getFloat64(0, true);\n    }\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return hasValue(value)\n    ? tryCatch(\n        () => inner(deserialize(value)),\n        () => undefined\n      )\n    : value;\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<string>\n];\n\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lsfr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (key?: null | string): Transport => {\n  const [encrypt, decrypt, hash] = lfsr(key ?? \"\");\n\n  return [\n    (data: any) => to64u(encrypt(patchSerialize(data))),\n    (encoded: any) =>\n      hasValue(encoded) ? patchDeserialize(decrypt(from64u(encoded))) : null,\n    (data: any, numericOrBits?: any) =>\n      hash(serialize(data), numericOrBits) as any,\n  ];\n};\n\nexport const defaultTransport = createTransport();\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\n","import { type Nullish, createTransport } from \"@tailjs/util\";\n\nexport const [httpEncode, httpDecode] = createTransport();\n\nexport let [httpEncrypt, httpDecrypt] = [null, null] as any; // [httpEncode, httpDecode];\n\nexport const setStorageKey = (key: string | Nullish) =>\n  ([httpEncrypt, httpDecrypt] = createTransport(key));\n","import { Timestamp } from \"@tailjs/types\";\nimport { F, SSR, T, nil, performance, promise, setTimeout, undefined } from \".\";\n\nexport const now: (truncate?: boolean) => number = (\n  round = T,\n  _tmp?: number\n) => (\n  (_tmp = SSR ? Date.now() : performance.timeOrigin + performance.now()),\n  round ? Math.trunc(_tmp) : _tmp\n);\n\nexport type Timeout = {\n  (): void; // Clear\n  (callback: () => void, delay?: number): void;\n  clear(delay?: number, cleanup?: () => void): void;\n  wait(delay?: number): Promise<void>;\n  isActive(): boolean;\n  finish(): void;\n  pulse(): Timeout;\n};\n\nexport const delay = (ms: number): Promise<void> =>\n  promise((resolve) => setTimeout(resolve, ms));\n\nexport const formatDuration = (ms: number) =>\n  ms > 250 ? `${(ms / 1000).toFixed(2)}s` : `${Math.round(ms)}ms`;\n\nexport const timeout = (callback?: () => void, delay?: number): Timeout => {\n  let id = 0;\n  let currentCallback = callback;\n  let capturedCallback: typeof callback | null = null;\n\n  const clear = () => (\n    (currentCallback = undefined),\n    id < 0 ? clearInterval(-id) : clearTimeout(id),\n    (id = 0)\n  );\n\n  const timeout = (callback?: () => void, delay?: number) => {\n    clear();\n    if (!callback) return;\n\n    currentCallback = callback;\n    id =\n      delay! < 0\n        ? -setInterval(callback, -delay!)\n        : setTimeout(() => ((currentCallback = undefined), callback()), delay);\n  };\n\n  timeout.clear = (delay?: number, cleanup?: () => void, currentId = id) =>\n    id &&\n    (delay\n      ? setTimeout(() => id === currentId && (clear(), cleanup?.()), delay)\n      : (clear(), cleanup?.()));\n\n  timeout.wait = (delay: number): Promise<void> =>\n    promise((resolve) => timeout(resolve, delay));\n\n  timeout.pulse = () => (currentCallback?.(), timeout);\n\n  timeout.isActive = () => currentCallback != nil;\n  timeout.finish = () =>\n    (capturedCallback = currentCallback) && (clear(), capturedCallback());\n\n  return callback && timeout(callback, delay), timeout;\n};\n\nexport const timer = (time = () => now(), started = T) => {\n  let elapsed = 0;\n  let origin = started ? time() : 0;\n\n  const timer = (start?: boolean): Timestamp => {\n    if (origin) {\n      elapsed += -origin + (origin = time());\n    } else if (start === T) {\n      origin = time();\n    }\n\n    if (start === F) {\n      origin = 0;\n    }\n    return elapsed;\n  };\n  timer.reset = () => (origin && (origin = time()), (elapsed = 0));\n  return timer;\n};\n\nexport const defer = (f: VoidFunction, ms = 0) =>\n  ms ? setTimeout(f, ms) : window.queueMicrotask(f);\n","import type { LocalID, UUID } from \"@tailjs/types\";\nimport { now, reduce, replace, split } from \".\";\n\nexport type TabId = string;\n\nconst KEY_PREFIX = \"(t~\";\n\nexport const mapSharedId = (id: string) => `${KEY_PREFIX}${id}`;\n\nconst randomValues = (arg: any) => crypto.getRandomValues(arg);\nexport const uuidv4 = (): UUID =>\n  replace(\n    ([1e7] as any) + -1e3 + -4e3 + -8e3 + -1e11,\n    /[018]/g,\n    (c: any) => (\n      (c *= 1),\n      (c ^ (randomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)\n    )\n  );\n\nexport const randomSafeInt = (arr?: Uint32Array) => (\n  randomValues((arr = new Uint32Array(2))),\n  // keep all 32 bits of the the first, top 20 of the second for 52 random bits\n  arr[0] * (1 << 20) + (arr[1] >>> 12)\n);\n\nconst localIdBuffer = new Uint32Array(2);\nexport const nextId = (): LocalID => randomSafeInt(localIdBuffer).toString(36);\n\nexport const compareTabIds = (id: TabId, other: TabId) =>\n  id.localeCompare(other, \"en\") < 0 ? id : other;\n\nexport const getMinTabId = (id: TabId, ...other: TabId[]) =>\n  other.length === 0\n    ? id\n    : other.length === 1\n    ? compareTabIds(id, other[0])\n    : reduce(other, (min, id) => compareTabIds(id, min), id);\n\nexport const TAB_ID = `${now().toString(36)}-${randomSafeInt().toString(36)}`;\n\nlet tabIdParts: [date: string, random: string];\nexport const formatTabId = (tabId = TAB_ID) => (\n  (tabIdParts = split(tabId, \"-\") as any),\n  `${new Date(parseInt(tabIdParts[0], 36)).toISOString()} (${tabIdParts[1]})`\n);\n","import type { TrackerConfiguration } from \"..\";\n\nexport const isTracker = \"__isTracker\";\n\nexport const trackerConfig: Required<TrackerConfiguration> = {\n  name: \"tail\",\n  src: \"/_t.js\",\n  disabled: false,\n  postEvents: true,\n  postFrequency: 2000,\n  requestTimeout: 5000,\n  heartbeatFrequency: 0,\n  clientKey: null,\n  apiKey: null,\n\n  /**\n   * Log events to the browser's developer console.\n   */\n  debug: false,\n  impressionThreshold: 1000,\n  captureContextMenu: true,\n  defaultActivationTracking: \"auto\",\n  tags: { default: [\"data-id\", \"data-name\"] },\n};\n","import {\n  CONTEXT_MENU_QUERY,\n  EVENT_HUB_QUERY,\n  VARIABLES_QUERY,\n} from \"@constants\";\nimport type { Nullish } from \"@tailjs/util\";\nimport { T, document, join, parseDomain, replace, split } from \".\";\n\nexport const ERR_BUFFER_OVERFLOW = \"buffer-overflow\";\nexport const ERR_POST_FAILED = \"post-failed\";\nexport const ERR_INVALID_COMMAND = \"invalid-command\";\nexport const ERR_INTERNAL_ERROR = \"internal-error\";\nexport const ERR_ARGUMENT_ERROR = \"invalid-argument\";\nexport const ERR_RESERVED = \"reserved\";\nexport const ERR_CONFIG_LOCKED = \"config-locked\";\nexport const ERR_DUPPLICATE_KEY = \"key\";\n\nconst src = split(\"\" + document.currentScript![\"src\"], \"#\");\nconst args = split(\"\" + (src[1] || \"\"), \";\");\n\nexport const SCRIPT_SRC = src[0];\nexport const TRACKER_DOMAIN =\n  args[1] || parseDomain(SCRIPT_SRC)?.domain?.domainName;\n\nexport const isInternalUrl = (url: string | Nullish) =>\n  !!(\n    TRACKER_DOMAIN &&\n    parseDomain(url)?.domain?.domainName.endsWith(TRACKER_DOMAIN) === T\n  );\n\nexport const mapUrl = (...urlParts: string[]) =>\n  replace(join(urlParts), /(^(?=\\?))|(^\\.(?=\\/))/, SCRIPT_SRC.split(\"?\")[0]);\n\nexport const VAR_URL = mapUrl(\"?\", EVENT_HUB_QUERY);\nexport const MNT_URL = mapUrl(\"?\", CONTEXT_MENU_QUERY);\nexport const USR_URL = mapUrl(\"?\", VARIABLES_QUERY);\n","import { del, forEach, hashSet, openPromise, set } from \".\";\n\ntype HandlerArgs<Args extends any[]> = [...params: Args, unbind: () => void];\nexport const eventSet = <Args extends any[] = []>(\n  once = false\n): [\n  add: (handler: (...args: HandlerArgs<Args>) => void) => () => void,\n  invoke: (...args: Args) => void\n] => {\n  const handlers = hashSet<(...args: HandlerArgs<Args>) => void>();\n  const unbinder = (handler: any) => () => del(handlers, handler);\n  let invokeArgs: Args | null = null;\n\n  return [\n    (handler: (...args: HandlerArgs<Args>) => void): (() => void) => (\n      // If the event has already fired call the handler with whatever args were used when it happened.\n      once && invokeArgs\n        ? handler(...invokeArgs, () => {})\n        : set(handlers, handler),\n      unbinder(handler)\n    ),\n    (...args: Args) =>\n      forEach(handlers, (handler) => {\n        handler(...(invokeArgs = args), unbinder(handler));\n      }),\n  ];\n};\n\nexport const startupLock = openPromise();\n\nexport const [registerStartupHandler, startupComplete] = eventSet(true);\n\nregisterStartupHandler(() => startupLock(true));\n","import { parseTagString, type Tag } from \"@tailjs/types\";\nimport type { Nullish } from \"@tailjs/util\";\nimport {\n  attr,\n  attrs,\n  bool,\n  concat2,\n  createElement,\n  cssProperty,\n  F,\n  filter,\n  flatMap,\n  forAncestorsOrSelf,\n  forEach,\n  fun,\n  get,\n  hashSet,\n  iterable,\n  map,\n  match,\n  matches,\n  nil,\n  NodeWithParentElement,\n  obj,\n  regex,\n  replace,\n  size,\n  str,\n  T,\n  test,\n  trackerConfig,\n  values,\n  weakMap,\n} from \".\";\nimport type { BoundaryData, TagMappings } from \"..\";\n\nexport const boundaryData = weakMap<Node, BoundaryData>();\nexport const getBoundaryData = (el: Node) => get(boundaryData, el);\n\nexport const trackerPropertyName = (name: string, css = F) =>\n  (css ? \"--track-\" : \"track-\") + name;\n\n// const trackerProperty = (\n//   el: Element,\n//   name: string,\n//   value = attr(el, trackerPropertyName(name)),\n//   css = cssProperty(el as Element, trackerPropertyName(name, T))\n// ) => (value ? (css ? value + \" \" + css : value) : css);\n\ntype MatchAttributeRule = readonly [\n  match: RegExp,\n  selector?: string,\n  baseRank?: string\n];\n\ntype CacheMatchRules = [\n  eligibleCache: { [name: string]: boolean },\n  rules: MatchAttributeRule[] | Nullish\n];\n\n/**\n * Extracts an element's tags given an attribute name, and a list of rules about how to match..\n * Since this function is external, its local variables are added as local parameters. Don't tamper.\n *\n * An optional `eligibleCache` can be passed along to speed up rejecting attribute names that definitely don't match anything.\n */\nconst matchAttributeNames = (\n  el: Element | Nullish,\n  cached: CacheMatchRules | Nullish,\n  tags: Set<string>,\n  prefix?: string | boolean,\n  value?: string,\n  eligible?: boolean\n) =>\n  cached?.[1] &&\n  forEach(\n    attrs(el),\n    (name) =>\n      (cached[0][name] ??=\n        ((eligible = F),\n        str(\n          (prefix =\n            // Grrr.. we did not. Let's loop through them then.\n            forEach(\n              cached[1],\n              ([match, selector, prefix], _, stop) =>\n                test(name, match) &&\n                // Sneakily we \"delete\" the eligible flag, so the skipNameCache's `??=` assignment will always be reevaluated.\n                // If this code branch is never hit, we return the initial value `false`, and this check will never be performed again.\n                // We do this check before the selector check, since this result is not generally cacheable.\n                ((eligible = undefined), !selector || matches(el, selector)) &&\n                stop(prefix ?? name)\n            ))\n        ) && // The empty string is also \"true\" since it means precense of the attribute without a value (as in `<div tag-yes />).\n          (!(value = el!.getAttribute(name)!) || bool(value, false)) &&\n          parseTagString(value, replace(prefix, /\\-/g, \":\"), tags),\n        eligible))\n  );\n\n// We cache the tracker configuration's rules for tag mappings.\nlet cachedTagMapper: (el: Element, tags: Set<string>) => void = () => {};\nlet cachedMappings: TagMappings | undefined;\nconst parseTagAttributes = (el: Element, tags: Set<string>) => {\n  if (cachedMappings === (cachedMappings = trackerConfig.tags)) {\n    return cachedTagMapper(el, tags);\n  }\n\n  const parse = (rule: TagMappings[string]): MatchAttributeRule[] =>\n      !rule\n        ? []\n        : regex(rule)\n        ? [[rule]]\n        : iterable(rule)\n        ? flatMap(rule, parse)\n        : [\n            obj(rule)\n              ? [regex(rule.match, false), rule.selector, rule.prefix]\n              : [regex(rule, false)],\n          ],\n    cache: CacheMatchRules = [\n      {},\n      // Start by checking whether we have any of the good ol', documented, \"tail.js official\" tag attributes.\n      [[/^(?:track\\-)?tags?(?:$|\\-)(.*)/], ...parse(values(cachedMappings))],\n    ];\n\n  (cachedTagMapper = (el: Element, tags: Set<string>) =>\n    matchAttributeNames(el, cache, tags))(el, tags);\n};\n\nconst cssPropertyWithBase = (el: Element, name: string) =>\n  concat2(\n    cssProperty(el, trackerPropertyName(name, T)),\n    cssProperty(el, trackerPropertyName(\"base-\" + name, T)),\n    \"\"\n  );\n\n// We cannot cache as broadly for CSS based rules, so we cache per selector instead.\nconst parsedCssRules: {\n  [rule: string]: CacheMatchRules;\n} = {};\n\nconst parseCssMappingRules = (\n  el: Element,\n  tags: Set<string>,\n  rulesString = cssPropertyWithBase(el, \"attributes\")\n) => {\n  matchAttributeNames(\n    el,\n    (parsedCssRules[rulesString] ??= [\n      {},\n      filter(\n        match(\n          rulesString,\n          /(?:(\\S+)\\:\\s*)?(?:\\((\\S+)\\)|([^\\s,:]+))\\s*(?!\\S*\\:)/g,\n          (_, prefix, rule1, rule2) =>\n            [regex(rule1 || rule2, false), , prefix] as const,\n          []\n        ),\n        T\n      ),\n    ]),\n    tags\n  );\n  parseTagString(cssPropertyWithBase(el, \"tags\"), undefined, tags);\n};\n\nlet currentBoundaryData: BoundaryData | Nullish;\nexport const trackerProperty = (\n  el: Element,\n  name: string,\n  inherit:\n    | boolean\n    | ((el: NodeWithParentElement, distance: number) => boolean) = F,\n  boundaryData?: (el: BoundaryData) => string | Nullish\n): string | null =>\n  (inherit\n    ? forAncestorsOrSelf(\n        el,\n        (el, r) => r(trackerProperty(el, name, F)),\n        fun(inherit, F)\n      )\n    : concat2(\n        attr(el, trackerPropertyName(name)),\n        cssProperty(el, trackerPropertyName(name, T))\n      )) ??\n  (boundaryData &&\n    (currentBoundaryData = getBoundaryData(el)) &&\n    boundaryData(currentBoundaryData)) ??\n  nil;\n\nlet propertyValue: string | Nullish;\nexport const trackerFlag = (\n  el: Element,\n  name: string,\n  inherit:\n    | boolean\n    | ((el: NodeWithParentElement, distance: number) => boolean) = F,\n  boundaryData?: (data: BoundaryData) => boolean | Nullish\n) =>\n  (propertyValue = trackerProperty(el, name, inherit, boundaryData as any)) ===\n    \"\" || (propertyValue == nil ? propertyValue : bool(propertyValue, T));\n\nexport type ParsedTags = { tags?: Tag[] };\n\nexport const parseTags = (\n  sourceEl: Element | Nullish,\n  stoppingCriterion?: (el: Element, distance: number) => boolean,\n  elementTagData?: (el: Element) => Iterable<Tag> | Nullish,\n  tags?: Set<string>\n): ParsedTags =>\n  !sourceEl\n    ? {}\n    : ((tags ??= hashSet<string>()),\n      parseCssMappingRules(sourceEl, tags),\n      forAncestorsOrSelf(\n        sourceEl,\n        (el) => {\n          parseTagAttributes(el, tags!);\n          parseTagString(map(elementTagData?.(el)), undefined, tags!);\n        },\n        stoppingCriterion\n      ),\n      size(tags) ? { tags: [...tags] } : {});\n\nlet styleElement: Node;\nexport const injectCssDefaults = (document: Document) => {\n  document.body.appendChild(\n    (((styleElement =\n      // --track-base-attributes and --track-base-tags are not set, since they are supposed to be inherited.\n      createElement(\"style\")).innerText = `* { ${trackerPropertyName(\n      \"tags\",\n      T\n    )}:; ${trackerPropertyName(\"attributes\", T)}:;}`),\n    styleElement)\n  );\n};\n","import { Encodable } from \"@tailjs/util\";\nimport {\n  F,\n  T,\n  TAB_ID,\n  array,\n  decode,\n  encode,\n  filter,\n  fun,\n  httpDecode,\n  httpDecrypt,\n  httpEncode,\n  httpEncrypt,\n  map,\n  mapSharedId,\n  nil,\n  now,\n  push,\n  shift,\n  timeout,\n  undefined,\n} from \".\";\n\nexport interface SimpleStorage {\n  getItem: (key: string) => string | null;\n  setItem: (key: string, value: string, timeout?: number) => void;\n  removeItem: (key: string) => void;\n\n  /**\n   * A flag whether the storage natively supports expiry of stale value. In that case, the timestamp for expiry will not be serialized.\n   * This is the case for cookies, so no need to bloat the scarce data capacity more than necessary.\n   */\n  supportsExpiry?: boolean;\n}\n\nexport interface StorageAccess {\n  <T extends Encodable = Encodable>(key: string): T | null;\n  <T extends Encodable>(key: string, value: T, timeout?: number): T;\n\n  <T extends Encodable>(\n    key: string,\n    value: (current: T) => T,\n    timeout?: number\n  ): T;\n}\n\nexport interface MappedStorageAccess<T extends Encodable> {\n  (): T | null;\n  (value: T, timeout?: number): T;\n  (value: (current: T) => T, timeout?: number): T;\n}\n\nexport interface ObservableStorageAccess extends StorageAccess {\n  <T extends Encodable | null>(\n    handler: StorageItemListener<T>,\n    self: boolean\n  ): () => boolean | void;\n}\n\nexport type StorageItemListener<T extends Encodable = Encodable> = (\n  key: string,\n  value: T | null,\n  oldValue: T | null,\n  sourceId: string | null\n) => boolean | void;\n\nconst memoryStorage = (): SimpleStorage => {\n  const values: Record<string, string> = {};\n  return {\n    getItem: (key) => values[key] as any,\n    setItem: (key, value) => (values[key] = value),\n    removeItem: (key) => delete values[key],\n  };\n};\n\ntype StorageEntry<T extends Encodable = Encodable> = [\n  value: T,\n  expires?: number,\n  source?: string\n];\n\nconst serialize = <T extends Encodable = Encodable>(\n  value: T,\n  expires?: number,\n  sourceId?: string | null,\n  secure = false\n): T extends null ? null : string =>\n  value == nil\n    ? nil\n    : ((secure ? httpEncrypt : httpEncode)(\n        sourceId || expires\n          ? {\n              $: [\n                value as any,\n                expires, // If there is a source ID we need a value to keep the array length.\n                sourceId,\n              ],\n            }\n          : value\n      ) as any);\n\nlet decoded: any, expires: number;\nconst deserialize = <T extends Encodable = Encodable>(\n  value: string | null,\n  removeExpired?: () => void,\n  secure = false\n): StorageEntry<T> | null =>\n  !value /* including empty string */\n    ? nil\n    : ((decoded = (secure ? httpDecrypt : httpDecode)(value)),\n      decoded.$\n        ? (((expires = +((decoded = decoded.$)[1] ?? 0)),\n          expires > 0 && expires < now(F)\n            ? (removeExpired?.(), nil)\n            : [decoded[0], expires, decoded[2]]) as StorageEntry<any>)\n        : [decoded]);\n\ntype StorageDelta = {\n  key: string | null;\n  newValue: string | null;\n  oldValue: string | null;\n};\n\ntype DeltaEventMapper = (\n  listener: (delta: StorageDelta) => void,\n  remove?: boolean\n) => void;\n\nlet entry: StorageEntry<Encodable> | null;\nlet oldEntry: StorageEntry<Encodable> | null;\nconst storage: {\n  (storage: SimpleStorage): StorageAccess;\n  (\n    storage: SimpleStorage,\n    register?: DeltaEventMapper,\n    secure?: boolean\n  ): ObservableStorageAccess;\n} = (\n  storage: SimpleStorage,\n  register?: DeltaEventMapper,\n  secure?: boolean\n): ObservableStorageAccess => {\n  const sourceId = register ? TAB_ID : undefined;\n  const removeExpired = (key: string | null) => () =>\n    key && storage.removeItem(key);\n\n  const ownListeners = new Set<StorageItemListener>();\n  const accessor = Object.assign((arg0: any, arg1?: any, arg2?: any): any => {\n    if (fun(arg0)) {\n      if (!register) return;\n      // Listener.\n      const [innerHandler, triggerSelf = F] = [arg0, arg1] as [\n        StorageItemListener,\n        boolean\n      ];\n\n      const handler: StorageItemListener = (...args) => {\n        let res = innerHandler(...args);\n        return res === F && unlisten?.();\n      };\n\n      const listener = ({ key, newValue, oldValue }: StorageEvent): any => (\n        ((entry = deserialize(newValue, removeExpired(key), secure)),\n        (oldEntry = deserialize(oldValue, undefined, secure))),\n        key &&\n          handler(\n            key,\n            entry?.[0] ?? nil,\n            oldEntry?.[0] ?? nil,\n            entry?.[2] ?? nil\n          )\n      );\n\n      let unlisten = () => (\n        (unlisten = nil!), register(listener, T), ownListeners.delete(handler)\n      );\n\n      register(listener);\n\n      triggerSelf && ownListeners.add(handler);\n      return unlisten;\n    }\n    let [key, value, timeout = 0] = [arg0, arg1, arg2] as [\n      string,\n      Encodable | ((current: any) => any) | undefined,\n      number\n    ];\n\n    if (value === undefined) {\n      // get\n      return (\n        deserialize(storage.getItem(key), removeExpired(key), secure)?.[0] ??\n        nil\n      );\n    }\n\n    if (fun(value)) {\n      //update\n      return accessor(key, value(accessor(key)), timeout);\n    }\n\n    // set\n    const data =\n      value == nil || timeout < 0\n        ? nil\n        : serialize(\n            value,\n            timeout && !storage.supportsExpiry ? now(T) + timeout : undefined,\n            sourceId,\n            secure\n          );\n\n    data == nil\n      ? storage?.removeItem(key)\n      : storage?.setItem(key, data, timeout > 0 ? timeout : undefined);\n\n    ownListeners.size &&\n      (((entry = deserialize(data, undefined, secure)),\n      (oldEntry = deserialize(storage.getItem(key), undefined, secure))),\n      ownListeners.forEach((handler) =>\n        handler(key, entry?.[0] ?? nil, oldEntry?.[0] ?? nil, entry?.[2] ?? nil)\n      ));\n    return value;\n  });\n  return accessor;\n};\n\nexport const cookieStorage: SimpleStorage = {\n  getItem: (key) => (\n    (key = encode(key)),\n    decode(\n      document.cookie\n        .split(\";\")\n        .map((kv) => kv.split(\"=\"))\n        .find((kv) => kv[0].trim() === key)?.[1] || nil\n    )\n  ),\n  setItem: (key, value, maxAge) =>\n    (document.cookie = `${encode(key)}=${encode(\n      value ?? \"\"\n    )}; Path=/; SameSite=Lax${\n      !value || maxAge != nil\n        ? `; Max-Age=${Math.round((maxAge ?? 0) / 1000)}`\n        : \"\"\n    }`),\n\n  removeItem: (key) => cookieStorage.setItem(key, \"\", 0),\n\n  supportsExpiry: true,\n};\n\nexport const memory = storage(memoryStorage());\nexport const cookies = storage(cookieStorage);\nexport const secureCookies = storage(cookieStorage, undefined, true);\nexport const session = storage(sessionStorage);\nexport const shared = storage(\n  localStorage,\n  (listener, remove) =>\n    remove\n      ? window.removeEventListener(\"storage\", listener)\n      : window.addEventListener(\"storage\", listener),\n  true\n);\nexport const bind = <T extends Encodable = Encodable>(\n  storage: StorageAccess,\n  key: string,\n  useSharedId = T\n): MappedStorageAccess<T> => {\n  useSharedId && (key = mapSharedId(key));\n  return (...args: any[]) => (storage as any)(key, ...args);\n};\n\nexport type SharedQueue<T extends Encodable = Encodable> = {\n  (item: T, replace?: boolean): () => boolean;\n  (): T | null;\n};\nexport const sharedQueue = <T extends Encodable>(\n  key: string,\n  keyExpiry = 2000,\n  useSharedId = T\n): SharedQueue<T> => {\n  const queue = bind<[item: T, expires: number][]>(shared, key, useSharedId);\n  return (item?: T, replace = F): any => {\n    if (item === undefined) {\n      // Get\n      let match: T | null = nil;\n      queue((current) => {\n        current = filter(current, (item) => item[1] > now());\n        match = shift(current)?.[0] ?? nil;\n        return current;\n      });\n\n      return match;\n    }\n\n    let exists = T;\n\n    const updateQueue = (replace: boolean) =>\n      queue((current) =>\n        replace\n          ? map(current, (other) =>\n              other[0] === item\n                ? ((exists = T), [item, now() + keyExpiry])\n                : (other as any)\n            )\n          : push(current ?? [], [item, now() + keyExpiry])!\n      );\n\n    updateQueue(replace);\n    if (keyExpiry) {\n      let poll = timeout();\n      const refreshKey = () => (updateQueue(T), !exists && poll(), exists);\n\n      poll(refreshKey, -keyExpiry / 2);\n    }\n    return () => exists;\n  };\n};\n","import { TrackedEvent } from \"@tailjs/types\";\nimport type { Nullish } from \"@tailjs/util\";\nimport {\n  T,\n  any,\n  del,\n  filter,\n  get,\n  getOrSet,\n  hashMap,\n  hashSet,\n  map,\n  set,\n} from \".\";\n\nconst dependencies = Symbol();\n\nconst cleared = hashSet<TrackedEvent>();\n\n// If an event refers to another event it will not get posted before that is posted.\n// That also means that if the referred event is never posted, neither is the event.\n// TODO: Evaluate if this may cause a memory leak.\nconst pendingDependencies = hashMap<TrackedEvent, Set<TrackedEvent>>();\nconst areAllDependenciesPosted = (ev: TrackedEvent) =>\n  !any(ev[dependencies], (dep) => !get(cleared, dep));\n\nexport const hasDependencies = (event: TrackedEvent) =>\n  !areAllDependenciesPosted(event) &&\n  (map(event[dependencies], (dep) =>\n    set(\n      getOrSet(pendingDependencies, dep, () => hashSet()),\n      event\n    )\n  ),\n  T);\n\nlet stalled: Set<TrackedEvent> | Nullish;\nexport const completeDependency = (event: TrackedEvent) => (\n  set(cleared, event),\n  (stalled = pendingDependencies.get(event)) && // Free memory when all dependant events are cleared\n    (!stalled.size && del(pendingDependencies, event),\n    filter(\n      stalled,\n      (dep) => areAllDependenciesPosted(dep) && (del(stalled!, dep), T)\n    ))\n);\n\nexport const addDependency = (\n  event: TrackedEvent,\n  dependency: TrackedEvent\n) => (\n  event !== dependency &&\n    ((event[dependencies] ??= []).push(dependency) as any),\n  event\n);\n","import type { Nullish } from \"@tailjs/util\";\nimport {\n  F,\n  Json,\n  T,\n  TAB_ID,\n  defer,\n  filter,\n  fun,\n  map,\n  mapSharedId,\n  nil,\n  shared,\n  shift,\n  size,\n} from \".\";\n\nexport interface MessageHandler<T extends Json = Json> {\n  (value: Exclude<T, null>, sourceId: string, direct: boolean): boolean | void;\n}\n\nexport type MessageSource = [sourceId: string, direct: boolean, self: string];\n\ntype HandlerArgs<F> = F extends (\n  source: MessageSource,\n  ...args: infer A\n) => void\n  ? A\n  : never;\n\ntype ExtractMessageTypes<T> = T extends {\n  [key in infer K]: (...args: any[]) => void;\n}\n  ? K extends string | number\n    ? [K, ...HandlerArgs<T[K]>]\n    : never\n  : never;\n\nexport interface Channel<Default extends Json = Json> {\n  <T extends Default>(handler: MessageHandler<T>, self?: boolean): () =>\n    | void\n    | boolean;\n  <T extends Default>(data: T, ...targetIds: (string | Nullish)[]): void;\n}\n\nexport const createChannel: {\n  <T extends Json = Json>(id: string): Channel<T>;\n  <\n    Handlers extends Record<\n      string | number,\n      (source: MessageSource, ...args: any[]) => void\n    >\n  >(\n    id: string,\n    handlers: Handlers,\n    self?: boolean\n  ): Channel<ExtractMessageTypes<Handlers>>;\n} = (id: any, handlers?: any, self?: any): any => {\n  id = mapSharedId(`c_${id}`);\n  const channelKey = id;\n\n  const getTargetKey = (targetId: string) => `${id}!${targetId}`;\n  const ownKey = getTargetKey(TAB_ID);\n\n  const channel = (arg0: any, ...rest: any[]): any => {\n    let cleared = T;\n    if (fun(arg0)) {\n      // Add listener.\n      return shared((key, value, _, sourceId) => {\n        if (\n          value != nil &&\n          sourceId &&\n          (key === channelKey || key === ownKey)\n        ) {\n          const result = (arg0 as MessageHandler)(\n            value,\n            sourceId,\n            key === ownKey\n          );\n\n          return result !== F;\n        }\n      }, (rest[0] ?? self) === T);\n    }\n    rest = filter(rest);\n\n    map(size(rest) ? map(rest, getTargetKey) : [id], (destinationKey) => {\n      cleared = F;\n      shared(destinationKey, arg0);\n      defer(() => cleared !== (cleared = T) && shared(destinationKey, nil));\n    });\n  };\n\n  if (handlers) {\n    channel((value: any, sourceId: string, direct: boolean) =>\n      handlers[shift(value) as any]?.(\n        [sourceId, direct, sourceId === TAB_ID],\n        ...value\n      )\n    );\n  }\n\n  return channel;\n};\n","import {\n  ERR_DUPPLICATE_KEY,\n  F,\n  T,\n  createChannel,\n  entries,\n  err,\n  eventSet,\n  fromEntries,\n  listen,\n  registerStartupHandler,\n  timeout,\n} from \".\";\n\nconst globalStateChannel = createChannel<1 | 2 | 3 | Record<string, any>>(\"ss\");\nconst globalStateResolvers: Record<string, [() => any, (value: any) => void]> =\n  {};\n\nconst [listeners, callListeners] = eventSet(true);\n\nexport { listeners as addGlobalStateResolvedListener };\n\nexport let globalStateResolved = F;\nconst resolveTimeout = timeout();\n\nexport const abortGlobalStateResolve = () => (resolveTimeout.finish(), T);\n\nexport const registerSharedState = <T>(\n  key: string,\n  resolve: () => T,\n  apply: (value: T | undefined) => void\n): ((updatedValue: T) => void) => (\n  globalStateResolvers[key]\n    ? err(ERR_DUPPLICATE_KEY, key)\n    : (globalStateResolvers[key] = [resolve, apply]),\n  (value) => globalStateChannel({ [key]: value })\n);\n\nregisterStartupHandler(() => {\n  resolveTimeout(() => ((globalStateResolved = T), callListeners()), 75);\n  let hasResponse = F;\n  globalStateChannel((payload, source) =>\n    payload === 1 // Ask out\n      ? globalStateChannel(2, source) // Offer state\n      : payload === 2\n      ? // Accept state once.\n        (hasResponse !== (hasResponse = T) && globalStateChannel(3, source), T)\n      : // We got picked for sharing the state\n      payload === 3\n      ? globalStateChannel(\n          fromEntries(\n            entries(globalStateResolvers, ([key, [resolve]]) => [\n              key,\n              resolve(),\n            ])\n          ),\n          source\n        )\n      : // Apply state\n        (entries(globalStateResolvers, ([key, [, apply]]) =>\n          apply(payload[key])\n        ),\n        resolveTimeout.finish())\n  );\n  // Ping on wakeup\n  globalStateChannel(1);\n\n  listen(window, \"pageshow\", () => !hasResponse && globalStateChannel(1));\n  listen(window, \"pagehide\", () => (hasResponse = F));\n});\n","import {\n  Expired,\n  F,\n  MAX_SAFE_INTEGER,\n  OpenPromise,\n  OpenPromiseWithTimeout,\n  Reset,\n  T,\n  TAB_ID,\n  TabId,\n  any,\n  clear,\n  createChannel,\n  debug,\n  defer,\n  del,\n  delay,\n  entries,\n  formatDuration,\n  getMinTabId,\n  keys,\n  listen,\n  nil,\n  now,\n  openPromise,\n  push,\n  registerStartupHandler,\n  size,\n  splice,\n  timeout,\n  trackerConfig,\n  tryAsync,\n  values,\n  window,\n} from \".\";\n\ntype Data = any;\ntype ActionId = string;\n\n// After this amount of ms it is assumed safe that all tabe have received a message sent from any other tab.\nconst MAX_MESSAGE_DELAY = 25;\nconst CLOSED_TAB_TIMEOUT = 500; // After this duration a closed tab is considered gone.\n\nexport type CommitAction<Data = any> = (\n  data: Data[],\n  critical: boolean\n) => Promise<boolean | void>;\n\nexport type ExitAction = (terminating: boolean) => void;\n\nconst enum MessageType {\n  /**\n   * Informs other tabs that a new tab loaded (either from bf cache or first load).\n   * The other tabs will reply with the same message to the new tab so it will know about all current tabs.\n   */\n  Loaded = 1,\n\n  /**\n   * Informs other tabs that a tab is unloading (either to bf cache or for good).\n   * When all tabs are unloading the last one will collect and commit their pending data.\n   *\n   */\n  Unloading = 2,\n\n  /**\n   * Broadcasts events that were collected in the tab.\n   */\n  Collect = 3,\n\n  /**\n   * Instructs a tab to coordinate a commit. It will do so if it has the smallest known tab ID, otherwise it will forward the request\n   * to the tab it thinks has the smallest ID.\n   */\n  Coordinate = 4,\n\n  /**\n   * Tabs will clear their collected data on this message. The tab that has the cooridnator ID will additionally commit it.\n   */\n  Commit = 5,\n\n  /**\n   * The tab received focus.\n   */\n  Activated = 6,\n\n  /**\n   * Tab lost focus.\n   */\n  Deactivated = 7,\n}\n\nexport type ActionHandler = [commit: CommitAction, exit?: ExitAction];\ntype ActionState = [\n  collected: Data[],\n  commitHandle: OpenPromiseWithTimeout<[success: boolean, items: number]>\n];\n\n// This is used to keep track of open and closing tabs so we can evaluate which tabs has the smalles ID (was opened first).\n// This tab must be the one comitting since it is the only one that is guaranteed to have seen all previous posts form other tabs.\n// This approach can also be thought of as an efficient algorithm for \"leader election\" to prevent multiple tabs making HTTP requests at the same time.\n// Interleaved HTTP requests must be avoided since it breaks the server state stored in the HTTP cookies.\n//\n// It cannot be prevented when all tabs are closing and an existing request has already been made to a slow server.\n// In this case the client flags the request to let the server know the the state should not be updated with the final request.\n// When this final race-condition occurs it is assumed _unlikely_ that the final request will contain other events than \"VIEW_END\" events (no \"VIEW\" events in particular),\n// so the book-keeping made for session duration, number of views,  previous session etc. is equally _unlikely_ to get out of sync.\nconst knownTabs: Record<\n  TabId,\n  number | null // If closed, at timestamp for when it happened.\n> = {};\n\nconst actionHandlers: Record<string, ActionHandler> = {};\n\nlet localData: Record<ActionId, Data[]> = {};\n\nconst flushLocalData = () => {\n  const currentData = localData;\n  localData = {};\n  return currentData;\n};\nexport const registerAction = <Data>(\n  id: ActionId,\n  ...actionHandler: ActionHandler\n): [\n  post: (...data: Data[]) => void,\n  commit: (critical?: boolean) => Promise<number>\n] => {\n  actionHandlers[id] = actionHandler;\n  return [\n    (...data) =>\n      size(data) &&\n      (push((localData[id] ??= []), ...data),\n      !closing &&\n        defer(\n          () =>\n            size(localData) && channel([MessageType.Collect, flushLocalData()])\n        )),\n    () => coordinateCommit(id),\n  ];\n};\n\nconst actionStates: Record<TabId, ActionState> = {};\nconst getActionState = (id: ActionId): ActionState =>\n  (actionStates[id] ??= [\n    [],\n    openPromise<[success: boolean, items: number]>(\n      trackerConfig.requestTimeout * 2\n    )([T, 0]),\n  ]);\n\nconst purgeClosedTabs = (timeout: number) =>\n  entries(\n    knownTabs,\n    ([key, value]) =>\n      value && Date.now() - value > timeout && del(knownTabs, key)\n  );\n\nconst getCoordinatorId = () => getMinTabId(TAB_ID, ...keys(knownTabs));\n\nconst isLastTab = () =>\n  !any(values(knownTabs), (closing) => !closing) &&\n  getCoordinatorId() === TAB_ID;\n\nconst channel = createChannel(\n  \"cs\",\n  {\n    [MessageType.Loaded]: ([sourceId, direct]) => {\n      knownTabs[sourceId] ??= nil;\n      !direct &&\n        sourceId !== TAB_ID &&\n        !closing &&\n        channel([MessageType.Loaded], sourceId);\n    },\n    [MessageType.Unloading](\n      [sourceId],\n      freezing: boolean,\n      data: Record<string, any>\n    ) {\n      knownTabs[sourceId] = Date.now();\n      entries(data, ([key, value]) => collect(key, value));\n      if (!freezing) {\n        keys(\n          actionHandlers,\n          (key) => isLastTab() && channel([MessageType.Commit, key, TAB_ID, T])\n        );\n      }\n    },\n\n    [MessageType.Collect](_, data: Record<ActionId, Data[]>) {\n      entries(data, ([key, value]) => collect(key, value));\n    },\n    [MessageType.Coordinate](_, actionId: ActionId) {\n      coordinateCommit(actionId);\n    },\n    [MessageType.Commit](\n      _,\n      actionId: ActionId,\n      coordinator: TabId,\n      critical: boolean\n    ) {\n      const [collected, handle] = getActionState(actionId);\n      const data = splice(collected, 0);\n      TAB_ID === coordinator &&\n        (async () => {\n          const n = size(data);\n          let success =\n            !n ||\n            ((await tryAsync(actionHandlers[actionId]?.[0](data, critical))) ??\n              T);\n\n          if (!success || n) {\n            debug(\n              `The action handler for '${actionId}' ${\n                success ? \"completed sucessfully\" : \"rejected\"\n              }.`\n            );\n          }\n\n          // The action did not succeed.\n          // It will only return false if it got cancelled or the server definitely failed in a way where the events will not get duplicated if posted again.\n          // Share the failed data with all tabs, instead of just keeping it locally, so it will get posted again even in the rare event where this tab got unloaded before the commit failed.\n          !success &&\n            (channel([MessageType.Collect, { [actionId]: data }]),\n            critical && debug(\"A critical request to commit got rejected.\"));\n\n          handle([success, n]);\n        })();\n    },\n    [MessageType.Activated]: ([sourceId]) => (\n      purgeClosedTabs(0), // At least one tab isn't closing. Purge the closed ones.\n      updatePollingTab(sourceId)\n    ),\n    [MessageType.Deactivated]: () => updatePollingTab(nil),\n  },\n  T\n);\n\nconst collect = (actionId: ActionId, data: Data[]) => {\n  return push(getActionState(actionId)[0], ...data);\n};\n\nlet closing = T;\nlet initPromise: OpenPromise | null = nil;\nconst init = async () => {\n  await initPromise;\n  if (closing === (closing = F)) {\n    return;\n  }\n  initPromise = openPromise();\n  try {\n    clear(knownTabs);\n    channel([MessageType.Loaded]);\n    // At this point we don't know how many tabs there are, if any. We need to wait a bit and see.\n    await delay(50);\n  } finally {\n    initPromise(T);\n  }\n};\n\nconst terminate = async (freeze: boolean) => {\n  if (closing === (closing = T)) {\n    return;\n  }\n  values(actionHandlers, (handler) => handler[1]?.(T));\n\n  channel([MessageType.Unloading, freeze, flushLocalData()]);\n  // We unloaded or froze. If we were the timeout leader (either coordinator or active) we need to tell the others that we deactivated.\n  toggleActive(F);\n};\n\nconst coordinateCommit = async (actionId: ActionId): Promise<number> => {\n  await initPromise;\n  if (closing) return 0; // Don't initiate commit when closing.\n\n  // If we are shutting down we will allow another tab shutting down to be elected as master. (Shutdown means all tabs are closed).\n  const coordinator = getCoordinatorId();\n  if (coordinator !== TAB_ID) {\n    channel([MessageType.Coordinate, actionId], coordinator);\n    return 0;\n  }\n\n  const handle = getActionState(actionId)[1];\n  const t0 = now(F);\n\n  let result = await handle;\n  handle(Reset);\n\n  channel([MessageType.Commit, actionId, TAB_ID, F]);\n  result = await handle;\n  debug(\n    result === Expired\n      ? `Commit timed out for '${actionId}.`\n      : !result[0] ||\n          (result[1] &&\n            `${result[0] ? \"Successfully comitted\" : \"Failed to commit\"} ${\n              result[1]\n            } items for '${actionId}' after ${formatDuration(now(F) - t0)}`)\n  );\n\n  return result[1];\n};\n\n// Timeout leader coordination\n\nlet safeTimeoutTimestamp: number = MAX_SAFE_INTEGER;\nlet selectedPollingTab: TabId | null = nil;\n\nconst updatePollingTab = (activeId: TabId | null) =>\n  (selectedPollingTab = activeId ??= getCoordinatorId()) === TAB_ID\n    ? (safeTimeoutTimestamp = Math.min(\n        safeTimeoutTimestamp,\n        now() + MAX_MESSAGE_DELAY\n      ))\n    : (safeTimeoutTimestamp = MAX_SAFE_INTEGER);\n\n// Polling for responses / regularly posting events etc.  must happen from intervals /timeouts in all tabs,\n// but only the one that is the \"timeout leader\" may execute the logic to avoid race conditions.\n// The coordinator can always be reached via messages (they are not throttled), but the tab in control of polling should preferably be the one that has focus\n// since background tabs are throttled.\nexport const isForegroundTab = () =>\n  initPromise?.() === T &&\n  (purgeClosedTabs(CLOSED_TAB_TIMEOUT), now() > safeTimeoutTimestamp);\n\nlet active = F;\nconst toggleActive = (toggle: boolean) =>\n  active !== (active = toggle) && toggle\n    ? channel([MessageType.Activated])\n    : !toggle &&\n      TAB_ID === selectedPollingTab &&\n      channel([MessageType.Deactivated]);\n\nregisterStartupHandler(() => {\n  listen(window, \"pageshow\", () => init());\n  listen(document, \"resume\" as any, () => init());\n  init();\n\n  listen(window, [\"beforeunload\", \"pagehide\"], () => terminate(F));\n  listen(document, \"freeze\" as any, () => terminate(T));\n\n  // Background flush event buffer.\n  timeout(\n    () =>\n      isForegroundTab() && keys(actionHandlers, (key) => coordinateCommit(key)),\n    -trackerConfig.postFrequency\n  );\n\n  listen(document, \"visibilitychange\", () =>\n    toggleActive(document.visibilityState === \"visible\")\n  );\n  listen(window, \"focus\", () => toggleActive(T));\n  listen(window, \"blur\", () => toggleActive(F));\n  toggleActive(document.visibilityState === \"visible\");\n});\n","import { MUTEX_REQUEST_COOKIE, MUTEX_RESPONSE_COOKIE } from \"@constants\";\nimport { EncodableObject } from \"@tailjs/util\";\nimport {\n  F,\n  T,\n  createChannel,\n  debug,\n  decompose,\n  eventSet,\n  formatDuration,\n  isForegroundTab,\n  nil,\n  now,\n  promise,\n  registerStartupHandler,\n  // cookies,\n  secureCookies,\n  timeout,\n  trackerConfig,\n  tryCatch,\n} from \".\";\n\nconst cookies = secureCookies;\n\n// If a post has not completed within this threshold concurrent posting may happen.\nconst ACTIVE_REQUEST_POLL = 25;\nconst PASSIVE_REQUEST_POLL = 500;\n\nconst [addResponseListener, callResponseHandlers] =\n  eventSet<[affinity: string, variables: EncodableObject]>();\n\nexport { addResponseListener };\n\nconst responseChannel = createChannel<true | { error: any }>(\"req\");\n\nconst checkResponseCookie = () => {\n  return (\n    tryCatch(() =>\n      decompose(\n        cookies<\n          [string, [string, number], string | undefined, EncodableObject]\n        >(MUTEX_RESPONSE_COOKIE),\n        (affinity, source, error, variables) => (\n          cookies(MUTEX_RESPONSE_COOKIE, nil),\n          debug(\n            `Got response for ${source?.[0]} after ${\n              source?.[1] ? formatDuration(now() - source[1]) : \"(unknown)\"\n            }.`\n          ),\n          callResponseHandlers(affinity, variables),\n          error\n            ? (responseChannel({ error }), debug(`Response error: ${error}`))\n            : responseChannel(T),\n          T\n        )\n      )\n    ) || F\n  );\n};\n\nconst responseTimeout = timeout();\n\nconst pollResponseCookie = () => (\n  isForegroundTab() && checkResponseCookie(),\n  responseTimeout(\n    pollResponseCookie,\n    cookies(MUTEX_REQUEST_COOKIE) ? ACTIVE_REQUEST_POLL : PASSIVE_REQUEST_POLL\n  )\n);\n\nregisterStartupHandler(() => pollResponseCookie());\n\nexport const tryAcquireRequestLock = async (\n  force: boolean,\n  source: string,\n  action: (forced: boolean) => boolean | any\n): Promise<boolean> => {\n  const sourceLabel = `(${source ?? \"(unknown)\"})`;\n  checkResponseCookie();\n  let forced = !!cookies(MUTEX_REQUEST_COOKIE);\n  if (!force && forced) {\n    debug(`Another request is currently in progress - request cancelled.`);\n    return F;\n  }\n  let t0 = now();\n  const cookieValue = [sourceLabel, t0];\n  cookies(MUTEX_REQUEST_COOKIE, cookieValue, trackerConfig.requestTimeout);\n  cookies(MUTEX_RESPONSE_COOKIE, nil);\n  if (action(forced) === F) {\n    cookies(MUTEX_REQUEST_COOKIE, nil);\n    return T;\n  }\n\n  return await promise<boolean>((resolve) =>\n    responseChannel((response) => (resolve(response === T), F), T)\n  );\n};\n","import type { TrackedEvent } from \"@tailjs/types\";\nimport { httpEncode } from \"@tailjs/util\";\nimport {\n  ERR_POST_FAILED,\n  F,\n  TAB_ID,\n  VAR_URL,\n  addResponseListener,\n  clean,\n  completeDependency,\n  debug,\n  err,\n  eventSet,\n  hasDependencies,\n  map,\n  navigator,\n  nil,\n  now,\n  push,\n  registerAction,\n  registerSharedState,\n  shift,\n  size,\n  splice,\n  startupLock,\n  tryAcquireRequestLock,\n} from \".\";\n\nconst [addPostListener, callPostListeners] =\n  eventSet<[events: TrackedEvent[]]>();\n\nconst [addShutdownListener, callShutdownListeners] = eventSet();\n\nexport {\n  addPostListener as addQueuePostListener,\n  addShutdownListener as addTerminationListener,\n};\nexport const enqueueEvent = (event: TrackedEvent) => {\n  const queue = [event];\n  const batch: TrackedEvent[] = [];\n  let ready: TrackedEvent[] | undefined;\n  while (queue.length) {\n    const event = shift(queue)!;\n    if (hasDependencies(event)) {\n      continue;\n    }\n    (ready = completeDependency(event)) && splice(queue, 1, 0, ...ready);\n\n    push(batch, event);\n  }\n  post(...batch);\n};\n\nconst [post, commit] = registerAction<TrackedEvent>(\n  \"events\",\n  async (events, force) => {\n    if (!size(events)) {\n      return F;\n    }\n    await startupLock;\n\n    if (force && !affinity) {\n      debug(\n        \"WARN: Force post downgraded to normal post because affinity has not been set.\"\n      );\n      force = F;\n    }\n    debug(\"Post started\");\n\n    callPostListeners(events);\n\n    return await tryAcquireRequestLock(force, TAB_ID, (discardCookies) => {\n      const t0 = now();\n      const postData = httpEncode([\n        map(\n          events,\n          (\n            ev,\n            _,\n            event = {\n              ...ev,\n              timestamp: Math.min(0, (ev.timestamp ??= t0) - t0),\n            }\n          ) => (clean(event), debug(event, nil, event.type), event)\n        ),\n        [affinity, discardCookies],\n      ]);\n      !navigator.sendBeacon(\n        VAR_URL,\n        new Blob([postData], {\n          // This content type avoids the overhead of the \"preflight\" request that is otherwise made by browsers in cross-domain scenarios.\n          // (application/x-www-form-urlencoded could also work).\n          type: \"text/plain\",\n        })\n      ) && err(ERR_POST_FAILED, events);\n    });\n  },\n  (terminating) => (terminating && callShutdownListeners(), undefined)\n);\n\nexport { commit };\n\n// Force posts will not happen before this is set.\nlet affinity: any | undefined;\nconst broadcastAffinity = registerSharedState(\n  \"affinity\",\n  () => affinity,\n  (value) => (affinity = value)\n);\nconst setAffinity = (value: any) => (\n  (affinity = value), broadcastAffinity(value)\n);\n\naddResponseListener(setAffinity);\n","import { F, T, addTerminationListener, del, hashSet, map } from \".\";\n\nexport type PendingActionHandle = (commit?: boolean) => void;\n\n// These will be flushed when / if the user leaves the page.\nconst activeHandles = hashSet<PendingActionHandle>();\n\nlet flushing = F;\n\nexport const noopAction: PendingActionHandle = () => {};\n\nexport const flushViewEndActions = () => {\n  flushing = T;\n  map(activeHandles, (item) => item(T));\n};\n\nexport const registerViewEndAction = (\n  action: (flushed: boolean) => void\n): PendingActionHandle => {\n  const handler = (commit = T) =>\n    del(activeHandles, handler) && commit && action(flushing);\n\n  activeHandles.add(handler);\n\n  return handler;\n};\n\naddTerminationListener(() => flushViewEndActions());\n","import type { UserAgentEvent } from \"@tailjs/types\";\nimport { window } from \"../lib\";\n\nexport const detectDeviceType = (): Pick<\n  UserAgentEvent,\n  \"deviceType\" | \"screen\"\n> => {\n  // Common thresholds based on https://yesviz.com/viewport/\n  const screen = window?.screen;\n  if (!screen) return {};\n\n  let { width: w, height: h, orientation: o } = screen; // Get's the resolution in logical (CSS) pixels.\n  const landscape = w < h;\n  const angle = o?.angle ?? window[\"orientation\"] ?? 0;\n  (angle === -90 || angle === 90) && ([w, h] = [h, w]);\n\n  return {\n    deviceType: w < 480 ? \"mobile\" : w <= 1024 ? \"tablet\" : \"desktop\",\n    screen: { dpr: window.devicePixelRatio, width: w, height: h, landscape },\n  };\n};\n","import { QUERY_DEVICE } from \"@constants\";\nimport {\n  HeartbeatEvent,\n  LocalID,\n  Timestamp,\n  UserAgentEvent,\n  UserInteractionEvent,\n  ViewEndedEvent,\n  ViewEvent,\n  ViewTimingEvent,\n  cast,\n  isViewEvent,\n} from \"@tailjs/types\";\nimport {\n  TrackerExtensionFactory,\n  detectDeviceType,\n  isChangeUserCommand,\n} from \"..\";\nimport {\n  F,\n  noopAction as NO_OP,\n  T,\n  addDependency,\n  assign,\n  debug,\n  del,\n  document,\n  eventSet,\n  forEach,\n  getViewportSize,\n  isForegroundTab,\n  isInternalUrl,\n  listen,\n  location,\n  map,\n  mark,\n  matchExHash,\n  navigator,\n  nextId,\n  nil,\n  now,\n  parseDomain,\n  parseParameters,\n  push,\n  registerSharedState,\n  registerViewEndAction,\n  replace,\n  session,\n  sharedQueue,\n  split,\n  timeout,\n  timer,\n  trackerConfig,\n  transpose,\n  undefined,\n  window,\n} from \"../lib\";\n\ntype TabInfo = [\n  id: LocalID,\n  created: Timestamp,\n  navigated: Timestamp,\n  views: number\n];\n\nlet currentViewEvent: ViewEvent | undefined;\n\nexport const getCurrentViewId = () => currentViewEvent?.id;\nconst [addViewChangedListener, viewChanged] = eventSet<[viewId: string]>();\nexport { addViewChangedListener };\n\nexport type ViewMessage = {\n  view?: { id: string; timing: UserInteractionEvent[\"timing\"] };\n  who?: LocalID;\n  vars?: [key: string, value: any, source: string][];\n};\n\nlet pushPopNavigation: ViewEvent[\"navigationType\"] | undefined;\n\nexport type ReferringViewData = [\n  viewId: LocalID,\n  relatedEventId: LocalID | undefined\n];\n\nconst referrers = sharedQueue<ReferringViewData>(\"ref\", 10000);\nexport const pushNavigationSource = (navigationEventId: LocalID) =>\n  referrers([currentViewEvent!.id, navigationEventId]);\n\nconst totalDuration = timer();\nconst visibleDuration = timer();\nconst interactiveDuration = timer();\n\nexport const getVisibleDuration = () => visibleDuration();\n\nconst [onFrame, callOnFrame] = eventSet<[frame: HTMLIFrameElement]>();\nexport { onFrame };\n\nconst knownFrames = new WeakSet<any>();\nconst frames = document.getElementsByTagName(\"iframe\");\n\nexport const context: TrackerExtensionFactory = {\n  id: \"context\",\n  setup(tracker) {\n    timeout(\n      () =>\n        forEach(\n          frames,\n          (frame) => mark(knownFrames, frame) && callOnFrame(frame)\n        ),\n      -1000\n    ).pulse();\n\n    let isNewTab = T;\n\n    let activations = 1;\n    let viewPosted = F; // Don't post heartbeats on hide before the view has been posted.\n\n    const tab = session<TabInfo>(\"t\", (current) => {\n      if ((isNewTab = !current)) {\n        return [nextId(), now(), now(), 0];\n      }\n      current[2] = now();\n      return current;\n    });\n    let firstTab = T;\n    registerSharedState(\n      \"first\",\n      () => F,\n      (first) => {\n        if (!first) {\n          firstTab = F;\n          currentViewEvent &&\n            del(currentViewEvent, [\"firstTab\", \"landingPage\"]);\n        }\n      }\n    );\n\n    let pendingViewEvent = NO_OP;\n    let pendingViewEndEvent = NO_OP;\n\n    let currentLocation: string | null = nil;\n    const postView = (force = F) => {\n      if (\n        matchExHash(\"\" + currentLocation, (currentLocation = location.href)) &&\n        !force\n      ) {\n        return;\n      }\n\n      pendingViewEvent();\n      pendingViewEndEvent();\n\n      totalDuration.reset();\n      visibleDuration.reset();\n      interactiveDuration.reset();\n\n      session<TabInfo>(\"t\", () => {\n        tab[2] = now();\n        ++tab[3];\n        return tab;\n      });\n\n      const { href, domain } = parseDomain(location.href) ?? {};\n      currentViewEvent = {\n        type: \"VIEW\",\n        timestamp: now(),\n        id: nextId(),\n        tab: tab[0],\n        href,\n        path: location.pathname,\n        hash: location.hash || undefined,\n        domain,\n        tabIndex: tab[3],\n        viewport: getViewportSize(),\n      };\n      viewChanged(currentViewEvent.id);\n\n      currentViewEvent.firstTab = firstTab;\n      firstTab && tab[3] === 1 && (currentViewEvent.landingPage = T);\n\n      // Query string\n      const trySplit = (s: string, sep: string, parts = split(s, sep)) =>\n        parts.length > 1 ? parts : nil;\n\n      const ps = parseParameters(replace(location.href, /^[^?]*\\??/, \"\"));\n      if (ps) {\n        const qs = (currentViewEvent!.queryString = transpose(ps, ([k, v]) => [\n          k.toLowerCase(),\n          v.length > 1\n            ? v\n            : trySplit(v[0], \"|\") ||\n              trySplit(v[0], \";\") ||\n              trySplit(v[0], \",\") ||\n              v,\n        ]));\n        map(\n          [\"source\", \"medium\", \"campaign\", \"term\", \"content\"],\n          (p, _) => ((currentViewEvent!.utm ??= {})[p] = qs[`utm_${p}`]?.[0])\n        );\n      }\n\n      !(currentViewEvent.navigationType = pushPopNavigation) &&\n        performance &&\n        map(\n          performance.getEntriesByType(\"navigation\"),\n          (entry: PerformanceNavigationTiming) => {\n            currentViewEvent!.redirects = entry.redirectCount;\n            currentViewEvent!.navigationType = replace(\n              entry.type,\n              /\\_/g,\n              \"-\"\n            ) as any;\n          }\n        );\n\n      pushPopNavigation = undefined;\n\n      if ((currentViewEvent.navigationType ??= \"navigate\") === \"navigate\") {\n        // Try find related event and parent tab context if any.\n        // And only if navigating (not back/forward/refresh)\n\n        if (isNewTab && isInternalUrl(document.referrer)) {\n          const referrer = referrers();\n\n          currentViewEvent.view = referrer?.[0];\n          currentViewEvent.related = referrer?.[1];\n        }\n      }\n\n      // Referrer\n      const referrer = document.referrer || nil;\n      referrer &&\n        !isInternalUrl(referrer) &&\n        (currentViewEvent!.externalReferrer = {\n          href: referrer,\n          domain: parseDomain(referrer)?.domain,\n        });\n\n      viewPosted = F;\n      pendingViewEvent = registerViewEndAction(\n        () => (\n          (viewPosted = T),\n          push(tracker, currentViewEvent),\n          currentViewEvent?.firstTab && push(tracker, { flush: T })\n        )\n      );\n      pendingViewEndEvent = registerViewEndAction(() => {\n        push(\n          tracker,\n\n          { type: \"VIEW_ENDED\", timing: {} } as ViewEndedEvent,\n\n          {\n            set: { view: undefined },\n          }\n        );\n        isNewTab = F;\n      });\n\n      push(tracker, {\n        get: {\n          view: (view: any) => (currentViewEvent!.definition = view),\n          rendered: () => {\n            // Allow some extra time for gossiping to figure out if we are the only tab.\n            // This will also ensure that the view is set on the event if both `view` and `rendered` are set in the same `set` command.\n            timeout(pendingViewEvent, 100);\n          },\n        },\n      });\n\n      tracker.push({\n        get: {\n          [QUERY_DEVICE]: (value) => {\n            if (!value || !isForegroundTab()) return;\n            push(\n              tracker,\n              cast<UserAgentEvent>({\n                type: \"USER_AGENT\",\n                hasTouch: navigator.maxTouchPoints > 0,\n                userAgent: navigator.userAgent,\n                view: currentViewEvent?.id,\n                languages: map(\n                  navigator.languages,\n                  (id, i, parts = split(id, \"-\")) =>\n                    cast<UserAgentEvent[\"languages\"]>({\n                      id,\n                      language: parts[0],\n                      region: parts[1],\n                      primary: i === 0,\n                      preference: i + 1,\n                    })\n                ),\n                timezone: {\n                  iana: Intl.DateTimeFormat().resolvedOptions().timeZone,\n                  offset: new Date().getTimezoneOffset(),\n                },\n                ...detectDeviceType(),\n              })\n            );\n          },\n        },\n      });\n    };\n\n    const interactiveTimeout = timeout();\n    listen(\n      document,\n      [\"pointermove\", \"scroll\", \"pointerdown\", \"keydown\"],\n      () => {\n        interactiveDuration(T);\n        interactiveTimeout(() => interactiveDuration(F), 10000);\n      }\n    );\n\n    listen(document, \"visibilitychange\", () => {\n      if (document.visibilityState === \"hidden\") {\n        visibleDuration(F);\n        interactiveDuration(F);\n      } else {\n        visibleDuration(T);\n        ++activations;\n      }\n    });\n\n    listen(\n      window,\n      \"popstate\",\n      () => ((pushPopNavigation = \"back-forward\"), postView())\n    );\n    map([\"push\", \"replace\"], (name) => {\n      const inner = history[(name += \"State\")];\n      history[name] = (...args: any) => {\n        inner.apply(history, args);\n        pushPopNavigation = \"navigate\";\n        postView();\n      };\n    });\n\n    postView();\n\n    const heartbeat = timeout();\n    const resetHeartbeat = () =>\n      viewPosted &&\n      trackerConfig.heartbeatFrequency > 0 &&\n      heartbeat(\n        () =>\n          isForegroundTab() &&\n          tracker.push(cast<HeartbeatEvent>({ type: \"HEARTBEAT\", timing: {} })),\n        -trackerConfig.heartbeatFrequency\n      );\n\n    resetHeartbeat();\n\n    return {\n      processCommand(command) {\n        if (isChangeUserCommand(command)) {\n          tracker.push(\n            command.username\n              ? { type: \"LOGIN\", username: command.username }\n              : { type: \"LOGOUT\" }\n          );\n          return T;\n        }\n        return F;\n      },\n      decorate(event) {\n        resetHeartbeat();\n\n        if (!currentViewEvent || isViewEvent(event)) return;\n        const view = currentViewEvent?.id,\n          ctx = {\n            view,\n            timing: (event as ViewTimingEvent)?.timing && {\n              activations,\n              totalTime: totalDuration(),\n              visibleTime: visibleDuration(),\n              interactiveTime: interactiveDuration(),\n            },\n          };\n\n        ctx && (assign(event, ctx), addDependency(event, currentViewEvent));\n      },\n    };\n  },\n};\n","import {\n  AnchorNavigationEvent,\n  CartUpdatedEvent,\n  ComponentClickEvent,\n  ConfiguredComponent,\n  NavigationEvent,\n  UserInteractionEvent,\n  cast,\n  isViewEndedEvent,\n} from \"@tailjs/types\";\nimport {\n  TrackerExtensionFactory,\n  getComponentContext,\n  onFrame,\n  pushNavigationSource,\n  tryGetCartEventData,\n} from \"..\";\n\nimport { CONTEXT_MENU_COOKIE } from \"@constants\";\nimport type { Nullish } from \"@tailjs/util\";\nimport { parseActivationTags } from \"..\";\nimport {\n  F,\n  MNT_URL,\n  T,\n  any,\n  attr,\n  attrl,\n  clear,\n  cookies,\n  del,\n  document,\n  encode,\n  equals,\n  forAncestorsOrSelf,\n  getBoundaryData,\n  getScreenPos,\n  getViewport,\n  isInternalUrl,\n  keys,\n  listen,\n  location,\n  map,\n  mapUrl,\n  matchExHash,\n  navigator,\n  nextId,\n  nil,\n  noopAction,\n  obj,\n  parseDomain,\n  push,\n  registerViewEndAction,\n  tagName,\n  timeout,\n  trackerConfig,\n  trackerFlag,\n  tryCatch,\n  window,\n} from \"../lib\";\n\nconst isLinkElement = (\n  el: Element,\n  href: any = tagName(el) === \"A\" && attr(el, \"href\")\n): el is HTMLAnchorElement =>\n  href && href != \"#\" && !href.startsWith(\"javascript:\");\n\nconst isClickable = (\n  el: Element,\n  t = tagName(el),\n  attr = trackerFlag(el, \"button\")\n): el is HTMLElement =>\n  attr !== F &&\n  (equals(t, \"A\", \"BUTTON\") ||\n    (t === \"INPUT\" && equals(attrl(el, \"type\"), \"button\", \"submit\")) ||\n    attr === T);\n\nfunction getElementLabel(el: Element | EventTarget | null, container: Element) {\n  let info: Pick<UserInteractionEvent, \"element\"> | undefined;\n  forAncestorsOrSelf(el ?? container, (el) =>\n    equals(tagName(el), \"IMG\") || el === container\n      ? ((info = {\n          element: {\n            tagName: el.tagName,\n            text:\n              attr(el, \"title\") ||\n              attr(el, \"alt\") ||\n              (el as HTMLElement).innerText?.trim().substring(0, 100) ||\n              undefined,\n          },\n        }),\n        F)\n      : T\n  );\n  return info;\n}\nexport const userInteraction: TrackerExtensionFactory = {\n  id: \"navigation\",\n\n  setup(tracker) {\n    const pollContextCookie = timeout();\n\n    // There can be all kinds of fishy navigation logic happening, so it is not enough just to look at link (<A>) clicks.\n    // Hence, when navigation occurs (in the current tab), we do not send the event before we have an VIEW_END.\n    // We rely on that the logic for VIEW_END takes care all the different ways to navigate (history.push etc.) so this is where we know that navigation happened for sure.\n    let pendingNavigationEvent = noopAction;\n\n    const stripPositions = <T = any>(el: any, hitTest: boolean): T =>\n      hitTest\n        ? el\n        : (map(keys(el), (key) =>\n            key === \"rect\" ||\n            //key === \"pos\"  Changed so pos is always included.\n            key === \"viewport\"\n              ? del(el, key)\n              : obj(el[key]) &&\n                map(el[key], (item) => stripPositions(item, hitTest))\n          ),\n          el);\n    const trackDocument = (document: Document) => {\n      listen(\n        document,\n        [\"click\", \"contextmenu\", \"auxclick\"],\n        (ev: MouseEvent) => {\n          // Cancel whatever we might be waiting for.\n          pendingNavigationEvent?.(F);\n\n          let trackClicks: boolean | Nullish;\n          let trackRegion: boolean | Nullish;\n          let clickableElement: HTMLElement | null = nil! as HTMLElement; // Typescript insists this is never?\n\n          let nav = F;\n\n          forAncestorsOrSelf<boolean>(ev.target, (el) => {\n            clickableElement ??= isClickable(el) ? el : nil;\n            nav = nav || tagName(el) === \"NAV\";\n\n            let cmp: ConfiguredComponent | ConfiguredComponent[] | Nullish;\n\n            trackClicks ??=\n              trackerFlag(el, \"clicks\", T, (data) => data.track?.clicks) ??\n              ((cmp = getBoundaryData(el)?.component) &&\n                any(cmp, (cmp) => cmp.track?.clicks !== F));\n            trackRegion ??=\n              trackerFlag(el, \"region\", T, (data) => data.track?.region) ??\n              ((cmp = getBoundaryData(el)?.component) &&\n                any(cmp, (cmp) => cmp.track?.region));\n          });\n\n          if (!clickableElement) {\n            return;\n          }\n          const componentContext = getComponentContext(clickableElement);\n          const tags = parseActivationTags(clickableElement);\n          trackClicks ??= !nav;\n          trackRegion ??= T;\n\n          const sharedEventProperties = {\n            ...(trackRegion\n              ? {\n                  pos: getScreenPos(clickableElement, ev),\n                  viewport: getViewport(),\n                }\n              : nil),\n            ...getElementLabel(ev.target, clickableElement),\n            ...componentContext,\n            ...tags,\n            timing: {},\n          };\n\n          if (isLinkElement(clickableElement!)) {\n            const external = clickableElement.hostname !== location.hostname;\n            const { domain, href } = parseDomain(clickableElement.href);\n            if (\n              clickableElement.host === location.host &&\n              clickableElement.pathname === location.pathname &&\n              clickableElement.search === location.search\n            ) {\n              if (clickableElement.hash === \"#\") {\n                // Don't care about that one.\n                return;\n              }\n              if (clickableElement.hash !== location.hash) {\n                push(\n                  tracker,\n                  cast<AnchorNavigationEvent>({\n                    type: \"ANCHOR_NAVIGATION\",\n                    anchor: clickableElement.hash,\n                    ...sharedEventProperties,\n                  })\n                );\n              }\n              return;\n            }\n\n            const navigationEvent: NavigationEvent = cast<NavigationEvent>({\n              id: nextId(),\n              type: \"NAVIGATION\",\n              href: external ? clickableElement.href : href,\n              external,\n              domain,\n              self: T,\n              anchor: clickableElement.hash,\n              ...sharedEventProperties,\n            });\n\n            if (ev.type === \"contextmenu\") {\n              const referrerConsumed = pushNavigationSource(navigationEvent.id);\n\n              const currentUrl = clickableElement.href;\n              const internalUrl = isInternalUrl(currentUrl);\n\n              if (!internalUrl) {\n                if (!trackerConfig.captureContextMenu) return;\n                clickableElement.href = mapUrl(\n                  MNT_URL,\n                  \"=\",\n                  encode(currentUrl)\n                );\n                tryCatch(\n                  () =>\n                    navigator.userActivation?.isActive &&\n                    navigator.clipboard.writeText(currentUrl)\n                );\n              }\n\n              const flag = Date.now();\n              cookies(CONTEXT_MENU_COOKIE, flag, 11000);\n              pollContextCookie(() => {\n                (clickableElement as HTMLAnchorElement).href = currentUrl;\n                if (\n                  !referrerConsumed() ||\n                  +cookies(CONTEXT_MENU_COOKIE)! === flag + 1\n                ) {\n                  cookies(CONTEXT_MENU_COOKIE, nil);\n                  navigationEvent.self = F;\n                  push(tracker, navigationEvent);\n                  clear(pollContextCookie);\n                }\n              }, -100);\n\n              let unbindAll = listen(\n                document,\n                [\"keydown\", \"keyup\", \"visibilitychange\", \"pointermove\"],\n                () =>\n                  unbindAll() &&\n                  clear(pollContextCookie, 10000, () =>\n                    cookies(CONTEXT_MENU_COOKIE, \"\")\n                  )\n              );\n            } else if (ev.button <= 1) {\n              if (\n                ev.button === 1 || //Middle-click: new tab.\n                ev.ctrlKey || // New tab\n                ev.shiftKey || // New window\n                ev.altKey || // Download\n                attr(clickableElement, \"target\") !== window.name\n              ) {\n                pushNavigationSource(navigationEvent.id);\n                navigationEvent.self = F;\n                // Fire immediately, we are staying on the page.\n                push(tracker, navigationEvent);\n                return;\n              } else if (!matchExHash(location.href, clickableElement.href)) {\n                navigationEvent.exit = navigationEvent.external;\n                // No \"real\" navigation will happen if it is only the hash changing.\n                pushNavigationSource(navigationEvent.id);\n              }\n\n              // If it so happened that navigation happened we will send it on VIEW_END.\n              pendingNavigationEvent = registerViewEndAction(() =>\n                push(tracker, navigationEvent)\n              );\n            }\n            return;\n          }\n\n          const cart = tryGetCartEventData(ev.target as Element);\n          (cart || trackClicks) &&\n            push(\n              tracker,\n              cart\n                ? cast<CartUpdatedEvent>({\n                    type: \"CART_UPDATED\",\n                    ...sharedEventProperties,\n                    ...cart,\n                  })\n                : cast<ComponentClickEvent>({\n                    type: \"COMPONENT_CLICK\",\n                    ...sharedEventProperties,\n                  })\n            );\n          return;\n        }\n      );\n    };\n\n    trackDocument(document);\n    onFrame(\n      (frame) => frame.contentDocument && trackDocument(frame.contentDocument)\n    );\n\n    return {\n      decorate(eventData) {\n        if (isViewEndedEvent(eventData)) {\n          pendingNavigationEvent(T);\n        }\n      },\n    };\n  },\n};\n","import {\n  type CartAction,\n  type CartEventData,\n  type CartUpdatedEvent,\n  type OrderEvent,\n} from \"@tailjs/types\";\nimport type { Nullish } from \"@tailjs/util\";\nimport { TrackerExtensionFactory, isCartCommand, isOrderCommand } from \"..\";\nimport {\n  F,\n  T,\n  equals,\n  forAncestorsOrSelf,\n  getBoundaryData,\n  item,\n  nil,\n  obj,\n  push,\n  str,\n  trackerProperty,\n  undefined,\n} from \"../lib\";\n\nexport const parseCartEventData = (\n  data: boolean | string | CartEventData | Nullish\n): CartEventData | undefined => (\n  data == nil ? undefined : (data === T || data === \"\") && (data = \"add\"),\n  str(data) && equals(data, \"add\", \"remove\", \"update\", \"clear\")\n    ? { action: data as CartAction }\n    : obj(data)\n    ? data\n    : undefined\n);\n\nfunction normalizeCartEventData(data: CartEventData | Nullish) {\n  if (!data) return undefined;\n\n  if (data.units != nil && equals(data.action, nil, \"add\", \"remove\")) {\n    if (data.units === 0) return undefined;\n    data.action = data.units > 0 ? \"add\" : \"remove\";\n  }\n  return data;\n}\n\nexport function tryGetCartEventData(sourceElement: Element) {\n  // Find cart. Look for cart attributes and/or data until the first content is met.\n  let contextCart: CartEventData | Nullish;\n  forAncestorsOrSelf(\n    sourceElement,\n    (el, r) =>\n      !!(contextCart ??= parseCartEventData(\n        getBoundaryData(el)?.cart ?? trackerProperty(el, \"cart\")\n      )) &&\n      !contextCart.item &&\n      (contextCart.item = item(getBoundaryData(el)?.content, -1)) &&\n      r(contextCart)\n  );\n\n  return normalizeCartEventData(contextCart);\n}\n\nexport const commerce: TrackerExtensionFactory = {\n  id: \"cart\",\n  setup(tracker) {\n    return {\n      processCommand(command) {\n        if (isCartCommand(command)) {\n          let cart = command.cart;\n          cart === \"clear\"\n            ? push(tracker, {\n                type: \"CART_UPDATED\",\n                action: \"clear\",\n              } as CartUpdatedEvent)\n            : (cart = normalizeCartEventData(cart)!) &&\n              push(tracker, {\n                ...cart,\n                type: \"CART_UPDATED\",\n              } as CartUpdatedEvent);\n\n          return T;\n        }\n        if (isOrderCommand(command)) {\n          push(tracker, {\n            type: \"ORDER\",\n            ...command.order,\n          } as OrderEvent);\n\n          return T;\n        }\n        return F;\n      },\n    };\n  },\n};\n","import {\n  ImpressionEvent,\n  cast,\n  type ActivatedComponent,\n  type ActivatedContent,\n  type ConfiguredComponent,\n  type Rectangle,\n  type UserInteractionEvent,\n} from \"@tailjs/types\";\nimport {\n  BoundaryCommand,\n  BoundaryData,\n  TrackerExtensionFactory,\n  getVisibleDuration,\n  isDataBoundaryCommand,\n  isScanComponentsCommand,\n} from \"..\";\nimport {\n  F,\n  NodeWithParentElement,\n  PendingActionHandle,\n  T,\n  any,\n  boundaryData,\n  clear,\n  concat,\n  del,\n  filter,\n  flatMap,\n  forAncestorsOrSelf,\n  forEach,\n  get,\n  getRect,\n  getScreenPos,\n  getViewport,\n  join,\n  map,\n  max,\n  nil,\n  parseTags,\n  push,\n  registerViewEndAction,\n  scanAttributes,\n  set,\n  size,\n  str,\n  timeout,\n  timer,\n  trackerConfig,\n  trackerFlag,\n  trackerProperty,\n  undefined,\n  unshift,\n} from \"../lib\";\nexport type ActivatedDomComponent = ConfiguredComponent & ActivatedComponent;\n\nexport const componentDomConfiguration = Symbol(\"DOM configuration\");\n\nexport const parseActivationTags = (el: Element) =>\n  parseTags(el, undefined, (el) => map(get(boundaryData, el)?.tags));\n\nconst hasComponentOrContent = (boundary?: BoundaryData | null) =>\n  boundary?.component || boundary?.content;\n\nlet entry: BoundaryData | undefined;\nexport const parseBoundaryTags = (el: Element) =>\n  parseTags(\n    el,\n    (ancestor) =>\n      ancestor !== el && !!hasComponentOrContent(get(boundaryData, ancestor)),\n    (el) =>\n      (entry = get(boundaryData, el)) &&\n      concat(\n        flatMap([entry.component, entry.content], (item) =>\n          flatMap(item, (item) => map(item.tags, F))\n        ),\n        entry.tags\n      )\n  );\n\nlet content: ActivatedContent[] | undefined;\nconst stripRects = (\n  component: ActivatedDomComponent,\n  keep?: boolean\n): ActivatedDomComponent =>\n  keep\n    ? component\n    : {\n        ...component,\n        rect: undefined,\n        content:\n          (content = component.content) &&\n          map(content, (content) => ({ ...content, rect: undefined })),\n      };\n\nconst enum IncludeState {\n  Secondary = 0,\n  Primary = 1,\n  Promoted = 2,\n}\n\nconst setContext = timeout();\n\nexport const getComponentContext = (\n  el: NodeWithParentElement,\n  directOnly = F\n) => {\n  clear(setContext);\n\n  let collectedContent: ActivatedContent[] = [];\n\n  type Area = {} & string; // For clarity.\n  let collected: (ActivatedDomComponent | Area)[] = [];\n\n  let includeState = IncludeState.Secondary;\n  let rect: Rectangle | undefined;\n  forAncestorsOrSelf(el, (el) => {\n    const entry = get(boundaryData, el);\n    if (!entry) {\n      return;\n    }\n\n    if (hasComponentOrContent(entry)) {\n      const components = filter(\n        entry.component,\n        (entry) =>\n          includeState === IncludeState.Secondary ||\n          (!directOnly &&\n            ((includeState === IncludeState.Primary &&\n              entry.track?.secondary !== T) ||\n              entry.track?.promote))\n      );\n\n      rect =\n        (any(components, (item) => item.track?.region) && getRect(el)) ||\n        undefined;\n      const tags = parseBoundaryTags(el);\n      entry.content &&\n        unshift(\n          collectedContent,\n          ...map(entry.content, (item) => ({\n            ...item,\n            rect,\n            ...tags,\n          }))\n        );\n\n      components.length &&\n        (unshift(\n          collected,\n          ...map(\n            components,\n            (item) => (\n              (includeState = max(\n                includeState,\n                item.track?.secondary // INV: Secondary components are only included here if we did not have any components from a child element.\n                  ? IncludeState.Primary\n                  : IncludeState.Promoted\n              )),\n              stripRects(\n                {\n                  ...item,\n                  content: collectedContent,\n                  rect,\n                  ...tags,\n                },\n                !!rect\n              )\n            )\n          )\n        ),\n        (collectedContent = []));\n    }\n\n    const area = entry.area || trackerProperty(el, \"area\");\n    area && unshift(collected, ...map(area));\n  });\n\n  let areaPath: string[] | undefined;\n  let components: ActivatedComponent[] | undefined;\n\n  if (collectedContent.length) {\n    // Content without a contaning component is gathered in an ID-less component.\n    push(collected, stripRects({ id: \"\", rect, content: collectedContent }));\n  }\n\n  forEach(collected, (item) => {\n    if (str(item)) {\n      push((areaPath ??= []), item);\n    } else {\n      item.area ??= join(areaPath, \"/\");\n      unshift((components ??= []), item);\n    }\n  });\n\n  return components || areaPath\n    ? { components: components, area: join(areaPath, \"/\") }\n    : undefined;\n};\n\nconst intersectionHandler = Symbol();\nexport const components: TrackerExtensionFactory = {\n  id: \"components\",\n  setup(tracker) {\n    const observer = new IntersectionObserver(\n      (els) =>\n        forEach(\n          els,\n          ({ target, isIntersecting, boundingClientRect, intersectionRatio }) =>\n            target[intersectionHandler]?.(\n              isIntersecting,\n              boundingClientRect,\n              intersectionRatio\n            )\n        ),\n      // Low thresholds used to be able to handle components larger than viewports\n      { threshold: [0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.75] }\n    );\n\n    function registerComponent({ boundary: el, ...command }: BoundaryCommand) {\n      let update =\n        \"add\" in command\n          ? (current: BoundaryData) =>\n              cast<BoundaryData>({\n                ...current,\n                component: concat(current?.component, command.component),\n                content: concat(current?.content, command.content),\n                area: command?.area ?? current?.area,\n                tags: concat(current?.tags, command.tags),\n                cart: command.cart ?? current?.cart,\n                track: command.track ?? current?.track,\n              })\n          : command[\"update\"];\n\n      set(boundaryData, el, update ?? command);\n\n      let components: ConfiguredComponent[] | undefined;\n      if (\n        (components = filter(\n          get(boundaryData, el)?.component,\n          (cmp) =>\n            // Impression settings from the DOM/CSS are ignorred for secondary and inferred components (performance thing)\n            cmp!.track?.impressions ||\n            (cmp.track?.secondary ?? cmp.inferred) !== T\n        ))\n      ) {\n        if (!size(components)) {\n          return;\n        }\n\n        let visible = F;\n        let impressions = 0;\n        let event: PendingActionHandle | null = nil;\n        let fold: number;\n        const captureState = timeout();\n        const t = timer(() => getVisibleDuration(), F);\n\n        el[intersectionHandler] = (\n          intersecting: boolean,\n          rect: DOMRectReadOnly,\n          ratio: number\n        ) => {\n          intersecting =\n            ratio >= 0.75 ||\n            (rect.top < (fold = window.innerHeight / 2) && rect.bottom > fold);\n\n          t(intersecting);\n          if (visible !== (visible = intersecting)) {\n            //el[\"style\"].border = visible ? \"2px solid blue\" : \"\";\n            if (visible) {\n              captureState(() => {\n                ++impressions;\n                if (!event) {\n                  const events = filter(\n                    map(\n                      components,\n                      (cmp) =>\n                        ((cmp!.track?.impressions ||\n                          trackerFlag(\n                            el,\n                            \"impressions\",\n                            T,\n                            (data) => data.track?.impressions\n                          )) &&\n                          cast<ImpressionEvent>({\n                            type: \"IMPRESSION\",\n                            pos: getScreenPos(el),\n                            viewport: getViewport(),\n                            ...getComponentContext(el, T),\n                          })) ||\n                        nil\n                    )\n                  );\n                  event = registerViewEndAction(() =>\n                    push(\n                      tracker,\n                      ...map(\n                        events,\n                        (ev) => (\n                          ((ev.duration = t()), (ev.impressions = impressions)),\n                          ev\n                        )\n                      )\n                    )\n                  );\n                }\n              }, -trackerConfig.impressionThreshold);\n            } else {\n              clear(captureState); // Not visible, clear timeout.\n            }\n          }\n          !el.isConnected && (event?.(), (event = nil));\n        };\n        observer.observe(el);\n      }\n    }\n\n    return {\n      decorate(eventData) {\n        // Strip tracking configuration.\n        forEach((eventData as UserInteractionEvent).components, (component) =>\n          del(component as any, \"track\")\n        );\n      },\n      processCommand(cmd) {\n        return isDataBoundaryCommand(cmd)\n          ? (registerComponent(cmd), T)\n          : isScanComponentsCommand(cmd)\n          ? (map(\n              scanAttributes(cmd.scan.attribute, cmd.scan.components),\n              registerComponent\n            ),\n            T)\n          : F;\n      },\n    };\n  },\n};\n","import { QUERY_DEVICE } from \"@constants\";\nimport { TrackedEvent, isConsentEvent, isTrackedEvent } from \"@tailjs/types\";\nimport type { Nullish } from \"@tailjs/util\";\nimport {\n  Listener,\n  Tracker,\n  TrackerCommand,\n  TrackerConfiguration,\n  TrackerExtension,\n  defaultExtensions,\n  isExtensionCommand,\n  isFlushCommand,\n  isGetCommand,\n  isListenerCommand,\n  isSetCommand,\n  isTagAttributesCommand,\n  isToggleCommand,\n  isTrackerAvailableCommand,\n} from \".\";\nimport {\n  ERR_INTERNAL_ERROR,\n  ERR_INVALID_COMMAND,\n  F,\n  T,\n  USR_URL,\n  addGlobalStateResolvedListener,\n  addQueuePostListener,\n  addResponseListener,\n  array,\n  assign,\n  commit,\n  createChannel,\n  define,\n  del,\n  enqueueEvent,\n  entries,\n  err,\n  filter,\n  fun,\n  globalStateResolved,\n  httpDecode,\n  isTracker,\n  listen,\n  map,\n  mapUrl,\n  nextId,\n  nil,\n  now,\n  openPromise,\n  push,\n  registerSharedState,\n  setStorageKey,\n  size,\n  sort,\n  splice,\n  startupComplete,\n  str,\n  trackerConfig,\n  tryCatch,\n  variables,\n  window,\n} from \"./lib\";\n\nexport let tracker: Tracker;\nexport const initializeTracker = (config: TrackerConfiguration | string) => {\n  if (tracker) return tracker;\n  str(config) && (config = httpDecode(config)!);\n\n  // Make sure the configuration has all parameters set to valid values.\n  map(\n    [\"vars\", \"hub\"],\n    (p) => !fun(config[p]) && (config[p] = mapUrl(config[p]))\n  );\n\n  assign(trackerConfig, config);\n  setStorageKey(del(trackerConfig, \"clientKey\"));\n  const apiKey = del(trackerConfig, \"apiKey\");\n\n  const queuedCommands = window[trackerConfig.name] ?? [];\n  if (!array(queuedCommands)) {\n    err(\n      `The global variable for the tracker \"${trackerConfig.name}\" is used for something else than an array of queued commands.`\n    );\n    return;\n  }\n\n  // Extensions / listeners\n  const extensions: [number, TrackerExtension][] = [];\n  let listeners: Listener[] = [];\n  // Extensions may post commands when constructed and while the tracker is initializing\n\n  const callListeners = (event: string, ...args: any[]) => {\n    let keep = T;\n    listeners = filter(listeners, (listener) =>\n      tryCatch(\n        () => (\n          listener[event]?.(...args, {\n            tracker: tracker,\n            unsubscribe: () => (keep = F),\n          }),\n          keep // Will be set synchronously in the unsubscribe handler before this value is returned.\n        )\n      )\n    );\n  };\n  addQueuePostListener((events) => callListeners(\"post\", events));\n  const pendingStateCommands: TrackerCommand[] = [];\n  addGlobalStateResolvedListener(\n    () => pendingStateCommands.length && push(tracker, ...pendingStateCommands)\n  );\n\n  // Variables\n\n  const localVariables = Object.fromEntries(\n    map(\n      [\"view\", \"tags\", \"rendered\", \"loaded\", \"scripts\", QUERY_DEVICE],\n      (key) => [key, T]\n    )\n  );\n\n  let publicVariables: [string, string][];\n  const [getVars, setVars] = variables(\n    tracker,\n    (kvs) =>\n      size((publicVariables = filter(kvs, ([key]) => !localVariables[key]))) &&\n      updateVariables(publicVariables)\n  );\n  addResponseListener((_, variables) => setVars(variables));\n\n  const updateVariables = registerSharedState(\n    \"vars\",\n    () =>\n      map(\n        filter(entries(getVars()), ([key]) => !localVariables[key]),\n        ([key, value]) => [key, value] as const\n      ),\n    (vars) => vars && setVars(vars, T)\n  );\n\n  // Main\n\n  let mainArgs: TrackerCommand[] | null = nil;\n  let currentArg = 0;\n  let insertArgs = F;\n\n  define(window, {\n    [trackerConfig.name]: [\n      (tracker = define(\n        {},\n        {\n          id: [nextId()],\n          push: [\n            (...commands: TrackerCommand[]) => {\n              if (!mainArgs && apiKey) {\n                if (commands[0] !== apiKey) {\n                  throw new Error(\"Invalid API key.\");\n                }\n                commands.splice(0, 1);\n              }\n\n              if (!commands.length) {\n                return;\n              }\n\n              commands = commands.flatMap(\n                (command) => (\n                  !command\n                    ? command\n                    : typeof command === \"string\" &&\n                      (command = httpDecode<TrackerCommand>(command)),\n                  array(command) ? command : [command]\n                )\n              );\n\n              let flush = F; // // Flush after these commands, optionally without waiting for other requests to finish (because the page is unloading and we have no better option even though it may split sessions.)\n\n              commands = filter(commands, (command) => {\n                if (!command) return F;\n\n                if (isTagAttributesCommand(command)) {\n                  trackerConfig.tags = assign(\n                    {},\n                    trackerConfig.tags,\n                    command.tagAttributes\n                  );\n                } else if (isToggleCommand(command)) {\n                  trackerConfig.disabled = command.disable;\n                  return F;\n                } else if (isFlushCommand(command)) {\n                  flush = T;\n                  return F;\n                } else if (isTrackerAvailableCommand(command)) {\n                  command(tracker);\n                  return F;\n                }\n                if (\n                  !globalStateResolved &&\n                  !isListenerCommand(command) &&\n                  !isExtensionCommand(command)\n                ) {\n                  pendingStateCommands.push(command);\n                  return F;\n                }\n                // #endregion\n                return T;\n              });\n\n              if (!commands.length && !flush) {\n                return;\n              }\n\n              const getCommandRank = (cmd: TrackerCommand) =>\n                isExtensionCommand(cmd)\n                  ? -100\n                  : isListenerCommand(cmd)\n                  ? -50\n                  : isSetCommand(cmd)\n                  ? -10\n                  : isTrackedEvent(cmd)\n                  ? 90\n                  : 0;\n\n              // Put events last to allow listeners and interceptors from the same batch to work on them.\n              // Sets come before gets to avoid unnecessary waiting\n              // Extensions then listeners are first so they can evaluate the rest.\n              const expanded: TrackerCommand[] = sort(commands, getCommandRank);\n\n              // Allow nested calls to tracker.push from listerners and interceptors. Insert commands in the currently processed main batch.\n              if (\n                mainArgs &&\n                splice(\n                  mainArgs,\n                  insertArgs ? currentArg + 1 : mainArgs.length,\n                  0,\n                  ...expanded\n                )\n              )\n                return;\n\n              mainArgs = expanded;\n\n              for (currentArg = 0; currentArg < mainArgs.length; currentArg++) {\n                if (!mainArgs[currentArg]) continue;\n                tryCatch(\n                  () => {\n                    const command = mainArgs![currentArg];\n                    callListeners(\"command\", command);\n                    insertArgs = F;\n                    if (isTrackedEvent(command)) {\n                      command.timestamp ??= now();\n                      if (isConsentEvent(command)) {\n                        splice(mainArgs, currentArg + 1, 0, {\n                          set: { consent: command.nonEssentialTracking },\n                        });\n                      }\n\n                      insertArgs = T;\n                      let skip = F;\n                      map(extensions, ([, extension], i) => {\n                        if (\n                          skip ||\n                          extension.decorate?.(command as TrackedEvent) === F\n                        ) {\n                          skip = T;\n                        }\n                      });\n\n                      if (skip) {\n                        return; // Skip event and process next command.\n                      }\n\n                      enqueueEvent(command);\n                    } else if (isGetCommand(command)) {\n                      getVars(command.get, command.timeout);\n                    } else if (isSetCommand(command)) {\n                      setVars(command.set);\n                      map(entries(command.set), ([key, value]) =>\n                        callListeners(\"set\", key, value)\n                      );\n                    } else if (isListenerCommand(command)) {\n                      push(listeners, command.listener);\n                    } else if (isExtensionCommand(command)) {\n                      let extension: TrackerExtension | Nullish;\n                      if (\n                        (extension = tryCatch(\n                          () => command.extension.setup(tracker),\n                          (e) => err(nil, command.extension, e)\n                        ))\n                      ) {\n                        push(extensions, [command.priority ?? 100, extension]);\n                        sort(extensions, ([priority]) => priority);\n                      }\n                    } else if (isTrackerAvailableCommand(command)) {\n                      command(tracker); // Variables have already been loaded once.\n                    } else {\n                      let success = F;\n                      for (const [, extension] of extensions) {\n                        if (\n                          (success = extension.processCommand?.(command) ?? F)\n                        ) {\n                          break;\n                        }\n                      }\n                      !success && err(ERR_INVALID_COMMAND, command);\n                    }\n                  },\n                  (e) => err(ERR_INTERNAL_ERROR, nil, e)\n                );\n              }\n\n              mainArgs = nil;\n              if (flush) {\n                commit();\n              }\n            },\n          ],\n          [isTracker]: [T],\n        }\n      ) as any),\n    ],\n  });\n\n  startupComplete();\n\n  push(\n    tracker,\n    { set: { loaded: T } },\n    ...map(defaultExtensions, (extension) => ({ extension })),\n    ...queuedCommands\n  );\n\n  return tracker;\n};\n","import type { Component, ExternalReference } from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  attr,\n  document,\n  get,\n  hashSet,\n  map,\n  nil,\n  parseInt,\n  push,\n  set,\n  split,\n  str,\n} from \".\";\nimport type { BoundaryCommand } from \"..\";\n\ntype MappedComponent = [\n  command: {\n    component?: Component;\n    content?: ExternalReference;\n    area?: string;\n  },\n  elements: HTMLElement[]\n];\nexport function scanAttributes(\n  attributeName: string,\n  references: MappedComponent[0][]\n): BoundaryCommand[] {\n  if (!references) return [];\n  const commands: BoundaryCommand[] = [];\n\n  const seen = hashSet<any>();\n  document.querySelectorAll(`[${attributeName}]`).forEach((el) => {\n    if (get(seen, el)) {\n      return;\n    }\n\n    const stack: any[] = [];\n\n    while (attr(el, attributeName) != nil) {\n      set(seen, el);\n      const delta = split(attr(el, attributeName)!, \"|\");\n      attr(el, attributeName, nil);\n      for (let i = 0; i < delta.length; i++) {\n        let item: any = delta[i];\n        if (item === \"\") {\n          continue; // If the attribute starts with \"|\" it means \"keep stack\". Splitting the array on \"|\" will give an empty item.\n        }\n        const number = item === \"-\" ? -1 : parseInt(str(item, F) ?? \"\", 36);\n        if (number < 0) {\n          stack.length += number;\n          continue;\n        } else if (i === 0) {\n          stack.length = 0; // The first item has an value to replace the stack since not preceded by neither \"|\" nor an negative number (pop).\n        }\n\n        if (isNaN(number) && /^[\"\\[{]/.test(item)) {\n          // Poor man's parser. If the JSON contains '|'s keep going until it works.\n          let json = \"\";\n          for (; i < delta.length; i++) {\n            try {\n              item = JSON.parse((json += delta[i]));\n              break;\n            } catch (e) {}\n          }\n        }\n\n        if (number >= 0 && references[number]) {\n          item = references[number];\n        }\n        stack.push(item);\n      }\n      push(\n        commands,\n        ...map(stack, (data) => ({ add: T, ...data, boundary: el }))\n      );\n      const next = el.nextElementSibling!; // Ignore TS null error.\n      if (el.tagName === \"WBR\") {\n        el.parentNode?.removeChild(el);\n      }\n      el = next;\n    }\n  });\n\n  return commands;\n}\n","import { ScrollEvent, cast } from \"@tailjs/types\";\nimport { addViewChangedListener, type TrackerExtensionFactory } from \"..\";\nimport {\n  T,\n  defer,\n  listen,\n  map,\n  push,\n  relativeScrollPos,\n  scrollPos,\n  window,\n} from \"../lib\";\n\nexport const scroll: TrackerExtensionFactory = {\n  id: \"scroll\",\n  setup(tracker) {\n    let emitted: Partial<Record<Required<ScrollEvent>[\"scrollType\"], boolean>> =\n      {};\n    let initialScroll = scrollPos(T);\n\n    addViewChangedListener(() =>\n      defer(() => ((emitted = {}), (initialScroll = scrollPos(T))), 250)\n    );\n\n    listen(window, \"scroll\", () => {\n      const scroll = scrollPos();\n      const offset = relativeScrollPos();\n\n      if (scroll.y >= initialScroll.y) {\n        const types: (keyof typeof emitted)[] = [];\n\n        !emitted[\"fold\"] &&\n          scroll.y >= initialScroll.y + 200 &&\n          ((emitted[\"fold\"] = T), types.push(\"fold\"));\n\n        !emitted[\"page-middle\"] &&\n          offset.y >= 0.5 &&\n          ((emitted[\"page-middle\"] = T), types.push(\"page-middle\"));\n\n        !emitted[\"page-end\"] &&\n          offset.y >= 0.99 &&\n          ((emitted[\"page-end\"] = T), types.push(\"page-end\"));\n\n        const mapped = map(types, (scrollType) =>\n          cast<ScrollEvent>({\n            type: \"SCROLL\",\n            scrollType,\n            offset,\n          })\n        );\n\n        mapped.length && push(tracker, mapped);\n      }\n    });\n  },\n};\n","import { FormEvent, FormField, Timestamp, cast } from \"@tailjs/types\";\nimport type { Nullish } from \"@tailjs/util\";\nimport {\n  TrackerExtensionFactory,\n  addViewChangedListener,\n  getComponentContext,\n  getVisibleDuration,\n  onFrame,\n} from \"..\";\nimport {\n  NodeWithParentElement,\n  T,\n  addTerminationListener,\n  attr,\n  document,\n  entries,\n  get,\n  getOrSet,\n  getRect,\n  item,\n  listen,\n  map,\n  nil,\n  now,\n  push,\n  replace,\n  scopeAttr,\n  timeout,\n  trackerFlag,\n  trackerPropertyName,\n  undefined,\n  uuidv4,\n} from \"../lib\";\n\ntype FormElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\n\nconst enum FormFillState {\n  None = 0,\n  Submitted = 1,\n  Pending = 2,\n  Submitting = 3,\n}\n\ntype FormState = [\n  event: FormEvent,\n  fields: WeakMap<Element, FormFieldState>,\n  element: HTMLFormElement,\n  fillState: FormFillState,\n  started: Timestamp,\n  nextFillOrder: number\n];\n\nconst currentValue = Symbol();\ntype FormFieldState = FormField & {\n  [currentValue]: string;\n};\n\nexport const forms: TrackerExtensionFactory = {\n  id: \"forms\",\n  setup(tracker) {\n    const formEvents = new Map<HTMLFormElement, FormState>();\n\n    const getFormFieldValue = (element: any): string =>\n      element.selectedOptions\n        ? [...element.selectedOptions].map((option) => option.value).join(\",\")\n        : element.type === \"checkbox\"\n        ? element.checked\n          ? \"yes\"\n          : \"no\"\n        : element.value;\n\n    const getFormState = (\n      el: FormElement\n    ): [input: FormElement, state: FormState] | undefined => {\n      const formElement = el.form;\n      if (!formElement) return; // Don't care if we started with an element that didn't map to a field.\n\n      const refName =\n        scopeAttr(formElement, trackerPropertyName(\"ref\")) || \"track_ref\";\n\n      const parseElements = () => {\n        map(\n          formElement.querySelectorAll(\n            \"INPUT,SELECT,TEXTAREA\"\n          ) as NodeListOf<FormElement>,\n          (el, i) => {\n            if (!el.name || el.type === \"hidden\") {\n              if (\n                el.type === \"hidden\" &&\n                (el.name === refName || trackerFlag(el, \"ref\"))\n              ) {\n                !el.value && (el.value = uuidv4());\n                state[0].ref = el.value;\n              }\n              return;\n            }\n\n            const name = el.name;\n            const field = (state[0].fields![name] ??= {\n              id: el.id || name,\n              name,\n              label: replace(\n                item(el.labels, 0)?.innerText ?? el.name,\n                /^\\s*(.*?)\\s*\\*?\\s*$/g,\n                \"$1\"\n              ),\n              activeTime: 0,\n              type: el.type ?? \"unknown\",\n              [currentValue as any]: getFormFieldValue(el),\n            }) as FormFieldState;\n\n            state[0].fields![field.name] = field;\n            state[1].set(el, field);\n          }\n        );\n      };\n\n      let capturedContext: ReturnType<typeof getComponentContext>;\n\n      const isFormVisible = () =>\n        formElement.isConnected && getRect(formElement).width;\n\n      const state = getOrSet(formEvents, formElement, () => {\n        const fieldMap = new Map<Element, FormFieldState>();\n        const ev: FormEvent = {\n          type: \"FORM\",\n          name:\n            scopeAttr(formElement, trackerPropertyName(\"form-name\")) ||\n            attr(formElement, \"name\") ||\n            formElement.id ||\n            undefined,\n          activeTime: 0,\n          totalTime: 0,\n          fields: {},\n        };\n\n        let state: FormState;\n        const commitEvent = () => {\n          handleLostFocus(); // focusout or change events may not be called when the user leaves the page while a field has focus.\n\n          // If the form has disappeared it is heuristically assumed it was submitted successfully.\n          state[3] >= FormFillState.Pending &&\n            (ev.completed =\n              state[3] === FormFillState.Submitting || !isFormVisible());\n          push(\n            tracker,\n            cast<FormEvent>({\n              ...capturedContext,\n              ...ev,\n              totalTime: now(T) - state[4],\n            })\n          );\n          state[3] = FormFillState.Submitted;\n        };\n\n        addViewChangedListener(commitEvent);\n        addTerminationListener(commitEvent);\n\n        const commitTimeout = timeout();\n\n        listen(formElement, \"submit\", () => {\n          capturedContext = getComponentContext(formElement);\n          state[3] = FormFillState.Submitting;\n\n          commitTimeout(() => {\n            // If the form disappears within 750 ms but no navigation happens it is assumed that it was \"submitted\" somehow, e.g. via AJAX.\n            // This heurtistic may result in false positives if the user clicks submit, gets vaildation errors and then leaves the site instantly.\n            //\n            // If the server is aggressively slow to respond to a post and the for goes back into pending state,\n            // it is undefined whether the submit happened or not, if the user leaves the site before the server responds.\n            // In this case it will count as abandondment.\n\n            if (formElement.isConnected && getRect(formElement).width > 0) {\n              state[3] = FormFillState.Pending;\n              commitTimeout();\n            } else {\n              commitEvent();\n            }\n          }, 750);\n        });\n\n        return (state = [\n          ev,\n          fieldMap,\n          formElement,\n          FormFillState.None,\n          now(T),\n          1,\n        ]);\n      });\n      if (!get(state[1], el)) {\n        // This will also be the case if a new field was added to the DOM.\n        parseElements();\n      }\n      return [el!, state];\n    };\n\n    const getFieldInfo = (\n      el: NodeWithParentElement,\n      [formElement, state] = getFormState(el as any) ?? [],\n      field = state?.[1].get(formElement as Element)\n    ) => field && ([state![0], field, formElement!, state!] as const);\n\n    let currentField: ReturnType<typeof getFieldInfo> | null = nil;\n    const handleLostFocus = () => {\n      if (!currentField) return;\n\n      const [form, field, el, state] = currentField;\n      const active = -(tv0 - (tv0 = getVisibleDuration()));\n      const total = -(t0 - (t0 = now(T)));\n\n      const previousValue = field[currentValue];\n      const newValue = (field[currentValue] = getFormFieldValue(el));\n\n      if (newValue !== previousValue) {\n        field.fillOrder ??= state[5]++;\n        if (field.filled) {\n          field.corrections = (field.corrections ?? 0) + 1;\n        }\n        field.filled = T;\n\n        state[3] = FormFillState.Pending;\n        entries(\n          form.fields!,\n          ([name, value]) =>\n            (value.lastField = name === field.name || undefined)\n        );\n      }\n\n      field.activeTime! += active;\n      field.totalTime! += total;\n      form.activeTime! += active;\n      currentField = nil;\n    };\n\n    let tv0 = 0;\n    let t0 = 0;\n    const wireFormFields = (document: Document | Nullish) => {\n      document &&\n        listen(\n          document,\n          [\"focusin\", \"focusout\", \"change\"],\n          (ev, _, current = getFieldInfo(ev.target)) => {\n            current &&\n              ((currentField = current),\n              ev.type === \"focusin\"\n                ? ((t0 = now(T)), (tv0 = getVisibleDuration()))\n                : handleLostFocus());\n          }\n        );\n    };\n\n    wireFormFields(document);\n    onFrame((frame) => frame.contentDocument && wireFormFields);\n  },\n};\n","import {\n  TrackerExtensionFactory,\n  commerce,\n  components,\n  context,\n  forms,\n  scroll,\n  userInteraction,\n} from \"..\";\n\nexport const defaultExtensions: TrackerExtensionFactory[] = [\n  context,\n  components,\n  userInteraction,\n  scroll,\n  commerce,\n  forms,\n];\n","export const commandTest =\n  <T = any>(...name: any[]) =>\n  (command: any): command is T =>\n    command === name[0] ||\n    name.some(\n      (name) => typeof name === \"string\" && command?.[name] !== undefined\n    );\n","import { CartEventData } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Triggers events related to a shopping cart.\n */\nexport interface CartCommand {\n  cart: \"clear\" | CartEventData;\n}\n\nexport const isCartCommand = commandTest<CartCommand>(\"cart\");\n","import type { Nullish } from \"@tailjs/util\";\nimport { commandTest } from \"./shared\";\n\nexport interface ChangeUserCommand {\n  username: string | Nullish;\n}\n\nexport const isChangeUserCommand = commandTest<ChangeUserCommand>(\"username\");\n","import type { TagMappings } from \"..\";\nimport { commandTest } from \"./shared\";\n\nexport type TagAttributesCommand = {\n  tagAttributes: TagMappings;\n};\nexport const isTagAttributesCommand =\n  commandTest<TagAttributesCommand>(\"tagAttributes\");\n","import { commandTest } from \"./shared\";\n\n/**\n * Enables or disables tracking.\n */\nexport type ToggleCommand = {\n  disable: boolean;\n};\nexport const isToggleCommand = commandTest<ToggleCommand>(\"disable\");\n","import type {\n  CartAction,\n  CartEventData,\n  ConfiguredComponent,\n  Content,\n  Tag,\n  TrackingSettings,\n} from \"@tailjs/types\";\n\nimport { commandTest } from \"./shared\";\n\nexport interface BoundaryData {\n  /**\n   * The component definition(s) associated with the boundary element.\n   */\n  component?: ConfiguredComponent | ConfiguredComponent[] | null;\n\n  /**\n   * The content definition(s) associated with the boundary element.\n   */\n  content?: Content | Content[] | null;\n\n  /**\n   * The name of the content area associated with the boundary element.\n   *\n   * A content area is used to indicate where activated components are used.\n   */\n  area?: string | null;\n\n  /**\n   *  These tags will be added to the components and content in user activations with the boundary element or any of its descendants.\n   */\n  tags?: Tag | Tag[] | null;\n\n  /**\n   * The element will include cart data when activated.\n   */\n  cart?: CartAction | CartEventData;\n\n  /**\n   * Settings that will apply to components contained by the boundary element including itself, similar to specifying \"track-*\" HMTL attributes on the element.\n   */\n  track?: TrackingSettings;\n}\n\n/**\n * Registers an element as the boundary for a component or similar tracking data. All events triggered from the element or its descendants will have this information attached.\n * In case of nested boundaries the closest one is used.\n */\nexport type BoundaryCommand = {\n  boundary: Element;\n} & (\n  | (BoundaryData & {\n      /**\n       * The content, tags and components will be added to the existing, if any.\n       */\n      add?: boolean;\n    })\n  | { update: (current?: BoundaryData) => BoundaryData | null }\n);\n\n// {\n//   /**\n//    * The component definition(s) associated with the boundary element.\n//    */\n//   component?: ConfiguredComponent | ConfiguredComponent[] | null;\n\n//   /**\n//    * The content definition(s) associated with the boundary element.\n//    */\n//   content?: Content | Content[] | null;\n\n//   /**\n//    * The name of the content area associated with the boundary element.\n//    *\n//    * A content area is used to indicate where activated components are used.\n//    */\n//   area?: string | string[] | null;\n\n//   /**\n//    *  These tags will be added to the components and content in user activations with the boundary element or any of its descendants.\n//    */\n//   tags?: Tag | Tag[] | null;\n\n//   /**\n//    * The element will include cart data when activated.\n//    */\n//   cart?: CartAction | CartEventData;\n\n//   /**\n//    * The element's component will be included in the stack even when the activation tracking level is `direct`.\n//    */\n//   promote?: boolean;\n\n//   /**\n//    * Specifies how the this command modifies the data associated with the boundary element.\n//    *\n//    * Only properties present in this command are affected (e.g. `component` or `content`) unless the action is `clear`.\n//    *\n//    * @default \"add\"\n//    */\n//   action?: \"add\" | \"remove\" | \"clear\";\n\n//   /**\n//    * The DOM element that gets this command's data associated.\n//    */\n//   boundary: Element;\n// }\n\nexport const isDataBoundaryCommand = commandTest<BoundaryCommand>(\"boundary\");\n","import type { TrackerExtensionFactory } from \"..\";\nimport { commandTest } from \"./shared\";\n\nexport interface ExtensionCommand {\n  extension: TrackerExtensionFactory;\n  priority?: number;\n}\nexport const isExtensionCommand = commandTest<ExtensionCommand>(\"extension\");\n","import { T } from \"../lib/alias\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Causes all queued events to be posted to the server immediately.\n */\nexport type FlushCommand = { flush: boolean; force?: boolean; defer?: boolean };\nexport const isFlushCommand = commandTest<FlushCommand>(T, \"flush\");\n","import type { ReservedVariables, Tracker } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/** Used to get a context variable from the tracker. This is async, so if a key is anticipated to eventually be set, the callback will wait for it if does not already have a value.\n * This command can also be used for polling by returning `true` from the callback in which case it will be called everytime the value is set (not necessarily with a changed value).\n *\n */\nexport interface GetCommand {\n  /**\n   * If the functions returns true it will be triggered again if the value changes.\n   */\n  get: Record<string, GetCallback> & {\n    [key in keyof ReservedVariables]?: GetCallback<ReservedVariables[key]>;\n  };\n  /**\n   * If no one has set the value after this amount of ms, the callback will be triggered with `undefined` as the value and a flag indicating that the request timed out.\n   * If set to zero the callback will always be called synchronously with either the value or undefined if it is not defined.\n   * Negative values means \"no timeout\".\n   */\n  timeout?: number;\n}\n\n/**\n * The callback that is called for {@link GetCommand}s when a tracker variable is set or changed.\n * To enable/simplify polling the callback gets triggered again next time the variable changes if it returns `true`.\n */\nexport type GetCallback<T = any> = (\n  /** The current value of the variable in the tracker. */\n  value: T | undefined,\n\n  /** The key for which the callback is registered.  */\n  key: string,\n\n  /** Whether the callback is called with an undefined value because the timeout elapsed. */\n  timeout: boolean,\n\n  /** The tracker where the variable was set. */\n  tracker: Tracker\n) => any | true;\n\nexport const isGetCommand = commandTest<GetCommand>(\"get\");\n","import type { Listener } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Registers a listener that will be invoked before and after events are flushed.\n * Useful for debugging or client-side integration with other tracker libraries (if one absolutely must).\n */\nexport interface ListenerCommand {\n  listener: Listener;\n}\nexport const isListenerCommand = commandTest<ListenerCommand>(\"listener\");\n","import { Order, OrderEvent } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Shorthand command to trigger an {@link OrderEvent} event.\n */\nexport interface OrderCommand {\n  /**\n   * The order that was completed or cancelled.\n   */\n  order: Order;\n}\n\nexport const isOrderCommand = commandTest<OrderCommand>(\"order\");\n","import type { Component, ExternalReference } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\nexport type ComponentOrContent =\n  | { component: Component }\n  | { content: ExternalReference };\n\n/**\n * Registers an element as the boundary for a component. All events triggered from the element or its descendants will have this information attached.\n * In case of nested boundaries the closest one is used.\n */\nexport interface ScanComponentsCommand {\n  scan: {\n    attribute: string;\n    components: ComponentOrContent[];\n  };\n}\n\nexport const isScanComponentsCommand =\n  commandTest<ScanComponentsCommand>(\"scan\");\n","import type { ReservedVariables } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Set the specified properties in the tracker's variables\n */\nexport interface SetCommand {\n  /** An object where the names of the properties correspond to the variables set in the tracker. */\n  set: Record<string, any> & Partial<ReservedVariables>;\n}\n\nexport const isSetCommand = commandTest<SetCommand>(\"set\");\n","import type { Tracker, TrackerCommand } from \"..\";\n\nexport type TrackerAvailableCommand = (tracker: Tracker) => void;\nexport const isTrackerAvailableCommand = (\n  command: TrackerCommand\n): command is (tracker: Tracker) => void => typeof command === \"function\";\n","import {\n  array,\n  entries,\n  err,\n  ERR_ARGUMENT_ERROR,\n  F,\n  item,\n  map,\n  obj,\n  push,\n  T,\n  tryCatch,\n  undefined,\n} from \".\";\nimport { GetCallback, Tracker } from \"..\";\n\nexport type Variables = [\n  get: {\n    (): Record<string, any>;\n    (values: Record<string, GetCallback>, timeout?: number): void;\n  },\n  set: {\n    (key: string, value: any, passive?: boolean): void;\n    (values: Record<string, any>, passive?: boolean): void;\n    (values: [string, any][], passive: boolean): void;\n  }\n];\n\nexport const variables = (\n  tracker: Tracker,\n  listen?: (values: [key: string, value: any][]) => void\n): Variables => {\n  const data: Record<string, any> = {};\n\n  const callbacks: Record<string, GetCallback[]> = {};\n\n  const getCallbacks = (\n    key: string,\n    reset: boolean\n  ): [previous: GetCallback[], current: GetCallback[]] => [\n    (callbacks[key] ??= []),\n    reset ? (callbacks[key] = []) : callbacks[key],\n  ];\n\n  const set = (...args: any[]) => {\n    const passive = item(args, -1) === T;\n    const kvs = array(args[0])\n      ? args[0]\n      : obj(args[0])\n      ? entries(args[0])\n      : [[args[0], args[1]]];\n    map(kvs, ([key, value]) => {\n      key = \"\" + key;\n      data[key] = value;\n      const [callbacks, next] = getCallbacks(key, T);\n      map(\n        callbacks,\n        (callback) =>\n          callback(value, key, F, tracker) === T && push(next, callback)\n      );\n    });\n\n    !passive && listen?.(kvs);\n  };\n\n  const get: Variables[0] = (\n    values?: Record<string, GetCallback>,\n    timeout?: number\n  ): any => {\n    if (!values) return data;\n\n    map(entries(values), ([key, callback]) => {\n      if (!callback) return err(ERR_ARGUMENT_ERROR, key);\n      let inner = callback;\n\n      const [queue] = getCallbacks(key, F);\n\n      let triggered = F;\n      callback = (value, key, current) => {\n        triggered = T;\n        return tryCatch(() => inner(value, key, current, tracker));\n      };\n\n      if (data[key] === undefined && timeout !== 0) {\n        push(queue, callback);\n\n        timeout &&\n          timeout > 0 &&\n          setTimeout(\n            () =>\n              !triggered && // The callback has not yet been triggered, timeout happened.\n              callback(undefined, key, T, tracker) !== T &&\n              (inner = () => {}), // Neutralize the inner callback so it is not invoked again if a value arrives after the timeout.\n            timeout\n          );\n      } else {\n        callback(data[key], key, T, tracker) === T && push(queue, callback);\n      }\n    });\n  };\n  return [get, set];\n};\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\nimport { initializeTracker } from \"./initializeTracker\";\nimport { F, T, define, window } from \"./lib\";\n\n// This assumes the script is loaded from the RequestHandler's ?cfg route.\n\n// To prevent external scripts from eaves-dropping and get a hold of the storage key, this is how initialization works:\n// 1: The configuration scripts appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overriden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nlet loaded = F;\ndefine(window, {\n  [INITIALIZE_TRACKER_FUNCTION]: [\n    (callback: (init: typeof initializeTracker) => void) => {\n      if (loaded === (loaded = T)) return;\n      callback(initializeTracker);\n    },\n  ],\n});\n"],"names":["currentValue","matchSelected","MUTEX_RESPONSE_COOKIE","typeTest","types","ev","type","some","isTrackedEvent","isViewEvent","isViewEndedEvent","isConsentEvent","splitRanks","ranks","toLowerCase","replace","split","filter","rank","parseTagString","input","baseRank","target","Array","isArray","join","test","decodeURIComponent","_","name","value","sep","parsedTag","tags","baseRanks","_0","tag","quote1","quote2","unquoted","length","pop","concat","push","add","undefined","nil","T","F","fromEntries","Object","assign","st","setTimeout","pi","parseInt","MAX_SAFE_INTEGER","Number","SSR","window","win","doc","document","nav","navigator","body","loc","location","perf","performance","err","code","args","error","console","message","round","x","decimals","bool","Math","pow","decode","encode","encodeURIComponent","parameters","equals","values","lowerCase","s","concat2","value1","value2","defaultValue","typePrefixes","is","exec","testOrConvertFunction","convert","parse","str","toString","fun","obj","array","iterable","Symbol","iterator","sort","items","sortKey","item","lhs","rhs","splice","start","deleteCount","unshift","shift","sources","size","map","keys","entries","mapOrRecord","project","index","forEach","action","initialValue","breakSignal","cloneOrProject","flatMap","projection","source","predicate","emptyIsNull","any","i","stop","hashSet","Set","clear","clearable","key","del","get","has","delete","set","getOrSet","transpose","additionalEntries","promise","Promise","resolve","Reset","Expired","openPromise","timeout","currentResolve","currentPromise","resolved","reset","capturedResolve","delay","then","p","match","regex","selector","escapeRegEx","REGEX_NEVER","unionOrNever","parts","joined","RegExp","stringRuleCache","separators","part","text","separator","replaceValue","isUndefined","isObject","isSymbol","isIterable","codes","chars","charCode","charCodeAt","FNVs","32","64","128","entropy","max","random","serialize","data","options","multiple","Error","floatBuffer","floatView","pow32","Uint8Array","append","subarray","isReplacement","appendNull","appendByte","isFinite","floor","appendBytes","hi","lo","appendInt64","ArrayBuffer","DataView","setFloat64","bytes","ascii","ci","c","c2","encodeUtf8","Date","sec","getTime","getMilliseconds","ns","appendArray","Uint8ClampedArray","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","invalidTypeReplacement","byte","newLength","newArray","abs","deserialize","pos","read","readMap","readArray","readStr","readBin","readExt","readFloat","readUInt","readInt","debug","first","view","buffer","byteOffset","getFloat32","getFloat64","lengthSize","String","fromCharCode","exports","screenPos","y","rect","createTransport","encrypt","decrypt","hash","n","j","pad","prime","mixer","mixer255","iw","mixer0","window0","resetMixer","updateMixer","ENTROPY","cipher","numericOrBits","bits","BigInt","asUintN","MIN_SAFE_INTEGER","chunk","cleaners","refs","refIndex","patchProperty","addCleaner","inner","val","patched","cleaner","isSafeInteger","toJSON","Map","isDefined","k","REF_PROP","serialized","base64","encoded","hasValue","from64u","matchedRef","v","e","httpEncode","httpDecode","httpEncrypt","httpDecrypt","now","_tmp","timeOrigin","trunc","ms","formatDuration","toFixed","callback","id","currentCallback","capturedCallback","clearInterval","clearTimeout","setInterval","cleanup","currentId","wait","pulse","isActive","finish","timer","time","started","elapsed","origin","defer","f","queueMicrotask","randomValues","arg","crypto","getRandomValues","randomSafeInt","arr","localIdBuffer","nextId","compareTabIds","other","localeCompare","TAB_ID","trackerConfig","src","disabled","postEvents","postFrequency","requestTimeout","heartbeatFrequency","clientKey","apiKey","impressionThreshold","captureContextMenu","defaultActivationTracking","default","MAX_ANCESTOR_DISTANCE","forAncestorsOrSelf","el","stoppingCriterion","distance","returnValue","nodeType","prev","parentElement","ownerDocument","defaultView","frameElement","scopeAttr","node","attr","getAttribute","removeAttribute","setAttribute","cssProperty","getComputedStyle","getPropertyValue","define","props","writable","configurable","defineProperties","tagName","scrollPos","int","scrollX","scrollY","matchExHash","href1","href2","getScreenPos","mouseEvent","includeFold","getPos","xpx","ypx","offsetWidth","offsetHeight","pageFolds","innerHeight","pointerType","pageY","pageX","getRect","getBoundingClientRect","left","top","width","height","listen","names","cb","capture","passive","unbinders","mapped","removeEventListener","addEventListener","a","unbind","parseDomain","href","all","protocol","domainName","substring","domain","getViewport","innerWidth","totalWidth","totalHeight","tryCatch","finallyCallback","stopImmediatePropagation","currentScript","SCRIPT_SRC","TRACKER_DOMAIN","isInternalUrl","url","endsWith","mapUrl","urlParts","VAR_URL","MNT_URL","eventSet","once","handlers","unbinder","handler","invokeArgs","startupLock","registerStartupHandler","startupComplete","cachedMappings","currentBoundaryData","propertyValue","decoded","expires","entry","oldEntry","boundaryData","WeakMap","getBoundaryData","trackerPropertyName","css","matchAttributeNames","cached","prefix","eligible","r","getAttributeNames","matches","cachedTagMapper","cssPropertyWithBase","parsedCssRules","trackerProperty","inherit","trackerFlag","parseTags","sourceEl","elementTagData","rulesString","rule1","rule2","cache","rule","removeExpired","secure","$","storage","register","sourceId","removeItem","ownListeners","accessor","arg0","arg1","arg2","innerHandler","listener","unlisten","triggerSelf","newValue","oldValue","getItem","supportsExpiry","setItem","cookieStorage","cookie","kv","find","trim","maxAge","stalled","cookies","secureCookies","session","sessionStorage","shared","localStorage","remove","createChannel","self","channelKey","getTargetKey","targetId","ownKey","channel","rest","cleared","destinationKey","direct","dependencies","pendingDependencies","hashMap","areAllDependenciesPosted","dep","globalStateChannel","globalStateResolvers","listeners","callListeners","globalStateResolved","resolveTimeout","registerSharedState","apply","knownTabs","hasResponse","payload","actionHandlers","localData","flushLocalData","currentData","actionStates","getActionState","purgeClosedTabs","getCoordinatorId","reducer","min","reduce","previous","current","1","closing","2","freezing","collect","3","4","actionId","coordinateCommit","5","coordinator","critical","collected","handle","success","async","always","tryAsync","6","updatePollingTab","7","initPromise","init","await","terminate","freeze","toggleActive","t0","result","safeTimeoutTimestamp","selectedPollingTab","activeId","isForegroundTab","active","toggle","visibilityState","addResponseListener","callResponseHandlers","responseChannel","checkResponseCookie","decompose","affinity","variables","tuple","responseTimeout","pollResponseCookie","addPostListener","callPostListeners","addShutdownListener","callShutdownListeners","enqueueEvent","post","commit","events","force","sourceLabel","forced","discardCookies","postData","event","timestamp","o","sendBeacon","Blob","response","terminating","broadcastAffinity","activeHandles","flushing","noopAction","registerViewEndAction","addTerminationListener","currentViewEvent","pushPopNavigation","queue","userInteraction","setup","tracker","pollContextCookie","pendingNavigationEvent","trackDocument","trackClicks","trackRegion","clickableElement","cmp","t","track","clicks","component","region","componentContext","getComponentContext","parseActivationTags","container","info","sharedEventProperties","viewport","element","innerText","timing","startsWith","isLinkElement","external","hostname","host","pathname","search","anchor","navigationEvent","referrerConsumed","pushNavigationSource","currentUrl","userActivation","clipboard","writeText","flag","unbindAll","button","ctrlKey","shiftKey","altKey","exit","sourceElement","contextCart","parseCartEventData","cart","content","normalizeCartEventData","onFrame","frame","contentDocument","decorate","eventData","addViewChangedListener","viewChanged","referrers","useSharedId","bind","exists","updateQueue","poll","keyExpiry","navigationEventId","totalDuration","visibleDuration","interactiveDuration","getVisibleDuration","callOnFrame","knownFrames","WeakSet","frames","getElementsByTagName","context","mark","isNewTab","activations","viewPosted","tab","firstTab","pendingViewEvent","NO_OP","pendingViewEndEvent","currentLocation","postView","trySplit","qs","referrer","path","tabIndex","landingPage","ps","query","queryString","utm","navigationType","getEntriesByType","redirects","redirectCount","related","externalReferrer","flush","definition","rendered","qd","h","landscape","angle","hasTouch","maxTouchPoints","userAgent","languages","language","primary","preference","timezone","iana","Intl","DateTimeFormat","resolvedOptions","timeZone","offset","getTimezoneOffset","screen","w","orientation","deviceType","dpr","devicePixelRatio","interactiveTimeout","heartbeat","history","resetHeartbeat","processCommand","command","isChangeUserCommand","username","dependency","ctx","totalTime","visibleTime","interactiveTime","units","commerce","isCartCommand","isOrderCommand","order","hasComponentOrContent","boundary","stripRects","keep","setContext","directOnly","areaPath","components","collectedContent","includeState","area","secondary","promote","ancestor","intersectionHandler","observer","IntersectionObserver","els","isIntersecting","boundingClientRect","intersectionRatio","threshold","registerComponent","fold","visible","impressions","captureState","update","inferred","intersecting","ratio","bottom","duration","isConnected","observe","cmd","isDataBoundaryCommand","isScanComponentsCommand","attributeName","scan","attribute","references","commands","seen","querySelectorAll","stack","delta","number","isNaN","json","JSON","next","nextElementSibling","parentNode","removeChild","scroll","emitted","initialScroll","scrollType","defaultExtensions","formEvents","getFormFieldValue","selectedOptions","option","checked","currentField","handleLostFocus","form","field","state","total","previousValue","tv0","fillOrder","filled","corrections","fields","lastField","activeTime","wireFormFields","formElement","capturedContext","refName","fieldMap","commitEvent","completed","commitTimeout","label","labels","ref","commandTest","isTagAttributesCommand","isToggleCommand","isExtensionCommand","isFlushCommand","isGetCommand","isListenerCommand","isSetCommand","isTrackerAvailableCommand","initializeTracker","config","queuedCommands","extensions","pendingStateCommands","publicVariables","localVariables","getVars","setVars","updateVariables","mainArgs","currentArg","insertArgs","callbacks","getCallbacks","unsubscribe","addQueuePostListener","addGlobalStateResolvedListener","triggered","kvs","vars","tagAttributes","disable","expanded","consent","nonEssentialTracking","skip","extension","ready","batch","hasDependencies","priority","__isTracker","loaded",".tail.js.init"],"mappings":"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","x_google_ignoreList":[18]}