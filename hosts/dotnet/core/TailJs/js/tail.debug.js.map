{"version":3,"file":"tail.debug.js","sources":["../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/util/src/accessors.ts","../../../../../npm/packages/@tailjs/util/src/types.ts","../../../../../npm/packages/@tailjs/util/src/iterators.ts","../../../../../npm/packages/@tailjs/util/src/time.ts","../../../../../npm/packages/@tailjs/util/src/concurrency.ts","../../../../../npm/packages/@tailjs/util/src/events.ts","../../../../../npm/packages/@tailjs/client/src/lib2/ids.ts","../../../../../npm/packages/@tailjs/client/src/lib2/page-events.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/base64.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/lfsr.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/transport.ts","../../../../../npm/node_modules/.pnpm/@ygoe+msgpack@1.0.3/node_modules/@ygoe/msgpack/msgpack.js","../../../../../npm/packages/@tailjs/client/src/lib2/storage.ts","../../../../../npm/packages/@tailjs/client/src/lib2/channel.ts","../../../../../npm/packages/@tailjs/client/src/lib2/shared-state.ts","../../../../../npm/packages/@tailjs/client/src/lib2/consts.ts","../../../../../npm/packages/@tailjs/client/src/lib2/request.ts","../../../../../npm/packages/@tailjs/client/src/pusher.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["export const MUTEX_REQUEST_COOKIE = \".tail.rq\";\nexport const MUTEX_RESPONSE_COOKIE = \".tail.rs\";\nexport const CONTEXT_MENU_COOKIE = \".tail.cm\";\n\nexport const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_MENU_QUERY = \"mnt\";\n","import {\n  And,\n  Extends,\n  GeneralizeContstants,\n  If,\n  IsAny,\n  Minus,\n  NO_ARG,\n  NotFunction,\n  PrettifyIntersection,\n  Primitives,\n  RecordType,\n  UnionToIntersection,\n  count,\n  forEach,\n  hasMethod,\n  isArray,\n  isAwaitable,\n  isDefined,\n  isFunction,\n  isObject,\n  isString,\n  isUndefined,\n  map,\n  reduce,\n  throwError,\n} from \".\";\n\ntype ReadonlyMapLike<K = any, V = any> = {\n  has?(key: K): boolean;\n  get(key: K): V | undefined;\n};\n\n// #region Shared types\ntype MapLike<K = any, V = any> = ReadonlyMapLike<K, V> & {\n  set(key: K, value: V): any;\n  delete(key: K): any;\n};\n\ntype ReadonlySetLike<K = any> = {\n  has(key: K): boolean;\n};\ntype SetLike<K = any> = ReadonlySetLike<K> & {\n  add(key: K): any;\n  delete(key: K): any;\n};\n\ntype ReadonlyPropertyContainer<K extends any = any, V extends any = any> =\n  | {\n      [P in keyof K]: V;\n    }\n  | ReadonlyMapLike<K, V>\n  | ReadonlySetLike<K>;\n\ntype PropertyContainer<K extends any = any, V extends any = any> =\n  | ReadonlyPropertyContainer<K, V>\n  | MapLike<K, V>\n  | SetLike<K>;\n\nexport type TupleIndices<T extends readonly any[]> = T extends readonly []\n  ? never\n  : number extends T[\"length\"]\n  ? number\n  : T extends readonly [any, ...infer Rest]\n  ? TupleIndices<Rest> | Rest[\"length\"]\n  : never;\n\nexport type KeyType<T extends ReadonlyPropertyContainer | null | undefined> =\n  T extends Primitives\n    ? never\n    : T extends ReadonlyMapLike<infer K, any> | ReadonlySetLike<infer K>\n    ? K\n    : T extends readonly any[]\n    ? TupleIndices<T>\n    : keyof T;\n\nexport type ValueType<\n  T extends ReadonlyPropertyContainer | null | undefined,\n  K = KeyType<T>,\n  Context extends undefined | \"get\" | \"set\" = undefined\n> = IsAny<T> extends true\n  ? any\n  : T extends null | undefined | void\n  ? never\n  : K extends KeyType<T>\n  ? T extends ReadonlyMapLike<K, infer V>\n    ? V | If<Extends<Context, \"get\" | \"set\">, undefined>\n    : T extends ReadonlySetLike<K>\n    ? boolean\n    : T[K] | If<And<Extends<T, RecordType>, Extends<Context, \"set\">>, undefined>\n  : never;\n\ntype AcceptUnknownContainers<\n  T extends ReadonlyPropertyContainer | null | undefined\n> = IsAny<T> extends true\n  ? T\n  : T extends null | undefined | void\n  ? never\n  : T extends MapLike\n  ? MapLike<unknown, unknown> | T\n  : T extends SetLike\n  ? SetLike<unknown> | T\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? readonly unknown[] | [] | T\n    : T\n  : T;\n\n// #endregion\n\n// #region get\n\nconst updateSingle = (target: any, key: any, value: any) =>\n  setSingle(target, key, isFunction(value) ? value(get(target, key)) : value);\n\nconst setSingle = (target: any, key: any, value: any) => {\n  value === undefined\n    ? target.delete\n      ? target.delete(key)\n      : delete target[key]\n    : target.set\n    ? target.set(key, value)\n    : target.add\n    ? value\n      ? target.add(key)\n      : target.delete(key)\n    : (target[key] = value);\n\n  return value;\n};\n\nexport const setSingleIfNotDefined = (\n  target: any,\n  key: any,\n  value: any,\n  error: (\n    key: string,\n    currentValue: any,\n    newValue: any,\n    target: any\n  ) => string | Error\n) => {\n  const currentValue = get(target, key);\n  if (isDefined(currentValue)) {\n    throwError(error(key, currentValue, value, target));\n  }\n  return setSingle(target, key, value);\n};\n\nexport const get: {\n  <\n    T extends ReadonlyPropertyContainer | null | undefined,\n    K extends KeyType<T>\n  >(\n    target: T,\n    key: K\n  ): ValueType<T, K, \"get\">;\n  <\n    T extends ReadonlyPropertyContainer | null | undefined,\n    K extends KeyType<T>,\n    R extends\n      | ValueType<T, K>\n      | (() => ValueType<T, K>)\n      | undefined\n      | (() => ValueType<T, K> | undefined)\n  >(\n    target: T,\n    key: K,\n    initializer: R\n  ): ValueType<\n    T,\n    K,\n    R extends ValueType<T, K> | (() => ValueType<T, K>) ? undefined : \"get\"\n  >;\n} = <\n  T extends ReadonlyPropertyContainer | null | undefined,\n  K extends KeyType<T>,\n  R extends ValueType<T, K> | undefined = undefined\n>(\n  target: T,\n  key: K | undefined,\n  initializer?: (() => R) | R\n) => {\n  if (!target) return undefined as any;\n\n  let value = (target as any).get\n    ? (target as any).get(key)\n    : (target as any).has\n    ? (target as any).has(key)\n    : target[key as any];\n\n  if (isUndefined(value) && isDefined(initializer)) {\n    isDefined(\n      (value = isFunction(initializer) ? (initializer as any)() : initializer)\n    ) && setSingle(target, key, value);\n  }\n  return value;\n};\n\n// #endregion\n\n// #region set and update\n\ntype UpdateFunction<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current,\n  Factory\n> = Factory extends false\n  ? (\n      current: Current,\n      key: Key,\n      target: T\n    ) => GeneralizeContstants<ValueType<T, Key>> | undefined\n  : (key: Key, target: T) => GeneralizeContstants<ValueType<T, Key>>;\n\ntype Updater<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current = ValueType<T, Key>,\n  SettersOnly = false,\n  Factory = false\n> = SettersOnly extends true\n  ? ValueType<T, Key> | (Factory extends true ? never : undefined)\n  : IsAny<T> extends true\n  ? NotFunction | UpdateFunction<any, any, any, Factory>\n  :\n      | (ValueType<T, Key> extends Function\n          ? never\n          : ValueType<T, Key> | (Factory extends true ? never : undefined))\n      | UpdateFunction<T, Key, Current, Factory>;\n\ntype UpdaterType<T, SettersOnly = false> = SettersOnly extends true\n  ? T\n  : T extends (...args: any) => infer T\n  ? T\n  : T;\n\ntype BulkUpdateObject<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> = T extends MapLike | SetLike | any[]\n  ? {\n      [P in KeyType<T>]: Updater<T, P, ValueType<T, P>, SettersOnly, Factory>;\n    }\n  : { [P in keyof T & KeyType<T>]?: Updater<T, P, T[P], SettersOnly, Factory> };\n\ntype BulkUpdateKeyValue<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false,\n  K extends keyof T = keyof T\n> = IsAny<T> extends true\n  ? [any, Updater<T, any, any, SettersOnly, Factory>]\n  : T extends MapLike | SetLike | any[]\n  ? [\n      KeyType<T>,\n      Updater<T, KeyType<T>, ValueType<T, KeyType<T>>, SettersOnly, Factory>\n    ]\n  : K extends any\n  ? [K, Updater<T, KeyType<T>, any, SettersOnly, Factory>]\n  : never;\n\ntype BulkUpdates<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> =\n  | BulkUpdateObject<T, SettersOnly, Factory>\n  | Iterable<\n      | BulkUpdateKeyValue<T, SettersOnly, Factory>\n      | BulkUpdateObject<T, SettersOnly, Factory>\n    >;\n\ntype SetErrorHandler<T extends ReadonlyPropertyContainer | null | undefined> = (\n  key: KeyType<T>,\n  currentValue: ValueType<T>,\n  newValue: ValueType<T>,\n  target: T\n) => string | Error;\n\ntype SettableKeyType<T extends PropertyContainer> = T extends readonly any[]\n  ? // `KeyType<T>` won't do.\n    // If this `keyof` constraint is not set TypeScript will only constrain values for readonly tuple items to T[number] and not T[K].\n    keyof T\n  : T extends RecordType\n  ? keyof any\n  : KeyType<T>;\n\ntype SettableValueType<T extends PropertyContainer, K> = K extends KeyType<T>\n  ?\n      | ValueType<T, K>\n      // `undefined` removes elements from maps and sets so also allowed.\n      | (T extends MapLike | SetLike ? undefined : never)\n  : T extends RecordType\n  ? any\n  : never;\n\ntype SettableValueFunctionType<T extends PropertyContainer, K, V> = (\n  current: SettableValueType<T, K>\n) => V;\n\ntype IsGeneralKey<T, S = keyof any> = S extends T ? true : false;\n\n/** List of keys in T that has undefined values. If Template does not allow undefined values for a key it is excluded from the reuslts. */\ntype UndefinedKeys<\n  T,\n  Template = {},\n  K extends keyof T = keyof T\n> = K extends keyof T\n  ? T[K] extends undefined\n    ? K extends keyof Template\n      ? undefined extends Template[K]\n        ? K\n        : never\n      : K\n    : never\n  : never;\n\ntype SetSingleResultType<\n  T extends PropertyContainer,\n  K,\n  V\n> = T extends RecordType\n  ? AssignRecord<T, { [P in K & keyof any]: V }>\n  : K extends KeyType<T>\n  ? V extends ValueType<T, K> | (T extends readonly any[] ? never : undefined)\n    ? T\n    : never\n  : never;\n\ntype SettableKeyValueTuple<T extends PropertyContainer> =\n  KeyType<T> extends keyof any\n    ?\n        | {\n            [P in KeyType<T>]: readonly [P, SettableValueType<T, P>];\n          }[KeyType<T>]\n        | (T extends RecordType ? [keyof any, any] : never)\n    : readonly [KeyType<T>, SettableValueType<T, KeyType<T>>];\n\ntype SettableKeyValueRecord<T extends PropertyContainer> =\n  SettableKeyType<T> extends keyof any\n    ? RecordType &\n        ({\n          [P in KeyType<T>]?: SettableValueType<T, P>;\n        } & {\n          [P in SettableKeyType<T>]?: P extends KeyType<T>\n            ? ValueType<T, P>\n            : SettableValueType<T, P>;\n        })\n    : never;\n\ntype SettableValueList<T extends PropertyContainer> = T extends Primitives\n  ? never\n  :\n      | SettableKeyValueRecord<T>\n      | readonly (SettableKeyValueRecord<T> | SettableKeyValueTuple<T>)[];\n\ntype AllKeys<T> = T extends infer T ? keyof T : never;\ntype AnyValue<T, K> = T extends infer T\n  ? K extends keyof T\n    ? T[K]\n    : never\n  : never;\n\ntype MergeObjects<T> = {\n  [P in AllKeys<T>]: AnyValue<T, P>;\n};\n\ntype KeyValueTupleToRecord<Item> = Item extends readonly [infer K, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : Item extends readonly (infer KV)[]\n  ? { [P in KV & keyof any]: KV }\n  : Item extends RecordType\n  ? Item\n  : never;\n\ntype AssignRecord<T, S> = {\n  [P in Exclude<\n    keyof T | keyof S,\n    IsGeneralKey<keyof T | keyof S> extends true ? never : UndefinedKeys<S, T>\n  >]: P extends keyof S\n    ? IsGeneralKey<P> extends true\n      ? AnyValue<S | T, P>\n      : P extends keyof T\n      ? S[P] extends T[P]\n        ? GeneralizeContstants<S[P]> extends T[P]\n          ? GeneralizeContstants<S[P]>\n          : S[P]\n        : never\n      : GeneralizeContstants<S[P]>\n    : P extends keyof T\n    ? T[P]\n    : never;\n};\n\ntype SetResult<\n  T extends PropertyContainer,\n  V extends any\n> = T extends RecordType\n  ? PrettifyIntersection<\n      AssignRecord<\n        T,\n        V extends RecordType\n          ? V\n          : MergeObjects<KeyValueTupleToRecord<V[keyof V]>>\n      >\n    >\n  : T;\n\ntype SetOrUpdateFunction<\n  SettersOnly,\n  ErrorHandler = false,\n  Readonly = false\n> = {\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined,\n    U extends Updater<\n      T extends null | undefined ? never : T,\n      K,\n      ValueType<T, K>,\n      SettersOnly\n    >,\n    K extends KeyType<T>\n  >(\n    target: T,\n    key: K,\n    value: U,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): UpdaterType<U>;\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined\n  >(\n    target: T,\n    values: BulkUpdates<T extends null | undefined ? never : T, SettersOnly>,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): T;\n};\n\nconst createSetOrUpdateFunction =\n  <SettersOnly, Error>(\n    setter: (target: any, key: any, value: any, error?: any) => any\n  ): SetOrUpdateFunction<SettersOnly, Error> =>\n  (target: PropertyContainer, key: any, value: any = NO_ARG, error?: any) => {\n    if (!target) return undefined;\n    if (value !== NO_ARG) {\n      return setter(target, key, value, error);\n    }\n\n    forEach(key, (item) =>\n      isArray(item)\n        ? setter(target, item[0], item[1])\n        : forEach(item, ([key, value]) => setter(target, key, value))\n    );\n\n    return target;\n  };\n\nexport const assign = createSetOrUpdateFunction<true, false>(setSingle);\nexport const update = createSetOrUpdateFunction<false, false>(updateSingle);\nexport const assignIfUndefined = createSetOrUpdateFunction<false, true>(\n  setSingleIfNotDefined\n);\n\nexport const swap = <T extends PropertyContainer, K extends KeyType<T>>(\n  target: T,\n  key: K,\n  value: ValueType<T, K>\n): ValueType<T, K, \"get\"> => {\n  const current = get(target, key) as any;\n  if (value !== current) setSingle(target, key, value);\n  return current as any;\n};\n\n// #endregion\n\nexport const add = <T extends PropertyContainer<any, boolean>>(\n  target: T,\n  key: KeyType<T>\n) =>\n  target instanceof Set\n    ? target.has(key)\n      ? false\n      : (target.add(key), true)\n    : get(target, key) !== assign(target, key, true as any);\n\nexport const has = <T extends ReadonlyPropertyContainer>(\n  target: T,\n  key: KeyType<T>\n) =>\n  hasMethod(target, \"has\")\n    ? target.has(key)\n    : isDefined((target as any).get?.(key) ?? (target as any)[key]);\n\ntype RemoveDeepArgs<\n  T,\n  Current extends any[] = [],\n  Depth extends number = 20\n> = T extends PropertyContainer\n  ? Depth extends 0\n    ? Current\n    :\n        | (Depth extends 20 ? never : Current)\n        | RemoveDeepArgs<\n            ValueType<T>,\n            [...Current, KeyType<T>[] | KeyType<T>],\n            Minus<Depth, 1>\n          >\n  : Current;\n\ntype RemoveDeepValue<\n  T,\n  Args extends any[],\n  ArrayIt = false\n> = T extends PropertyContainer\n  ? ArrayIt extends true\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>[]]\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>]\n    ? ValueType<T> | undefined\n    : Args extends [infer R, ...infer Rest]\n    ? RemoveDeepValue<ValueType<T>, Rest, R extends any[] ? true : ArrayIt>\n    : never\n  : never;\n\nconst clearSingle = (target: any, key: any) => {\n  if (isUndefined(target ?? key)) return undefined;\n\n  let current = get(target, key);\n\n  if (hasMethod(target, \"delete\")) {\n    target.delete(key);\n  } else {\n    delete target[key];\n  }\n  return current;\n};\n\n/**\n * Removes one or more values from a property container specified by the provided key or array of keys.\n *\n * If more than one level of key arguments are specified, values will be removed from the property container at the deepest level.\n * If a property container becomes empty along the path of keys, it will be removed from its parent.\n *\n */\nexport const clear = <\n  T extends PropertyContainer | null | undefined,\n  Args extends RemoveDeepArgs<T>\n>(\n  target: T,\n  ...keys: Args\n): RemoveDeepValue<T, Args> => {\n  const removed: any[] = [];\n  let array = false;\n\n  const clearStep = (\n    target: any,\n    index: number,\n    parent?: any,\n    parentKey?: any\n  ) => {\n    if (!target) return;\n    const targetKeys = keys[index];\n    if (index === keys.length - 1) {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) => removed.push(clearSingle(target, key)));\n      } else {\n        removed.push(clearSingle(target, targetKeys));\n      }\n    } else {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) =>\n          clearStep(get(target, key), index + 1, target, key)\n        );\n      } else {\n        clearStep(get(target, targetKeys), index + 1, target, targetKeys);\n      }\n      if (!count(target) && parent) {\n        remove(parent, parentKey);\n      }\n    }\n  };\n  clearStep(target, 0);\n  return array ? removed : removed[0];\n};\n\n/**\n * Removes the specified keys from a  property container.\n *\n * The difference between {@link clear} and this function is that it does not consider nested property containers and that arrays will be spliced (as opposed to `clear` where the index will be set to `undefined`).\n */\nexport const remove: {\n  <T extends PropertyContainer | null | undefined>(\n    target: T,\n    key: KeyType<T> | undefined\n  ): T extends null | undefined ? T : ValueType<T, KeyType<T>> | undefined;\n  <T extends PropertyContainer | null | undefined>(\n    target: T,\n    ...keys: (KeyType<T> | undefined)[]\n  ): (T extends null | undefined ? T : ValueType<T, KeyType<T>> | undefined)[];\n} = (target: PropertyContainer, key: any, ...keys: any[]) => {\n  if (!target) return undefined;\n\n  if (keys.length) {\n    // Sort array keys descending as they would otherwise not match their offset as the array is spliced along the way.\n    return (isArray(target) ? keys.sort((x, y) => y - x) : keys).map((key) =>\n      remove(target, key)\n    );\n  }\n\n  return isArray(target)\n    ? key < target.length\n      ? (target as any[]).splice(key, 1)[0]\n      : undefined\n    : clearSingle(target, key);\n};\n\ntype EntryToObject<Item> = Item extends readonly [infer K & keyof any, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : never;\n\ntype EntriesToObject<Entries> = UnionToIntersection<\n  InlinePropertyDescriptors<\n    Entries extends null | undefined | boolean\n      ? {}\n      : Entries extends readonly [\n          Partial<Readonly<PropertyDescriptor>>,\n          ...infer Rest\n        ]\n      ? EntriesToObject<Rest[number]>\n      : Entries extends readonly [infer Item, ...infer Rest]\n      ? EntryToObject<Item> & EntriesToObject<Rest>\n      : Entries extends readonly (infer Items)[]\n      ? EntryToObject<Items>\n      : Entries\n  >\n>;\n\ntype InlinePropertyDescriptors<T> = {\n  [P in keyof T]: T[P] extends () => infer V | { value: infer V }\n    ? V\n    : T[P] extends { get(): infer V }\n    ? V\n    : T[P];\n};\n\ntype PropertyList =\n  | boolean\n  | null\n  | undefined\n  | [defaults: Partial<PropertyDescriptor>, ...items: PropertyList[]]\n  | [key: keyof any, value: any][]\n  | (Record<keyof any, any> & { [Symbol.iterator]?: never });\n\nexport const define: {\n  <T, P extends PropertyList[]>(\n    target: T,\n    ...properties: P\n  ): (T extends Function ? T : {}) &\n    PrettifyIntersection<T & EntriesToObject<P[number]>>;\n} = (target: any, ...args: any[]) => {\n  const add = (arg: any, defaults?: any) => {\n    if (!arg) return;\n    let properties: readonly any[];\n    if (isArray(arg)) {\n      if (isObject(arg[0])) {\n        // Tuple with the first item the defaults and the next the definitions with those defaults,\n        // ([{enumerable: false, ...}, ...])\n        (arg as any[]).splice(1).forEach((items) => add(items, arg[0]));\n        return;\n      }\n      // ([[key1, value1], [key2, value2], ...])\n      properties = arg;\n    } else {\n      // An object.\n      properties = map(arg)!;\n    }\n\n    properties.forEach(([key, value]) =>\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        writable: false,\n        ...defaults,\n        ...(isObject(value) && (\"get\" in value || \"value\" in value)\n          ? value\n          : isFunction(value) && !value.length\n          ? { get: value }\n          : { value }),\n      })\n    );\n  };\n\n  args.forEach((arg) => add(arg));\n  return target as any;\n};\n\ntype PropertySelector<T> =\n  | keyof T\n  | {\n      [P in keyof T]?: PropertySelector<T[P]> | [...keys: (keyof T[P])[]];\n    };\n\ntype SinglePickResult<T, Selected> = Selected extends\n  | (string & infer K)\n  | (infer K)[]\n  ? { [P in keyof T & K]: T[P] }\n  : keyof Selected extends infer Keys\n  ? {\n      [P in Keys & keyof any & keyof Selected]: P extends keyof T\n        ? Selected[P] extends true\n          ? T[P]\n          : SinglePickResult<T[P], Selected[P]>\n        : never;\n    }\n  : never;\n\ntype PickResults<T, Selectors> = PrettifyIntersection<\n  Selectors extends [infer Item, ...infer Rest]\n    ? SinglePickResult<T, Item> & SinglePickResult<T, Rest>\n    : never\n>;\n\nexport const pick = <T, Selectors extends PropertySelector<T>[], U>(\n  source: T | (null | (undefined & U)),\n  ...args: Selectors\n): U extends undefined ? undefined : PickResults<T, Selectors> => {\n  if (source === undefined) return undefined as any;\n\n  return Object.fromEntries(\n    args.flatMap((arg) =>\n      isObject(arg, true)\n        ? isArray(arg)\n          ? arg.map((args) =>\n              isArray(args)\n                ? args.length === 1\n                  ? [args[0], source![args[0]]]\n                  : pick(source![args[0]], ...(args[1] as any[]))\n                : [args[0], source![args[1]]]\n            )\n          : Object.entries(args).map(([key, value]) => [\n              key,\n              value === true ? source![key] : pick(source![key], value),\n            ])\n        : ([[arg, source![arg]]] as any)\n    )\n  ) as any;\n};\n\nexport type Wrapped<T> =\n  | T\n  | (() => Wrapped<T>)\n  | ((arg: any, ...args: any) => never);\n\nexport type Unwrap<T> = T extends Wrapped<infer T> ? T : never;\n\nexport const unwrap = <T extends Wrapped<any>>(value: T): Unwrap<T> =>\n  isFunction(value)\n    ? unwrap(value())\n    : isAwaitable(value)\n    ? value.then((result) => unwrap(result))\n    : value;\n\nexport const unlock = <T extends ReadonlyPropertyContainer>(\n  readonly: T\n): T extends ReadonlyMapLike<infer K, infer V>\n  ? MapLike<K, V>\n  : T extends ReadonlySetLike<infer T>\n  ? SetLike<T>\n  : T => readonly as any;\n","import { Wrapped, map, obj, unwrap, type reduce } from \".\";\n\nexport type IsNever<T> = [T] extends [never] ? true : false;\n\nexport type UnwrapTuple<T extends any[]> = T extends readonly []\n  ? []\n  : T extends readonly [infer Item, ...infer Rest]\n  ? [Item, ...UnwrapTuple<Rest>]\n  : T extends readonly (infer T)[]\n  ? T[]\n  : never;\n\n/**\n * Shorthand for a value that is optionally awaitable.\n */\nexport type MaybePromise<T> = PromiseLike<T> | T;\n\nexport type ValueOrDefault<T, R, D = undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? D\n  : R;\n\n/** Shorter than writing all this out, and slightly easier to read. */\nexport type Nullish = null | undefined;\n\n/**\n * Removes null'ish values from a union.\n */\nexport type OmitNullish<T> = T extends Nullish ? never : T;\n\n/**\n * The defined part of a type, excluding undefined and void (which is also undefined).\n */\nexport type Defined<T> = Exclude<T, undefined | void>;\n\n/**\n * A record that may have the specified keys and values.\n */\nexport type PartialRecord<K extends keyof any, T> = Partial<Record<K, T>>;\n\n/**\n * Makes the specified properties partial.\n */\nexport type PickPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>;\n\n/**\n * Makes all other properties than the specified partial.\n */\nexport type OmitPartial<T, K extends keyof T> = Pick<T, K> &\n  Partial<Omit<T, K>>;\n\n/**\n * The ECMAScript primitive types.\n */\nexport type Primitives =\n  | null\n  | undefined\n  | void\n  | boolean\n  | number\n  | bigint\n  | string\n  | symbol\n  | Date;\n\nexport type RecordType = object &\n  Record<keyof any, any> & {\n    [Symbol.iterator]?: never;\n    [Symbol.hasInstance]?: never;\n  };\n\n/** Simplifies the return value for functions like `get<T,Required extends boolean>(value: T, required?:Required): MaybeRequired<T,Required> => ...` */\nexport type MaybeRequired<T, Required> = If<Required, T, T | undefined>;\n\n/** Negates a Boolean value */\nexport type Not<B> = If<B, false, true>;\n\nexport type And<P1, P2> = P1 | P2 extends true ? true : false;\nexport type Or<P1, P2> = true extends P1 | P2 ? true : false;\n\nexport type All<P extends readonly any[]> = P extends []\n  ? true\n  : P extends [infer Item, ...infer Rest]\n  ? And<Item extends false ? false : true, All<Rest>>\n  : false;\n\nexport type ToBoolean<Criteria> = Criteria extends\n  | null\n  | undefined\n  | never\n  | void\n  | false\n  ? false\n  : true;\n\n/** Simplifies Boolean checks (insted of having to write B extends bla, bla...).  */\nexport type IfNot<B, True = undefined, False = never> = If<B, False, True>;\n\n/** Simplifies Boolean checks (insted of having to write B extends bla, bla...).  */\nexport type If<B, True, False = never> = ToBoolean<B> extends true\n  ? True\n  : False;\n\n/** Type 1 extends type 2 */\nexport type Extends<T1, T2> = T1 extends T2 ? true : false;\n\n/**\n * Common function type used for projection of [key,value] entries.\n */\nexport type KeyValueProjection<K, V, R> = (\n  entry: [key: K, value: V],\n  index: number\n) => R;\n\n/**\n * Shorthand for a type that is inferred from a parameter and can either be the item in an iterable, or just the type itself.\n */\nexport type IterableOrSelf<T> = IterableOrArrayLike<T> | T;\n\ntype FunctionComparisonEqualsWrapped<T> = T extends (\n  T extends {} ? infer R & {} : infer R\n)\n  ? { [P in keyof R]: R[P] }\n  : never;\n\ntype FunctionComparisonEquals<A, B> = (<\n  T\n>() => T extends FunctionComparisonEqualsWrapped<A> ? 1 : 2) extends <\n  T\n>() => T extends FunctionComparisonEqualsWrapped<B> ? 1 : 2\n  ? true\n  : false;\n\n/**\n * Tests if a type is `any`.\n */\nexport type IsAny<T> = FunctionComparisonEquals<T, any>;\n\nexport type UndefinedNotAny<T, Defined = T> = If<\n  IsAny<T>,\n  Defined,\n  T extends undefined ? undefined : Defined\n>;\n\n/**\n * Only returns the type if it is not `any`.\n */\nexport type ExcludeAny<T> = FunctionComparisonEquals<T, any> extends true\n  ? never\n  : T;\n\n/**\n * Utility type to allow `as const` to be used on tuples returned from functions without actually making them `readonly` (which is annoying).\n * Normally TypeScript considers the return value of a function like `x=>[10,\"four\"]` to be `(string|number)[]` (which is also annoying).\n */\nexport type ConstToNormal<T> = T extends readonly [...any[]]\n  ? { -readonly [P in keyof T]: ConstToNormal<T[P]> }\n  : Voidefined<T>;\n\n/**\n * Goes with {@link Nulls} to simplify the expression.\n */\nexport type ArgNulls<T, Arg> = (T | Nullish) & Arg;\n\n/**\n *  TypeScript may be very literal when it infers types. The type fo a function parameter with the value `10` may be inferred as `10` and not `number`.\n *  This is an issue in e.g. {@link reduce}.\n */\nexport type GeneralizeContstants<T> = T extends number\n  ? number\n  : T extends string\n  ? string\n  : T extends boolean\n  ? boolean\n  : T extends (...args: infer A) => infer R\n  ? (...args: GeneralizeContstants<A>) => GeneralizeContstants<R>\n  : unknown extends T\n  ? unknown\n  : {\n      [P in keyof T]: GeneralizeContstants<T[P]>;\n    };\n\n/**\n * The eclectic type found everywhere on the Internet.\n * It convers a union like `{a:1}|{b:2}` to the intersection `{a:1, b:2}`\n */\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never;\n\n/**\n * Makes a union of objects like `{a:1}&{b:2}` appear as `{a:1,b:2}` in intellisense.\n */\nexport type PrettifyIntersection<T> = T extends infer T\n  ? { [P in keyof T]: T[P] }\n  : never;\n\ntype KeyValuePairToProperty<K, V> = K extends keyof any\n  ? { [P in K]: V }\n  : never;\n\n/**\n * Makes an array of key/value pairs to an object with the corresponding properties.\n */\nexport type KeyValuePairsToObject<T> = PrettifyIntersection<\n  T extends readonly []\n    ? {}\n    : T extends readonly [[infer K, infer V], ...infer Rest]\n    ? KeyValuePairToProperty<K, V> & KeyValuePairsToObject<Rest>\n    : T extends readonly [infer K, infer V][]\n    ? UnionToIntersection<KeyValuePairToProperty<K, V>>\n    : never\n>;\n\n/**\n * Anything but a function.\n */\nexport type NotFunction =\n  | bigint\n  | boolean\n  | null\n  | number\n  | string\n  | symbol\n  | undefined\n  | {\n      [key: string | number | symbol]: any;\n      [Symbol.hasInstance]?: never;\n    };\n\ntype CreateArray<Len, Ele, Arr extends Ele[] = []> = Arr[\"length\"] extends Len\n  ? Arr\n  : CreateArray<Len, Ele, [Ele, ...Arr]>;\n\nexport type Add<A extends number, B extends number> = [\n  ...CreateArray<A, 1>,\n  ...CreateArray<B, 1>\n][\"length\"];\n\nexport type Minus<A extends number, B extends number> = CreateArray<\n  A,\n  1\n> extends [...CreateArray<B, 1>, ...infer R]\n  ? R[\"length\"]\n  : never;\n\nexport type Entries<T> = UnionToTuple<\n  {\n    [P in keyof T]: [P, T[P]];\n  } extends infer T\n    ? T[keyof T]\n    : never\n>;\n\nconst internal = Symbol();\ntype Token = typeof internal;\n\n/** Can be used to avoid infinite recursion by recognizing if a type has already been seen. Use with {@link CurrentRecursion}. */\n\nexport type RecursionKey<T, Seen> = Seen extends [Token, T, ...infer Rest]\n  ? [Token, T, T, ...Rest]\n  : [Token, T, T];\n\n/** Can be used to avoid infinite recursion by recognizing if how many times a type has already been seen. Use with {@link RecursionKey}. */\nexport type CurrentRecursion<T, Seen> = Seen extends [Token, T, ...infer Rest]\n  ? Rest[\"length\"]\n  : 0;\n\n/** Can be used to avoid infinite recursion by recognizing if how many times a type has already been seen. Use instead of `never` as the seed for seen types. */\nexport type RecursionSeed = Token;\n\n// From https://www.hacklewayne.com/typescript-convert-union-to-tuple-array-yes-but-how.\n\nexport type UnionToTuple<T> = PickOne<T> extends infer U // assign PickOne<T> to U\n  ? Exclude<T, U> extends never // T and U are the same\n    ? [T]\n    : [...UnionToTuple<Exclude<T, U>>, U] // recursion\n  : never;\n\ntype Contra<T> = T extends any ? (arg: T) => void : never;\n\ntype InferContra<T> = [T] extends [(arg: infer I) => void] ? I : never;\n\ntype PickOne<T> = InferContra<InferContra<Contra<Contra<T>>>>;\n\n/** Returns a type if T is not undefined. */\nexport type IfDefined<T, R = T> = T extends undefined ? undefined : R;\n\n/**\n * Trick for having a function that returns a non-null value, if a formal paramter always has a non-null value,\n * simliar to .NET's [NotNullIfNotNull].\n *\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\nexport type AllKeys<Ts> = Ts extends infer T ? keyof T : never;\n/**\n * Creates a new type where with all the properties from any of the specified types.\n * This can make life easier for code working with polymorphic types.\n */\n\nexport type CommonTypeTemplate<Ts> = {\n  [P in AllKeys<Ts>]?: Ts extends infer T\n    ? P extends keyof T\n      ? T[P]\n      : never\n    : never;\n};\n\nexport type ExpandTypes<\n  Ts,\n  Common = CommonTypeTemplate<Ts>\n> = Ts extends infer T\n  ? {\n      [P in keyof Common]: P extends keyof T ? T[P] : Common[P];\n    }\n  : never;\n\n/**\n * Typescript has the distinction between `void` and `undefined`.\n * I'm sure there is a theorically sound explanation. Both that and the distinction are annoying so this little utility type maps `void` to `undefined`.\n *\n * The ampersand union trick makes TypeScript relax instead of the \"The type T could be instantiated etc...\" error.\n */\nexport type Voidefined<T> = T extends void ? T & undefined : T;\n\n/**\n * An extension to T[] and Iterable<T> that also correctly captures weird things like NodeListOf<T>\n */\nexport type IterableOrArrayLike<T> =\n  | Iterable<T>\n  | { [item: number]: T; length: number };\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = (value: any, parse?: boolean) => T | undefined;\n\nexport const undefined = void 0;\nexport const nil = null;\n\n/** Caching this value potentially speeds up tests rather than using `Number.MAX_SAFE_INTEGER`. */\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/** Using this cached value speeds up testing if an object is iterable seemingly by an order of magnitude. */\nexport const symbolIterator = Symbol.iterator;\n\n/** Fast way to check for precence of function argument. */\nexport const NO_ARG = Symbol();\n\nconst createConverter =\n  <T>(typeTester: TypeTester<T>, parser?: (value: any) => T | undefined) =>\n  (value: any, parse = true) =>\n    typeTester(value)\n      ? value\n      : parser && parse && isDefined((value = parser(value)))\n      ? value\n      : undefined;\n\nexport const tryCatch = <T, C = undefined>(\n  expression: () => T,\n  errorHandler: boolean | ((error: any) => C) = true as any,\n  clean?: () => void\n): T | (C extends Error ? T : C) => {\n  try {\n    return expression();\n  } catch (e) {\n    if (!isBoolean(errorHandler)) {\n      const error = errorHandler?.(e) as any;\n      if (error instanceof Error) throw error;\n      return error;\n    }\n    if (errorHandler) {\n      throw e;\n    }\n    console.error(e);\n    return undefined as any;\n  } finally {\n    clean?.();\n  }\n};\n\nexport const tryCatchAsync = async <T, C = void>(\n  expression: () => PromiseLike<T> | T,\n  errorHandler:\n    | boolean\n    | ((error: any, last: boolean) => Promise<C> | C) = true as any,\n  clean?: () => void,\n  retries = 1\n): Promise<T | C> => {\n  while (retries--) {\n    try {\n      return await expression();\n    } catch (e) {\n      if (!isBoolean(errorHandler)) {\n        const error = (await errorHandler?.(e, !retries)) as any;\n        if (error instanceof Error) throw error;\n        return error;\n      } else if (errorHandler && !retries) {\n        throw e;\n      } else {\n        console.error(e);\n      }\n    } finally {\n      clean?.();\n    }\n  }\n  return undefined as any;\n};\n\nexport const as = <T, D = undefined, Args extends any[] = []>(\n  value: any,\n  converter: (value: any, ...rest: Args) => T | undefined,\n  defaultValue?: D,\n  ...args: Args\n): T | D => ((value = converter(value, ...args)) ?? defaultValue) as any;\n\nexport const cast = <T, V, Args extends any[] = []>(\n  value: V,\n  typeTest: (value: any, ...args: Args) => value is T,\n  ...args: Args\n): V extends T ? V : undefined =>\n  typeTest(value, ...args) ? (value as any) : undefined;\n\nexport const isNull = (value: any): value is null => value === nil;\n\nexport const isUndefined = (value: any): value is undefined | void =>\n  value === undefined;\n\nexport const isDefined = <T>(value: T): value is Defined<T> =>\n  value !== undefined;\n\nexport const isNullish = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value == nil;\n\nexport const hasValue = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value != nil;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\n\nexport const parseBoolean = createConverter(isBoolean, (value) => !!value);\nexport const isTruish = (value: any) => !!value;\n\nexport type Falsish = void | null | undefined | 0 | \"\" | false;\n\nexport const isFalsish = (value: any): value is Falsish => !value;\n\nexport const isInteger: (value: any) => value is number =\n  Number.isSafeInteger as any;\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\nexport const parseNumber = createConverter(isNumber, (value) =>\n  parseFloat(value)\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\nexport const parseBigInt = createConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createConverter(isString, (value) =>\n  hasValue(value) ? \"\" + value : value\n);\n\nexport const isArray: (value: any) => value is readonly any[] = Array.isArray;\n\n/**\n * Returns the value as an array following these rules:\n * - If the value is undefined (this does not include `null`), so is the return value.\n * - If the value is already an array its original value is returned unless `clone` is true. In that case a copy of the value is returned.\n * - If the value is iterable, an array containing its values is returned\n * - Otherwise, an array with the value as its single item is returned.\n */\nexport const toArray = <T>(\n  value: T | Iterable<T>,\n  clone = false\n): T extends undefined ? undefined : T[] =>\n  isUndefined(value)\n    ? undefined\n    : !clone && isArray(value)\n    ? value\n    : isIterable(value)\n    ? [...value]\n    : ([value] as any);\n\nexport const isObject = <AcceptIterables extends boolean = false>(\n  value: any,\n  acceptIterables: AcceptIterables = false as any\n): value is AcceptIterables extends true\n  ? object & (Record<keyof any, any> | Iterable<any>)\n  : object & Record<keyof any, any> & { [Symbol.iterator]?: never } =>\n  value != null &&\n  typeof value === \"object\" &&\n  (acceptIterables || !value[symbolIterator]);\n\nexport const hasMethod = <T, Name extends keyof any>(\n  value: T | unknown,\n  name: Name | keyof T\n): value is {\n  [P in keyof T]: P extends Name\n    ? T extends { [P in Name]?: (...args: infer Args) => infer R }\n      ? Args extends unknown\n        ? (...args: any) => any\n        : (...args: Args) => R\n      : (...args: any) => any\n    : T[P];\n} => typeof (value as any)?.[name] === \"function\";\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\n\nexport const isIterable = (\n  value: any,\n  acceptStrings = false\n): value is Iterable<any> =>\n  !!(value?.[symbolIterator] && (typeof value === \"object\" || acceptStrings));\n\nexport const toIterable = <T>(value: T | Iterable<T>): Iterable<T> =>\n  isIterable(value) ? value : [value];\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == nil\n    ? value === nil\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\nexport const identity = <T = any>(value: T) => value;\n\nexport const clone = <T>(value: T, depth: number | boolean = true): T =>\n  isObject(value, true)\n    ? isArray(value)\n      ? depth\n        ? value.map((value) => clone(value, depth === true || --(depth as any)))\n        : [...value]\n      : isSet(value)\n      ? new Set<any>(\n          depth\n            ? (map as any)(value, (value: any) =>\n                clone(value, depth === true || --(depth as any))\n              )\n            : value\n        )\n      : isMap(value)\n      ? new Map<any, any>(\n          depth\n            ? (map as any)(value, (value: any) =>\n                // Does not clone keys.\n                [value[0], clone(value[1], depth === true || --(depth as any))]\n              )\n            : value\n        )\n      : depth\n      ? obj(\n          map(value as any, ([k, v]) => [\n            k,\n            clone(v, depth === true || --(depth as any)),\n          ])!\n        )\n      : { ...value }\n    : (value as any);\n\n/**\n * Evaluates a function that can be used to capture values using parameter default values.\n *\n * For example `(previous=current)=>(current+=2, previous)\n */\nexport const capture = <R>(capture: (...args: any[]) => R) => capture();\n\ntype ErrorGenerator = string | Error | (() => string | Error);\n\nexport const throwError = <T = any>(\n  error: ErrorGenerator,\n  transform: (string: string) => Error = (message) => new TypeError(message)\n): T => {\n  throw isString((error = unwrap(error))) ? transform(error) : error;\n};\n\ntype CombineTypeTests<T> = T extends []\n  ? {}\n  : T extends [infer F, ...infer Rest]\n  ? F extends (value: any) => value is infer R\n    ? (IsAny<R> extends true ? T : R) & CombineTypeTests<Rest>\n    : never\n  : never;\n\nexport const validate = <\n  T,\n  Validator extends\n    | ((candidate: T) => candidate is any)\n    | ((candiate: T) => R)\n    | [\n        validate: (candiate: T) => any,\n        ...typeTests: ((candidate: T) => candidate is any)[]\n      ]\n    | (R & NotFunction),\n  R\n>(\n  value: T,\n  validate: Validator | R,\n  validationError?: ErrorGenerator,\n  undefinedError?: ErrorGenerator\n): Defined<\n  Validator extends [any, ...infer TypeTests]\n    ? CombineTypeTests<TypeTests>\n    : Validator extends ((value: any) => infer R) | infer R\n    ? R extends Falsish\n      ? never\n      : Validator extends (value: any) => value is infer R\n      ? IsAny<R> extends true\n        ? T\n        : Defined<R>\n      : T\n    : never\n> =>\n  (\n    isArray(validate)\n      ? validate.every((test) => test(value))\n      : isFunction(validate)\n      ? validate(value)\n      : validate\n  )\n    ? value\n    : required(value, undefinedError ?? validationError) &&\n      (throwError(validationError ?? \"Validation failed.\") as any);\n\nexport class InvariantViolatedError extends Error {\n  constructor(invariant?: string) {\n    super(invariant ? \"INV: \" + invariant : \"An invariant was violated.\");\n  }\n}\n\n/**\n * States an invariant.\n */\nexport const invariant = <T>(\n  test: Wrapped<T | false>,\n  description?: string\n): Defined<T> => {\n  const valid = unwrap(test);\n  return isDefined(valid) && valid !== false\n    ? (valid as any)\n    : throwError(new InvariantViolatedError(description));\n};\n\nexport const required = <T>(value: T, error?: ErrorGenerator): Defined<T> =>\n  isDefined(value)\n    ? value\n    : throwError(\n        error ?? \"A required value is missing\",\n        (text) => new TypeError(text.replace(\"...\", \" is required.\"))\n      );\n","import {\n  add,\n  ConstToNormal,\n  GeneralizeContstants,\n  get,\n  hasMethod,\n  IsAny,\n  isArray,\n  isDefined,\n  isFalsish,\n  isFunction,\n  isObject,\n  isSet,\n  isTruish,\n  IterableOrArrayLike,\n  KeyValuePairsToObject,\n  MAX_SAFE_INTEGER,\n  Minus,\n  NotFunction,\n  RecordType,\n  symbolIterator,\n  toArray,\n  undefined,\n  UndefinedNotAny,\n} from \".\";\n\nexport const UTF16MAX = 0xffff;\n\nlet stopInvoked = false;\nexport const stop = (yieldValue?: any) => ((stopInvoked = true), yieldValue);\n\nexport const toCharCodes = (s: string) =>\n  [...new Array(s.length)].map((_, i) => s.charCodeAt(i));\nexport const codePoint = (string: string, index: number = 0) =>\n  string.codePointAt(index)!;\n\nexport type IteratorSource =\n  | any\n  | null\n  | undefined\n  | number\n  | Iterable<any>\n  | NotFunction\n  | NavigatingIteratorStep;\n\nexport type IteratorSourceOf<T> =\n  | (T extends number ? number : never)\n  | Iterable<T>\n  | (T extends readonly [infer K, infer V]\n      ? K extends keyof any\n        ? { [P in K]: V }\n        : never\n      : never)\n  | NavigatingIteratorStep<T>;\n\ntype IteratorItem<S extends IteratorSource> = IsAny<S> extends true\n  ? any\n  : S extends number\n  ? number\n  : S extends RecordType\n  ? [keyof S, S[keyof S]]\n  : S extends (...args: any) => infer T | undefined\n  ? T\n  : S extends Iterable<infer T>\n  ? T\n  : never;\n\nexport type IteratorItems<S extends IteratorSource[]> = S extends readonly [\n  infer S\n]\n  ? IteratorItem<S>\n  : S extends readonly [infer S, ...infer Rest]\n  ? IteratorItem<S> | IteratorItems<Rest>\n  : S extends (infer S)[]\n  ? IteratorItem<S>\n  : never;\n\nexport interface IteratorControl<S extends IteratorSource> {\n  source: S;\n  prev: IteratorItem<S> | undefined;\n  skip(): void;\n  end(): void;\n  end<P>(value: P): P;\n}\n\nexport type IteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = IteratorItem<S>,\n  Value = IteratorItem<S>\n> = (\n  value: Value,\n  index: number\n) => Projection | typeof stop | undefined | void;\n\ntype IteratorProjection<\n  S extends IteratorSource,\n  Projection\n> = unknown extends Projection ? IteratorItem<S> : ConstToNormal<Projection>;\n\ntype StartEndArgs<S extends IteratorSource> =\n  | []\n  | (S extends number\n      ? [offset?: number]\n      : S extends NavigatingIteratorStep<infer T>\n      ? [offset?: T, maxIterations?: number]\n      : [start?: number, end?: number]);\n\nexport type NavigatingIteratorStep<T = any> = (\n  current: T | undefined\n) => T | undefined;\n\ntype FlatIteratorItem<T, D extends number = 1, O = false> = T extends\n  | undefined\n  | void\n  ? never\n  : D extends 0\n  ? T\n  : T extends Iterable<any> | (O extends true ? Record<keyof any, any> : never)\n  ? D extends 1\n    ? IteratorItem<T>\n    : FlatIteratorItem<IteratorItem<T>, Minus<D, 1>, O>\n  : T;\n\ntype UndefinedIfUndefined<S, T> = S extends null | void | undefined\n  ? undefined\n  : T;\n\ntype ProjectedItem<P> = Exclude<P, undefined | void | typeof stop>;\n\nfunction* createFilteringIterator<\n  S extends IteratorSource,\n  P = IteratorItem<S>\n>(source: S, action?: IteratorAction<S, P>): Iterable<ProjectedItem<P>> {\n  if (!source) return;\n\n  let i = 0;\n  for (let item of source as any) {\n    action && (item = action(item, i++));\n    if (item !== undefined) {\n      yield item;\n    }\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n}\n\nfunction* createObjectIterator<\n  S extends Record<keyof any, any>,\n  P = IteratorItem<S>\n>(source: S, action?: IteratorAction<S, P>): Iterable<P> {\n  let i = 0;\n  for (const key in source) {\n    let value = [key, source[key]] as any;\n    action && (value = action(value, i++));\n\n    if (value !== undefined) {\n      yield value;\n    }\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n}\n\nfunction* createRangeIterator(length = 0, offset = 0): Iterable<number> {\n  while (length--) yield offset++;\n}\n\nexport function* createStringIterator(\n  input: string,\n  start: number,\n  end: number\n): Iterable<[char: string, codePoint: number]> {\n  while (start < end) {\n    const codePoint = input.codePointAt(start)!;\n    let p = input[start++];\n    if (codePoint > UTF16MAX) {\n      start++;\n      p = String.fromCodePoint(codePoint);\n    }\n    yield [p, codePoint];\n  }\n}\n\nexport function* createNavigatingIterator<T>(\n  step: NavigatingIteratorStep<T>,\n  start?: T | undefined,\n  maxIterations = Number.MAX_SAFE_INTEGER\n): Iterator<T> {\n  if (isDefined(start)) yield start;\n  while (maxIterations-- && isDefined((start = step(start)))) {\n    yield start;\n  }\n}\n\nconst sliceAction = <\n  S extends IteratorSource,\n  A extends IteratorAction<S, any> | undefined\n>(\n  action: A,\n  start: any,\n  end: any\n): A =>\n  (start ?? end) !== undefined\n    ? ((start ??= 0),\n      (end ??= MAX_SAFE_INTEGER),\n      (value, index) =>\n        start--\n          ? undefined\n          : end!--\n          ? action\n            ? action(value, index)\n            : value\n          : end)\n    : (action as any);\n\nexport type Filter<S extends IteratorSource> = (\n  value: IteratorItem<S>,\n  index: number\n) => any;\n\nconst createIterator = <S extends IteratorSource, P = IteratorItem<S>>(\n  source: S,\n  action?: IteratorAction<S, P>,\n  start?: any,\n  end?: any\n): Iterable<P> =>\n  source == null\n    ? ([] as any)\n    : source[symbolIterator]\n    ? createFilteringIterator(\n        source,\n        start === undefined ? action : sliceAction(action, start as any, end)\n      )\n    : typeof source === \"object\"\n    ? createObjectIterator(\n        source as any,\n        sliceAction(action, start as any, end)\n      )\n    : createIterator(\n        isFunction(source)\n          ? createNavigatingIterator(source, start, end)\n          : (createRangeIterator(source as number, start as any) as any),\n        action\n      );\n\nconst mapToArray = <T, M>(\n  projected: Iterable<T>,\n  map: M\n): true extends M ? T[] : Iterable<T> =>\n  map && !isArray(projected) ? [...projected] : (projected as any);\n\ntype ProjectFunction = {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): Iterable<IteratorProjection<S, R>>;\n  <S extends IteratorSource>(source: S, ...rest: StartEndArgs<S>): Iterable<\n    IteratorItem<S>\n  >;\n};\n\ntype MapFunction = {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): UndefinedNotAny<S, IteratorProjection<S, R>[]>;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): UndefinedNotAny<S, IteratorItem<S>[]>;\n};\n\ntype FlatProjectFunction = <\n  S extends IteratorSource,\n  D extends number = 1,\n  R = IteratorItem<S>,\n  O extends boolean = false\n>(\n  source: S,\n  projection?: FlatIteratorAction<S, R, D, O>,\n  depth?: D,\n  expandObjects?: O,\n  ...rest: StartEndArgs<S>\n) => FlatIteratorItem<Iterable<R>, D>;\n\nexport const project: ProjectFunction = ((\n  source: any,\n  projection: any,\n  start: any,\n  end: any\n) =>\n  projection != null && !isFunction(projection)\n    ? // The second argument is the value of `start`.\n      createIterator(source, undefined, projection, start)\n    : createIterator(source, projection, start, end)) as any;\n\nexport const flatProject: FlatProjectFunction = function (\n  source,\n  projection?,\n  depth = 1 as any,\n  expandObjects: any = false,\n  start?: any,\n  end?: any\n) {\n  return createIterator(\n    flatten(\n      createIterator(source, undefined, start, end),\n      depth + 1,\n      expandObjects,\n      false\n    ),\n    projection\n  ) as any;\n\n  function* flatten(\n    value: any,\n    depth: number,\n    expandObjects: boolean,\n    nested: boolean\n  ) {\n    if (value != null) {\n      if (\n        value?.[symbolIterator] ||\n        (expandObjects && value && typeof value === \"object\")\n      ) {\n        for (const item of nested ? createIterator(value) : value) {\n          if (depth > 1 || depth <= 0) {\n            yield* flatten(item, depth - 1, expandObjects, true);\n          } else {\n            yield item;\n          }\n        }\n      } else {\n        yield value;\n      }\n    }\n  }\n};\n\nexport const map: MapFunction = (\n  source: any,\n  projection?: any,\n  start: any = undefined,\n  end?: any\n) => {\n  if (start === undefined && isArray(source)) {\n    let i = 0;\n    const mapped: any[] = [];\n    for (let j = 0, n = source.length; j < n && !stopInvoked; j++) {\n      let value = source[j];\n      if (projection && value !== undefined) {\n        value = projection(value, i++);\n      }\n      if (value !== undefined) {\n        mapped.push(value);\n      }\n    }\n    stopInvoked = false;\n    return mapped;\n  }\n  return source !== undefined\n    ? toArray(project(source, projection, start, end))\n    : (undefined as any);\n};\n\nexport const zip = <Lhs extends IteratorSource, Rhs extends IteratorSource>(\n  lhs: Lhs,\n  rhs: Rhs\n): Iterable<[IteratorItem<Lhs>, IteratorItem<Rhs> | undefined]> => {\n  const it2 = createIterator(rhs)[Symbol.iterator]();\n  return createIterator(lhs, (lhs) => [lhs, it2.next()?.value] as [any, any]);\n};\n\nexport const distinct: {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorProjection<S, R>>;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorItem<S>>;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  isDefined(source)\n    ? new Set<any>([...project(source, projection, start, end)])\n    : undefined;\n\nexport const single: {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorProjection<S, R> | undefined;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorItem<S> | undefined;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  !source\n    ? undefined\n    : (source = mapDistinct(source, projection, start, end) as any).length > 1\n    ? undefined\n    : source[0];\n\nexport const mapDistinct: MapFunction = (\n  source: any,\n  projection?: any,\n  start?: any,\n  end?: any\n) =>\n  isDefined(source)\n    ? [...(distinct as any)(source, projection, start, end)]\n    : source;\n\nexport function* concatIterators<S extends IteratorSource[]>(\n  ...iterators: S\n): Iterable<IteratorItems<S>> {\n  for (const iterator of iterators) {\n    if (!iterator) continue;\n    yield* createIterator(iterator);\n  }\n}\n\ntype AllCanBeUndefined<T extends any[]> = T extends readonly [infer S]\n  ? undefined extends S\n    ? true\n    : false\n  : T extends readonly [infer S, ...infer Rest]\n  ? AllCanBeUndefined<Rest> extends false\n    ? false\n    : undefined extends S\n    ? true\n    : false\n  : true;\n\nexport const concat = <S extends (IterableOrArrayLike<any> | undefined)[]>(\n  ...iterators: S\n):\n  | (AllCanBeUndefined<S> extends true ? undefined : never)\n  | IteratorItems<S>[] =>\n  iterators.reduce(\n    (r: undefined | any[], it) => (it ? (r ?? []).concat(toArray(it)) : r),\n    undefined\n  ) as any;\n\nexport const intersection = <\n  T,\n  A extends Iterable<T> | undefined,\n  B extends Iterable<T> | undefined,\n  MapToArray extends boolean = A extends any[]\n    ? true\n    : B extends any[]\n    ? true\n    : false\n>(\n  a: A,\n  b: B,\n  mapToArray?: MapToArray\n): MapToArray extends true ? T[] : Iterable<T> => {\n  if (!a || !b) return [];\n  isSet(b) && ([b, a] = [a, b] as any);\n  const lookup = isSet(a) ? a : new Set(a);\n  return filter(b, (value) => lookup.has(value), mapToArray) as any;\n};\n\nexport const intersects = (\n  a: Iterable<any> | undefined,\n  b: Iterable<any> | undefined\n) => !!count(intersection(a, b));\n\ntype FlatIteratorAction<\n  S extends IteratorSource,\n  R = FlatIteratorItem<S>,\n  D extends number = 1,\n  O = false\n> = IteratorAction<S, R, FlatIteratorItem<S, D, O>>;\n\nexport const flatMap = <\n  S extends IteratorSource,\n  D extends number = 1,\n  O extends boolean = false,\n  R = IteratorItem<S>\n>(\n  source: S,\n  action: FlatIteratorAction<S, R, D, O> = (item) => item as any,\n  depth: D = 1 as any,\n  expandObjects: O = false as any,\n  ...rest: StartEndArgs<S>\n): FlatIteratorItem<R, D>[] =>\n  map(flatProject(source, action, depth, expandObjects, ...rest)) as any;\n\nconst traverseInternal = <T>(\n  root: T | T[] | undefined,\n  selector: (current: T) => Iterable<T> | undefined,\n  include: boolean,\n  results: T[],\n  seen: Set<T>\n) => {\n  if (isArray(root)) {\n    forEachInternal(root, (item) =>\n      traverseInternal(item, selector, include, results, seen)\n    );\n    return results;\n  }\n  if (!root || !add(seen, root)) {\n    return undefined;\n  }\n  include && results.push(root);\n  forEachInternal(selector(root), (item) =>\n    traverseInternal(item, selector, true, results, seen)\n  );\n\n  return results;\n};\n\ntype JoinResult<T> = T extends readonly []\n  ? never\n  : T extends readonly [infer Item, ...infer Rest]\n  ?\n      | Exclude<Item extends Iterable<infer T> ? T : Item, undefined>\n      | JoinResult<Rest>\n  : never;\n\nexport const join = <T extends readonly any[]>(...items: T): JoinResult<T>[] =>\n  items.flatMap((item) => toArray(item) ?? []).filter(isDefined) as any;\n\nexport const expand = <T>(\n  root: T | T[],\n  selector: (\n    current: Exclude<T, undefined>\n  ) => Iterable<T | undefined> | undefined,\n  includeSelf = true\n): T extends undefined ? undefined : Exclude<T, undefined>[] =>\n  traverseInternal(root, selector, includeSelf, [], new Set()) as any;\n\nconst forEachArray = (source: readonly any[], action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let j = 0, n = source.length; j < n; j++) {\n    if (\n      source[j] !== undefined &&\n      ((returnValue = action(source[j], i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachItereable = (source: Iterable<any>, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let value of source as any) {\n    if (\n      value !== undefined &&\n      ((returnValue = action(value, i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachObject = (source: any, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let key in source) {\n    if (\n      ((returnValue = action([key, source[key]], i++) ?? returnValue),\n      stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachInternal: <S extends IteratorSource, R>(\n  source: S,\n  action: IteratorAction<S, R>,\n  start?: any,\n  end?: any\n) => R | undefined = (source, action, start = undefined, end?: any) => {\n  if (source == null) return;\n\n  let returnValue: any;\n  if (start === undefined) {\n    if (isArray(source)) return forEachArray(source, action);\n    if (source[symbolIterator]) return forEachItereable(source as any, action);\n    if (typeof source === \"object\") return forEachObject(source, action);\n  }\n\n  for (const value of createIterator(source, action, start, end)) {\n    returnValue = (value as any) ?? returnValue;\n  }\n\n  return returnValue;\n};\n\nexport const forEach = forEachInternal as <S extends IteratorSource, R>(\n  source: S,\n  action: IteratorAction<S, R>,\n  ...rest: StartEndArgs<S>\n) => R | undefined;\n\nexport const flatForEach = <\n  S extends IteratorSource,\n  R,\n  Depth extends number,\n  O extends boolean = false\n>(\n  source: S,\n  action: FlatIteratorAction<S, R, Depth, O>,\n  depth: Depth = 1 as any,\n  expandObjects: O = false as any,\n  ...rest: StartEndArgs<S>\n): R | undefined =>\n  forEachInternal(\n    flatProject(source, undefined, depth, expandObjects, ...(rest as any)),\n    action as any\n  ) as any;\n\nexport const obj: {\n  <S extends IteratorSource, P extends readonly [keyof any, any]>(\n    source: S,\n    selector: IteratorAction<S, P>,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<P[]>;\n  <S extends IteratorSourceOf<readonly [keyof any, any]>>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<S>;\n} = ((source: any, selector: any, ...rest: any[]) =>\n  Object.fromEntries((map as any)(source, selector, ...rest))) as any;\n\nexport const groupReduce: <\n  S extends IteratorSource,\n  Key,\n  Accumulator = unknown\n>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  reducer: (\n    accumulator: GeneralizeContstants<Accumulator>,\n    ...rest: Parameters<IteratorAction<S, Accumulator>>\n  ) => Accumulator,\n  seed?: Accumulator | (() => Accumulator),\n  ...reset: StartEndArgs<S>\n) => Map<Key, Accumulator> = (\n  source,\n  keySelector,\n  reducer,\n  seed,\n  start?: any,\n  end?: any\n) => {\n  const groups = new Map<any, any>();\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  const action: IteratorAction<any, any> = (item, index) => {\n    const key = keySelector(item, index);\n    let acc = groups.get(key) ?? seedFactory();\n    const value = reducer(acc, item, index);\n    if (isDefined(value)) {\n      groups.set(key, value);\n    }\n  };\n  forEachInternal(source, action, start, end);\n  return groups as any;\n};\n\nexport const group: <S extends IteratorSource, Key, R = IteratorItem<S>>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  valueSelector?: (item: IteratorItem<S>, index: number) => R,\n  ...rest: StartEndArgs<S>\n) => S extends undefined ? undefined : Map<Key, R[]> = (\n  source,\n  keySelector,\n  valueSelector = (item: any) => item,\n  start?: any,\n  end?: any\n) => {\n  if (source == null) return undefined as any;\n  const groups = new Map<any, any[]>();\n  (forEachInternal as any)(\n    source,\n    (item: any, index: number) => {\n      const key = keySelector(item, index);\n      const value = valueSelector(item, index);\n      get(groups, key as any, () => []).push(value);\n    },\n    start,\n    end\n  );\n  return groups as any;\n};\n\nexport const reduce: <\n  S extends IteratorSource,\n  Reducer extends (\n    ...args: [\n      accumulator: unknown extends Accumulator\n        ? any\n        : GeneralizeContstants<Accumulator>,\n      ...rest: Parameters<IteratorAction<S, Accumulator>>\n    ]\n  ) => GeneralizeContstants<Accumulator>,\n  Accumulator\n>(\n  source: S,\n  reducer: Reducer,\n  seed?: Accumulator | (() => Accumulator),\n  ...rest: StartEndArgs<S>\n) => Reducer extends (...args: any) => infer R\n  ? R | (unknown extends Accumulator ? undefined : never)\n  : never = (source, reducer, seed, start?: any, end?: any) => {\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  return (\n    forEachInternal(\n      source,\n      (value, index) =>\n        (seed =\n          ((reducer as any)(seed as any, value, index) as any) ??\n          seedFactory()),\n      start,\n      end\n    ) ?? (seedFactory() as any)\n  );\n};\n\ntype FilterItem<S extends IteratorSource, F> = F extends (\n  value: any,\n  ...args: any\n) => value is infer T\n  ? T\n  : IteratorItem<S>;\n\nexport const filter: {\n  <\n    S extends IteratorSource,\n    MapToArray extends boolean = S extends any[] ? true : false,\n    P extends Filter<S> = Filter<S>\n  >(\n    source: S,\n    predicate?: P,\n    map?: MapToArray,\n    ...rest: StartEndArgs<S>\n  ): MapToArray extends true\n    ? UndefinedIfUndefined<S, FilterItem<S, P>[]>\n    : Iterable<FilterItem<S, P>>;\n} = (\n  source: IteratorSource,\n  predicate: Filter<any> = (item: any) => item != null,\n  map = isArray(source) as any,\n  start?: any,\n  end?: any\n) =>\n  mapToArray(\n    createIterator(\n      source,\n      (item, index) => (predicate(item, index) ? item : undefined),\n      start,\n      end\n    ),\n    map\n  ) as any;\n\nlet filterInternal = filter;\n\nexport const count: <S>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => UndefinedIfUndefined<S, number> = (\n  source: IteratorSource,\n  filter?: Filter<IteratorSource>,\n  start?: any,\n  end?: any\n) => {\n  if (!source) return undefined as any;\n\n  let n: number;\n  if (filter) {\n    source = filterInternal(source, filter, false, start, end) as any;\n  } else {\n    if (isDefined((n = source![\"length\"] ?? source![\"size\"]))) {\n      return n;\n    }\n    if (!source[symbolIterator]) {\n      return Object.keys(source).length;\n    }\n  }\n  n = 0;\n  return forEachInternal(source, () => ++n) as any;\n};\n\nexport const sum: {\n  <S extends IteratorSourceOf<number>>(\n    source: S,\n    selector?: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n  <S extends IteratorSource>(\n    source: S,\n    selector: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n} = (\n  source: any,\n  selector: any = (item: any) => item,\n  start?: any,\n  end?: any\n) =>\n  reduce(\n    source,\n    (sum, value, index) => sum + (selector(value, index) ?? 0),\n    0,\n    start,\n    end\n  );\n\nexport const values: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => UndefinedIfUndefined<\n  S,\n  IteratorItem<S> extends readonly [any, infer Item] ? Item : IteratorItem<S>\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isObject(source) ? (item: any) => item[1] : (item: any) => item,\n    start,\n    end\n  );\n\nexport const keys: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => UndefinedIfUndefined<\n  S,\n  IteratorItem<S> extends readonly [infer Key, any] ? Key : number\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isObject(source) ? (item: any) => item[0] : (_item: any, i: number) => i,\n    start,\n    end\n  );\n\nexport const first: <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: Filter<any>,\n  start?: any,\n  end?: any\n) =>\n  !source || isArray(source)\n    ? source?.[0]\n    : forEachInternal(\n        source,\n        (value, i) =>\n          !predicate || predicate(value, i) ? stop(value) : undefined,\n        start,\n        end\n      );\n\nexport const last: <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: any,\n  start?: any,\n  end?: any\n) =>\n  !source\n    ? undefined\n    : isArray(source)\n    ? source[source.length - 1]\n    : forEachInternal(\n        source,\n        (item, i) => (!predicate || predicate(item, i) ? item : undefined),\n        start,\n        end\n      );\n\nexport const find = <S extends IteratorSource>(\n  source: S,\n  predicate: Filter<S>,\n  ...rest: StartEndArgs<S>\n): UndefinedIfUndefined<S, IteratorItem<S>> =>\n  !source\n    ? undefined\n    : (source as any).find\n    ? (source as any).find(predicate)\n    : first(filterInternal(source as any, predicate, false, ...rest));\n\nexport const some: <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => UndefinedIfUndefined<S, boolean> = (\n  source,\n  predicate,\n  start?: any,\n  rangeEnd?: any\n) =>\n  source === undefined\n    ? undefined\n    : hasMethod(source, \"some\")\n    ? source.some(predicate ?? isTruish)\n    : forEachInternal<any, boolean>(\n        source,\n        predicate\n          ? (item, index) => (predicate(item, index) ? stop(true) : false)\n          : () => stop(true),\n        start,\n        rangeEnd\n      ) ?? false;\n\nexport const every = <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n): UndefinedIfUndefined<S, boolean> =>\n  !source\n    ? undefined\n    : (!some(\n        source,\n        predicate ? (item, index) => !predicate(item, index) : isFalsish,\n        ...rest\n      ) as any);\n\nexport const binarySearch: {\n  (arr: Array<number>, find: number): number;\n  <T = number>(arr: Array<T>, find: T, compare: (x: T, y: T) => number): number;\n} = <T = number>(\n  arr: Array<T>,\n  find: T,\n  compare: (x: T, y: T) => number = ((x: any, y: any) => x - y) as any\n) => {\n  let m = 0;\n  let n = arr.length - 1;\n  let cmp: number;\n  let k: number;\n  while (m <= n) {\n    k = (n + m) >> 1;\n    cmp = compare(find, arr[k]);\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return k;\n    }\n  }\n  return ~m;\n};\n","import {\n  MaybePromise,\n  define,\n  isDefined,\n  isFunction,\n  isNumber,\n  promise,\n  tryCatchAsync,\n} from \".\";\n\nexport let now = () =>\n  typeof performance !== \"undefined\"\n    ? Math.trunc(performance.timeOrigin + performance.now())\n    : Date.now();\n\nexport type CancellableCallback = (cancel: () => void) => MaybePromise<any>;\n\nexport type Timer = {\n  (toggle?: boolean): number;\n};\n\nexport const createTimer = (started = true): Timer => {\n  let t0: number | boolean = started && now();\n  let elapsed = 0;\n  return (toggle?: boolean) => {\n    t0 && (elapsed += now() - (t0 as number));\n    isDefined(toggle) && (t0 = toggle && now());\n    return elapsed;\n  };\n};\n\nexport interface Clock {\n  readonly active: boolean;\n  readonly busy: boolean;\n  restart(frequency?: number, callback?: CancellableCallback): Clock;\n  toggle(start: boolean, trigger?: boolean): Clock;\n  trigger(skipQueue?: boolean): Promise<boolean>;\n}\n\nexport interface ClockSettings {\n  frequency?: number;\n  queue?: boolean;\n  paused?: boolean;\n  trigger?: boolean;\n  once?: boolean;\n  callback?: CancellableCallback;\n}\n\nexport const clock: {\n  (callback: CancellableCallback, frequency: number): Clock;\n  (settings: ClockSettings): Clock;\n} = (\n  callbackOrSettings: CancellableCallback | ClockSettings,\n  frequency = 0\n): Clock => {\n  const settings = isFunction(callbackOrSettings)\n    ? {\n        frequency,\n        callback: callbackOrSettings,\n      }\n    : callbackOrSettings;\n\n  let {\n    queue = true,\n    paused = false,\n    trigger = false,\n    once = false,\n    callback = () => {},\n  } = settings;\n  frequency = settings.frequency ?? 0;\n\n  let timeoutId = 0;\n  const mutex = promise(true).resolve();\n\n  const outerCallback = async (skipQueue?: boolean) => {\n    if (!timeoutId || (!queue && mutex.pending && skipQueue !== true)) {\n      return false;\n    }\n    (instance as any).busy = true;\n    if (skipQueue !== true) {\n      await mutex;\n    }\n\n    mutex.reset();\n    let cancelled = frequency < 0 || once;\n    await tryCatchAsync(\n      () => callback!(() => (cancelled = true)),\n      false,\n      () => mutex.resolve()\n    );\n    if (cancelled) {\n      reset(false);\n    }\n\n    (instance as any).busy = false;\n    return true;\n  };\n\n  const reset = (start: boolean) => {\n    clearInterval(timeoutId);\n    (instance as any).active = !!(timeoutId = start\n      ? (setInterval(\n          outerCallback,\n          frequency < 0 ? -frequency : frequency\n        ) as any)\n      : 0);\n    return instance;\n  };\n\n  const instance: Clock = {\n    active: false,\n    busy: false,\n    restart: (newFrequency, newCallback) => {\n      frequency = newFrequency ?? frequency;\n      callback = newCallback ?? callback;\n      return reset(true);\n    },\n    toggle: (start, trigger) =>\n      start !== instance.active\n        ? start\n          ? trigger\n            ? (reset(true), instance.trigger(), instance)\n            : reset(true)\n          : reset(false)\n        : instance,\n    trigger: async (skipQueue) =>\n      (await outerCallback(skipQueue)) && (reset(instance.active), true),\n  };\n\n  return instance.toggle(!paused, trigger);\n};\n","import {\n  MaybePromise,\n  Unwrap,\n  Wrapped,\n  isDefined,\n  isFunction,\n  isInteger,\n  isUndefined,\n  now,\n  throwError,\n  createTimer,\n  tryCatchAsync,\n  undefined,\n  unwrap,\n} from \".\";\n\nexport class ResetablePromise<T = void, E = any> implements PromiseLike<T> {\n  private _promise: OpenPromise<T>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public get value() {\n    return this._promise.value;\n  }\n  public get error() {\n    return this._promise.error;\n  }\n  public get pending() {\n    return this._promise.pending;\n  }\n\n  public resolve(value: T, ifPending = false) {\n    this._promise.resolve(value, ifPending);\n    return this;\n  }\n\n  public reject(value?: E, ifPending = false) {\n    this._promise.reject(value, ifPending);\n    return this;\n  }\n\n  public reset() {\n    this._promise = new OpenPromise<T>();\n    return this;\n  }\n\n  public signal(value: T) {\n    this.resolve(value);\n    this.reset();\n    return this;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): PromiseLike<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport class OpenPromise<T = void, E = any> implements PromiseLike<T> {\n  private readonly _promise: Promise<T>;\n\n  public readonly resolve: (value: T, ifPending?: boolean) => this;\n  public readonly reject: (reason: E | undefined, ifPending?: boolean) => this;\n  public readonly value: (T extends void ? true : T) | undefined;\n  public readonly error: E | true;\n  public pending = true;\n\n  constructor() {\n    let captured: any[];\n    this._promise = new Promise((...args: any[]) => {\n      captured = args.map((inner, i) => (value: any, ifPending: boolean) => {\n        if (!this.pending) {\n          if (ifPending) return this;\n          throw new TypeError(\"Promise already resolved/rejected.\");\n        }\n\n        (this as any).pending = false;\n        (this as any)[i ? \"error\" : \"value\"] = !isDefined(value) || value;\n        inner(value);\n        return this;\n      });\n    });\n\n    [this.resolve, this.reject] = captured!;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | null\n      | undefined,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | null\n      | undefined\n  ): Promise<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport type Lock = {\n  (timeout?: number): Promise<() => void>;\n  <T>(action: () => MaybePromise<T>, timeout?: number): Promise<T | undefined>;\n};\n\nexport const createLock = (): Lock => {\n  const semaphore = promise<boolean>(true);\n  let currentLock: (() => void) | undefined;\n  const t0 = createTimer();\n  const wait = async (actionOrMs?: (() => any) | number, ms?: number) => {\n    if (isFunction(actionOrMs)) {\n      const release = await wait(ms);\n      return release\n        ? await tryCatchAsync(actionOrMs, true, release)\n        : undefined;\n    }\n    while (currentLock) {\n      if (\n        isUndefined(\n          await (actionOrMs ? race(delay(actionOrMs), semaphore) : semaphore)\n        )\n      ) {\n        return undefined;\n      }\n      actionOrMs! -= t0(); // If the above did not return undefined we got the semaphore.\n    }\n    return (currentLock = () => semaphore.signal(!(currentLock = undefined)));\n  };\n  return wait;\n};\n\nexport const delay = <T extends Wrapped<any> = void>(\n  ms: number | undefined,\n  value?: T\n): MaybePromise<Unwrap<T>> =>\n  isUndefined(ms) || isInteger(ms)\n    ? !ms || ms <= 0\n      ? unwrap(value)!\n      : new Promise<any>((resolve) =>\n          setTimeout(async () => resolve(await unwrap(value)), ms)\n        )\n    : throwError(`Invalid delay ${ms}.`);\n\nexport const promise: {\n  <T = void>(resetable?: false): OpenPromise<T>;\n  <T = void>(resetable: true): ResetablePromise<T>;\n} = (resetable?: boolean) =>\n  resetable ? new ResetablePromise() : (new OpenPromise() as any);\n\ntype UnwrapPromiseArg<T> = T extends () => infer T ? Awaited<T> : Awaited<T>;\ntype UnwrapPromiseArgs<T extends any[]> = T extends readonly [infer Arg]\n  ? [UnwrapPromiseArg<Arg>]\n  : T extends readonly [infer Arg, ...infer Rest]\n  ? [UnwrapPromiseArg<Arg>, ...UnwrapPromiseArgs<Rest>]\n  : [];\n\nexport type AsyncValue<T> =\n  | undefined\n  | T\n  | PromiseLike<T>\n  | (() => T)\n  | (() => PromiseLike<T>);\n\nexport const waitAll = <Args extends AsyncValue<any>[]>(\n  ...args: Args\n): Promise<UnwrapPromiseArgs<Args>> =>\n  Promise.all(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n\nexport const race = <Args extends AsyncValue<any>[]>(\n  ...args: Args\n): Promise<UnwrapPromiseArgs<Args>[number]> =>\n  Promise.race(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n","import { filter, isUndefined, reduce } from \".\";\n\nexport type Rebinder = () => boolean;\nexport type Unbinder = () => boolean;\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\n\nexport type SourceListener<Args extends any[]> = (...args: Args) => void;\nexport type Listener<Args extends any[]> = (\n  ...args: [...args: Args, unbind: Unbinder]\n) => void;\n\nexport const createEventBinders = <Args extends any[]>(\n  listener: Listener<Args>,\n  attach: (listener: SourceListener<Args>) => void,\n  detach: (listener: SourceListener<Args>) => void\n): Binders => {\n  let bound = false;\n\n  const outerListener = (...args: Args) => listener(...args, unbind);\n\n  const unbind = () =>\n    bound !== (bound = false) && (detach(outerListener), true);\n\n  const rebind = () =>\n    bound !== (bound = true) && (attach(outerListener), true);\n\n  rebind();\n  return [unbind, rebind];\n};\n\nexport const joinEventBinders = (\n  ...binders: (Binders | undefined)[]\n): Binders => (\n  (binders = filter(binders)),\n  [\n    () => reduce(binders, (changed, binder) => binder![0]() || changed, false),\n    () => reduce(binders, (changed, binder) => binder![1]() || changed, false),\n  ]\n);\n\nexport type EventHandler<Args extends any[]> = (...payload: Args) => void;\n\nexport const createEvent = <Args extends any[]>(): [\n  listen: (listener: Listener<Args>, triggerCurrent?: boolean) => Binders,\n  dispatch: (...payload: Args) => void\n] => {\n  const listeners = new Set<SourceListener<Args>>();\n  let dispatchedArgs: Args | undefined;\n  return [\n    (handler, trigger) => {\n      const binders = createEventBinders(\n        handler,\n        (handler) => listeners.add(handler),\n        (handler) => listeners.delete(handler)\n      );\n      trigger && dispatchedArgs && handler(...dispatchedArgs, binders[0]);\n      return binders;\n    },\n    (...payload) => (\n      (dispatchedArgs = payload),\n      listeners.forEach((handler) => handler(...payload))\n    ),\n  ];\n};\n\nexport type ChainedEventHandler<Args extends any[], T> = (\n  ...args: [\n    ...args: Args,\n    next: {\n      (): T;\n      (...args: Args): T;\n    },\n    unbind: Unbinder\n  ]\n) => T;\n\ntype LinkedNode<T> = [\n  prev: LinkedNode<T> | undefined,\n  item: T,\n  next: LinkedNode<T> | undefined\n];\n\nexport const createChainedEvent = <T = void, Args extends any[] = []>(): [\n  register: (\n    handler: ChainedEventHandler<Args, T>,\n    priority?: number\n  ) => Binders,\n  invoke: (...args: Args) => T | undefined\n] => {\n  type Item = [\n    handler: ChainedEventHandler<Args, T>,\n    priority: number,\n    binders: Binders\n  ];\n  type Node = LinkedNode<Item>;\n  let head: Node | undefined;\n  let tail: Node | undefined;\n  let next: Node | undefined;\n\n  const register = (\n    handler: ChainedEventHandler<Args, T>,\n    // Make sure that handler gets rebound at their previous priority without jumping discrete increments.\n    // (It is deseriable to be able to specfiy priority 0 or  10 without having to think about how many 0s there are)\n    priority = (tail?.[1][1] ?? 0) + 0.000001\n  ) => {\n    const registerNode = (node?: Node) => {\n      let bound = true;\n      node ??= [\n        undefined,\n        [\n          handler,\n          priority,\n          [\n            () => {\n              if (!bound) return false;\n              node![0] ? (node![0][2] = node![2]) : (head = node![2]);\n              node![2] ? (node![2][0] = node![0]) : (tail = node![0]);\n              node![0] = node![2] = undefined;\n              return !(bound = false);\n            },\n            () => (bound ? false : (registerNode(node), (bound = true))),\n          ],\n        ],\n        undefined,\n      ];\n      next = head;\n      if (!next) {\n        head = tail = node;\n      } else if (priority >= tail![1][1]) {\n        node[0] = tail;\n        tail = tail![2] = node;\n      } else {\n        // INV: priority < tail.priority, so next will be non-null after loop;\n        while (next![1][1]! <= priority) {\n          next = next[2]!;\n        }\n\n        (node[0] = (node[2] = next)[0]) ? (node[0][2] = node) : (head = node);\n        next[0] = node;\n      }\n\n      return node[1][2];\n    };\n    return registerNode();\n  };\n\n  const invoke = (node: Node | undefined, args: Args) => (\n    (next = node?.[2]),\n    node\n      ? node[1][0](\n          ...args,\n          (...nextArgs: Args) =>\n            invoke(next!, nextArgs.length ? nextArgs : args),\n          node[1][2][0]\n        )\n      : undefined\n  );\n\n  return [register, (...args) => invoke(head, args)];\n};\n","import { now } from \"@tailjs/util\";\n\nexport type UUID = string;\n\nexport let TAB_ID =\n  now().toString(36) +\n  Math.trunc(1296 * Math.random()) //\n    .toString(36)\n    .padStart(2, \"0\");\n\nlet localId = 0;\nexport const nextId = () => TAB_ID + \"_\" + nextLocalId();\nexport const nextLocalId = () => ++localId;\n","import {\n  Binders,\n  Listener,\n  Unbinder,\n  clock,\n  createEvent,\n  createEventBinders,\n  createTimer,\n  isArray,\n  joinEventBinders,\n  map,\n} from \"@tailjs/util\";\n\ntype AllMaps = WindowEventMap &\n  GlobalEventHandlersEventMap &\n  DocumentEventMap &\n  HTMLElementEventMap;\n\nexport const listen = <K extends keyof AllMaps>(\n  target: {\n    addEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions\n    ): void;\n    removeEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | EventListenerOptions\n    ): void;\n  },\n  name: K | K[],\n  listener: (\n    ev: AllMaps[K extends any[] ? K[number] : K],\n    unbind?: Unbinder\n  ) => any,\n  options: AddEventListenerOptions = { capture: true, passive: true }\n): Binders => {\n  return isArray(name)\n    ? joinEventBinders(\n        ...map(name, (name) => listen(target, name as any, listener, options))\n      )\n    : createEventBinders(\n        listener,\n        (listener) => target.addEventListener(name, listener, options),\n        (listener) => target.addEventListener(name, listener, options)\n      );\n};\n\ntype PageLoadListenerArgs = [loaded: boolean];\nconst [addPageLoadedListener, dispatchPageLoaded] =\n  createEvent<PageLoadListenerArgs>();\n\nlet loaded = true;\nlisten(\n  window,\n  \"pagehide\",\n  () => loaded && dispatchPageLoaded((loaded = false))\n);\nlisten(\n  window,\n  \"pageshow\",\n  () => !loaded && dispatchPageLoaded((loaded = true))\n);\nlisten(\n  document,\n  \"visibilitychange\",\n  () =>\n    document.visibilityState === \"visible\" &&\n    !loaded &&\n    dispatchPageLoaded((loaded = true))\n);\n\ndispatchPageLoaded(loaded);\n\ntype PageActivatedListenerArgs = [activated: boolean, totalDuration: number];\nlet activated = false;\nlet activeTime = createTimer(false);\n\nconst [addPageActivatedListener, dispatchPageActivated] =\n  createEvent<PageActivatedListenerArgs>();\n\nconst activationTimeout = clock({\n  callback: () =>\n    activated && dispatchPageActivated((activated = false), activeTime(false)),\n  frequency: 20000,\n  once: true,\n  paused: true,\n});\nconst setActivated = () =>\n  !activated &&\n  (dispatchPageActivated((activated = true), activeTime(true)),\n  activationTimeout.restart());\n\nlisten(window, \"focus\", setActivated);\nlisten(window, \"blur\", () => activationTimeout.trigger());\n\nlisten(document.body, \"keydown\", setActivated);\nlisten(document.body, \"pointermove\", setActivated);\nlisten(window, \"scroll\", setActivated);\n\nsetActivated();\n\nexport const getActiveTime = () => activeTime();\nexport { addPageLoadedListener, addPageActivatedListener };\n","const codes: number[] = [];\nconst chars: number[] = [];\nexport const charCode = (s: string, index = 0) => s.charCodeAt(index);\nexport const fromCharCodes = (chars: number[]) => String.fromCharCode(...chars);\n\n[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"].forEach(\n  (p, i) => (codes[(chars[i] = p.charCodeAt(0))] = i)\n);\n\n/**\n * Encodes an array of bytes to Base64URL without padding (URL safe Base64 using `-` and `_` instead of `+` and `/`).\n *\n * (thanks to Jon Leighton at https://gist.github.com/jonleighton/958841).\n */\nexport const to64u = (bytes: Uint8Array) => {\n  let i = 0;\n  let chunk: number;\n  const n = bytes.length;\n\n  const base64: number[] = [];\n  while (i < n) {\n    chunk = (bytes[i++] << 16) | (bytes[i++] << 8) | bytes[i++];\n    base64.push(\n      chars[(chunk & 16515072) >> 18],\n      chars[(chunk & 258048) >> 12],\n      chars[(chunk & 4032) >> 6],\n      chars[chunk & 63]\n    );\n  }\n  base64.length += n - i;\n\n  return fromCharCodes(base64);\n};\n\n/**\n * Decodes a BaseURL encoded string (without padding).\n */\nexport const from64u = (encoded: string) => {\n  let i = 0;\n  let j = 0;\n  let p: number;\n  const n = encoded.length;\n  const bytes = new Uint8Array(3 * ((n / 4) | 0) + (((n + 3) & 3) % 3));\n  while (i < n) {\n    bytes[j++] =\n      (codes[charCode(encoded, i++)] << 2) |\n      ((p = codes[charCode(encoded, i++)]) >> 4);\n    if (i < n) {\n      bytes[j++] = ((p & 15) << 4) | ((p = codes[charCode(encoded, i++)]) >> 2);\n      if (i < n) {\n        bytes[j++] = ((p & 3) << 6) | codes[charCode(encoded, i++)];\n      }\n    }\n  }\n  return bytes;\n};\n","import { hasValue, isBoolean } from \"..\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  (value: T, bits?: 32 | 64 | 128): string;\n  <B extends boolean>(value: T, numeric: B): B extends true ? number : string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key = \"\"): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (iw = 0; iw < key.length; mixer0 += window0[iw] = key.charCodeAt(iw++));\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero it all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: Uint8Array, numericOrBits: any = 64) => {\n      if (!hasValue(source)) return null;\n      bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n","import msgpack from \"@ygoe/msgpack\";\nconst { deserialize, serialize } = msgpack;\n\nimport { HashFunction, from64u, lfsr, to64u } from \".\";\nimport {\n  IsNever,\n  Nullish,\n  hasValue,\n  isArray,\n  isDefined,\n  isFunction,\n  isIterable,\n  isNumber,\n  isObject,\n  isString,\n  isSymbol,\n  isUndefined,\n  map,\n  tryCatch,\n} from \"..\";\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\nexport type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the constract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properies that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param validate This property has no effect other than letting TypeScript validate whether the value can be deserialized back to its original form without losing properties.\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  (value: any, validate?: false): string;\n  <T = Encodable>(value: T & EncodableContract<T>, validate: true): string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(encoded: string | Nullish) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\nconst floatBuffer = new ArrayBuffer(8);\nconst floatView = new DataView(floatBuffer);\n\n/**\n * Misc. fixes to the msgpack library. For example, it does not handle exponential numbers well.\n */\nconst patchSerialize = (value: any) => {\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number;\n  const patchProperty = (\n    value: any,\n    key: any,\n    val = value[key],\n    patched = inner(val)\n  ) => (\n    (val !== patched || isSymbol(key)) &&\n      ((value[key] = patched), addCleaner(() => (value[key] = val))),\n    val\n  );\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (value == null || isFunction(value) || isSymbol(value)) {\n      return null;\n    }\n\n    if (Number.isFinite(value) && !Number.isSafeInteger(value)) {\n      // A bug in @ygoe/msgpack means floats do not get encoded. We need to encode them in a different way.\n      // This is how it landed, since data structure is highly unlikely to be encountered,\n      // yet it is probably not the best way to do this (apart from fixing the bug ofc.)\n      floatView.setFloat64(0, value, true);\n      return { \"\": [...new Uint32Array(floatBuffer)] };\n    }\n\n    if (!isObject(value, true)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if (isDefined((refIndex = (refs ??= new Map()).get(value)))) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isObject(value)) {\n      refs.set(value, refs.size + 1);\n\n      Object.keys(value).forEach(\n        (k) =>\n          (isUndefined(patchProperty(value, k)) || isSymbol(k)) &&\n          delete value[k]\n      );\n    } else if (isIterable(value)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  const serialized = serialize(inner(value));\n  cleaners?.forEach((cleaner) => cleaner());\n  return serialized;\n};\n\nconst patchDeserialize = (value: Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value, true)) return value;\n\n    if (isArray(value[\"\"]) && (value = value[\"\"]).length === 2) {\n      return new DataView(new Uint32Array(value).buffer).getFloat64(0, true);\n    }\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return hasValue(value)\n    ? tryCatch(\n        () => inner(deserialize(value)),\n        () => undefined\n      )\n    : undefined;\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<any>\n];\n\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lsfr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (\n  key?: null | string,\n  json = false\n): Transport => {\n  const [encrypt, decrypt, hash] = lfsr(key ?? \"\");\n  const fastStringHash = (value: any, bitsOrNumeric: any) => {\n    if (isNumber(value) && bitsOrNumeric === true) return value;\n\n    value = isString(value)\n      ? new Uint8Array(map(value.length, (i) => value.charCodeAt(i) & 255))\n      : json\n      ? JSON.stringify(value)\n      : patchSerialize(value);\n    return hash(value, bitsOrNumeric);\n  };\n  return json\n    ? [\n        (data: any) => JSON.stringify(data),\n        (encoded) =>\n          encoded == null\n            ? undefined\n            : tryCatch(() => JSON.parse(encoded, undefined)),\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ]\n    : [\n        (data: any) => to64u(encrypt(patchSerialize(data))),\n        (encoded: any) =>\n          hasValue(encoded)\n            ? patchDeserialize(decrypt(from64u(encoded)))\n            : null,\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ];\n};\n\nexport const defaultTransport = createTransport();\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\n","﻿(function () {\r\n\t\"use strict\";\r\n\r\n\t// Serializes a value to a MessagePack byte array.\r\n\t//\r\n\t// data: The value to serialize. This can be a scalar, array or object.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple values in data are concatenated to multiple MessagePack arrays.\r\n\t// - invalidTypeReplacement: The value that is used to replace values of unsupported types, or a function that returns such a value, given the original value as parameter.\r\n\tfunction serialize(data, options) {\r\n\t\tif (options && options.multiple && !Array.isArray(data)) {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\r\n\t\t}\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet floatBuffer, floatView;\r\n\t\tlet array = new Uint8Array(128);\r\n\t\tlet length = 0;\r\n\t\tif (options && options.multiple) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tappend(data[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tappend(data);\r\n\t\t}\r\n\t\treturn array.subarray(0, length);\r\n\r\n\t\tfunction append(data, isReplacement) {\r\n\t\t\tswitch (typeof data) {\r\n\t\t\t\tcase \"undefined\":\r\n\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\tappendBoolean(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tappendNumber(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tappendString(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif (data === null)\r\n\t\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\telse if (data instanceof Date)\r\n\t\t\t\t\t\tappendDate(data);\r\n\t\t\t\t\telse if (Array.isArray(data))\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\r\n\t\t\t\t\t\tappendBinArray(data);\r\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\r\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\r\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tappendObject(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\r\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendNull(data) {\r\n\t\t\tappendByte(0xc0);\r\n\t\t}\r\n\r\n\t\tfunction appendBoolean(data) {\r\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\r\n\t\t}\r\n\r\n\t\tfunction appendNumber(data) {\r\n\t\t\tif (isFinite(data) && Math.floor(data) === data) {\r\n\t\t\t\t// Integer\r\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0 && data >= -0x20) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\r\n\t\t\t\t\tappendBytes([0xcc, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\r\n\t\t\t\t\tappendBytes([0xd0, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\r\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\r\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\r\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\r\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\r\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\r\n\t\t\t\t\t// 32 bits for bitwise operations.\r\n\t\t\t\t\tlet hi = data / pow32;\r\n\t\t\t\t\tlet lo = data % pow32;\r\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\r\n\t\t\t\t\tappendByte(0xd3);\r\n\t\t\t\t\tappendInt64(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0) {   // below int64\r\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t\telse {   // above uint64\r\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Float\r\n\t\t\t\tif (!floatView) {\r\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\r\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\r\n\t\t\t\t}\r\n\t\t\t\tfloatView.setFloat64(0, data);\r\n\t\t\t\tappendByte(0xcb);\r\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendString(data) {\r\n\t\t\tlet bytes = encodeUtf8(data);\r\n\t\t\tlet length = bytes.length;\r\n\r\n\t\t\tif (length <= 0x1f)\r\n\t\t\t\tappendByte(0xa0 + length);\r\n\t\t\telse if (length <= 0xff)\r\n\t\t\t\tappendBytes([0xd9, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(bytes);\r\n\t\t}\r\n\r\n\t\tfunction appendArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x90 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let index = 0; index < length; index++) {\r\n\t\t\t\tappend(data[index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendBinArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendBytes([0xc4, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(data);\r\n\t\t}\r\n\r\n\t\tfunction appendObject(data) {\r\n\t\t\tlet length = 0;\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tif (data[key] !== undefined) {\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x80 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tlet value = data[key];\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tappend(key);\r\n\t\t\t\t\tappend(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendDate(data) {\r\n\t\t\tlet sec = data.getTime() / 1000;\r\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\r\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\r\n\t\t\t\tappendInt64(sec);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendByte(byte) {\r\n\t\t\tif (array.length < length + 1) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + 1)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray[length] = byte;\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\tfunction appendBytes(bytes) {\r\n\t\t\tif (array.length < length + bytes.length) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + bytes.length)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray.set(bytes, length);\r\n\t\t\tlength += bytes.length;\r\n\t\t}\r\n\r\n\t\tfunction appendInt64(value) {\r\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\r\n\t\t\t// bitwise operations.\r\n\t\t\tlet hi, lo;\r\n\t\t\tif (value >= 0) {\r\n\t\t\t\t// Same as uint64\r\n\t\t\t\thi = value / pow32;\r\n\t\t\t\tlo = value % pow32;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\r\n\t\t\t\tvalue++;\r\n\t\t\t\thi = Math.abs(value) / pow32;\r\n\t\t\t\tlo = Math.abs(value) % pow32;\r\n\t\t\t\thi = ~hi;\r\n\t\t\t\tlo = ~lo;\r\n\t\t\t}\r\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deserializes a MessagePack byte array to a value.\r\n\t//\r\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple concatenated MessagePack arrays are returned as an array.\r\n\tfunction deserialize(array, options) {\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet pos = 0;\r\n\t\tif (array instanceof ArrayBuffer) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\r\n\t\t}\r\n\t\tif (!array.length) {\r\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\r\n\t\t}\r\n\t\tif (!(array instanceof Uint8Array)) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tlet data;\r\n\t\tif (options && options.multiple) {\r\n\t\t\t// Read as many messages as are available\r\n\t\t\tdata = [];\r\n\t\t\twhile (pos < array.length) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Read only one message and ignore additional data\r\n\t\t\tdata = read();\r\n\t\t}\r\n\t\treturn data;\r\n\r\n\t\tfunction read() {\r\n\t\t\tconst byte = array[pos++];\r\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\r\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\r\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\r\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\r\n\t\t\tif (byte === 0xc0) return null;   // nil\r\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\r\n\t\t\tif (byte === 0xc2) return false;   // false\r\n\t\t\tif (byte === 0xc3) return true;   // true\r\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\r\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\r\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\r\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\r\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\r\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\r\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\r\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\r\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\r\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\r\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\r\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\r\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\r\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\r\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\r\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\r\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\r\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\r\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\r\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\r\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\r\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\r\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\r\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\r\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\r\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\r\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\r\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\r\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\r\n\t\t\tconsole.debug(\"msgpack array:\", array);\r\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\r\n\t\t}\r\n\r\n\t\tfunction readInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\tlet first = true;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tlet byte = array[pos++];\r\n\t\t\t\t\tvalue += byte & 0x7f;\r\n\t\t\t\t\tif (byte & 0x80) {\r\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvalue *= 256;\r\n\t\t\t\t\tvalue += array[pos++];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readUInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tvalue *= 256;\r\n\t\t\t\tvalue += array[pos++];\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readFloat(size) {\r\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\r\n\t\t\tpos += size;\r\n\t\t\tif (size === 4)\r\n\t\t\t\treturn view.getFloat32(0, false);\r\n\t\t\tif (size === 8)\r\n\t\t\t\treturn view.getFloat64(0, false);\r\n\t\t}\r\n\r\n\t\tfunction readBin(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = array.subarray(pos, pos + size);\r\n\t\t\tpos += size;\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readMap(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = {};\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tlet key = read();\r\n\t\t\t\tdata[key] = read();\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readArray(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = [];\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readStr(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet start = pos;\r\n\t\t\tpos += size;\r\n\t\t\treturn decodeUtf8(array, start, size);\r\n\t\t}\r\n\r\n\t\tfunction readExt(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet type = readUInt(1);\r\n\t\t\tlet data = readBin(size);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 255:\r\n\t\t\t\t\treturn readExtDate(data);\r\n\t\t\t}\r\n\t\t\treturn { type: type, data: data };\r\n\t\t}\r\n\r\n\t\tfunction readExtDate(data) {\r\n\t\t\tif (data.length === 4) {\r\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\treturn new Date(sec * 1000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 8) {\r\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\r\n\t\t\t\t\t((data[1] << 14) >>> 0) +\r\n\t\t\t\t\t((data[2] << 6) >>> 0) +\r\n\t\t\t\t\t(data[3] >>> 2);\r\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\r\n\t\t\t\t\t((data[4] << 24) >>> 0) +\r\n\t\t\t\t\t((data[5] << 16) >>> 0) +\r\n\t\t\t\t\t((data[6] << 8) >>> 0) +\r\n\t\t\t\t\tdata[7];\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 12) {\r\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\tpos -= 8;\r\n\t\t\t\tlet sec = readInt(8);\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Encodes a string to UTF-8 bytes.\r\n\tfunction encodeUtf8(str) {\r\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\r\n\t\tlet ascii = true, length = str.length;\r\n\t\tfor (let x = 0; x < length; x++) {\r\n\t\t\tif (str.charCodeAt(x) > 127) {\r\n\t\t\t\tascii = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\r\n\t\tfor (let ci = 0; ci !== length; ci++) {\r\n\t\t\tlet c = str.charCodeAt(ci);\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tbytes[i++] = c;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c < 2048) {\r\n\t\t\t\tbytes[i++] = c >> 6 | 192;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\r\n\t\t\t\t\tif (++ci >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\r\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\r\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\r\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\r\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\r\n\t\t\t\t}\r\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\r\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\r\n\t\t\t}\r\n\t\t\tbytes[i++] = c & 63 | 128;\r\n\t\t}\r\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\r\n\t}\r\n\r\n\t// Decodes a string from UTF-8 bytes.\r\n\tfunction decodeUtf8(bytes, start, length) {\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = start, str = \"\";\r\n\t\tlength += start;\r\n\t\twhile (i < length) {\r\n\t\t\tlet c = bytes[i++];\r\n\t\t\tif (c > 127) {\r\n\t\t\t\tif (c > 191 && c < 224) {\r\n\t\t\t\t\tif (i >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\r\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 223 && c < 240) {\r\n\t\t\t\t\tif (i + 1 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\r\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 239 && c < 248) {\r\n\t\t\t\t\tif (i + 2 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\r\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\r\n\t\t\t}\r\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\r\n\t\t\telse if (c <= 0x10ffff) {\r\n\t\t\t\tc -= 0x10000;\r\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\r\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\r\n\t\t\t}\r\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\r\n\t// The exported functions\r\n\tlet msgpack = {\r\n\t\tserialize: serialize,\r\n\t\tdeserialize: deserialize,\r\n\r\n\t\t// Compatibility with other libraries\r\n\t\tencode: serialize,\r\n\t\tdecode: deserialize\r\n\t};\r\n\r\n\t// Environment detection\r\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\r\n\t\t// Node.js\r\n\t\tmodule.exports = msgpack;\r\n\t}\r\n\telse {\r\n\t\t// Global object\r\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\r\n\t}\r\n\r\n})();\r\n","import {\n  Binders,\n  Listener,\n  clear,\n  clock,\n  createEvent,\n  forEach,\n  isDefined,\n  isString,\n  isUndefined,\n  joinEventBinders,\n  now,\n} from \"@tailjs/util\";\nimport { createTransport } from \"@tailjs/util/transport\";\nimport { DEBUG, TAB_ID, addPageLoadedListener, error, listen, log } from \".\";\n\nexport type Metadata<T = any> = [value: T, source?: string, expires?: number];\n\nexport type StorageProviderObserver<T = any> = (\n  newValue: T | undefined,\n  oldValue: T | undefined,\n  key: string | null\n) => void;\n\nexport interface StorageProvider {\n  getItem<T = any>(key: string): [value: T, source?: string] | undefined;\n  setItem<T = any>(\n    key: string,\n    value: T,\n    source?: string,\n    timeout?: number\n  ): void;\n  removeItem(key: string): void;\n  observe?<T = any>(key: string, observer: StorageProviderObserver<T>): Binders;\n}\n\ntype TypedStorageObserverArgs<T = any> = [\n  newValue: T | undefined,\n  context: {\n    key: string | null;\n    oldValue: string | undefined;\n    source?: string | undefined;\n    self?: boolean;\n  }\n];\nexport type TypedStorageObserver<T = any> = Listener<\n  TypedStorageObserverArgs<T>\n>;\n\nexport interface TypedStorage {\n  get<T = any>(key: string): T | undefined;\n  set<T>(key: string, value: T, timeout?: number): T;\n  delete(key: string): void;\n  update<T = any>(\n    key: string,\n    newValue: (current: T | undefined) => T,\n    timeout?: number\n  ): T;\n  observe?<T = any>(\n    key: string,\n    observer: TypedStorageObserver<T>,\n    includeSelf?: boolean\n  ): Binders;\n}\n\nexport interface BoundStorage<T = any> {\n  get(): T | undefined;\n  set<Undefined extends undefined | never = never>(\n    value: T | undefined,\n    timeout?: number\n  ): T | Undefined;\n  delete(): void;\n  update<Undefined extends undefined | T = T>(\n    newValue: (current: T | undefined) => T | Undefined,\n    timeout?: number\n  ): T | Undefined;\n  observe?(observer: TypedStorageObserver<T>, observeSelf?: boolean): Binders;\n}\n\n// TODO: Initialize from tailjs.init.\nexport const [serialize, deserialize] = createTransport(\"foo\", DEBUG);\n\nexport const mapStorage = <P extends StorageProvider>(\n  provider: P\n): P[\"observe\"] extends undefined ? TypedStorage : Required<TypedStorage> => {\n  const [addOwnListener, dispatchOwn] = createEvent<TypedStorageObserverArgs>();\n\n  const get = (key: string) => provider.getItem(key)?.[0];\n\n  const set = <T>(key: string, value: T | undefined, timeout?: number) => {\n    const oldValue = get(key);\n    if (isUndefined(value)) {\n      provider.removeItem(key);\n      dispatchOwn(undefined, { key, oldValue, source: TAB_ID, self: true });\n    } else {\n      provider.setItem(key, value, TAB_ID, timeout);\n      dispatchOwn(value, { key, oldValue, source: TAB_ID, self: true });\n    }\n    if (timeout! <= 0) {\n      provider.removeItem(key);\n    }\n    return value as any;\n  };\n\n  let retries = 0;\n  const update = <T>(\n    key: string,\n    newValue: (current: T | undefined) => T | undefined,\n    timeout: number\n  ) => {\n    if (retries++ > 3) {\n      error(`Race condition ('${key}').`, true);\n    }\n    const value = set(key, newValue(provider.getItem<T>(key)?.[0]), timeout);\n    const writtenValue = provider.getItem(key);\n    if (writtenValue?.[1] && writtenValue?.[1] !== TAB_ID) {\n      return update(key, newValue, timeout);\n    }\n    retries = 0;\n    return value;\n  };\n\n  return {\n    get,\n    set,\n    delete: (key) => set(key, undefined),\n    update,\n    observe: provider.observe\n      ? (key, listener, observeSelf) => {\n          const [unbind, bind] = joinEventBinders(\n            provider.observe!(key, (newValue, oldValue, key) =>\n              listener(\n                newValue?.[0],\n                { key, oldValue: oldValue?.[0], source: newValue?.[1] },\n                unbind\n              )\n            ),\n            observeSelf\n              ? addOwnListener(\n                  (value, context, unbind) =>\n                    context.key === key && listener(value, context, unbind)\n                )\n              : undefined\n          );\n          return [unbind, bind];\n        }\n      : undefined,\n  } as TypedStorage as any;\n};\n\nconst parsePayload = (value: any): [value: string, timeout?: number] => {\n  if (!isString(value)) return [value];\n\n  const [, payload, parsedTimeout] = value.match(/(.*?)(?:@:([0-9a-z]+))?$/)!;\n  return [\n    payload,\n    isDefined(parsedTimeout) ? parseInt(parsedTimeout, 36) : undefined,\n  ];\n};\nconst purgeIfExpired = (key: string, value: any) => {\n  const [payload, timeout] = parsePayload(value);\n  if (timeout && timeout - now() < 0) {\n    clear(localStorage, key);\n    return undefined;\n  }\n  return payload;\n};\n\nexport const sharedStorage = mapStorage({\n  getItem: (key) => deserialize(purgeIfExpired(key, localStorage.getItem(key))),\n  setItem: (key, value, source, timeout) =>\n    localStorage.setItem(\n      key,\n      serialize([value, source]) +\n        (timeout! > 0 ? `@:${(now() + timeout!).toString(36)}` : \"\")\n    ),\n  removeItem: (key) => localStorage.removeItem(key),\n  observe: (key, observer) => {\n    const [unbind, bind] = listen(\n      window,\n      \"storage\",\n      ({ key: changedKey, newValue, oldValue }) =>\n        key == changedKey &&\n        observer(\n          deserialize(parsePayload(newValue)[0]),\n          deserialize(parsePayload(oldValue)[0]),\n          key\n        )\n    );\n\n    return joinEventBinders(\n      [unbind, bind],\n      addPageLoadedListener((loaded) => (loaded ? bind() : unbind()))\n    );\n  },\n});\n\nconst purgeTask = clock({\n  frequency: 2000,\n  callback: () =>\n    forEach(localStorage, ([key, value]) => !purgeIfExpired(key as any, value)),\n  trigger: true,\n});\naddPageLoadedListener((loaded) => purgeTask.toggle(loaded));\n\nexport const bindStorage: {\n  <T>(\n    key: string,\n    defaultTimeout?: number,\n    storage?: Required<TypedStorage>\n  ): Required<BoundStorage<T>>;\n  <T>(\n    key: string,\n    defaultTimeout?: number,\n    storage?: TypedStorage\n  ): BoundStorage<T>;\n} = <T>(\n  key: string,\n  defaultTimeout?: number,\n  storage: TypedStorage = sharedStorage\n): Required<BoundStorage<T>> => ({\n  get: () => storage.get<T>(key),\n  set: (value, timeout) =>\n    storage.set(key, value as any, timeout ?? defaultTimeout),\n  delete: () => storage.delete(key),\n  update: (updater, timeout) =>\n    storage.update(key, updater as any, timeout ?? defaultTimeout),\n  observe: storage.observe\n    ? (observer, includeSelf) => storage.observe!(key, observer, includeSelf)\n    : undefined!,\n});\n","import {\n  filter,\n  isDefined,\n  isObject,\n  joinEventBinders,\n  map,\n} from \"@tailjs/util\";\nimport { TAB_ID, bindStorage, sharedStorage } from \".\";\n\n/**\n * A channel is used by tabs to communicate with each other.\n */\nexport type Channel<T> = {\n  /**\n   * Posts a message in the channel.\n   *\n   * @param payload The payload of the message.\n   * @param target If specified, on the tab with this ID will get the message.\n   */\n  post(payload: T, target?: string): void;\n\n  /**\n   * Stop receiving messages from the channel.\n   * A tab automatically subscribes/unsubscribes when it enters and leaves bfcache.\n   */\n  unsubscribe: () => void;\n};\n\ntype ChannelPayload<T> = [sender: string, payload: T, target?: string];\n\n/**\n * Subscribes to the channel with the specified id.\n */\nexport const subscribeChannel = <T>(\n  id: string,\n  handler: (sender: string, payload: T, direct: boolean) => void,\n  listenSelf = false,\n  storage = sharedStorage\n): Channel<T> => {\n  const channel = bindStorage<ChannelPayload<T>>(id, 0, storage);\n  return {\n    post: (payload, target) => channel.set([TAB_ID, payload, target]),\n    unsubscribe: channel.observe(\n      (value) =>\n        isDefined(value) &&\n        (!value[2] || value[2] === TAB_ID) &&\n        handler(value[0], value[1], isDefined(value[2])),\n      listenSelf\n    )[0],\n  };\n};\n\nlet chatChannel: Channel<[message: string, error?: string]> | undefined;\nexport const error: {\n  (message: string, fatal: boolean): void;\n  (message: string, cause?: any, fatal?: boolean);\n} = (message: string, error?: any, throwError = false) => {\n  if (typeof error === \"boolean\") {\n    throwError = error;\n    error = null;\n  }\n  log(error ? message : null, error ?? message);\n  if (throwError) {\n    throw new Error(message);\n  }\n};\n\nexport const log = (message: any, error?: any) => {\n  const source = message;\n  if (error) {\n    error = JSON.stringify(\n      (error = isObject(error)\n        ? {\n            message: error.message ?? error,\n            stack: error.stack,\n          }\n        : error)\n    );\n  }\n\n  message = JSON.stringify(message);\n  (chatChannel ??= subscribeChannel<[string, string]>(\n    \"chat\",\n    (sender, parts) =>\n      console[parts[1] ? \"error\" : \"log\"](\n        sender === TAB_ID ? \"This tab\" : `Other tab (${sender})`,\n        ...map(filter(parts), (value) => JSON.parse(value))\n      ),\n    true\n  )).post([message, error]);\n  return source;\n};\n","import { clear, clock, createEvent, forEach, now, assign } from \"@tailjs/util\";\nimport {\n  TAB_HEARTBEAT,\n  TAB_ID,\n  addPageLoadedListener,\n  subscribeChannel,\n} from \".\";\n\nexport type TabState = {\n  id: string;\n  hearbeat: number;\n  viewId?: string;\n  navigated?: number;\n};\n\nexport type State = {\n  knownTabs: Record<string, TabState>;\n  variables: Record<string, any>;\n};\n\nconst tabState: TabState = {\n  id: TAB_ID,\n  hearbeat: now(),\n};\n\nconst state: State = {\n  knownTabs: {\n    [TAB_ID]: tabState,\n  },\n  variables: {},\n};\n\ntype StateMessage =\n  | { type: \"query\"; data?: undefined }\n  | {\n      type: \"set\";\n      data: State;\n    }\n  | {\n      type: \"patch\";\n      data: State[\"variables\"];\n    }\n  | {\n      type: \"tab\";\n      data?: TabState;\n    };\n\nconst initTimeout = clock(() => dispatchState(\"ready\", { state }), -25);\nconst stateChannel = subscribeChannel<StateMessage>(\n  \"state\",\n  (sender, { type, data }) => {\n    if (type === \"query\") {\n      !initTimeout.active &&\n        stateChannel.post({ type: \"set\", data: state }, sender);\n    } else if (type === \"set\" && initTimeout.active) {\n      assign(state, data);\n      initTimeout.trigger();\n    } else if (type === \"patch\") {\n      assign(state, data);\n      dispatchState(\"update\", { state, variables: data });\n    } else if (type === \"tab\") {\n      assign(state.knownTabs, sender, data);\n      dispatchState(\"update\", { state, tab: data });\n    }\n  }\n);\n\nconst [addStateListener, dispatchState] = createEvent<\n  [\n    event: \"ready\" | \"update\",\n    state: {\n      state: State;\n      variables?: State[\"variables\"];\n      tab?: TabState;\n    }\n  ]\n>();\n\nconst heartbeat = clock(() => {\n  const timeout = now() - TAB_HEARTBEAT * 2;\n  forEach(\n    state?.knownTabs,\n    // Remove interval tabs.\n    ([tabId, tabState]) =>\n      tabState[0] < timeout && clear(state!.knownTabs, tabId)\n  );\n  tabState.hearbeat = now();\n  stateChannel.post({ type: \"tab\", data: tabState });\n}, TAB_HEARTBEAT);\n\nconst toggleTab = (loading: boolean) => {\n  stateChannel.post({ type: \"tab\", data: loading ? tabState : undefined });\n  if (loading) {\n    initTimeout.restart();\n    stateChannel.post({ type: \"query\" });\n  } else {\n    initTimeout.toggle(false);\n  }\n  heartbeat.toggle(loading);\n};\n\naddPageLoadedListener((loaded) => toggleTab(loaded), true);\n\nexport { addStateListener };\n","export const DEBUG = true;\nexport const TAB_HEARTBEAT = 5_000;\nexport const STATE_KEY = \"_t.sr\";\n","import { clock } from \"@tailjs/util\";\nimport { listen, log } from \".\";\n\nconst eventQueue: string[] = [];\n\nconst poster = clock(() => {\n  if (eventQueue.length) {\n    //log([\"Posting\", eventQueue.splice(0)]);\n  }\n}, 5000);\n\nexport const enqueueEvent = (event: string) => {\n  eventQueue.push(event);\n};\n\nlisten(\n  document,\n  \"visibilitychange\",\n  () => document.visibilityState === \"hidden\" && poster.trigger()\n);\n\n// const postLock = createLock<string[]>(\"test_queue_lck\", 2000);\n// export const post = async (data: string[]) => {\n//   if (\n//     !(\n//       await postLock(async () => {\n//         let pending: string[] | undefined;\n//         await tryCatchAsync(\n//           async () => {\n//             for (;;) {\n//               postLock.data.update(\n//                 (current) => ((pending = current!), undefined)\n//               );\n//               if (data) {\n//                 pending = [...(pending ?? []), ...data];\n//                 data = undefined as any;\n//               }\n//               if (!pending) {\n//                 break;\n//               }\n\n//               log([\"Posting\", pending]);\n//               await delay(2000);\n//               if (Math.random() < 0.5) {\n//                 throw new Error(\"Eeek!\");\n//               }\n//               log(`Posted ${pending.length} item(s).`);\n//             }\n//           },\n//           async (e, last) => {\n//             if (last) {\n//               error(\n//                 `Post failed 3 times in a row, events will not be sent.`,\n//                 e\n//               );\n//               throw e;\n//             } else {\n//               pending &&\n//                 postLock.data.update(\n//                   (current) => ((current ??= []).unshift(...pending!), current)\n//                 );\n//               error(`Post failed, retrying...`, e);\n//               await delay(250);\n//             }\n//           },\n//           undefined,\n//           3\n//         );\n//       }, 0)\n//     )[1]\n//   ) {\n//     postLock.data.update(\n//       (current) => ((current ??= []).push(...data), current)\n//     );\n//     log(\"Another post is active. Queued data.\");\n//   }\n// };\n","import {\n  addPageActivatedListener,\n  addStateListener,\n  getActiveTime,\n  listen,\n  log,\n  enqueueEvent,\n} from \"./lib2\";\n\n//const lck = createLock(\"test\");\nexport const attach = async () => {\n  addPageActivatedListener((activated) => {\n    // console.log(\n    //   `Activated: ${activated}. Total active time: ${getActiveTime()}.`\n    // );\n  }, true);\n\n  addStateListener((event, state) => {\n    log(state.tab);\n  });\n\n  listen(document.body, \"click\", () => {\n    enqueueEvent(\"Click!\");\n  });\n\n  // let invocations = 0;\n  // let clicked = false;\n  // const pump = clock(\n  //   async () => {\n  //     const capturedClick = clicked;\n  //     if (!clicked && invocations % 2 === 1) {\n  //       await wait(1500);\n  //     }\n  //     console.log(`${++invocations}, clicked: ${capturedClick}.`);\n  //   },\n  //   { frequency: 1000, queue: false }\n  // );\n\n  // let testId = 1;\n  // listen(document.body, \"click\", async (e) => {\n  //   // clicked = true;\n  //   // console.log(pump.active, pump.busy);\n  //   // e.shiftKey && pump.toggle(!pump.active);\n  //   // console.log(await pump.trigger(true));\n  //   // (async () => {\n  //   //   clicked = false;\n  //   // })();\n  //   post([`Test ${testId++}`]);\n  // });\n  // listen(document.body, \"click\", () => {\n  //   updateTabState((tab) => (tab.navigated = now()));\n\n  //   lck(async () => {\n  //     console.log(\"Lock acquired.\");\n  //     await wait(5000);\n  //   });\n  // });\n  // listen(\n  //   window,\n  //   \"pageshow\",\n  //   () =>\n  //     activeTabs.update(\n  //       (current) => (\n  //         ((current = cast(current, isObject) ?? {})[TAB_ID] = now()), current\n  //       )\n  //     )\n  //   //activeStorage.update((current) => (current ?? 0) + 1)\n  // );\n  // listen(\n  //   window,\n  //   \"pagehide\",\n  //   () =>\n  //     activeTabs.update(\n  //       (current) => (isObject(current) && delete current[TAB_ID], current)\n  //     )\n  //   // activeStorage.update((current: any) =>\n  //   //   current > 0 ? current - 1 : current\n  //   // )\n  // );\n};\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\n//import { initializeTracker } from \"./initializeTracker\";\n//import { F, T, define, window } from \"./lib\";\nimport { attach } from \"./pusher\";\n\n// This assumes the script is loaded from the RequestHandler's ?cfg route.\n\n// To prevent external scripts from eaves-dropping and get a hold of the storage key, this is how initialization works:\n// 1: The configuration scripts appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overriden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nwindow[INITIALIZE_TRACKER_FUNCTION] = (callback: any) => {\n  callback(attach);\n};\n\n// let loaded = F;\n// define(window, {\n//   [INITIALIZE_TRACKER_FUNCTION]: [\n//     (callback: (init: typeof initializeTracker) => void) => {\n//       if (loaded === (loaded = T)) return;\n//       callback(initializeTracker);\n//     },\n//   ],\n// });\n"],"names":["setter","undefined","MAX_SAFE_INTEGER","Number","symbolIterator","Symbol","iterator","NO_ARG","tryCatch","expression","errorHandler","clean","e","isBoolean","error","Error","console","isUndefined","value","isDefined","hasValue","isString","isArray","Array","isObject","acceptIterables","isSymbol","isFunction","isIterable","acceptStrings","stopInvoked","sliceAction","action","start","end","index","createIterator","source","item","i","key","step","maxIterations","length","offset","map","projection","mapped","j","n","push","project","forEachInternal","returnValue","forEachArray","forEach","reduce","reducer","seed","seedFactory","filter","predicate","projected","setSingle","target","delete","set","add","get","initializer","has","assign","clearSingle","current","clear","keys","removed","array","clearStep","parent","parentKey","targetKeys","size","Object","remove","sort","x","y","splice","now","performance","Math","trunc","timeOrigin","Date","clock","callbackOrSettings","frequency","settings","callback","queue","paused","trigger","once","timeoutId","mutex","ResetablePromise","resolve","outerCallback","skipQueue","pending","instance","busy","reset","cancelled","async","retries","await","clearInterval","active","setInterval","restart","newFrequency","newCallback","toggle","_promise","constructor","this","ifPending","reject","OpenPromise","signal","then","onfulfilled","onrejected","captured","Promise","args","inner","TypeError","createEventBinders","listener","attach","detach","bound","outerListener","unbind","rebind","joinEventBinders","binders","changed","binder","createEvent","dispatchedArgs","listeners","Set","handler","payload","TAB_ID","toString","random","padStart","listen","name","options","capture","passive","addEventListener","addPageLoadedListener","dispatchPageLoaded","loaded","activated","window","document","visibilityState","activeTime","t0","createTimer","elapsed","addPageActivatedListener","dispatchPageActivated","activationTimeout","setActivated","codes","body","chars","charCode","s","charCodeAt","FNVs","p","32","64","128","entropy","max","deserialize","serialize","data","multiple","floatBuffer","floatView","pow32","Uint8Array","append","subarray","isReplacement","appendNull","appendByte","lo","isFinite","floor","appendBytes","hi","appendInt64","ArrayBuffer","DataView","setFloat64","appendNumber","bytes","str","ascii","ci","c","c2","ns","sec","getTime","getMilliseconds","appendArray","Uint8ClampedArray","appendBinArray","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","appendObject","invalidTypeReplacement","byte","newLength","newArray","abs","pos","read","readMap","readArray","readStr","readBin","readExt","readFloat","readUInt","readInt","debug","first","view","buffer","byteOffset","getFloat32","getFloat64","lengthSize","String","fromCharCode","decodeUtf8","type","msgpack","encode","decode","module","exports","msgpackJsName","REF_PROP","patchSerialize","cleaners","refs","refIndex","patchProperty","val","patched","addCleaner","cleaner","isSafeInteger","toJSON","Map","k","_","serialized","createTransport","json","encrypt","decrypt","hash","pad","bits","prime","mixer","mixer255","iw","mixer0","window0","resetMixer","updateMixer","ENTROPY","cipher","numericOrBits","BigInt","asUintN","MIN_SAFE_INTEGER","fastStringHash","bitsOrNumeric","JSON","stringify","encoded","parse","chunk","base64","matchedRef","entries","v","parsePayload","parsedTimeout","match","parseInt","purgeIfExpired","timeout","localStorage","sharedStorage","provider","addOwnListener","dispatchOwn","getItem","oldValue","removeItem","self","setItem","update","newValue","writtenValue","observe","observeSelf","bind","context","mapStorage","observer","changedKey","purgeTask","chatChannel","subscribeChannel","id","listenSelf","storage","channel","defaultTimeout","updater","includeSelf","post","unsubscribe","message","throwError","log","stack","sender","parts","tabState","hearbeat","state","knownTabs","variables","initTimeout","dispatchState","stateChannel","tab","addStateListener","heartbeat","TAB_HEARTBEAT","tabId","poster","loading","event"],"mappings":"yBAKO,IC6bHA,ECnESC,EAAAA,KAAAA,EAIAC,EAAmBC,OAAOD,iBAG1BE,EAAiBC,OAAOC,SAGxBC,EAASF,SAWTG,EAAW,CACtBC,EACAC,EAAAA,CAAAA,EACAC,KAEA,IACE,OAAOF,GAcT,CAbE,MAAOG,GACP,GAAA,CAAKC,EAAUH,CAAAA,EAAe,CAC5B,IAAMI,EAAQJ,IAAeE,CAAAA,EAC7B,GAAIE,aAAiBC,MAAO,MAAMD,EAClC,OAAOA,CACT,CACA,GAAIJ,EACF,MAAME,EAGR,OADAI,QAAQF,MAAMF,GACPX,EACC,QACRU,IAAAA,CACF,CA+CWM,EAAAA,EAAeC,GAC1BA,IAAUjB,EAECkB,EAAgBD,GAC3BA,IAAUjB,EAMCmB,EACXF,GAlGiB,MAmGgCA,EAEtCL,EAAaK,GACP,WAAA,OAAVA,EAwBIG,EAAYH,GACN,UAAA,OAAVA,EAMII,EAAmDC,MAAMD,QAqBzDE,EAAW,CACtBN,EACAO,EAAmC,CAAA,IAI1B,MAATP,GACiB,iBAAVA,IACNO,GAAAA,CAAoBP,EAAMd,IAoBhBsB,EAAYR,GACN,UAAVA,OAAAA,EAEIS,EAAcT,GACR,YAAA,OAAVA,EAEIU,EAAa,CACxBV,EACAW,EAAgB,CAAA,IAAA,EAAA,CAEbX,IAAQd,IAAqC,UAAA,OAAVc,GAAsBW,CAAAA,GCpiB1DC,EAAc,CAAA,EA0KZC,EAAc,CAIlBC,EACAC,EACAC,KAECD,GAASC,KAASjC,GACdgC,IAAW,EACXC,IAAQhC,EACT,CAACgB,EAAOiB,IACNF,CAAAA,GACIhC,EACAiC,CAAAA,GACAF,EACEA,EAAOd,EAAOiB,CACdjB,EAAAA,EACFgB,GACLF,EAODI,EAAiB,CACrBC,EACAL,EACAC,EACAC,IAEU,MAAVG,EACK,GACDA,EAAOjC,GAvGb,UAGEiC,EAAWL,GACX,GAAKK,EAAL,CAEA,IACSC,EADLC,EAAI,EACR,IAASD,KAAQD,EAKf,GAJAL,IAAWM,EAAON,EAAOM,EAAMC,CAAAA,EAAAA,GAC3BD,IAASrC,IACLqC,MAAAA,GAEJR,EAAa,CACfA,EAAc,CAAA,EACd,KACF,CAXW,CAaf,EAwFQO,EACAJ,IAAUhC,EAAY+B,EAASD,EAAYC,EAAQC,EAAcC,CAEjD,CAAA,EAAA,UAAA,OAAXG,EAzFb,UAGEA,EAAWL,GACX,IACWQ,EADPD,EAAI,EACR,IAAWC,KAAOH,EAAQ,CACxB,IAAInB,EAAQ,CAACsB,EAAKH,EAAOG,IAMzB,IALWtB,EAAXc,EAAmBA,EAAOd,EAAOqB,CAAAA,EAAAA,EAE7BrB,KAAUjB,IACNiB,MAAAA,GAEJY,EAAa,CACfA,EAAc,CAAA,EACd,KACF,CACF,CACF,EA0EQO,EACAN,EAAYC,EAAQC,EAAcC,CAEpCE,CAAAA,EAAAA,EACET,EAAWU,CAxDZ,EAAA,UACLI,EACAR,EACAS,EAAgBvC,OAAOD,kBAGvB,IADIiB,EAAUc,CAAcA,IAAAA,MAAAA,GACrBS,CAAmBvB,IAAAA,EAAWc,EAAQQ,EAAKR,CAC1CA,CAAAA,GAAAA,MAAAA,CAEV,EAgDqCI,EAAQJ,EAAOC,CAAAA,EA7EpD,UAA8BS,EAAS,EAAGC,EAAS,GACjD,KAAOD,CAAAA,IAAAA,MAAgBC,CACzB,EAAA,EA4EiCP,EAAkBJ,CAC3CD,EAAAA,CAAAA,EAmGKa,EAAmB,CAC9BR,EACAS,EACAb,EAAahC,EACbiC,KAEA,GAAID,IAAUhC,GAAaqB,EAAQe,CAAAA,EAAS,CAG1C,IAFA,IAAIE,EAAI,EACFQ,EAAgB,GACbC,EAAI,EAAGC,EAAIZ,EAAOM,OAAQK,EAAIC,GAAMnB,CAAAA,EAAakB,CAAK,GAAA,CAC7D,IAAI9B,EAAQmB,EAAOW,IAEjB9B,EADE4B,GAAc5B,IAAUjB,EAClB6C,EAAW5B,EAAOqB,CAAAA,EAAAA,EAExBrB,KAAUjB,GACZ8C,EAAOG,KAAKhC,EAEhB,CAEA,OADAY,EAAc,CAAA,EACPiB,CACT,CACA,OAAOV,IAAWpC,GDiKlBiB,GAGAD,EAAYC,CAAAA,EACRjB,EACUqB,EAAQJ,CAClBA,EAAAA,EACAU,EAAWV,CAAAA,EACX,CAAIA,GAAAA,GACH,CAACA,KCrPiC,CACvCmB,EACAS,EACAb,EACAC,IAEc,MAAdY,GAAuBnB,EAAWmB,GAG9BV,EAAeC,EAAQS,EAAYb,EAAOC,CAD1CE,EAAAA,EAAeC,EAAQpC,EAAW6C,EAAYb,CAoEtCkB,GAAQd,EAAQS,EAAYb,EAAOC,CAAAA,CAAAA,EAC1CjC,CAAAA,EA2NDmD,EAKe,CAACf,EAAQL,EAAQC,EAAQhC,EAAWiC,KACvD,GAAc,MAAVG,EAAJ,CAEA,IAAIgB,EAOOnC,EANX,GAAIe,IAAUhC,EAAW,CACvB,GAAIqB,EAAQe,CAAS,EAAA,OAvDJ,CAACA,EAAwBL,KAG5C,IAFA,IAAIqB,EACAd,EAAI,EACCS,EAAI,EAAGC,EAAIZ,EAAOM,OAAQK,EAAIC,EAAGD,IACxC,GACEX,EAAOW,KAAO/C,IACboD,EAAerB,EAAOK,EAAOW,GAAIT,MAAQc,EAAcvB,GACxD,CACAA,EAAAA,CAAAA,EACA,KACF,CAEF,OAAOuB,CA2CuBC,GAAajB,EAAQL,CAAAA,EACjD,GAAIK,EAAOjC,GAAiB,OAzCP,CAACiC,EAAuBL,KAC/C,IAAIqB,EAEKnC,EADLqB,EAAI,EACR,IAASrB,KAASmB,EAChB,GACEnB,IAAUjB,IACToD,EAAerB,EAAOd,EAAOqB,CAAAA,EAAAA,GAAQc,EAAcvB,GACpD,CACAA,EAAc,CAAA,EACd,KACF,CAEF,OAAOuB,IA6B+ChB,EAAeL,CACnE,EAAA,GAAsB,UAAXK,OAAAA,EAAqB,OA3Bd,CAACA,EAAaL,KAClC,IAAIqB,EAEKb,EADLD,EAAI,EACR,IAASC,KAAOH,EACd,GACIgB,EAAcrB,EAAO,CAACQ,EAAKH,EAAOG,IAAOD,CAAAA,EAAAA,GAAQc,EACnDvB,EACA,CACAA,EAAc,CAAA,EACd,KACF,CAEF,OAAOuB,IAegDhB,EAAQL,CAC/D,CAAA,CAEA,IAAWd,KAASkB,EAAeC,EAAQL,EAAQC,EAAOC,CACxDmB,EAAAA,EAAcnC,GAAkBmC,EAGlC,OAAOA,CAba,CAabA,EAGIE,EAAUH,EAkGVI,EAkBD,CAACnB,EAAQoB,EAASC,EAAMzB,EAAaC,KAC/C,IAAMyB,EAAc,IAAOhC,EAAW+B,CAAAA,EAAQA,EAASA,EAAAA,EACvD,OACEN,EACEf,EAAAA,CACCnB,EAAOiB,IACLuB,EACED,EAAiBC,EAAaxC,EAAOiB,CACtCwB,GAAAA,EAAAA,EACJ1B,EACAC,CAAAA,GACIyB,EAAAA,CAAAA,EAWGC,EAaT,CACFvB,EACAwB,EAA0BvB,GAAsB,MAARA,EACxCO,EAAMvB,EAAQe,CAAAA,EACdJ,EACAC,KAngBA4B,GA4gBEjB,GAzgBMvB,CAAAA,EAAQwC,CAAa,EAAA,CAAA,GAAIA,GAAcA,GAmgB7C1B,EACEC,EAAAA,CACCC,EAAMH,IAAW0B,EAAUvB,EAAMH,CAASG,EAAAA,EAAOrC,EAClDgC,EACAC,CAEFW,CAAAA,EFnpBEkB,EAAY,CAACC,EAAaxB,EAAUtB,KAC9BjB,KAAAA,IAAViB,EACI8C,EAAOC,OACLD,EAAOC,OAAOzB,CACPwB,EAAAA,OAAAA,EAAOxB,GAChBwB,EAAOE,IACPF,EAAOE,IAAI1B,EAAKtB,GAChB8C,EAAOG,IACPjD,EACE8C,EAAOG,IAAI3B,CAAAA,EACXwB,EAAOC,OAAOzB,GACfwB,EAAOxB,GAAOtB,EAEZA,GAqBIkD,EAyBT,CAKFJ,EACAxB,EACA6B,KAEA,IAEInD,EAFJ,GAAK8C,EAaL,OAXI9C,EAAQ8C,EAAgBI,IACxBJ,EAAgBI,IAAI5B,CACpBwB,EAAAA,EAAgBM,IAChBN,EAAgBM,IAAI9B,CAAAA,EACpBwB,EAAOxB,GAEPvB,EAAYC,CAAAA,GAAUC,EAAUkD,CAAAA,GAClClD,EACGD,EAAQS,EAAW0C,CAAAA,EAAgBA,IAAwBA,CACzDN,GAAAA,EAAUC,EAAQxB,EAAKtB,CAEvBA,EAAAA,CAAAA,EA+QIqD,GAjBTvE,EAiByD+D,EAf3D,CAACC,EAA2BxB,EAAUtB,EAAaX,EAAQO,KACzD,GAAKkD,EACL,OAAI9C,IAAUX,EACLP,EAAOgE,EAAQxB,EAAKtB,EAAOJ,IAGpCyC,EAAQf,EAAMF,GACZhB,EAAQgB,CACJtC,EAAAA,EAAOgE,EAAQ1B,EAAK,GAAIA,EAAK,EAAA,EAC7BiB,EAAQjB,EAAAA,CAAM,CAAEE,EAAKtB,KAAWlB,EAAOgE,EAAQxB,EAAKtB,CAAAA,CAAAA,CAAAA,EAGnD8C,EAAAA,GAuELQ,EAAc,CAACR,EAAaxB,KAChC,IAEIiC,EAFJ,IAAIxD,EAAY+C,GAAUxB,CAA1B,EASA,OAPIiC,EAAUL,EAAIJ,EAAQxB,CAO1B,ECcqC,YAAA,ODnBvBwB,GCmBkBC,ODlB9BD,EAAOC,OAAOzB,CAAAA,EAAAA,OAEPwB,EAAOxB,GAETiC,CAAAA,EAUIC,EAAQ,CAInBV,KACGW,KAEH,IAAMC,EAAiB,GACnBC,EAAQ,CAAA,EAENC,EAAY,CAChBd,EACA7B,EACA4C,EACAC,KAEA,IEqNF3C,EAOIY,EF5NGe,IACCiB,EAAaN,EAAKxC,GACpBA,IAAUwC,EAAKhC,OAAS,EACtBrB,EAAQ2D,IACVJ,EAAQ,CAAA,EACRI,EAAW1B,QAASf,GAAQoC,EAAQ1B,KAAKsB,EAAYR,EAAQxB,CAE7DoC,CAAAA,CAAAA,GAAAA,EAAQ1B,KAAKsB,EAAYR,EAAQiB,CAAAA,CAAAA,GAG/B3D,EAAQ2D,CAAAA,GACVJ,KACAI,EAAW1B,QAASf,GAClBsC,EAAUV,EAAIJ,EAAQxB,CAAAA,EAAML,EAAQ,EAAG6B,EAAQxB,CAGjDsC,CAAAA,GAAAA,EAAUV,EAAIJ,EAAQiB,CAAa9C,EAAAA,EAAQ,EAAG6B,EAAQiB,CAAAA,EAAAA,GEqM5D5C,EFnMe2B,GE8MT7C,EAAW8B,EAAIZ,UAAqBA,EAAQ6C,IACvCjC,EAAAA,EAEJZ,EAAOjC,IAId6C,EAAI,EACGG,EAAgBf,EAAAA,MAAgBY,CAJ5BkC,GAAAA,OAAOR,KAAKtC,CAAAA,EAAQM,OAVX1C,IFxMM8E,GACpBK,EAAOL,EAAQC,CAnBN,GAqBb,EAGF,OADAF,EAAUd,EAAQ,CACXa,EAAAA,EAAQD,EAAUA,EAAQ,EAAE,EAQxBQ,EAST,CAACpB,EAA2BxB,KAAamC,KAC3C,GAAKX,EAEL,OAAIW,EAAKhC,QAECrB,EAAQ0C,GAAUW,EAAKU,KAAAA,CAAMC,EAAGC,IAAMA,EAAID,CAAKX,EAAAA,GAAM9B,IAAKL,GAChE4C,EAAOpB,EAAQxB,CAAAA,CAAAA,EAIZlB,EAAQ0C,CAAAA,EACXxB,EAAMwB,EAAOrB,OACXqB,EAAkBwB,OAAOhD,EAAK,CAAA,EAAG,GACjCvC,KAAAA,EACFuE,EAAYR,EAAQxB,CAAAA,CAAAA,EGxmBfiD,EAAM,IACQ,aAAhBC,OAAAA,YACHC,KAAKC,MAAMF,YAAYG,WAAaH,YAAYD,IAChDK,CAAAA,EAAAA,KAAKL,IAmCEM,EAAAA,EAGT,CACFC,EACAC,EAAY,KAEZ,IAAMC,EAAWvE,EAAWqE,CACxB,EAAA,CACEC,UACAE,EAAAA,SAAUH,GAEZA,EAEAI,CAAAA,MACFA,EAAQ,CAAA,EAAIC,OACZA,EAAAA,CAAAA,EAAcC,QACdA,KAAeC,KACfA,EAAO,CAAA,EAAKJ,SACZA,EAAW,MACTD,EAAAA,EAGAM,GAFJP,EAAYC,EAASD,WAAa,EAElB,GACVQ,GCqFM,IAAIC,GDrFYC,QAEtBC,EAAAA,EAAuBC,MAAAA,IAC3B,GAAKL,CAAAA,GAAAA,CAAeJ,GAASK,EAAMK,cAAWD,EAC5C,MAAO,CAAA,GAERE,EAAiBC,KAAAA,CAAAA,KACdH,SACIJ,EAGRA,EAAMQ,MACN,EAAA,IAAIC,EAAYjB,EAAY,GAAKM,EAWjC,aF4UyBY,MAM3BC,EAAU,KAEV,KAAOA,KACL,IACE,OAAAC,ME/VMlB,EAAU,IAAOe,EAAY,CAAA,CAAA,CF4WrC,CAZE,MAAOtG,GACP,GAAKC,CAAAA,EEjW8B,CAAA,GFiWL,CAC5B,IAAMC,EAAeJ,MElWY,CAAA,GFkWGE,EAAIwG,CAAAA,CAAAA,EACxC,GAAItG,aAAiBC,MAAO,MAAMD,EAClC,OAAOA,EAIPE,QAAQF,MAAMF,CAAAA,EAER,QExWF6F,EAAME,QAEVO,CFwWJ,CAEF,OAAOjH,CAAAA,GE1WDiH,EAAAA,GACFD,EAAM,CAAA,CAAA,IAGPF,EAAiBC,KAAAA,CAAAA,EACX,EAGHC,EAAShF,IACbqF,cAAcd,CAAAA,EACbO,EAAiBQ,OAAAA,CAAAA,EAAYf,EAAYvE,EACrCuF,YACCZ,EACAX,EAAY,EAAKA,CAAAA,EAAYA,CAE/B,EAAA,GACGc,GAGHA,EAAkB,CACtBQ,OAAQ,CAAA,EACRP,KAAM,CAAA,EACNS,QAAS,CAACC,EAAcC,KACtB1B,EAAYyB,GAAgBzB,EAC5BE,EAAWwB,GAAexB,EACnBc,EAAAA,CAAAA,IAETW,OAAQ,CAAC3F,EAAOqE,IACdrE,IAAU8E,EAASQ,OACftF,EACEqE,GACGW,EAAM,CAAA,CAAA,EAAOF,EAAST,QAAAA,EAAWS,GAClCE,EAAAA,CAAAA,CACFA,EAAAA,EAAAA,CAAAA,GACFF,EACNT,QAAgBO,MAAAA,GAAAA,MACPD,EAAcC,CAAAA,IAAgBI,EAAMF,EAASQ,WAGxD,EAAA,OAAOR,EAASa,OAAAA,CAAQvB,EAAQC,CAAAA,CAAAA,QCjHrBI,EACHmB,SAERC,cACEC,KAAKd,MACP,CAAA,CAEA/F,YACE,OAAO6G,KAAKF,SAAS3G,KACvB,CACAJ,YACE,OAAOiH,KAAKF,SAAS/G,KACvB,CACAgG,cACE,OAAOiB,KAAKF,SAASf,OACvB,CAEOH,QAAQzF,EAAU8G,EAAAA,CAAAA,GAEvB,OADAD,KAAKF,SAASlB,QAAQzF,EAAO8G,CAAAA,EACtBD,IACT,CAEOE,OAAO/G,EAAW8G,EAAAA,CAAAA,GAEvB,OADAD,KAAKF,SAASI,OAAO/G,EAAO8G,CAAAA,EACrBD,IACT,CAEOd,QAEL,OADAc,KAAKF,SAAW,IAAIK,EACbH,IACT,CAEOI,OAAOjH,GAGZ,OAFA6G,KAAKpB,QAAQzF,CAAAA,EACb6G,KAAKd,MAAAA,EACEc,IACT,CAEOK,KACLC,EAIAC,GAKA,OAAOP,KAAKF,SAASO,KAAKC,EAAaC,CACzC,CAAA,CAAA,OAGWJ,EACML,SAEDlB,QACAsB,OACA/G,MACAJ,MACTgG,QAAU,CAAA,EAEjBgB,cACE,IAAIS,EACJR,KAAKF,SAAW,IAAIW,QAAQ,IAAIC,KAC9BF,EAAWE,EAAK5F,IAAAA,CAAK6F,EAAOnG,IAAM,CAACrB,EAAY8G,KAC7C,GAAKD,KAAKjB,QAQV,OAHAiB,KAAcjB,QAAU,CAAA,EACxBiB,KAAcxF,EAAI,QAAU,SAAA,CAAYpB,EAAUD,CAAUA,GAAAA,EAC5DwH,EAAMxH,CAAAA,EACC6G,KAPL,GAAIC,EAAW,OAAOD,KACtB,MAAM,IAAIY,UAAU,oCAAA,CAMX,CAAA,CAIdZ,CAAAA,EAAAA,CAAAA,KAAKpB,QAASoB,KAAKE,QAAUM,CAChC,CAEOH,KACLC,EAIAC,GAKA,OAAOP,KAAKF,SAASO,KAAKC,EAAaC,CACzC,CAAA,CAAA,CA8CK,IC9IMM,EAAqB,CAChCC,EACAC,EACAC,KAEA,IAAIC,EAAQ,CAAA,EAENC,EAAgB,IAAIR,IAAeI,EAAAA,GAAYJ,EAAMS,CAErDA,EAAAA,EAAS,IACbF,KAAWA,EAAQ,CAAA,KAAWD,EAAOE,CAAAA,EAAAA,CAAAA,GAEjCE,EAAS,IACbH,KAAWA,EAAAA,CAAAA,KAAkBF,EAAOG,CAAgB,EAAA,CAAA,GAGtD,OADAE,EACO,EAAA,CAACD,EAAQC,EAAO,EAGZC,EAAmB,IAC3BC,KAEFA,EAAUzF,EAAOyF,CAAAA,EAClB,CACE,IAAM7F,EAAO6F,EAAAA,CAAUC,EAASC,IAAWA,EAAQ,GAAQD,GAAAA,EAAAA,CAAAA,CAC3D,EAAA,IAAM9F,EAAO6F,EAAAA,CAAUC,EAASC,IAAWA,EAAQ,GAAA,GAAQD,EAAS,CAAA,CAAA,IAM3DE,EAAc,KAIzB,IACIC,EADEC,EAAY,IAAIC,IAEtB,MAAO,CACL,CAACC,EAAStD,KACR,IAAM+C,EAAUT,EACdgB,EACCA,GAAYF,EAAUvF,IAAIyF,CAAAA,EAC1BA,GAAYF,EAAUzF,OAAO2F,CAGhC,CAAA,EAAA,OADAtD,GAAWmD,GAAkBG,EAAWH,GAAAA,EAAgBJ,EAAQ,EACzDA,EAAAA,CAAAA,EAET,IAAIQ,KACDJ,EAAiBI,EAClBH,EAAUnG,QAASqG,GAAYA,EAAAA,GAAWC,CAE7C,CAAA,GAAA,EC1DQC,EACTrE,EAAAA,EAAMsE,SAAS,EAAA,EACfpE,KAAKC,MAAM,KAAOD,KAAKqE,OAAAA,CAAAA,EACpBD,SAAS,EAAA,EACTE,SAAS,EAAG,KCUJC,EAAS,CACpBlG,EAYAmG,EACAtB,EAIAuB,EAAmC,CAAEC,QAAAA,CAAAA,EAAeC,QAAS,CAAA,CAAA,IAEtDhJ,EAAQ6I,CAAAA,EACXf,EACKvG,GAAAA,EAAIsH,EAAOA,GAASD,EAAOlG,EAAQmG,EAAatB,EAAUuB,CAAAA,CAAAA,CAAAA,EAE/DxB,EACEC,EACCA,GAAa7E,EAAOuG,iBAAiBJ,EAAMtB,EAAUuB,CACrDvB,EAAAA,GAAa7E,EAAOuG,iBAAiBJ,EAAMtB,EAAUuB,KAKvDI,EAAuBC,GAC5BjB,EAEEkB,EAAAA,EAAAA,CAAAA,EAuBAC,GAtBJT,EACEU,OACA,WAAA,IACMF,GAAUD,EAAoBC,EAAS,CAAA,CAAA,CAAA,EAE/CR,EACEU,OACA,WACA,IAAA,CAAOF,GAAUD,EAAoBC,EAAAA,CAAAA,CAEvCR,CAAAA,EAAAA,EACEW,SACA,mBAAA,IAE+B,YAA7BA,SAASC,iBACRJ,CAAAA,GACDD,EAAoBC,EAAAA,CAAAA,CAGxBD,CAAAA,EAAAA,EAAmBC,CAGnB,EAAgB,CAAA,GACZK,GJxDuB,KACzB,IAAIC,EIuDWC,CAAAA,EJtDXC,EAAU,EACd,OAAQtD,IACNoD,IAAOE,GAAWzF,EAAAA,EAASuF,GAC3B7J,EAAUyG,CAAAA,IAAYoD,EAAKpD,GAAUnC,EAC9ByF,GAAAA,EIkDMD,MAEVE,EAA0BC,GAC/B5B,EAEI6B,EAAAA,EAAoBtF,EAAM,CAC9BI,SAAU,IACRwE,GAAaS,EAAuBT,EAAAA,CAAAA,EAAoBI,EAAAA,CAAAA,CAC1D9E,CAAAA,EAAAA,UAAW,IACXM,KAAAA,CAAAA,EACAF,OAAQ,CAAA,CAAA,CAAA,EAEJiF,EAAe,IAAA,CAClBX,IACAS,EAAuBT,EAAY,CAAA,EAAOI,IAC3CM,CAAAA,EAAAA,EAAkB5D,QAEpByC,GC9FMqB,GD8FNrB,EAAOU,OAAQ,QAASU,CACxBpB,EAAAA,EAAOU,OAAQ,OAAQ,IAAMS,EAAkB/E,QAAAA,CAAAA,EAE/C4D,EAAOW,SAASW,KAAM,UAAWF,GACjCpB,EAAOW,SAASW,KAAM,cAAeF,CACrCpB,EAAAA,EAAOU,OAAQ,SAAUU,GAEzBA,ECrGA,EAAwB,IAClBG,EAAkB,GACXC,EAAW,CAACC,EAAWxJ,EAAQ,IAAMwJ,EAAEC,WAAWzJ,CAG/D,ECIM0J,GDJN,CAAA,GAAI,oEAAoEtI,QAAAA,CACrEuI,EAAGvJ,IAAOgJ,EAAOE,EAAMlJ,GAAKuJ,EAAEF,WAAW,CAAA,GAAOrJ,GCGF,CAC/CwJ,GAAI,CAAC,YAAa,aAClBC,GAAI,CAAC,oBAAqB,gBAC1BC,IAAK,CAAC,oCAAqC,2BAAA,GAIvCC,EAAU,CAACC,EAAM,MAAQA,EAAOxG,KAAKqE,OAAAA,EAAY,mCCf/CoC,GAAWC,UAAEA,EAAAA,ICDpB,KASA,SAASA,EAAUC,EAAMlC,GACxB,GAAIA,GAAWA,EAAQmC,UAAAA,CAAahL,MAAMD,QAAQgL,CACjD,EAAA,MAAM,IAAIvL,MAAM,wEAAA,EAEjB,IACIyL,EAAaC,EADXC,EAAQ,WAEV7H,EAAQ,IAAI8H,WAAW,GAAA,EACvBhK,EAAS,EACb,GAAIyH,GAAWA,EAAQmC,SACtB,IAAK,IAAIhK,EAAI,EAAGA,EAAI+J,EAAK3J,OAAQJ,CAChCqK,GAAAA,EAAON,EAAK/J,EAIbqK,OAAAA,EAAON,CAER,EAAA,OAAOzH,EAAMgI,SAAS,EAAGlK,CAAAA,EAEzB,SAASiK,EAAON,EAAMQ,GACrB,OAAA,OAAeR,GACd,IAAK,YACJS,EAAAA,EACA,MACD,IAAK,WA0CgBT,IACtBU,EAAWV,EAAO,IAAO,GAAA,IA1CTA,CAAAA,EACd,MACD,IAAK,UA2CeA,IACrB,IA8BMW,EA9BFC,SAASZ,CAAS3G,GAAAA,KAAKwH,MAAMb,CAAAA,IAAUA,EAE9B,EAARA,EAAQ,GAAa,IAARA,IAGRA,EAAO,GAAc,CAAA,IAATA,EAFpBU,EAAWV,CAAAA,EAKI,EAAPA,GAAYA,GAAQ,IAC5Bc,EAAY,CAAC,IAAMd,EAAAA,EAEXA,GAAS,KAAgB,IAARA,EAGV,EAAPA,GAAYA,GAAQ,MAC5Bc,EAAY,CAAC,IAAMd,IAAS,EAAGA,EAAAA,EAEvBA,EAAS,CAAA,OAAkB,MAARA,EAGZ,EAAPA,GAAYA,GAAQ,WAC5Bc,EAAY,CAAC,IAAMd,IAAS,GAAIA,IAAS,GAAIA,IAAS,EAAGA,IAEjDA,EAAS,CAAA,YAAsB,WAARA,EAGhB,EAAPA,GAAYA,GAAQ,oBAK5Bc,EAAY,CAAC,KAFTC,EAAKf,EAAOI,KAEU,GAAIW,IAAO,GAAIA,IAAO,EAAGA,GAD/CJ,EAAKX,EAAOI,KAC8C,GAAIO,IAAO,GAAIA,IAAO,EAAGA,EAAAA,EAE/EX,GAAS,oBAA8B,mBAARA,EAKvCc,EADQd,EAAO,EACH,CAAC,IAAM,IAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAG/B,CAAC,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,OAP7DU,EAAW,GAAA,EACXM,EAAYhB,CAAAA,GAXZc,EAAY,CAAC,IAAMd,IAAS,GAAIA,IAAS,GAAIA,IAAS,EAAGA,EANzDc,EAAAA,EAAY,CAAC,IAAMd,IAAS,EAAGA,EAAAA,EAN/Bc,EAAY,CAAC,IAAMd,EAAAA,GAkCfG,IACJD,EAAc,IAAIe,YAAY,CAAA,EAC9Bd,EAAY,IAAIe,SAAShB,CAAAA,GAE1BC,EAAUgB,WAAW,EAAGnB,CACxBU,EAAAA,EAAW,GACXI,EAAAA,EAAY,IAAIT,WAAWH,IA/F1BkB,GAAapB,CACb,EAAA,MACD,IAAK,UAiGeA,IACrB,IAAIqB,GAmUcC,IAGnB,IADA,IAAIC,EAAAA,CAAAA,EAAclL,EAASiL,EAAIjL,OACtB2C,EAAI,EAAGA,EAAI3C,EAAQ2C,CAAAA,GAC3B,GAAwB,IAApBsI,EAAIhC,WAAWtG,CAAK,EAAK,CAC5BuI,EAAAA,CAAAA,EACA,KACA,CAKF,IADA,IAAItL,EAAI,EAAGoL,EAAQ,IAAIhB,WAAWiB,EAAIjL,QAAUkL,EAAQ,EAAI,EACnDC,EAAAA,EAAK,EAAGA,IAAOnL,EAAQmL,CAAAA,GAAM,CACrC,IAAIC,EAAIH,EAAIhC,WAAWkC,CACvB,EAAA,GAAIC,EAAI,IACPJ,EAAMpL,CAAAA,IAAOwL,MADd,CAIA,GAAIA,EAAI,KACPJ,EAAMpL,CAAAA,IAAOwL,GAAK,EAAI,QAElB,CACJ,GAAQ,MAAJA,GAAcA,EAAI,MAAQ,CAC7B,GAAA,EAAMD,GAAMnL,EACX,MAAM,IAAI5B,MAAM,yCACjB,EAAA,IAAIiN,EAAKJ,EAAIhC,WAAWkC,CACxB,EAAA,GAAIE,EAAK,OAAe,MAALA,EAClB,MAAM,IAAIjN,MAAM,8CAAgDiN,EAAGjE,SAAS,EAAA,EAAM,aAAe+D,EAAK,eACvGC,EACAJ,EAAMpL,CAAOwL,KADbA,EAAI,QAAgB,KAAJA,IAAe,KAAY,KAALC,KACpB,GAAK,IACvBL,EAAMpL,CAAOwL,IAAAA,GAAK,GAAK,GAAK,GAC5B,MACIJ,EAAMpL,CAAOwL,IAAAA,GAAK,GAAK,IAC5BJ,EAAMpL,CAAAA,IAAOwL,GAAK,EAAI,GAAK,GAC3B,CACDJ,EAAMpL,CAAAA,IAAW,GAAJwL,EAAS,GAlBrB,CAmBD,CACD,OAAOF,EAAQF,EAAQA,EAAMd,SAAS,EAAGtK,CACzC,CAAA,GAzWwB+J,CACnB3J,EAAAA,EAASgL,EAAMhL,OAEL,GAAVA,EAOHyK,EALkB,IAAVzK,EAEU,MAAVA,EAGI,CAAC,IAAMA,IAAW,GAAIA,IAAW,GAAIA,IAAW,EAAGA,GAFnD,CAAC,IAAMA,IAAW,EAAGA,GAFrB,CAAC,IAAMA,EAAAA,EAFnBqK,EAAW,IAAOrK,CAQnByK,EAAAA,EAAYO,CACZ,CAAA,GA9GerB,CACb,EAAA,MACD,IAAK,SACS,OAATA,EACHS,EACQT,GAAAA,aAAgBxG,KA+JRwG,IACnB,IASK2B,EATDC,EAAM5B,EAAK6B,QAAAA,EAAY,IACI,IAA3B7B,EAAK8B,gBAAAA,GAAkC,GAAPF,GAAYA,EAAM,WACrDd,EAAY,CAAC,IAAM,IAAMc,IAAQ,GAAIA,IAAQ,GAAIA,IAAQ,EAAGA,EAAAA,EAE7C,GAAPA,GAAYA,EAAM,YAE1Bd,EAAY,CAAC,IAAM,KADfa,EAA8B,IAAzB3B,EAAK8B,gBACkB,KAAA,GAAIH,IAAO,GAAIA,IAAO,EAAKA,GAAM,IAAO,EAAMC,EAAMxB,EAAQwB,IAAQ,GAAIA,IAAQ,GAAIA,IAAQ,EAAGA,EAAAA,GAI/Hd,EAAY,CAAC,IAAM,GAAI,KADnBa,EAA8B,IAAzB3B,EAAK8B,gBACsB,KAAA,GAAIH,IAAO,GAAIA,IAAO,EAAGA,EAAAA,EAC7DX,EAAYY,CAAAA,EAEb,EA3KW3M,MAAMD,QAAQgL,CAAAA,EACtB+B,EACQ/B,aAAgBK,YAAcL,aAAgBgC,kBAsHlChC,IACvB,IAAI3J,EAAS2J,EAAK3J,OAOjByK,EALa,GAAVzK,EAEe,MAAVA,EAGI,CAAC,IAAMA,IAAW,GAAIA,IAAW,GAAIA,IAAW,EAAGA,GAFnD,CAAC,IAAMA,IAAW,EAAGA,GAFrB,CAAC,IAAMA,IAMpByK,EAAYd,CAAAA,CA/HTiC,EACQjC,aAAgBkC,WAAalC,aAAgBmC,YAAcnC,aAAgBoC,aACnFpC,aAAgBqC,YAAcrC,aAAgBsC,aAC9CtC,aAAgBuC,cAAgBvC,aAAgBwC,aAChDT,EA8HkB/B,IACrB,IAcS9J,EAdLG,EAAS,EACb,IAASH,KAAO8J,EACGrM,KAAAA,IAAdqM,EAAK9J,IACRG,CAWF,GAAA,IAASH,KAPK,GAAVG,EAKHyK,EAHkB,MAAVzK,EAGI,CAAC,IAAMA,IAAW,GAAIA,IAAW,GAAIA,IAAW,EAAGA,GAFnD,CAAC,IAAMA,IAAW,EAAGA,EAAAA,EAFjCqK,EAAW,IAAOrK,CAMH2J,EAAAA,EAAM,CACrB,IAAIpL,EAAQoL,EAAK9J,GAAAA,KAAAA,IACbtB,IACH0L,EAAOpK,CAAAA,EACPoK,EAAO1L,CAAAA,EAER,CAjJE6N,GAVWzC,CAAAA,EAWZ,MACD,QACC,GAAKQ,GAAiB1C,CAAAA,GAAAA,CAAWA,EAAQ4E,uBAOxC,MAAM,IAAIjO,MAAM,oCAA8CuL,OAAAA,EAAQ,yBANxB,EAAA,YAAA,OAAnClC,EAAQ4E,uBAClBpC,EAAOxC,EAAQ4E,uBAAuB1C,CAAO,EAAA,CAAA,CAAA,EAE7CM,EAAOxC,EAAQ4E,yBAMnB,CAAA,CAAA,CAED,SAASjC,IACRC,EAAW,GACX,CAAA,CA+ED,SAASqB,EAAY/B,GACpB,IAAI3J,EAAS2J,EAAK3J,OAEJ,GAAVA,EAKHyK,EAHkB,MAAVzK,EAGI,CAAC,IAAMA,IAAW,GAAIA,IAAW,GAAIA,IAAW,EAAGA,GAFnD,CAAC,IAAMA,IAAW,EAAGA,EAFjCqK,EAAAA,EAAW,IAAOrK,CAMnB,EAAA,IAAK,IAAIR,EAAQ,EAAGA,EAAQQ,EAAQR,CAAAA,GACnCyK,EAAON,EAAKnK,EAEb,CAAA,CAuDD,SAAS6K,EAAWiC,GACnB,GAAIpK,EAAMlC,OAASA,EAAS,EAAG,CAE9B,IADA,IAAIuM,EAA2B,EAAfrK,EAAMlC,OACfuM,EAAYvM,EAAS,GAC3BuM,GAAa,EACd,IAAIC,EAAW,IAAIxC,WAAWuC,CAAAA,EAC9BC,EAASjL,IAAIW,CACbA,EAAAA,EAAQsK,CACR,CACDtK,EAAMlC,GAAUsM,EAChBtM,CACA,EAAA,CAED,SAASyK,EAAYO,GACpB,GAAI9I,EAAMlC,OAASA,EAASgL,EAAMhL,OAAQ,CAEzC,IADA,IAAIuM,EAA2B,EAAfrK,EAAMlC,OACfuM,EAAYvM,EAASgL,EAAMhL,QACjCuM,GAAa,EACd,IAAIC,EAAW,IAAIxC,WAAWuC,CAAAA,EAC9BC,EAASjL,IAAIW,CACbA,EAAAA,EAAQsK,CACR,CACDtK,EAAMX,IAAIyJ,EAAOhL,CACjBA,EAAAA,GAAUgL,EAAMhL,MAChB,CAED,SAAS2K,EAAYpM,GAGpB,IAAImM,EAYHJ,EAXG/L,EAAS,GAOZA,IAGAmM,EAFAA,EAAK1H,KAAKyJ,IAAIlO,CAASwL,EAAAA,GACvBO,EAAKtH,KAAKyJ,IAAIlO,CAAAA,EAASwL,KAPvBW,EAAKnM,EAAQwL,EACRxL,EAAQwL,GAUdU,EAAY,CAACC,IAAO,GAAIA,IAAO,GAAIA,IAAO,EAAGA,EAAIJ,IAAO,GAAIA,IAAO,GAAIA,IAAO,EAAGA,EACjF,CAAA,CACD,CAOD,SAASb,EAAYvH,EAAOuF,GAC3B,IAcIkC,EAdEI,EAAQ,WACV2C,EAAM,EAIV,GAAqB,UAAVxK,OAFVA,EADGA,aAAiB0I,YACZ,IAAIZ,WAAW9H,CAAAA,EAEbA,IAAAA,KAAAA,IAA6BA,EAAMlC,OAC7C,MAAM,IAAI5B,MAAM,sFAEjB,GAAK8D,CAAAA,EAAMlC,OACV,MAAM,IAAI5B,MAAM,2DAMjB,EAAA,GAJM8D,aAAiB8H,aACtB9H,EAAQ,IAAI8H,WAAW9H,CAGpBuF,GAAAA,GAAWA,EAAQmC,SAGtB,IADAD,EAAO,GACA+C,EAAMxK,EAAMlC,QAClB2J,EAAKpJ,KAAKoM,EAAAA,CAAAA,OAKXhD,EAAOgD,EAER,EAAA,OAAOhD,EAEP,SAASgD,IACR,IAAML,EAAOpK,EAAMwK,KACnB,GAAY,GAARJ,GAAgBA,GAAQ,IAAM,OAAOA,EACzC,GAAY,KAARA,GAAgBA,GAAQ,IAAM,OAAOM,EAAQN,EAAO,GACxD,EAAA,GAAY,KAARA,GAAgBA,GAAQ,IAAM,OAAOO,EAAUP,EAAO,GAC1D,EAAA,GAAY,KAARA,GAAgBA,GAAQ,IAAM,OAAOQ,EAAQR,EAAO,GACxD,EAAA,GAAa,MAATA,EAAe,OAAO,KAC1B,GAAa,MAATA,EAAe,MAAM,IAAIlO,MAAM,+BACnC,EAAA,GAAa,MAATkO,EAAe,MAAO,CAAA,EAC1B,GAAa,MAATA,EAAe,MAAO,CAAA,EAC1B,GAAa,MAATA,EAAe,OAAOS,EAAS,CAAA,EAAG,GACtC,GAAa,MAATT,EAAe,OAAOS,EAAS,CAAA,EAAG,CACtC,EAAA,GAAa,MAATT,EAAe,OAAOS,EAAS,CAAA,EAAG,CACtC,EAAA,GAAa,MAATT,EAAe,OAAOU,EAAS,CAAA,EAAG,CACtC,EAAA,GAAa,MAATV,EAAe,OAAOU,EAAAA,CAAS,EAAG,CACtC,EAAA,GAAa,MAATV,EAAe,OAAOU,EAAAA,CAAS,EAAG,CAAA,EACtC,GAAa,MAATV,EAAe,OAAOW,EAAU,CAAA,EACpC,GAAa,MAATX,EAAe,OAAOW,EAAU,CACpC,EAAA,GAAa,MAATX,EAAe,OAAOY,EAAS,GACnC,GAAa,MAATZ,EAAe,OAAOY,EAAS,CAAA,EACnC,GAAa,MAATZ,EAAe,OAAOY,EAAS,CACnC,EAAA,GAAa,MAATZ,EAAe,OAAOY,EAAS,GACnC,GAAa,MAATZ,EAAe,OAAOa,EAAQ,CAAA,EAClC,GAAa,MAATb,EAAe,OAAOa,EAAQ,CAClC,EAAA,GAAa,MAATb,EAAe,OAAOa,EAAQ,GAClC,GAAa,MAATb,EAAe,OAAOa,EAAQ,CAAA,EAClC,GAAa,MAATb,EAAe,OAAOU,EAAQ,CAClC,EAAA,GAAa,MAATV,EAAe,OAAOU,EAAQ,GAClC,GAAa,MAATV,EAAe,OAAOU,EAAQ,CAAA,EAClC,GAAa,MAATV,EAAe,OAAOU,EAAQ,CAClC,EAAA,GAAa,MAATV,EAAe,OAAOU,EAAQ,IAClC,GAAa,MAATV,EAAe,OAAOQ,EAAS,CAAA,EAAG,CACtC,EAAA,GAAa,MAATR,EAAe,OAAOQ,EAAS,CAAA,EAAG,CACtC,EAAA,GAAa,MAATR,EAAe,OAAOQ,EAAS,CAAA,EAAG,CACtC,EAAA,GAAa,MAATR,EAAe,OAAOO,EAAAA,CAAW,EAAG,CACxC,EAAA,GAAa,MAATP,EAAe,OAAOO,EAAAA,CAAW,EAAG,CAAA,EACxC,GAAa,MAATP,EAAe,OAAOM,EAAAA,CAAS,EAAG,CAAA,EACtC,GAAa,MAATN,EAAe,OAAOM,EAAAA,CAAS,EAAG,CAAA,EACtC,GAAY,KAARN,GAAgBA,GAAQ,IAAM,OAAOA,EAAO,IAEhD,MADAjO,QAAQ+O,MAAM,iBAAkBlL,CAAAA,EAC1B,IAAI9D,MAAM,uBAAyBkO,EAAO,eAAiBI,EAAM,GAAK,2CAA6CxK,EAAMlC,OAAS,6DACxI,CAAA,CAED,SAASmN,EAAQ5K,GAGhB,IAFA,IAIM+J,EAJF/N,EAAQ,EACR8O,EAAQ,CAAA,EACI,EAAT9K,CAAS,IACX8K,GAEH9O,GAAgB,KADZ+N,EAAOpK,EAAMwK,CAAAA,KAEN,IAAPJ,IACH/N,GAAS,KAEV8O,EAAQ,CAAA,GAIR9O,GADAA,GAAS,KACA2D,EAAMwK,CAAAA,IAGjB,OAAOnO,CACP,CAED,SAAS2O,EAAS3K,GAEjB,IADA,IAAIhE,EAAQ,EACI,EAATgE,CAAS,IAEfhE,EADS,IAATA,EACS2D,EAAMwK,CAEhB,IAAA,OAAOnO,CACP,CAED,SAAS0O,EAAU1K,GAClB,IAAI+K,EAAO,IAAIzC,SAAS3I,EAAMqL,OAAQb,EAAMxK,EAAMsL,WAAYjL,CAE9D,EAAA,OADAmK,GAAOnK,EACM,IAATA,EACI+K,EAAKG,WAAW,EAAA,CAAA,CACX,EAAA,IAATlL,EACI+K,EAAKI,WAAW,EAAG,CAAA,CAAA,EAAA,KAAA,CAC3B,CAED,SAASX,EAAQxK,EAAMoL,GAClBpL,EAAO,IAAGA,EAAO2K,EAASS,CAAAA,GAC1BhE,EAAOzH,EAAMgI,SAASwC,EAAKA,EAAMnK,CAAAA,EAErC,OADAmK,GAAOnK,EACAoH,CACP,CAED,SAASiD,EAAQrK,EAAMoL,GAClBpL,EAAO,IAAGA,EAAO2K,EAASS,CAE9B,GAAA,IADA,IAAIhE,EAAO,GACK,EAATpH,CAAAA,IAENoH,EADUgD,EACEA,GAAAA,EAAAA,EAEb,OAAOhD,CACP,CAED,SAASkD,EAAUtK,EAAMoL,GACpBpL,EAAO,IAAGA,EAAO2K,EAASS,CAE9B,GAAA,IADA,IAAIhE,EAAO,GACK,EAATpH,CAAAA,IACNoH,EAAKpJ,KAAKoM,EAEX,CAAA,EAAA,OAAOhD,CACP,CAED,SAASmD,EAAQvK,EAAMoL,GAClBpL,EAAO,IAAGA,EAAO2K,EAASS,CAAAA,GAC1BrO,EAAQoN,EAEZ,OADAA,GAAOnK,GA0FT,CAAoByI,EAAO1L,EAAOU,KAEjC,IAAIJ,EAAIN,EAAO2L,EAAM,GAErB,IADAjL,GAAUV,EACHM,EAAII,GAAQ,CAClB,IAAIoL,EAAIJ,EAAMpL,CAAAA,IACd,GAAQ,IAAJwL,EACH,GAAQ,IAAJA,GAAWA,EAAI,IAAK,CACvB,GAASpL,GAALJ,EACH,MAAM,IAAIxB,MAAM,0CAAA,EACjBgN,GAAS,GAAJA,IAAW,EAAiB,GAAbJ,EAAMpL,IAC1B,MACI,GAAQ,IAAJwL,GAAWA,EAAI,IAAK,CAC5B,GAAapL,GAATJ,EAAI,EACP,MAAM,IAAIxB,MAAM,0CAAA,EACjBgN,GAAS,GAAJA,IAAW,IAAmB,GAAbJ,EAAMpL,CAAAA,MAAc,EAAiB,GAAboL,EAAMpL,CAAAA,GACpD,KACI,CAAQ,GAAJwL,GAAI,KAAW,KAAJA,EAKf,MAAM,IAAIhN,MAAM,2CAA6CgN,EAAEhE,SAAS,EAAM,EAAA,cAAgBxH,EAAI,EAAA,EAJtG,GAAaI,GAATJ,EAAI,EACP,MAAM,IAAIxB,MAAM,0CACjBgN,EAAAA,GAAS,EAAJA,IAAU,IAAmB,GAAbJ,EAAMpL,CAAc,MAAA,IAAmB,GAAboL,EAAMpL,CAAc,MAAA,EAAiB,GAAboL,EAAMpL,CAE4B,GAAA,CAE3G,GAAS,MAALwL,EACC,CAAA,GAAS,QAALA,EAKJ,MAAM,IAAIhN,MAAM,8BAAgCgN,EAAEhE,SAAS,EAAA,EAAM,yBAJrEgE,GAAK,MAELH,GADAA,GAAO2C,OAAOC,aAAazC,GAAK,GAAK,KAAA,GAC9BwC,OAAOC,aAAiB,KAAJzC,EAAY,KAEsD,CAAA,MAN7EH,GAAO2C,OAAOC,aAAazC,CAO5C,CAAA,CACD,OAAOH,CAzHC6C,GAAW5L,EAAO5C,EAAOiD,EAChC,CAED,SAASyK,EAAQzK,EAAMoL,GAClBpL,EAAO,IAAGA,EAAO2K,EAASS,CAC9B,GAAII,EAAOb,EAAS,CAChBvD,EAAAA,EAAOoD,EAAQxK,CAAAA,EACnB,OACM,MADEwL,GAOYpE,IACpB,IAQK2B,EAIAC,EAZL,GAAoB,IAAhB5B,EAAK3J,OAKR,OAJIuL,GAAQ5B,EAAK,IAAM,KAAQ,IAC5BA,EAAK,IAAM,KAAQ,IACnBA,EAAK,IAAM,IAAO,GACpBA,EAAK,GACC,IAAIxG,KAAW,IAANoI,CAChB,EACD,GAAoB,IAAhB5B,EAAK3J,OAUR,OATIsL,GAAO3B,EAAK,IAAM,KAAQ,IAC3BA,EAAK,IAAM,KAAQ,IACnBA,EAAK,IAAM,IAAO,IACnBA,EAAK,KAAO,GACV4B,GAAkB,EAAV5B,EAAK,IAAYI,GAC1BJ,EAAK,IAAM,KAAQ,IACnBA,EAAK,IAAM,KAAQ,IACnBA,EAAK,IAAM,IAAO,GACpBA,EAAK,GACC,IAAIxG,KAAW,IAANoI,EAAaD,EAAK,GAClC,EACD,GAAoB,KAAhB3B,EAAK3J,OAOR,OANIsL,GAAO3B,EAAK,IAAM,KAAQ,IAC3BA,EAAK,IAAM,KAAQ,IACnBA,EAAK,IAAM,IAAO,GACpBA,EAAK,GACN+C,GAAO,EACHnB,EAAM4B,EAAQ,CACX,EAAA,IAAIhK,KAAW,IAANoI,EAAaD,EAAK,GAAA,EAEnC,MAAM,IAAIlN,MAAM,uCAAA,IAlCKuL,CAAAA,EAEd,CAAEoE,KAAMA,EAAMpE,KAAMA,CAC3B,CAAA,CAiCD,CAgFD,IAAIqE,EAAU,CACbtE,UAAWA,EACXD,YAAaA,EAGbwE,OAAQvE,EACRwE,OAAQzE,CAAAA,EAIyB0E,GAEjCA,GAAAC,QAAiBJ,EAIjB/F,OAAOA,OAAOoG,eAAiB,WAAaL,CAxiB7C,GAAA,iHDwIKM,GAAW,OAEXzE,GAAc,IAAIe,YAAY,CAAA,EAC9Bd,GAAY,IAAIe,SAAShB,EAAAA,EAKzB0E,GAAkBhQ,IACtB,IAAIiQ,EACAC,EACAC,EACEC,EAAgB,CACpBpQ,EACAsB,EACA+O,EAAMrQ,EAAMsB,GACZgP,EAAU9I,EAAM6I,CAAAA,KAEfA,IAAQC,GAAW9P,CAAAA,EAASc,CAAAA,IACzBtB,EAAMsB,GAAOgP,EAAUC,EAAW,IAAOvQ,EAAMsB,GAAO+O,CAC1DA,GAAAA,GAEIE,EAAcC,IAAyBP,IAAa,IAAIjO,KAAKwO,CAE7DhJ,EAAAA,EAASxH,GACA,MAATA,GAAiBS,EAAWT,CAAAA,GAAUQ,EAASR,CAAAA,EAC1C,KAGLf,OAAO+M,SAAShM,CAAAA,GAAAA,CAAWf,OAAOwR,cAAczQ,CAAAA,GAIlDuL,GAAUgB,WAAW,EAAGvM,EAAAA,CAAAA,CACjB,EAAA,CAAE,GAAI,CAAI,GAAA,IAAI0N,YAAYpC,EAAAA,EAAAA,GAG9BhL,EAASN,EAAAA,CAAAA,CAITA,EAAAA,EAAc0Q,QAAU1Q,KAAWA,EAAQA,EAAe0Q,OAAAA,GACtDlJ,EAAMxH,CAAAA,EAGXC,EAAWkQ,GAAYD,IAAS,IAAIS,KAAOzN,IAAIlD,CAAAA,CAAAA,GAC5CA,EAAM+P,MAET/P,EAAM+P,IAAYI,EAClBI,EAAW,IAAA,OAAavQ,EAAM+P,GAAAA,GAEzB,EAAGA,IAAWI,CAAAA,IAGnB7P,EAASN,CACXkQ,GAAAA,EAAKlN,IAAIhD,EAAOkQ,EAAKlM,KAAO,CAE5BC,EAAAA,OAAOR,KAAKzD,CAAOqC,EAAAA,QAChBuO,IACE7Q,EAAYqQ,EAAcpQ,EAAO4Q,CAAOpQ,CAAAA,GAAAA,EAASoQ,YAC3C5Q,EAAM4Q,EAAAA,GAERlQ,EAAWV,CAAAA,IAAAA,CAElBI,EAAQJ,CAAAA,GAAUiE,OAAOR,KAAKzD,GAAOyB,OAASzB,EAAMyB,OAClD,CAAA,GAAKzB,GACLA,GACFqC,QAAQ,CAACwO,EAAGxP,IACZA,KAAKrB,EACDoQ,EAAcpQ,EAAOqB,CAAAA,GACpBrB,EAAOqB,GAAK,KAAOkP,EAAW,IAAA,OAAavQ,EAAMqB,EAAAA,EAAAA,EAInDrB,GApCEA,EAuCL8Q,EAAa3F,GAAU3D,EAAMxH,CAEnC,CAAA,EAAA,OADAiQ,GAAU5N,QAASmO,GAAYA,EAAAA,CAAAA,EACxBM,CAAAA,EAgDIC,EAAkB,CAC7BzP,EACA0P,EAAO,CAAA,KAEP,GAAOC,CAAAA,EAASC,EAASC,IDlON7P,IA0CnB,IAxCA,IAAIS,EAEAV,EAEAS,EAEAsP,EAGAtO,EAMAuO,EAHAF,EAAO,GAMPG,EAAQ,GAQR5H,EAAmB,GAGnB6H,EAAQ,EAERC,EAAW,EAGXC,EAAK,EAELC,EAAS,EAEPC,EAAoB,GAErBF,EAAK,EAAGA,EAAKnQ,EAAIG,OAAQiQ,GAAUC,EAAQF,GAAMnQ,EAAIoJ,WAAW+G,CAGrE,EAAA,GAAA,IAAMG,EAAatQ,EACf,KACEoI,EAAS,IAAIiI,GACbH,EAA8B,KAAlBD,EAAQG,GACpBD,EAAAA,CAAM,CAAA,EAER,OAGEI,EAAehF,IAClB2E,EAKuB,KAJrBD,GAEE7H,CAAAA,EAAQ+H,GAAMA,EAAK,GAAK/H,EAAOjI,SAE/BiI,EAAO+H,GAAM5E,IAClBA,GAGF,MAAO,CAELvL,EACKH,IAMC,IALAyQ,EACA7P,EAAAA,EAAIZ,EAAOM,OACX2P,EA1GU,IA0GYrP,EA5GhB,GAEI,GA2GVe,EAAS,IAAI2I,WA7GP,EA6G4B1J,EAAIqP,CAAAA,EAEjCtP,EAAI,EAAGA,EAAIgQ,EAAahP,EAAOhB,CAAO+P,IAAAA,EAAY7G,EAOvD,CAAA,GAAA,IAJAlI,EAAOhB,CAAO+P,IAAAA,EACZL,EAjHQ,GAiHkBxG,EAAQ,EAAA,EAAqBoG,CAGpD/P,EAAAA,EAAI,EAAGA,EAAIU,EAAGe,EAAOhB,CAAAA,IAAO+P,EAAYL,EAAWrQ,EAAOE,CAAAA,GAAAA,GAC/D,KAAO+P,CAAOtO,IAAAA,EAAOhB,CAAOkJ,IAAAA,EAAAA,EAE5B,OAAOlI,CAAAA,EAER3B,GAAWA,EAGhBG,EACKH,IAEC,IADAyQ,EAAAA,EACKvQ,EAAI,EAAGA,EAAIyQ,EAAaD,EAAY1Q,EAAOE,CAAAA,GAAAA,GAOhD,IANAU,EACEZ,EAAOM,OAnIH,IAsIF+P,EAAWK,EAAY1Q,EAAOE,CApIxB,GAAA,GAAA,IAAA,MAsID,EAAG,OAAO,IAAIoK,WAAW,CAAA,EAIlC,IAFA3I,EAAS,IAAI2I,WAAW1J,CAAAA,EAEnBD,EAAI,EAAGA,EAAIC,EAAGe,EAAOhB,CAAO0P,IAAAA,EAAWK,EAAY1Q,EAAOE,CAC/D,GAAA,GAAA,OAAOyB,CAAAA,EAERiP,GAAWA,EAGhB,CAAC5Q,EAAoB6Q,EAAqB,MACxC,GAAA,CAAK9R,EAASiB,CAAAA,EAAS,OAAO,KAO9B,IANAkQ,EAAO1R,EAAUqS,CAAAA,EAAiB,GAAKA,EAEvCJ,KAECT,EAAMG,GAAS3G,EAAK0G,GAGnBhQ,EAAI,EACJA,EAAIF,EAAOM,OACX0P,EAAOc,OAAOC,QACZb,GACCF,EAAOc,OAAOT,EAAWK,EAAY1Q,EAAOE,CAAUiQ,GAAAA,CAAAA,GAAAA,CAAAA,GAI3D,MAAyB,CAAA,IAAlBU,EACH/S,OACEgT,OAAOhT,OAAOkT,kBACXhB,EAAOc,OAAOhT,OAAOD,iBAAmBC,OAAOkT,gBAAAA,CAAAA,EAEnDhB,EAAKtI,SAAS,GAAA,EAEtB,GC8FqCvH,GAAO,EACvC8Q,EAAAA,EAAiB,CAACpS,EAAYqS,ITuOnB,UAAVrS,OStOQA,GAAAA,CAAAA,IAAUqS,EAA+BrS,GAEtDA,EAAQG,EAASH,CACb,EAAA,IAAIyL,WAAW9J,EAAI3B,EAAMyB,OAASJ,GAA4B,IAAtBrB,EAAM0K,WAAWrJ,CAAAA,CAAAA,CAAAA,EACzD2P,EACAsB,KAAKC,UAAUvS,CAAAA,EACfgQ,GAAehQ,CACZmR,EAAAA,EAAKnR,EAAOqS,CAAAA,GAErB,OAAOrB,EACH,CACG5F,GAAckH,KAAKC,UAAUnH,CAAAA,EAC7BoH,GACY,MAAXA,EACIzT,KAAAA,EACAO,EAAS,IAAMgT,KAAKG,MAAMD,EAAAA,KAAAA,CAChC,CAAA,EAAA,CAACxS,EAAYgS,IACXI,EAAepS,EAAOgS,IAE1B,CACG5G,IFnRaqB,IAMpB,IALA,IACIiG,EADArR,EAAI,EAEFU,EAAI0K,EAAMhL,OAEVkR,EAAmB,GAClBtR,EAAIU,GACT2Q,EAAQjG,EAAOpL,CAAQ,KAAA,GAAOoL,EAAMpL,CAAAA,KAAQ,EAAKoL,EAAMpL,CACvDsR,IAAAA,EAAO3Q,KACLuI,GAAe,SAARmI,IAAqB,IAC5BnI,GAAe,OAARmI,IAAmB,IAC1BnI,GAAe,KAARmI,IAAiB,GACxBnI,EAAc,GAARmI,EAKV,EAAA,OAFAC,EAAOlR,QAAUM,EAAIV,EA1B2BgO,OAAOC,aAAgB/E,GA4BlDoI,CA5BkDpI,CA4BlDoI,GEkQM1B,EAAQjB,GAAe5E,CAAAA,CAAAA,CAAAA,EAC3CoH,IACCtS,OAAAA,EAASsS,IAzEOxS,EA0EKkR,GF/PPsB,IAMtB,IALA,IAEI5H,EAFAvJ,EAAI,EACJS,EAAI,EAEFC,EAAIyQ,EAAQ/Q,OACZgL,EAAQ,IAAIhB,WAAW,GAAK1J,EAAK,EAAK,IAAQA,EAAI,EAAK,GAAK,CACvDA,EAAJV,EAAIU,GACT0K,EAAM3K,CAAAA,IACHuI,EAAMG,EAASgI,EAASnR,CAAAA,EAAAA,IAAS,GAChCuJ,EAAIP,EAAMG,EAASgI,EAASnR,CAAU,EAAA,KAAA,EACtCA,EAAIU,IACN0K,EAAM3K,CAAAA,KAAa,GAAJ8I,IAAW,GAAOA,EAAIP,EAAMG,EAASgI,EAASnR,CAAU,EAAA,KAAA,EACnEA,EAAIU,KACN0K,EAAM3K,CAAa,KAAA,EAAJ8I,IAAU,EAAKP,EAAMG,EAASgI,EAASnR,CAI5D,EAAA,IAAA,OAAOoL,CAAAA,GE8OsC+F,CAAAA,CAAAA,EAtEvChL,EAASxH,GACRM,EAASN,EAAO,CAAA,CAAA,EAEjBI,EAAQJ,EAAM,GAAuC,GAAA,KAA9BA,EAAQA,EAAM,KAAKyB,OACrC,IAAI6K,SAAS,IAAIoB,YAAY1N,CAAAA,EAAOgP,MAAQG,EAAAA,WAAW,IAG5DnP,EAAAA,EAAM+P,MAAc6C,GAAc1C,IAAS,IAAIlQ,EAAM+P,MAChD6C,GAGL5S,EAAM+P,KACiB/P,OAAzBkQ,EAAMlQ,EAAM+P,KAAa/P,GACZ+P,IAGf9L,OAAO4O,QAAQ7S,CAAAA,EAAOqC,QACpB,CAAA,CAAEuO,EAAGkC,KAAOA,KAAOA,EAAItL,EAAMsL,CAAQ9S,KAAAA,EAAM4Q,GAAKkC,EAAAA,EAG3C9S,GAnB4BA,EAsB9BE,EAASF,CAAAA,EACZV,MACQkI,EAAM0D,GAAYlL,CAAAA,CAAAA,EAAAA,MAG1BjB,EAAAA,KAAAA,GA2CQ,KA3EW,IAACiB,EACpBkQ,EACA0C,EAEEpL,CAuEM,EACN,CAACxH,EAAYgS,IACXI,EAAepS,EAAOgS,CAAAA,EACzB,EExNO7G,CAAAA,GAAWD,KF2NO6F,EAAAA,EE3NQA,EAAgB,QAsElDgC,GAAAA,GAAgB/S,IACpB,IAES2I,EAASqK,EAFlB,OAAK7S,EAASH,CAAAA,GAER,CAAA,CAAG2I,EAASqK,GAAiBhT,EAAMiT,MAAM,0BAC/C,EAAO,CACLtK,EACA1I,EAAU+S,CAAiBE,EAAAA,SAASF,EAAe,EAAA,EAAA,KAAA,IALxB,CAAChT,EAM7B,EAEGmT,GAAiB,CAAC7R,EAAatB,KACnC,GAAA,CAAO2I,EAASyK,GAAWL,GAAa/S,CAAAA,EACxC,IAAIoT,GAA6B,GAAlBA,EAAU7O,EAAQ,EAIjC,OAAOoE,EAHLnF,EAAM6P,aAAc/R,EAGfqH,EAGI2K,IArFXC,IAEA,GAAOC,CAAAA,EAAgBC,GAAenL,EAAAA,EAEhCpF,EAAO5B,GAAgBiS,EAASG,QAAQpS,CAAAA,IAAO,GAE/C0B,EAAM,CAAI1B,EAAatB,EAAsBoT,KACjD,IAAMO,EAAWzQ,EAAI5B,CAWrB,EAAA,OAVIvB,EAAYC,CAAAA,GACduT,EAASK,WAAWtS,CAAAA,EACpBmS,EAAY1U,KAAAA,EAAW,CAAEuC,IAAAA,EAAKqS,SAAUxS,EAAAA,OAAQyH,EAAQiL,KAAM,CAAA,CAAA,CAAA,IAE9DN,EAASO,QAAQxS,EAAKtB,EAAO4I,EAAQwK,CAAAA,EACrCK,EAAYzT,EAAO,CAAEsB,IAAKqS,EAAAA,SAAAA,EAAUxS,OAAQyH,EAAQiL,KAAM,CAAA,CAAA,CAAA,GAE5C,EAAZT,GACFG,EAASK,WAAWtS,CAAAA,EAEftB,CAAAA,EAGLkG,EAAU,EACR6N,EAAS,CACbzS,EACA0S,EACAZ,KAEgB,EAAZlN,CAAAA,IACFtG,uBAA0B0B,OAAU,CAAA,CAAA,EAEtC,IAAMtB,EAAQgD,EAAI1B,EAAK0S,EAAST,EAASG,QAAWpS,CAAO,IAAA,EAAA,EAAK8R,CAC1Da,EAAAA,EAAeV,EAASG,QAAQpS,CACtC,EAAA,OAAI2S,IAAe,IAAMA,IAAe,KAAOrL,EACtCmL,EAAOzS,EAAK0S,EAAUZ,CAAAA,GAE/BlN,EAAU,EACHlG,EAAAA,EAGT,MAAO,CACLkD,IAAAA,EACAF,IACAD,EAAAA,OAASzB,GAAQ0B,EAAI1B,EAAAA,KAAAA,CACrByS,EAAAA,OAAAA,EACAG,QAASX,EAASW,QACd,CAAC5S,EAAKqG,EAAUwM,KACd,GAAOnM,CAAAA,EAAQoM,GAAQlM,EACrBqL,EAASW,QAAS5S,GAAM0S,EAAUL,EAAUrS,IAC1CqG,EACEqM,IAAW,GACX,CAAE1S,MAAKqS,SAAUA,IAAW,GAAIxS,OAAQ6S,IAAW,EAAA,EACnDhM,CAGJmM,CAAAA,EAAAA,EACIX,GACGxT,EAAOqU,EAASrM,IACfqM,EAAQ/S,MAAQA,GAAOqG,EAAS3H,EAAOqU,EAASrM,CAAAA,CAAAA,EAAAA,KAAAA,CAI1D,EAAA,MAAO,CAACA,EAAQoM,EAAK,EAAA,KAAA,EAwBFE,GAAW,CACtCZ,QAAUpS,GAAQ4J,GAAYiI,GAAe7R,EAAK+R,aAAaK,QAAQpS,CAAAA,CAAAA,CAAAA,EACvEwS,QAAS,CAACxS,EAAKtB,EAAOmB,EAAQiS,IAC5BC,aAAaS,QACXxS,EACA6J,GAAU,CAACnL,EAAOmB,EAAAA,GACJ,EAAXiS,EAAe,MAAM7O,EAAQ6O,EAAAA,GAAUvK,SAAS,EAAA,EAAQ,GAE/D+K,EAAAA,WAAatS,GAAQ+R,aAAaO,WAAWtS,CAC7C4S,EAAAA,QAAU5S,EAAKiT,GACb,GAAA,CAAOvM,EAAQoM,GAAQpL,EACrBU,OACA,UAAA,CACA,CAAGpI,IAAKkT,EAAYR,SAAAA,EAAUL,SAC5BrS,CAAAA,IAAAA,GAAOkT,GACPD,EACErJ,GAAY6H,GAAaiB,CAAAA,EAAU,EACnC9I,EAAAA,GAAY6H,GAAaY,CAAAA,EAAU,IACnCrS,CAIN,CAAA,EAAA,OAAO4G,EACL,CAACF,EAAQoM,GACT9K,EAAuBE,IAAYA,EAAS4K,EAASpM,GAAAA,CAAAA,CAAAA,CAAAA,CAKrDyM,CAAAA,EAAAA,GAAY5P,EAAM,CACtBE,UAAW,IACXE,SAAU,IACR5C,EAAQgR,aAAc,CAAA,CAAE/R,EAAKtB,KAAAA,CAAYmT,GAAe7R,EAAYtB,IACtEoF,QAAS,CAAA,CAAA,CAAA,EAEXkE,EAAuBE,GAAWiL,GAAU/N,OAAO8C,CAE5C,CAAA,EAAA,ICzJHkL,GAnBSC,GAAmB,CAC9BC,EACAlM,EACAmM,EAAa,CAAA,EACbC,EAAUxB,MAEV,IAAMyB,GDiLJ,CACFzT,EAEAwT,EAAwBxB,MAAAA,CAExBpQ,MAAW4R,OAAQ5R,EAAAA,IAAO5B,CAAAA,CAAAA,EAC1B0B,IAAMhD,EAAOoT,GACX0B,SAAQ9R,IAAI1B,EAAKtB,EAAcoT,GCxLkB,CDwLP4B,CAAAA,EAC5CjS,SAAc+R,SAAQ/R,OAAOzB,CAAAA,CAAAA,EAC7ByS,OAASkB,EAAS7B,GAChB0B,OAAAA,EAAQf,OAAOzS,EAAK2T,EAAgB7B,GC3La,CD2LF4B,CAAAA,EACjDd,QAASY,EAAQZ,QACb,CAACK,EAAUW,IAAgBJ,EAAQZ,QAAS5S,EAAKiT,EAAUW,CAC3DnW,EAAAA,KAAAA,CAAAA,IC9L2C6V,EAAOE,CACtD,EAAA,MAAO,CACLK,KAAM,CAACxM,EAAS7F,IAAWiS,EAAQ/R,IAAI,CAAC4F,EAAQD,EAAS7F,EAAAA,EACzDsS,YAAaL,EAAQb,QAClBlU,GACCC,EAAUD,CACRA,IAAAA,CAAAA,EAAM,IAAMA,EAAM,KAAO4I,IAC3BF,EAAQ1I,EAAM,GAAIA,EAAM,GAAIC,EAAUD,EAAM,EAAA,CAAA,EAC9C6U,GACA,EACJ,CAAA,EAIWjV,GAGT,CAACyV,EAAiBzV,EAAa0V,EAAa,CAAA,KAM9C,GALqB,WAAV1V,OAAAA,IACT0V,EAAa1V,EACbA,EAAQ,MAEV2V,GAAI3V,EAAQyV,EAAU,KAAMzV,GAASyV,CACjCC,EAAAA,EACF,MAAM,IAAIzV,MAAMwV,CAAAA,CAClB,EAGWE,GAAM,CAACF,EAAczV,KAChC,IAAMuB,EAASkU,EAsBf,OArBIzV,EAAAA,GACM0S,KAAKC,UACV3S,EAAQU,EAASV,CAAAA,EACd,CACEyV,QAASzV,EAAMyV,SAAWzV,EAC1B4V,MAAO5V,EAAM4V,KAEf5V,EAAAA,CAAAA,EAIRyV,EAAU/C,KAAKC,UAAU8C,CACxBX,GAAAA,KAAgBC,GACf,OAAA,CACCc,EAAQC,IACP5V,QAAQ4V,EAAM,GAAK,QAAU,OAC3BD,IAAW7M,EAAS,yBAA2B6M,KAAAA,GAC5C9T,EAAIe,EAAOgT,CAAAA,EAAS1V,GAAUsS,KAAKG,MAAMzS,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAG/CmV,GAAAA,KAAK,CAACE,EAASzV,EAAAA,EACXuB,CAAAA,ECtEHwU,GAAqB,CACzBf,GAAIhM,EACJgN,SAAUrR,EAGNsR,CAAAA,EAAAA,GAAe,CACnBC,UAAW,EACRlN,GAAS+M,EAAAA,EAEZI,UAAW,EAAC,EAkBRC,GAAcnR,EAAAA,IAAYoR,GAAc,QAAS,CAAEJ,YAAW,EAC9DK,EAAAA,GAAevB,GACnB,QAAA,CACCc,EAAAA,CAAUjG,KAAMpE,EAAAA,KAAAA,CAAAA,KACF,UAAToE,EACDwG,GAAY3P,QACX6P,GAAaf,KAAK,CAAE3F,KAAM,MAAOpE,KAAMyK,EAASJ,EAAAA,CAAAA,EAChC,QAATjG,GAAkBwG,GAAY3P,QACvChD,EAAOwS,GAAOzK,GACd4K,GAAY5Q,QAAAA,GACM,UAAToK,GACTnM,EAAOwS,GAAOzK,CACd6K,EAAAA,GAAc,SAAU,CAAEJ,MAAAA,GAAOE,UAAW3K,CAAAA,CAAAA,GAC1B,QAAToE,IACTnM,EAAOwS,GAAMC,UAAWL,EAAQrK,CAAAA,EAChC6K,GAAc,SAAU,CAAEJ,MAAAA,GAAOM,IAAK/K,CAAAA,CAAAA,MAKrCgL,GAAkBH,IAAiB3N,EAWpC+N,EAAAA,GAAYxR,EAAM,KACtB,IAAMuO,EAAU7O,IAAQ+R,IACxBjU,EACEwT,GAAOC,UAAAA,CAEP,CAAES,EAAOZ,KACPA,EAAS,GAAKvC,GAAW5P,EAAMqS,GAAOC,UAAWS,CAErDZ,CAAAA,EAAAA,GAASC,SAAWrR,EAAAA,EACpB2R,GAAaf,KAAK,CAAE3F,KAAM,MAAOpE,KAAMuK,EAAAA,CAAAA,CCtFZ,EAAA,GAAA,ECIvBa,IFgGNlN,EAAuBE,IAVrB0M,GAAaf,KAAK,CAAE3F,KAAM,MAAOpE,KAAMqL,EAAUd,GAAW5W,KAAAA,CAAAA,CAAAA,EACxD0X,GACFT,GAAYzP,QACZ2P,EAAAA,GAAaf,KAAK,CAAE3F,KAAM,OAE1BwG,CAAAA,GAAAA,GAAYtP,OAAO,CAAA,CAAA,EAErB2P,GAAU3P,OAAO+P,EAGkC,EAAA,CAAA,CAAA,EEhGtC5R,EAAM,OAIlB,MCCU+C,IDKboB,EACEW,SACA,mBACA,IAAmC,WAA7BA,SAASC,iBAAgC4M,GAAOpR,WCRlCa,UACpBgE,EAA0BR,MAAD,CAAA,CAMzB2M,EAAAA,GAAAA,CAAkBM,EAAOb,KACvBN,GAAIM,EAAMM,GAAG,CAAA,CAAA,EAGfnN,EAAOW,SAASW,KAAM,QAAS,MAAA,CAE/B,GCXFZ,OnBP2C,iBmBOJzE,IACrCA,EAAS2C,EAAAA,CAAAA","x_google_ignoreList":[12]}