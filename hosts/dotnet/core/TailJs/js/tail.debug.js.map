{"version":3,"file":"tail.debug.js","sources":["../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/util/src/accessors.ts","../../../../../npm/packages/@tailjs/util/src/types/conversions.ts","../../../../../npm/packages/@tailjs/util/src/types/validation.ts","../../../../../npm/packages/@tailjs/util/src/iterators.ts","../../../../../npm/packages/@tailjs/util/src/time.ts","../../../../../npm/packages/@tailjs/util/src/concurrency.ts","../../../../../npm/packages/@tailjs/util/src/events.ts","../../../../../npm/packages/@tailjs/client/src/lib2/ids.ts","../../../../../npm/packages/@tailjs/client/src/lib2/page-events.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/base64.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/lfsr.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/transport.ts","../../../../../npm/node_modules/.pnpm/@ygoe+msgpack@1.0.3/node_modules/@ygoe/msgpack/msgpack.js","../../../../../npm/packages/@tailjs/client/src/lib2/storage.ts","../../../../../npm/packages/@tailjs/client/src/lib2/channel.ts","../../../../../npm/packages/@tailjs/client/src/lib2/shared-state.ts","../../../../../npm/packages/@tailjs/client/src/lib2/consts.ts","../../../../../npm/packages/@tailjs/client/src/lib2/request.ts","../../../../../npm/packages/@tailjs/client/src/pusher.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["export const MUTEX_REQUEST_COOKIE = \".tail.rq\";\nexport const MUTEX_RESPONSE_COOKIE = \".tail.rs\";\nexport const CONTEXT_MENU_COOKIE = \".tail.cm\";\n\nexport const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_MENU_QUERY = \"mnt\";\n","import {\n  And,\n  Extends,\n  GeneralizeContstants,\n  If,\n  IsAny,\n  Minus,\n  NO_ARG,\n  NotFunction,\n  PrettifyIntersection,\n  Primitives,\n  RecordType,\n  UnionToIntersection,\n  count,\n  forEach,\n  hasMethod,\n  isArray,\n  isAwaitable,\n  isDefined,\n  isFunction,\n  isMap,\n  isObject,\n  isSet,\n  isString,\n  isUndefined,\n  map,\n  obj,\n  reduce,\n  throwError,\n} from \".\";\n\ntype ReadonlyMapLike<K = any, V = any> = {\n  has?(key: K): boolean;\n  get(key: K): V | undefined;\n};\n\n// #region Shared types\ntype MapLike<K = any, V = any> = ReadonlyMapLike<K, V> & {\n  set(key: K, value: V): any;\n  delete(key: K): any;\n};\n\ntype ReadonlySetLike<K = any> = {\n  has(key: K): boolean;\n};\ntype SetLike<K = any> = ReadonlySetLike<K> & {\n  add(key: K): any;\n  delete(key: K): any;\n};\n\ntype ReadonlyPropertyContainer<K extends any = any, V extends any = any> =\n  | {\n      [P in keyof K]: V;\n    }\n  | ReadonlyMapLike<K, V>\n  | ReadonlySetLike<K>;\n\ntype PropertyContainer<K extends any = any, V extends any = any> =\n  | ReadonlyPropertyContainer<K, V>\n  | MapLike<K, V>\n  | SetLike<K>;\n\nexport type TupleIndices<T extends readonly any[]> = T extends readonly []\n  ? never\n  : number extends T[\"length\"]\n  ? number\n  : T extends readonly [any, ...infer Rest]\n  ? TupleIndices<Rest> | Rest[\"length\"]\n  : never;\n\nexport type KeyType<T extends ReadonlyPropertyContainer | null | undefined> =\n  T extends Primitives\n    ? never\n    : T extends ReadonlyMapLike<infer K, any> | ReadonlySetLike<infer K>\n    ? K\n    : T extends readonly any[]\n    ? TupleIndices<T>\n    : keyof T;\n\nexport type ValueType<\n  T extends ReadonlyPropertyContainer | null | undefined,\n  K = KeyType<T>,\n  Context extends undefined | \"get\" | \"set\" = undefined\n> = IsAny<T> extends true\n  ? any\n  : T extends null | undefined | void\n  ? never\n  : K extends KeyType<T>\n  ? T extends ReadonlyMapLike<K, infer V>\n    ? V | If<Extends<Context, \"get\" | \"set\">, undefined>\n    : T extends ReadonlySetLike<K>\n    ? boolean\n    : T[K] | If<And<Extends<T, RecordType>, Extends<Context, \"set\">>, undefined>\n  : never;\n\ntype AcceptUnknownContainers<\n  T extends ReadonlyPropertyContainer | null | undefined\n> = IsAny<T> extends true\n  ? T\n  : T extends null | undefined | void\n  ? never\n  : T extends MapLike\n  ? MapLike<unknown, unknown> | T\n  : T extends SetLike\n  ? SetLike<unknown> | T\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? readonly unknown[] | [] | T\n    : T\n  : T;\n\n// #endregion\n\n// #region get\n\nconst updateSingle = (target: any, key: any, value: any) =>\n  setSingle(target, key, isFunction(value) ? value(get(target, key)) : value);\n\nconst setSingle = (target: any, key: any, value: any) => {\n  value === undefined\n    ? target.delete\n      ? target.delete(key)\n      : delete target[key]\n    : target.set\n    ? target.set(key, value)\n    : target.add\n    ? value\n      ? target.add(key)\n      : target.delete(key)\n    : (target[key] = value);\n\n  return value;\n};\n\nexport const setSingleIfNotDefined = (\n  target: any,\n  key: any,\n  value: any,\n  error: (\n    key: string,\n    currentValue: any,\n    newValue: any,\n    target: any\n  ) => string | Error\n) => {\n  const currentValue = get(target, key);\n  if (isDefined(currentValue)) {\n    throwError(error(key, currentValue, value, target));\n  }\n  return setSingle(target, key, value);\n};\n\nexport const get: {\n  <\n    T extends ReadonlyPropertyContainer | null | undefined,\n    K extends KeyType<T>\n  >(\n    target: T,\n    key: K\n  ): ValueType<T, K, \"get\">;\n  <\n    T extends ReadonlyPropertyContainer | null | undefined,\n    K extends KeyType<T>,\n    R extends\n      | ValueType<T, K>\n      | (() => ValueType<T, K>)\n      | undefined\n      | (() => ValueType<T, K> | undefined)\n  >(\n    target: T,\n    key: K,\n    initializer: R\n  ): ValueType<\n    T,\n    K,\n    R extends ValueType<T, K> | (() => ValueType<T, K>) ? undefined : \"get\"\n  >;\n} = <\n  T extends ReadonlyPropertyContainer | null | undefined,\n  K extends KeyType<T>,\n  R extends ValueType<T, K> | undefined = undefined\n>(\n  target: T,\n  key: K | undefined,\n  initializer?: (() => R) | R\n) => {\n  if (!target) return undefined as any;\n\n  let value = (target as any).get\n    ? (target as any).get(key)\n    : (target as any).has\n    ? (target as any).has(key)\n    : target[key as any];\n\n  if (isUndefined(value) && isDefined(initializer)) {\n    isDefined(\n      (value = isFunction(initializer) ? (initializer as any)() : initializer)\n    ) && setSingle(target, key, value);\n  }\n  return value;\n};\n\n// #endregion\n\n// #region set and update\n\ntype UpdateFunction<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current,\n  Factory\n> = Factory extends false\n  ? (\n      current: Current,\n      key: Key,\n      target: T\n    ) => GeneralizeContstants<ValueType<T, Key>> | undefined\n  : (key: Key, target: T) => GeneralizeContstants<ValueType<T, Key>>;\n\ntype Updater<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current = ValueType<T, Key>,\n  SettersOnly = false,\n  Factory = false\n> = SettersOnly extends true\n  ? ValueType<T, Key> | (Factory extends true ? never : undefined)\n  : IsAny<T> extends true\n  ? NotFunction | UpdateFunction<any, any, any, Factory>\n  :\n      | (ValueType<T, Key> extends Function\n          ? never\n          : ValueType<T, Key> | (Factory extends true ? never : undefined))\n      | UpdateFunction<T, Key, Current, Factory>;\n\ntype UpdaterType<T, SettersOnly = false> = SettersOnly extends true\n  ? T\n  : T extends (...args: any) => infer T\n  ? T\n  : T;\n\ntype BulkUpdateObject<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> = T extends MapLike | SetLike | any[]\n  ? {\n      [P in KeyType<T>]: Updater<T, P, ValueType<T, P>, SettersOnly, Factory>;\n    }\n  : { [P in keyof T & KeyType<T>]?: Updater<T, P, T[P], SettersOnly, Factory> };\n\ntype BulkUpdateKeyValue<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false,\n  K extends keyof T = keyof T\n> = IsAny<T> extends true\n  ? [any, Updater<T, any, any, SettersOnly, Factory>]\n  : T extends MapLike | SetLike | any[]\n  ? [\n      KeyType<T>,\n      Updater<T, KeyType<T>, ValueType<T, KeyType<T>>, SettersOnly, Factory>\n    ]\n  : K extends any\n  ? [K, Updater<T, KeyType<T>, any, SettersOnly, Factory>]\n  : never;\n\ntype BulkUpdates<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> =\n  | BulkUpdateObject<T, SettersOnly, Factory>\n  | Iterable<\n      | BulkUpdateKeyValue<T, SettersOnly, Factory>\n      | BulkUpdateObject<T, SettersOnly, Factory>\n    >;\n\ntype SetErrorHandler<T extends ReadonlyPropertyContainer | null | undefined> = (\n  key: KeyType<T>,\n  currentValue: ValueType<T>,\n  newValue: ValueType<T>,\n  target: T\n) => string | Error;\n\ntype SettableKeyType<T extends PropertyContainer> = T extends readonly any[]\n  ? // `KeyType<T>` won't do.\n    // If this `keyof` constraint is not set TypeScript will only constrain values for readonly tuple items to T[number] and not T[K].\n    keyof T\n  : T extends RecordType\n  ? keyof any\n  : KeyType<T>;\n\ntype SettableValueType<T extends PropertyContainer, K> = K extends KeyType<T>\n  ?\n      | ValueType<T, K>\n      // `undefined` removes elements from maps and sets so also allowed.\n      | (T extends MapLike | SetLike ? undefined : never)\n  : T extends RecordType\n  ? any\n  : never;\n\ntype SettableValueFunctionType<T extends PropertyContainer, K, V> = (\n  current: SettableValueType<T, K>\n) => V;\n\ntype IsGeneralKey<T, S = keyof any> = S extends T ? true : false;\n\n/** List of keys in T that has undefined values. If Template does not allow undefined values for a key it is excluded from the reuslts. */\ntype UndefinedKeys<\n  T,\n  Template = {},\n  K extends keyof T = keyof T\n> = K extends keyof T\n  ? T[K] extends undefined\n    ? K extends keyof Template\n      ? undefined extends Template[K]\n        ? K\n        : never\n      : K\n    : never\n  : never;\n\ntype SetSingleResultType<\n  T extends PropertyContainer,\n  K,\n  V\n> = T extends RecordType\n  ? AssignRecord<T, { [P in K & keyof any]: V }>\n  : K extends KeyType<T>\n  ? V extends ValueType<T, K> | (T extends readonly any[] ? never : undefined)\n    ? T\n    : never\n  : never;\n\ntype SettableKeyValueTuple<T extends PropertyContainer> =\n  KeyType<T> extends keyof any\n    ?\n        | {\n            [P in KeyType<T>]: readonly [P, SettableValueType<T, P>];\n          }[KeyType<T>]\n        | (T extends RecordType ? [keyof any, any] : never)\n    : readonly [KeyType<T>, SettableValueType<T, KeyType<T>>];\n\ntype SettableKeyValueRecord<T extends PropertyContainer> =\n  SettableKeyType<T> extends keyof any\n    ? RecordType &\n        ({\n          [P in KeyType<T>]?: SettableValueType<T, P>;\n        } & {\n          [P in SettableKeyType<T>]?: P extends KeyType<T>\n            ? ValueType<T, P>\n            : SettableValueType<T, P>;\n        })\n    : never;\n\ntype SettableValueList<T extends PropertyContainer> = T extends Primitives\n  ? never\n  :\n      | SettableKeyValueRecord<T>\n      | readonly (SettableKeyValueRecord<T> | SettableKeyValueTuple<T>)[];\n\ntype AllKeys<T> = T extends infer T ? keyof T : never;\ntype AnyValue<T, K> = T extends infer T\n  ? K extends keyof T\n    ? T[K]\n    : never\n  : never;\n\ntype MergeObjects<T> = {\n  [P in AllKeys<T>]: AnyValue<T, P>;\n};\n\ntype KeyValueTupleToRecord<Item> = Item extends readonly [infer K, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : Item extends readonly (infer KV)[]\n  ? { [P in KV & keyof any]: KV }\n  : Item extends RecordType\n  ? Item\n  : never;\n\ntype AssignRecord<T, S> = {\n  [P in Exclude<\n    keyof T | keyof S,\n    IsGeneralKey<keyof T | keyof S> extends true ? never : UndefinedKeys<S, T>\n  >]: P extends keyof S\n    ? IsGeneralKey<P> extends true\n      ? AnyValue<S | T, P>\n      : P extends keyof T\n      ? S[P] extends T[P]\n        ? GeneralizeContstants<S[P]> extends T[P]\n          ? GeneralizeContstants<S[P]>\n          : S[P]\n        : never\n      : GeneralizeContstants<S[P]>\n    : P extends keyof T\n    ? T[P]\n    : never;\n};\n\ntype SetResult<\n  T extends PropertyContainer,\n  V extends any\n> = T extends RecordType\n  ? PrettifyIntersection<\n      AssignRecord<\n        T,\n        V extends RecordType\n          ? V\n          : MergeObjects<KeyValueTupleToRecord<V[keyof V]>>\n      >\n    >\n  : T;\n\ntype SetOrUpdateFunction<\n  SettersOnly,\n  ErrorHandler = false,\n  Readonly = false\n> = {\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined,\n    U extends Updater<\n      T extends null | undefined ? never : T,\n      K,\n      ValueType<T, K>,\n      SettersOnly\n    >,\n    K extends KeyType<T>\n  >(\n    target: T,\n    key: K,\n    value: U,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): UpdaterType<U>;\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined\n  >(\n    target: T,\n    values: BulkUpdates<T extends null | undefined ? never : T, SettersOnly>,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): T;\n};\n\nconst createSetOrUpdateFunction =\n  <SettersOnly, Error>(\n    setter: (target: any, key: any, value: any, error?: any) => any\n  ): SetOrUpdateFunction<SettersOnly, Error> =>\n  (target: PropertyContainer, key: any, value: any = NO_ARG, error?: any) => {\n    if (!target) return undefined;\n    if (value !== NO_ARG) {\n      return setter(target, key, value, error);\n    }\n\n    forEach(key, (item) =>\n      isArray(item)\n        ? setter(target, item[0], item[1])\n        : forEach(item, ([key, value]) => setter(target, key, value))\n    );\n\n    return target;\n  };\n\nexport const assign = createSetOrUpdateFunction<true, false>(setSingle);\nexport const update = createSetOrUpdateFunction<false, false>(updateSingle);\nexport const assignIfUndefined = createSetOrUpdateFunction<false, true>(\n  setSingleIfNotDefined\n);\n\nexport const swap = <T extends PropertyContainer, K extends KeyType<T>>(\n  target: T,\n  key: K,\n  value: ValueType<T, K>\n): ValueType<T, K, \"get\"> => {\n  const current = get(target, key) as any;\n  if (value !== current) setSingle(target, key, value);\n  return current as any;\n};\n\n// #endregion\n\nexport const add = <T extends PropertyContainer<any, boolean>>(\n  target: T,\n  key: KeyType<T>\n) =>\n  target instanceof Set\n    ? target.has(key)\n      ? false\n      : (target.add(key), true)\n    : get(target, key) !== assign(target, key, true as any);\n\nexport const has = <T extends ReadonlyPropertyContainer>(\n  target: T,\n  key: KeyType<T>\n) =>\n  hasMethod(target, \"has\")\n    ? target.has(key)\n    : isDefined((target as any).get?.(key) ?? (target as any)[key]);\n\ntype RemoveDeepArgs<\n  T,\n  Current extends any[] = [],\n  Depth extends number = 20\n> = T extends PropertyContainer\n  ? Depth extends 0\n    ? Current\n    :\n        | (Depth extends 20 ? never : Current)\n        | RemoveDeepArgs<\n            ValueType<T>,\n            [...Current, KeyType<T>[] | KeyType<T>],\n            Minus<Depth, 1>\n          >\n  : Current;\n\ntype RemoveDeepValue<\n  T,\n  Args extends any[],\n  ArrayIt = false\n> = T extends PropertyContainer\n  ? ArrayIt extends true\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>[]]\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>]\n    ? ValueType<T> | undefined\n    : Args extends [infer R, ...infer Rest]\n    ? RemoveDeepValue<ValueType<T>, Rest, R extends any[] ? true : ArrayIt>\n    : never\n  : never;\n\nconst clearSingle = (target: any, key: any) => {\n  if (isUndefined(target ?? key)) return undefined;\n\n  let current = get(target, key);\n\n  if (hasMethod(target, \"delete\")) {\n    target.delete(key);\n  } else {\n    delete target[key];\n  }\n  return current;\n};\n\n/**\n * Removes one or more values from a property container specified by the provided key or array of keys.\n *\n * If more than one level of key arguments are specified, values will be removed from the property container at the deepest level.\n * If a property container becomes empty along the path of keys, it will be removed from its parent.\n *\n */\nexport const clear = <\n  T extends PropertyContainer | null | undefined,\n  Args extends RemoveDeepArgs<T>\n>(\n  target: T,\n  ...keys: Args\n): RemoveDeepValue<T, Args> => {\n  const removed: any[] = [];\n  let array = false;\n\n  const clearStep = (\n    target: any,\n    index: number,\n    parent?: any,\n    parentKey?: any\n  ) => {\n    if (!target) return;\n    const targetKeys = keys[index];\n    if (index === keys.length - 1) {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) => removed.push(clearSingle(target, key)));\n      } else {\n        removed.push(clearSingle(target, targetKeys));\n      }\n    } else {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) =>\n          clearStep(get(target, key), index + 1, target, key)\n        );\n      } else {\n        clearStep(get(target, targetKeys), index + 1, target, targetKeys);\n      }\n      if (!count(target) && parent) {\n        remove(parent, parentKey);\n      }\n    }\n  };\n  clearStep(target, 0);\n  return array ? removed : removed[0];\n};\n\n/**\n * Removes the specified keys from a  property container.\n *\n * The difference between {@link clear} and this function is that it does not consider nested property containers and that arrays will be spliced (as opposed to `clear` where the index will be set to `undefined`).\n */\nexport const remove: {\n  <T extends PropertyContainer | null | undefined>(\n    target: T,\n    key: KeyType<T> | undefined\n  ): T extends null | undefined ? T : ValueType<T, KeyType<T>> | undefined;\n  <T extends PropertyContainer | null | undefined>(\n    target: T,\n    ...keys: (KeyType<T> | undefined)[]\n  ): (T extends null | undefined ? T : ValueType<T, KeyType<T>> | undefined)[];\n} = (target: PropertyContainer, key: any, ...keys: any[]) => {\n  if (!target) return undefined;\n\n  if (keys.length) {\n    // Sort array keys descending as they would otherwise not match their offset as the array is spliced along the way.\n    return (isArray(target) ? keys.sort((x, y) => y - x) : keys).map((key) =>\n      remove(target, key)\n    );\n  }\n\n  return isArray(target)\n    ? key < target.length\n      ? (target as any[]).splice(key, 1)[0]\n      : undefined\n    : clearSingle(target, key);\n};\n\ntype EntryToObject<Item> = Item extends readonly [infer K & keyof any, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : never;\n\ntype EntriesToObject<Entries> = UnionToIntersection<\n  InlinePropertyDescriptors<\n    Entries extends null | undefined | boolean\n      ? {}\n      : Entries extends readonly [\n          Partial<Readonly<PropertyDescriptor>>,\n          ...infer Rest\n        ]\n      ? EntriesToObject<Rest[number]>\n      : Entries extends readonly [infer Item, ...infer Rest]\n      ? EntryToObject<Item> & EntriesToObject<Rest>\n      : Entries extends readonly (infer Items)[]\n      ? EntryToObject<Items>\n      : Entries\n  >\n>;\n\ntype InlinePropertyDescriptors<T> = {\n  [P in keyof T]: T[P] extends () => infer V | { value: infer V }\n    ? V\n    : T[P] extends { get(): infer V }\n    ? V\n    : T[P];\n};\n\ntype PropertyList =\n  | boolean\n  | null\n  | undefined\n  | [defaults: Partial<PropertyDescriptor>, ...items: PropertyList[]]\n  | [key: keyof any, value: any][]\n  | (Record<keyof any, any> & { [Symbol.iterator]?: never });\n\nexport const define: {\n  <T, P extends PropertyList[]>(\n    target: T,\n    ...properties: P\n  ): (T extends Function ? T : {}) &\n    PrettifyIntersection<T & EntriesToObject<P[number]>>;\n} = (target: any, ...args: any[]) => {\n  const add = (arg: any, defaults?: any) => {\n    if (!arg) return;\n    let properties: readonly any[];\n    if (isArray(arg)) {\n      if (isObject(arg[0])) {\n        // Tuple with the first item the defaults and the next the definitions with those defaults,\n        // ([{enumerable: false, ...}, ...])\n        (arg as any[]).splice(1).forEach((items) => add(items, arg[0]));\n        return;\n      }\n      // ([[key1, value1], [key2, value2], ...])\n      properties = arg;\n    } else {\n      // An object.\n      properties = map(arg)!;\n    }\n\n    properties.forEach(([key, value]) =>\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        writable: false,\n        ...defaults,\n        ...(isObject(value) && (\"get\" in value || \"value\" in value)\n          ? value\n          : isFunction(value) && !value.length\n          ? { get: value }\n          : { value }),\n      })\n    );\n  };\n\n  args.forEach((arg) => add(arg));\n  return target as any;\n};\n\ntype PropertySelector<T> =\n  | keyof T\n  | {\n      [P in keyof T]?: PropertySelector<T[P]> | [...keys: (keyof T[P])[]];\n    };\n\ntype SinglePickResult<T, Selected> = Selected extends\n  | (string & infer K)\n  | (infer K)[]\n  ? { [P in keyof T & K]: T[P] }\n  : keyof Selected extends infer Keys\n  ? {\n      [P in Keys & keyof any & keyof Selected]: P extends keyof T\n        ? Selected[P] extends true\n          ? T[P]\n          : SinglePickResult<T[P], Selected[P]>\n        : never;\n    }\n  : never;\n\ntype PickResults<T, Selectors> = PrettifyIntersection<\n  Selectors extends [infer Item, ...infer Rest]\n    ? SinglePickResult<T, Item> & SinglePickResult<T, Rest>\n    : never\n>;\n\nexport const pick = <T, Selectors extends PropertySelector<T>[], U>(\n  source: T | (null | (undefined & U)),\n  ...args: Selectors\n): U extends undefined ? undefined : PickResults<T, Selectors> => {\n  if (source === undefined) return undefined as any;\n\n  return Object.fromEntries(\n    args.flatMap((arg) =>\n      isObject(arg, true)\n        ? isArray(arg)\n          ? arg.map((args) =>\n              isArray(args)\n                ? args.length === 1\n                  ? [args[0], source![args[0]]]\n                  : pick(source![args[0]], ...(args[1] as any[]))\n                : [args[0], source![args[1]]]\n            )\n          : Object.entries(args).map(([key, value]) => [\n              key,\n              value === true ? source![key] : pick(source![key], value),\n            ])\n        : ([[arg, source![arg]]] as any)\n    )\n  ) as any;\n};\n\nexport type Wrapped<T> = T | (() => Wrapped<T>);\n\nexport type AsyncWrapped<T> = PromiseLike<\n  T | (() => Wrapped<T>) | ((arg: any, ...args: any) => never)\n>;\n\nexport type Unwrap<T> = T extends Wrapped<infer T>\n  ? T\n  : T extends AsyncWrapped<infer T>\n  ? PromiseLike<T>\n  : never;\n\nexport const unwrap: {\n  <T extends Wrapped<any>>(value: T): Unwrap<T>;\n  <T>(value: AsyncWrapped<T>): PromiseLike<T>;\n  <T>(value: Wrapped<T>): T;\n} = (value: Wrapped<any>): any =>\n  isFunction(value)\n    ? unwrap(value())\n    : isAwaitable(value)\n    ? value.then((result) => unwrap(result))\n    : value;\n\nexport const unlock = <T extends ReadonlyPropertyContainer>(\n  readonly: T\n): T extends ReadonlyMapLike<infer K, infer V>\n  ? MapLike<K, V>\n  : T extends ReadonlySetLike<infer T>\n  ? SetLike<T>\n  : T => readonly as any;\n\nexport const wrapFunction = <F extends ((...args: any) => any) | undefined>(\n  original: F,\n  wrap: (\n    original: F,\n    ...args: Parameters<Exclude<F, undefined>>\n  ) => ReturnType<Exclude<F, undefined>>\n): F => original && (((...args: any) => wrap(original, ...args)) as any);\n\nexport const clone = <T>(value: T, depth: number | boolean = true): T =>\n  isObject(value, true)\n    ? isArray(value)\n      ? depth\n        ? value.map((value) => clone(value, depth === true || --(depth as any)))\n        : [...value]\n      : isSet(value)\n      ? new Set<any>(\n          depth\n            ? (map as any)(value, (value: any) =>\n                clone(value, depth === true || --(depth as any))\n              )\n            : value\n        )\n      : isMap(value)\n      ? new Map<any, any>(\n          depth\n            ? (map as any)(value, (value: any) =>\n                // Does not clone keys.\n                [value[0], clone(value[1], depth === true || --(depth as any))]\n              )\n            : value\n        )\n      : depth\n      ? obj(\n          map(value as any, ([k, v]) => [\n            k,\n            clone(v, depth === true || --(depth as any)),\n          ])!\n        )\n      : { ...value }\n    : (value as any);\n","import type {\n  Defined,\n  FunctionComparisonEquals,\n  If,\n  IsAny,\n  MaybeUndefined,\n  Nullish,\n} from \"..\";\nimport { tryCatch } from \"..\";\n\n/**\n * Trick for having a function that returns a non-null value, if a formal paramter always has a non-null value,\n * simliar to .NET's [NotNullIfNotNull].\n *\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\nexport type AllKeys<Ts> = Ts extends infer T ? keyof T : never;\n/**\n * Creates a new type where with all the properties from any of the specified types.\n * This can make life easier for code working with polymorphic types.\n */\n\nexport type CommonTypeTemplate<Ts> = {\n  [P in AllKeys<Ts>]?: Ts extends infer T\n    ? P extends keyof T\n      ? T[P]\n      : never\n    : never;\n};\n\nexport type ExpandTypes<\n  Ts,\n  Common = CommonTypeTemplate<Ts>\n> = Ts extends infer T\n  ? {\n      [P in keyof Common]: P extends keyof T ? T[P] : Common[P];\n    }\n  : never;\n\n/**\n * Typescript has the distinction between `void` and `undefined`.\n * I'm sure there is a theorically sound explanation. Both that and the distinction are annoying so this little utility type maps `void` to `undefined`.\n *\n * The ampersand union trick makes TypeScript relax instead of the \"The type T could be instantiated etc...\" error.\n */\nexport type Voidefined<T> = T extends void ? T & undefined : T;\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = (value: any, parse?: boolean) => T | undefined;\n\nexport const undefined = void 0;\nexport const nil = null;\n\n/** Caching this value potentially speeds up tests rather than using `Number.MAX_SAFE_INTEGER`. */\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/** Using this cached value speeds up testing if an object is iterable seemingly by an order of magnitude. */\nexport const symbolIterator = Symbol.iterator;\n\n/** Fast way to check for precence of function argument. */\nexport const NO_ARG = Symbol();\n\nconst createConverter =\n  <T>(typeTester: TypeTester<T>, parser?: (value: any) => T | undefined) =>\n  (value: any, parse = true) =>\n    typeTester(value)\n      ? value\n      : parser && parse && isDefined((value = parser(value)))\n      ? value\n      : undefined;\n\nexport const isNull = (value: any): value is null => value === nil;\n\nexport const isUndefined = (value: any): value is undefined | void =>\n  value === undefined;\n\nexport const isDefined = <T>(value: T): value is Defined<T> =>\n  value !== undefined;\n\nexport const ifDefined = <T, R>(\n  value: T,\n  result: (value: Exclude<T, undefined>) => R\n): MaybeUndefined<T, R> =>\n  value !== undefined ? (result(value as any) as any) : undefined;\n\nexport const isNullish = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value == nil;\n\nexport const hasValue = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value != nil;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\n\nexport const parseBoolean = createConverter(isBoolean, (value) => !!value);\nexport const isTruish = (value: any) => !!value;\n\nexport type Falsish = void | null | undefined | 0 | \"\" | false;\n\nexport const isFalsish = (value: any): value is Falsish => !value;\n\nexport const isInteger: (value: any) => value is number =\n  Number.isSafeInteger as any;\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\nexport const parseNumber = createConverter(isNumber, (value) =>\n  parseFloat(value)\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\nexport const parseBigInt = createConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createConverter(isString, (value) =>\n  hasValue(value) ? \"\" + value : value\n);\n\nexport const isArray: (value: any) => value is readonly any[] = Array.isArray;\n\n/**\n * Returns the value as an array following these rules:\n * - If the value is undefined (this does not include `null`), so is the return value.\n * - If the value is already an array its original value is returned unless `clone` is true. In that case a copy of the value is returned.\n * - If the value is iterable, an array containing its values is returned\n * - Otherwise, an array with the value as its single item is returned.\n */\nexport const toArray = <T>(\n  value: T | Iterable<T>,\n  clone = false\n): MaybeUndefined<[T][0], T[]> =>\n  isUndefined(value)\n    ? undefined\n    : !clone && isArray(value)\n    ? value\n    : isIterable(value)\n    ? [...value]\n    : ([value] as any);\n\nexport const isObject = <AcceptIterables extends boolean = false>(\n  value: any,\n  acceptIterables: AcceptIterables = false as any\n): value is AcceptIterables extends true\n  ? object & (Record<keyof any, any> | Iterable<any>)\n  : object & Record<keyof any, any> & { [Symbol.iterator]?: never } =>\n  value != null &&\n  typeof value === \"object\" &&\n  (acceptIterables || !value[symbolIterator]);\n\nexport const hasMethod = <T, Name extends keyof any>(\n  value: T | unknown,\n  name: Name | keyof T\n): value is {\n  [P in keyof T]: P extends Name\n    ? T extends { [P in Name]?: (...args: infer Args) => infer R }\n      ? Args extends unknown\n        ? (...args: any) => any\n        : (...args: Args) => R\n      : (...args: any) => any\n    : T[P];\n} => typeof (value as any)?.[name] === \"function\";\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\n\nexport const isIterable = (\n  value: any,\n  acceptStrings = false\n): value is Iterable<any> =>\n  !!(value?.[symbolIterator] && (typeof value === \"object\" || acceptStrings));\n\nexport const toIterable = <T>(value: T | Iterable<T>): Iterable<T> =>\n  isIterable(value) ? value : [value];\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == nil\n    ? value === nil\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\n/**\n * Evaluates a function that can be used to capture values using parameter default values.\n *\n * For example `(previous=current)=>(current+=2, previous)\n */\nexport const capture = <R>(capture: (...args: any[]) => R) => capture();\n","import {\r\n  Defined,\r\n  Falsish,\r\n  IsAny,\r\n  NotFunction,\r\n  Wrapped,\r\n  isArray,\r\n  isBoolean,\r\n  isDefined,\r\n  isFunction,\r\n  isString,\r\n  unwrap,\r\n} from \"..\";\r\n\r\nexport type ErrorGenerator = string | Error | (() => string | Error);\r\n\r\nexport const throwError = <T = any>(\r\n  error: ErrorGenerator,\r\n  transform: (string: string) => Error = (message) => new TypeError(message)\r\n): T => {\r\n  throw isString((error = unwrap(error))) ? transform(error) : error;\r\n};\r\n\r\ntype CombineTypeTests<T> = T extends []\r\n  ? {}\r\n  : T extends [infer F, ...infer Rest]\r\n  ? F extends (value: any) => value is infer R\r\n    ? (IsAny<R> extends true ? T : R) & CombineTypeTests<Rest>\r\n    : never\r\n  : never;\r\n\r\nexport const validate = <\r\n  T,\r\n  Validator extends\r\n    | ((candidate: T) => candidate is any)\r\n    | ((candiate: T) => R)\r\n    | [\r\n        validate: (candiate: T) => any,\r\n        ...typeTests: ((candidate: T) => candidate is any)[]\r\n      ]\r\n    | (R & NotFunction),\r\n  R\r\n>(\r\n  value: T,\r\n  validate: Validator | R,\r\n  validationError?: ErrorGenerator,\r\n  undefinedError?: ErrorGenerator\r\n): Defined<\r\n  Validator extends [any, ...infer TypeTests]\r\n    ? CombineTypeTests<TypeTests>\r\n    : Validator extends ((value: any) => infer R) | infer R\r\n    ? R extends Falsish\r\n      ? never\r\n      : Validator extends (value: any) => value is infer R\r\n      ? IsAny<R> extends true\r\n        ? T\r\n        : Defined<R>\r\n      : T\r\n    : never\r\n> =>\r\n  (\r\n    isArray(validate)\r\n      ? validate.every((test) => test(value))\r\n      : isFunction(validate)\r\n      ? validate(value)\r\n      : validate\r\n  )\r\n    ? value\r\n    : required(value, undefinedError ?? validationError) &&\r\n      (throwError(validationError ?? \"Validation failed.\") as any);\r\n\r\nexport class InvariantViolatedError extends Error {\r\n  constructor(invariant?: string) {\r\n    super(invariant ? \"INV: \" + invariant : \"An invariant was violated.\");\r\n  }\r\n}\r\n\r\n/**\r\n * States an invariant.\r\n */\r\nexport const invariant = <T>(\r\n  test: Wrapped<T | false>,\r\n  description?: string\r\n): Defined<T> => {\r\n  const valid = unwrap(test);\r\n  return isDefined(valid) && valid !== false\r\n    ? (valid as any)\r\n    : throwError(new InvariantViolatedError(description));\r\n};\r\n\r\nexport const required = <T>(value: T, error?: ErrorGenerator): Defined<T> =>\r\n  isDefined(value)\r\n    ? (value as any)\r\n    : throwError(\r\n        error ?? \"A required value is missing\",\r\n        (text) => new TypeError(text.replace(\"...\", \" is required.\"))\r\n      );\r\n\r\nexport const tryCatch = <T, C = undefined>(\r\n  expression: () => T,\r\n  errorHandler: boolean | ((error: any) => C) = true as any,\r\n  clean?: () => void\r\n): T | (C extends Error ? T : C) => {\r\n  try {\r\n    return expression();\r\n  } catch (e) {\r\n    if (!isBoolean(errorHandler)) {\r\n      const error = errorHandler?.(e) as any;\r\n      if (error instanceof Error) throw error;\r\n      return error;\r\n    }\r\n    if (errorHandler) {\r\n      throw e;\r\n    }\r\n    console.error(e);\r\n    return undefined as any;\r\n  } finally {\r\n    clean?.();\r\n  }\r\n};\r\n\r\nexport const tryCatchAsync = async <T, C = void>(\r\n  expression: () => PromiseLike<T> | T,\r\n  errorHandler:\r\n    | boolean\r\n    | ((error: any, last: boolean) => Promise<C> | C) = true as any,\r\n  clean?: () => void,\r\n  retries = 1\r\n): Promise<T | C> => {\r\n  while (retries--) {\r\n    try {\r\n      return await expression();\r\n    } catch (e) {\r\n      if (!isBoolean(errorHandler)) {\r\n        const error = (await errorHandler?.(e, !retries)) as any;\r\n        if (error instanceof Error) throw error;\r\n        return error;\r\n      } else if (errorHandler && !retries) {\r\n        throw e;\r\n      } else {\r\n        console.error(e);\r\n      }\r\n    } finally {\r\n      clean?.();\r\n    }\r\n  }\r\n  return undefined as any;\r\n};\r\n","import {\n  add,\n  ConstToNormal,\n  GeneralizeContstants,\n  get,\n  hasMethod,\n  IsAny,\n  isArray,\n  isDefined,\n  isFalsish,\n  isFunction,\n  isObject,\n  isSet,\n  isTruish,\n  IterableOrArrayLike,\n  KeyValuePairsToObject,\n  MAX_SAFE_INTEGER,\n  Minus,\n  NotFunction,\n  RecordType,\n  symbolIterator,\n  toArray,\n  undefined,\n  MaybeUndefined,\n} from \".\";\n\nexport const UTF16MAX = 0xffff;\n\nlet stopInvoked = false;\nexport const stop = (yieldValue?: any) => ((stopInvoked = true), yieldValue);\n\nexport const toCharCodes = (s: string) =>\n  [...new Array(s.length)].map((_, i) => s.charCodeAt(i));\nexport const codePoint = (string: string, index: number = 0) =>\n  string.codePointAt(index)!;\n\nexport type IteratorSource =\n  | any\n  | null\n  | undefined\n  | number\n  | Iterable<any>\n  | NotFunction\n  | NavigatingIteratorStep;\n\nexport type IteratorSourceOf<T> =\n  | (T extends number ? number : never)\n  | Iterable<T>\n  | (T extends readonly [infer K, infer V]\n      ? K extends keyof any\n        ? { [P in K]: V }\n        : never\n      : never)\n  | NavigatingIteratorStep<T>;\n\ntype IteratorItem<S extends IteratorSource> = IsAny<S> extends true\n  ? any\n  : S extends number\n  ? number\n  : S extends RecordType\n  ? [keyof S, S[keyof S]]\n  : S extends (...args: any) => infer T | undefined\n  ? T\n  : S extends Iterable<infer T>\n  ? T\n  : never;\n\nexport type IteratorItems<S extends IteratorSource[]> = S extends readonly [\n  infer S\n]\n  ? IteratorItem<S>\n  : S extends readonly [infer S, ...infer Rest]\n  ? IteratorItem<S> | IteratorItems<Rest>\n  : S extends (infer S)[]\n  ? IteratorItem<S>\n  : never;\n\nexport interface IteratorControl<S extends IteratorSource> {\n  source: S;\n  prev: IteratorItem<S> | undefined;\n  skip(): void;\n  end(): void;\n  end<P>(value: P): P;\n}\n\nexport type IteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = IteratorItem<S>,\n  Value = IteratorItem<S>\n> = (\n  value: Value,\n  index: number\n) => Projection | typeof stop | undefined | void;\n\ntype IteratorProjection<\n  S extends IteratorSource,\n  Projection\n> = unknown extends Projection ? IteratorItem<S> : ConstToNormal<Projection>;\n\ntype StartEndArgs<S extends IteratorSource> =\n  | []\n  | (S extends number\n      ? [offset?: number]\n      : S extends NavigatingIteratorStep<infer T>\n      ? [offset?: T, maxIterations?: number]\n      : [start?: number, end?: number]);\n\nexport type NavigatingIteratorStep<T = any> = (\n  current: T | undefined\n) => T | undefined;\n\ntype FlatIteratorItem<T, D extends number = 1, O = false> = T extends\n  | undefined\n  | void\n  ? never\n  : D extends 0\n  ? T\n  : T extends Iterable<any> | (O extends true ? Record<keyof any, any> : never)\n  ? D extends 1\n    ? IteratorItem<T>\n    : FlatIteratorItem<IteratorItem<T>, Minus<D, 1>, O>\n  : T;\n\ntype UndefinedIfUndefined<S, T> = S extends null | void | undefined\n  ? undefined\n  : T;\n\ntype ProjectedItem<P> = Exclude<P, undefined | void | typeof stop>;\n\nfunction* createFilteringIterator<\n  S extends IteratorSource,\n  P = IteratorItem<S>\n>(source: S, action?: IteratorAction<S, P>): Iterable<ProjectedItem<P>> {\n  if (!source) return;\n\n  let i = 0;\n  for (let item of source as any) {\n    action && (item = action(item, i++));\n    if (item !== undefined) {\n      yield item;\n    }\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n}\n\nfunction* createObjectIterator<\n  S extends Record<keyof any, any>,\n  P = IteratorItem<S>\n>(source: S, action?: IteratorAction<S, P>): Iterable<P> {\n  let i = 0;\n  for (const key in source) {\n    let value = [key, source[key]] as any;\n    action && (value = action(value, i++));\n\n    if (value !== undefined) {\n      yield value;\n    }\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n}\n\nfunction* createRangeIterator(length = 0, offset = 0): Iterable<number> {\n  while (length--) yield offset++;\n}\n\nexport function* createStringIterator(\n  input: string,\n  start: number,\n  end: number\n): Iterable<[char: string, codePoint: number]> {\n  while (start < end) {\n    const codePoint = input.codePointAt(start)!;\n    let p = input[start++];\n    if (codePoint > UTF16MAX) {\n      start++;\n      p = String.fromCodePoint(codePoint);\n    }\n    yield [p, codePoint];\n  }\n}\n\nexport function* createNavigatingIterator<T>(\n  step: NavigatingIteratorStep<T>,\n  start?: T | undefined,\n  maxIterations = Number.MAX_SAFE_INTEGER\n): Iterator<T> {\n  if (isDefined(start)) yield start;\n  while (maxIterations-- && isDefined((start = step(start)))) {\n    yield start;\n  }\n}\n\nconst sliceAction = <\n  S extends IteratorSource,\n  A extends IteratorAction<S, any> | undefined\n>(\n  action: A,\n  start: any,\n  end: any\n): A =>\n  (start ?? end) !== undefined\n    ? ((start ??= 0),\n      (end ??= MAX_SAFE_INTEGER),\n      (value, index) =>\n        start--\n          ? undefined\n          : end!--\n          ? action\n            ? action(value, index)\n            : value\n          : end)\n    : (action as any);\n\nexport type Filter<S extends IteratorSource> = (\n  value: IteratorItem<S>,\n  index: number\n) => any;\n\nconst createIterator = <S extends IteratorSource, P = IteratorItem<S>>(\n  source: S,\n  action?: IteratorAction<S, P>,\n  start?: any,\n  end?: any\n): Iterable<P> =>\n  source == null\n    ? ([] as any)\n    : source[symbolIterator]\n    ? createFilteringIterator(\n        source,\n        start === undefined ? action : sliceAction(action, start as any, end)\n      )\n    : typeof source === \"object\"\n    ? createObjectIterator(\n        source as any,\n        sliceAction(action, start as any, end)\n      )\n    : createIterator(\n        isFunction(source)\n          ? createNavigatingIterator(source, start, end)\n          : (createRangeIterator(source as number, start as any) as any),\n        action\n      );\n\nconst mapToArray = <T, M>(\n  projected: Iterable<T>,\n  map: M\n): true extends M ? T[] : Iterable<T> =>\n  map && !isArray(projected) ? [...projected] : (projected as any);\n\ntype ProjectFunction = {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): Iterable<IteratorProjection<S, R>>;\n  <S extends IteratorSource>(source: S, ...rest: StartEndArgs<S>): Iterable<\n    IteratorItem<S>\n  >;\n};\n\ntype MapFunction = {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): MaybeUndefined<S, IteratorProjection<S, R>[]>;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): MaybeUndefined<S, IteratorItem<S>[]>;\n};\n\ntype FlatProjectFunction = <\n  S extends IteratorSource,\n  D extends number = 1,\n  R = IteratorItem<S>,\n  O extends boolean = false\n>(\n  source: S,\n  projection?: FlatIteratorAction<S, R, D, O>,\n  depth?: D,\n  expandObjects?: O,\n  ...rest: StartEndArgs<S>\n) => FlatIteratorItem<Iterable<R>, D>;\n\nexport const project: ProjectFunction = ((\n  source: any,\n  projection: any,\n  start: any,\n  end: any\n) =>\n  projection != null && !isFunction(projection)\n    ? // The second argument is the value of `start`.\n      createIterator(source, undefined, projection, start)\n    : createIterator(source, projection, start, end)) as any;\n\nexport const flatProject: FlatProjectFunction = function (\n  source,\n  projection?,\n  depth = 1 as any,\n  expandObjects: any = false,\n  start?: any,\n  end?: any\n) {\n  return createIterator(\n    flatten(\n      createIterator(source, undefined, start, end),\n      depth + 1,\n      expandObjects,\n      false\n    ),\n    projection\n  ) as any;\n\n  function* flatten(\n    value: any,\n    depth: number,\n    expandObjects: boolean,\n    nested: boolean\n  ) {\n    if (value != null) {\n      if (\n        value?.[symbolIterator] ||\n        (expandObjects && value && typeof value === \"object\")\n      ) {\n        for (const item of nested ? createIterator(value) : value) {\n          if (depth > 1 || depth <= 0) {\n            yield* flatten(item, depth - 1, expandObjects, true);\n          } else {\n            yield item;\n          }\n        }\n      } else {\n        yield value;\n      }\n    }\n  }\n};\n\nexport const map: MapFunction = (\n  source: any,\n  projection?: any,\n  start: any = undefined,\n  end?: any\n) => {\n  if (start === undefined && isArray(source)) {\n    let i = 0;\n    const mapped: any[] = [];\n    for (let j = 0, n = source.length; j < n && !stopInvoked; j++) {\n      let value = source[j];\n      if (projection && value !== undefined) {\n        value = projection(value, i++);\n      }\n      if (value !== undefined) {\n        mapped.push(value);\n      }\n    }\n    stopInvoked = false;\n    return mapped;\n  }\n  return source !== undefined\n    ? toArray(project(source, projection, start, end))\n    : (undefined as any);\n};\n\nexport const zip = <Lhs extends IteratorSource, Rhs extends IteratorSource>(\n  lhs: Lhs,\n  rhs: Rhs\n): Iterable<[IteratorItem<Lhs>, IteratorItem<Rhs> | undefined]> => {\n  const it2 = createIterator(rhs)[Symbol.iterator]();\n  return createIterator(lhs, (lhs) => [lhs, it2.next()?.value] as [any, any]);\n};\n\nexport const distinct: {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorProjection<S, R>>;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorItem<S>>;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  isDefined(source)\n    ? new Set<any>([...project(source, projection, start, end)])\n    : undefined;\n\nexport const single: {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorProjection<S, R> | undefined;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorItem<S> | undefined;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  !source\n    ? undefined\n    : (source = mapDistinct(source, projection, start, end) as any).length > 1\n    ? undefined\n    : source[0];\n\nexport const mapDistinct: MapFunction = (\n  source: any,\n  projection?: any,\n  start?: any,\n  end?: any\n) =>\n  isDefined(source)\n    ? [...(distinct as any)(source, projection, start, end)]\n    : source;\n\nexport function* concatIterators<S extends IteratorSource[]>(\n  ...iterators: S\n): Iterable<IteratorItems<S>> {\n  for (const iterator of iterators) {\n    if (!iterator) continue;\n    yield* createIterator(iterator);\n  }\n}\n\ntype AllCanBeUndefined<T extends any[]> = T extends readonly [infer S]\n  ? undefined extends S\n    ? true\n    : false\n  : T extends readonly [infer S, ...infer Rest]\n  ? AllCanBeUndefined<Rest> extends false\n    ? false\n    : undefined extends S\n    ? true\n    : false\n  : true;\n\nexport const concat = <S extends (IterableOrArrayLike<any> | undefined)[]>(\n  ...iterators: S\n):\n  | (AllCanBeUndefined<S> extends true ? undefined : never)\n  | IteratorItems<S>[] =>\n  iterators.reduce(\n    (r: undefined | any[], it) => (it ? (r ?? []).concat(toArray(it)) : r),\n    undefined\n  ) as any;\n\nexport const intersection = <\n  T,\n  A extends Iterable<T> | undefined,\n  B extends Iterable<T> | undefined,\n  MapToArray extends boolean = A extends any[]\n    ? true\n    : B extends any[]\n    ? true\n    : false\n>(\n  a: A,\n  b: B,\n  mapToArray?: MapToArray\n): MapToArray extends true ? T[] : Iterable<T> => {\n  if (!a || !b) return [];\n  isSet(b) && ([b, a] = [a, b] as any);\n  const lookup = isSet(a) ? a : new Set(a);\n  return filter(b, (value) => lookup.has(value), mapToArray) as any;\n};\n\nexport const intersects = (\n  a: Iterable<any> | undefined,\n  b: Iterable<any> | undefined\n) => !!count(intersection(a, b));\n\ntype FlatIteratorAction<\n  S extends IteratorSource,\n  R = FlatIteratorItem<S>,\n  D extends number = 1,\n  O = false\n> = IteratorAction<S, R, FlatIteratorItem<S, D, O>>;\n\nexport const flatMap = <\n  S extends IteratorSource,\n  D extends number = 1,\n  O extends boolean = false,\n  R = IteratorItem<S>\n>(\n  source: S,\n  action: FlatIteratorAction<S, R, D, O> = (item) => item as any,\n  depth: D = 1 as any,\n  expandObjects: O = false as any,\n  ...rest: StartEndArgs<S>\n): FlatIteratorItem<R, D>[] =>\n  map(flatProject(source, action, depth, expandObjects, ...rest)) as any;\n\nconst traverseInternal = <T>(\n  root: T | T[] | undefined,\n  selector: (current: T) => Iterable<T> | undefined,\n  include: boolean,\n  results: T[],\n  seen: Set<T>\n) => {\n  if (isArray(root)) {\n    forEachInternal(root, (item) =>\n      traverseInternal(item, selector, include, results, seen)\n    );\n    return results;\n  }\n  if (!root || !add(seen, root)) {\n    return undefined;\n  }\n  include && results.push(root);\n  forEachInternal(selector(root), (item) =>\n    traverseInternal(item, selector, true, results, seen)\n  );\n\n  return results;\n};\n\ntype JoinResult<T> = T extends readonly []\n  ? never\n  : T extends readonly [infer Item, ...infer Rest]\n  ?\n      | Exclude<Item extends Iterable<infer T> ? T : Item, undefined>\n      | JoinResult<Rest>\n  : never;\n\nexport const join = <T extends readonly any[]>(...items: T): JoinResult<T>[] =>\n  items.flatMap((item) => toArray(item) ?? []).filter(isDefined) as any;\n\nexport const expand = <T>(\n  root: T | T[],\n  selector: (\n    current: Exclude<T, undefined>\n  ) => Iterable<T | undefined> | undefined,\n  includeSelf = true\n): T extends undefined ? undefined : Exclude<T, undefined>[] =>\n  traverseInternal(root, selector, includeSelf, [], new Set()) as any;\n\nconst forEachArray = (source: readonly any[], action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let j = 0, n = source.length; j < n; j++) {\n    if (\n      source[j] !== undefined &&\n      ((returnValue = action(source[j], i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachItereable = (source: Iterable<any>, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let value of source as any) {\n    if (\n      value !== undefined &&\n      ((returnValue = action(value, i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachObject = (source: any, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let key in source) {\n    if (\n      ((returnValue = action([key, source[key]], i++) ?? returnValue),\n      stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachInternal: <S extends IteratorSource, R>(\n  source: S,\n  action: IteratorAction<S, R>,\n  start?: any,\n  end?: any\n) => R | undefined = (source, action, start = undefined, end?: any) => {\n  if (source == null) return;\n\n  let returnValue: any;\n  if (start === undefined) {\n    if (isArray(source)) return forEachArray(source, action);\n    if (source[symbolIterator]) return forEachItereable(source as any, action);\n    if (typeof source === \"object\") return forEachObject(source, action);\n  }\n\n  for (const value of createIterator(source, action, start, end)) {\n    returnValue = (value as any) ?? returnValue;\n  }\n\n  return returnValue;\n};\n\nexport const forEach = forEachInternal as <S extends IteratorSource, R>(\n  source: S,\n  action: IteratorAction<S, R>,\n  ...rest: StartEndArgs<S>\n) => R | undefined;\n\nexport const flatForEach = <\n  S extends IteratorSource,\n  R,\n  Depth extends number,\n  O extends boolean = false\n>(\n  source: S,\n  action: FlatIteratorAction<S, R, Depth, O>,\n  depth: Depth = 1 as any,\n  expandObjects: O = false as any,\n  ...rest: StartEndArgs<S>\n): R | undefined =>\n  forEachInternal(\n    flatProject(source, undefined, depth, expandObjects, ...(rest as any)),\n    action as any\n  ) as any;\n\nexport const obj: {\n  <S extends IteratorSource, P extends readonly [keyof any, any]>(\n    source: S,\n    selector: IteratorAction<S, P>,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<P>;\n  <S extends IteratorSourceOf<readonly [keyof any, any]>>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<IteratorItem<S>>;\n} = ((source: any, selector: any, ...rest: any[]) =>\n  Object.fromEntries((map as any)(source, selector, ...rest))) as any;\n\nexport const groupReduce: <\n  S extends IteratorSource,\n  Key,\n  Accumulator = unknown\n>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  reducer: (\n    accumulator: GeneralizeContstants<Accumulator>,\n    ...rest: Parameters<IteratorAction<S, Accumulator>>\n  ) => Accumulator,\n  seed?: Accumulator | (() => Accumulator),\n  ...reset: StartEndArgs<S>\n) => Map<Key, Accumulator> = (\n  source,\n  keySelector,\n  reducer,\n  seed,\n  start?: any,\n  end?: any\n) => {\n  const groups = new Map<any, any>();\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  const action: IteratorAction<any, any> = (item, index) => {\n    const key = keySelector(item, index);\n    let acc = groups.get(key) ?? seedFactory();\n    const value = reducer(acc, item, index);\n    if (isDefined(value)) {\n      groups.set(key, value);\n    }\n  };\n  forEachInternal(source, action, start, end);\n  return groups as any;\n};\n\nexport const group: <S extends IteratorSource, Key, R = IteratorItem<S>>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  valueSelector?: (item: IteratorItem<S>, index: number) => R,\n  ...rest: StartEndArgs<S>\n) => S extends undefined ? undefined : Map<Key, R[]> = (\n  source,\n  keySelector,\n  valueSelector = (item: any) => item,\n  start?: any,\n  end?: any\n) => {\n  if (source == null) return undefined as any;\n  const groups = new Map<any, any[]>();\n  (forEachInternal as any)(\n    source,\n    (item: any, index: number) => {\n      const key = keySelector(item, index);\n      const value = valueSelector(item, index);\n      get(groups, key as any, () => []).push(value);\n    },\n    start,\n    end\n  );\n  return groups as any;\n};\n\nexport const reduce: <\n  S extends IteratorSource,\n  Reducer extends (\n    ...args: [\n      accumulator: unknown extends Accumulator\n        ? any\n        : GeneralizeContstants<Accumulator>,\n      ...rest: Parameters<IteratorAction<S, Accumulator>>\n    ]\n  ) => GeneralizeContstants<Accumulator>,\n  Accumulator\n>(\n  source: S,\n  reducer: Reducer,\n  seed?: Accumulator | (() => Accumulator),\n  ...rest: StartEndArgs<S>\n) => Reducer extends (...args: any) => infer R\n  ? R | (unknown extends Accumulator ? undefined : never)\n  : never = (source, reducer, seed, start?: any, end?: any) => {\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  return (\n    forEachInternal(\n      source,\n      (value, index) =>\n        (seed =\n          ((reducer as any)(seed as any, value, index) as any) ??\n          seedFactory()),\n      start,\n      end\n    ) ?? (seedFactory() as any)\n  );\n};\n\ntype FilterItem<S extends IteratorSource, F> = F extends (\n  value: any,\n  ...args: any\n) => value is infer T\n  ? T\n  : IteratorItem<S>;\n\nexport const filter: {\n  <\n    S extends IteratorSource,\n    MapToArray extends boolean = S extends any[] ? true : false,\n    P extends Filter<S> = Filter<S>\n  >(\n    source: S,\n    predicate?: P,\n    map?: MapToArray,\n    ...rest: StartEndArgs<S>\n  ): MapToArray extends true\n    ? UndefinedIfUndefined<S, FilterItem<S, P>[]>\n    : Iterable<FilterItem<S, P>>;\n} = (\n  source: IteratorSource,\n  predicate: Filter<any> = (item: any) => item != null,\n  map = isArray(source) as any,\n  start?: any,\n  end?: any\n) =>\n  mapToArray(\n    createIterator(\n      source,\n      (item, index) => (predicate(item, index) ? item : undefined),\n      start,\n      end\n    ),\n    map\n  ) as any;\n\nlet filterInternal = filter;\n\nexport const count: <S>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => UndefinedIfUndefined<S, number> = (\n  source: IteratorSource,\n  filter?: Filter<IteratorSource>,\n  start?: any,\n  end?: any\n) => {\n  if (!source) return undefined as any;\n\n  let n: number;\n  if (filter) {\n    source = filterInternal(source, filter, false, start, end) as any;\n  } else {\n    if (isDefined((n = source![\"length\"] ?? source![\"size\"]))) {\n      return n;\n    }\n    if (!source[symbolIterator]) {\n      return Object.keys(source).length;\n    }\n  }\n  n = 0;\n  return forEachInternal(source, () => ++n) as any;\n};\n\nexport const sum: {\n  <S extends IteratorSourceOf<number>>(\n    source: S,\n    selector?: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n  <S extends IteratorSource>(\n    source: S,\n    selector: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n} = (\n  source: any,\n  selector: any = (item: any) => item,\n  start?: any,\n  end?: any\n) =>\n  reduce(\n    source,\n    (sum, value, index) => sum + (selector(value, index) ?? 0),\n    0,\n    start,\n    end\n  );\n\nexport const values: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => UndefinedIfUndefined<\n  S,\n  IteratorItem<S> extends readonly [any, infer Item] ? Item : IteratorItem<S>\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isObject(source) ? (item: any) => item[1] : (item: any) => item,\n    start,\n    end\n  );\n\nexport const keys: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => UndefinedIfUndefined<\n  S,\n  IteratorItem<S> extends readonly [infer Key, any] ? Key : number\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isObject(source) ? (item: any) => item[0] : (_item: any, i: number) => i,\n    start,\n    end\n  );\n\nexport const first: <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: Filter<any>,\n  start?: any,\n  end?: any\n) =>\n  !source || isArray(source)\n    ? source?.[0]\n    : forEachInternal(\n        source,\n        (value, i) =>\n          !predicate || predicate(value, i) ? stop(value) : undefined,\n        start,\n        end\n      );\n\nexport const last: <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: any,\n  start?: any,\n  end?: any\n) =>\n  !source\n    ? undefined\n    : isArray(source)\n    ? source[source.length - 1]\n    : forEachInternal(\n        source,\n        (item, i) => (!predicate || predicate(item, i) ? item : undefined),\n        start,\n        end\n      );\n\nexport const find = <S extends IteratorSource>(\n  source: S,\n  predicate: Filter<S>,\n  ...rest: StartEndArgs<S>\n): UndefinedIfUndefined<S, IteratorItem<S>> =>\n  !source\n    ? undefined\n    : (source as any).find\n    ? (source as any).find(predicate)\n    : first(filterInternal(source as any, predicate, false, ...rest));\n\nexport const some: <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => UndefinedIfUndefined<S, boolean> = (\n  source,\n  predicate,\n  start?: any,\n  rangeEnd?: any\n) =>\n  source === undefined\n    ? undefined\n    : hasMethod(source, \"some\")\n    ? source.some(predicate ?? isTruish)\n    : forEachInternal<any, boolean>(\n        source,\n        predicate\n          ? (item, index) => (predicate(item, index) ? stop(true) : false)\n          : () => stop(true),\n        start,\n        rangeEnd\n      ) ?? false;\n\nexport const every = <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n): UndefinedIfUndefined<S, boolean> =>\n  !source\n    ? undefined\n    : (!some(\n        source,\n        predicate ? (item, index) => !predicate(item, index) : isFalsish,\n        ...rest\n      ) as any);\n\nexport const binarySearch: {\n  (arr: Array<number>, find: number): number;\n  <T = number>(arr: Array<T>, find: T, compare: (x: T, y: T) => number): number;\n} = <T = number>(\n  arr: Array<T>,\n  find: T,\n  compare: (x: T, y: T) => number = ((x: any, y: any) => x - y) as any\n) => {\n  let m = 0;\n  let n = arr.length - 1;\n  let cmp: number;\n  let k: number;\n  while (m <= n) {\n    k = (n + m) >> 1;\n    cmp = compare(find, arr[k]);\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return k;\n    }\n  }\n  return ~m;\n};\n","import {\n  MaybePromise,\n  define,\n  isDefined,\n  isFunction,\n  isNumber,\n  promise,\n  tryCatchAsync,\n} from \".\";\n\nexport let now = () =>\n  typeof performance !== \"undefined\"\n    ? Math.trunc(performance.timeOrigin + performance.now())\n    : Date.now();\n\nexport type CancellableCallback = (cancel: () => void) => MaybePromise<any>;\n\nexport type Timer = {\n  (toggle?: boolean): number;\n};\n\nexport const createTimer = (started = true): Timer => {\n  let t0: number | boolean = started && now();\n  let elapsed = 0;\n  return (toggle?: boolean) => {\n    t0 && (elapsed += now() - (t0 as number));\n    isDefined(toggle) && (t0 = toggle && now());\n    return elapsed;\n  };\n};\n\nexport interface Clock {\n  readonly active: boolean;\n  readonly busy: boolean;\n  restart(frequency?: number, callback?: CancellableCallback): Clock;\n  toggle(start: boolean, trigger?: boolean): Clock;\n  trigger(skipQueue?: boolean): Promise<boolean>;\n}\n\nexport interface ClockSettings {\n  frequency?: number;\n  queue?: boolean;\n  paused?: boolean;\n  trigger?: boolean;\n  once?: boolean;\n  callback?: CancellableCallback;\n}\n\nexport const clock: {\n  (callback: CancellableCallback, frequency: number): Clock;\n  (settings: ClockSettings): Clock;\n} = (\n  callbackOrSettings: CancellableCallback | ClockSettings,\n  frequency = 0\n): Clock => {\n  const settings = isFunction(callbackOrSettings)\n    ? {\n        frequency,\n        callback: callbackOrSettings,\n      }\n    : callbackOrSettings;\n\n  let {\n    queue = true,\n    paused = false,\n    trigger = false,\n    once = false,\n    callback = () => {},\n  } = settings;\n  frequency = settings.frequency ?? 0;\n\n  let timeoutId = 0;\n  const mutex = promise(true).resolve();\n\n  const outerCallback = async (skipQueue?: boolean) => {\n    if (!timeoutId || (!queue && mutex.pending && skipQueue !== true)) {\n      return false;\n    }\n    (instance as any).busy = true;\n    if (skipQueue !== true) {\n      await mutex;\n    }\n\n    mutex.reset();\n    let cancelled = frequency < 0 || once;\n    await tryCatchAsync(\n      () => callback!(() => (cancelled = true)),\n      false,\n      () => mutex.resolve()\n    );\n    if (cancelled) {\n      reset(false);\n    }\n\n    (instance as any).busy = false;\n    return true;\n  };\n\n  const reset = (start: boolean) => {\n    clearInterval(timeoutId);\n    (instance as any).active = !!(timeoutId = start\n      ? (setInterval(\n          outerCallback,\n          frequency < 0 ? -frequency : frequency\n        ) as any)\n      : 0);\n    return instance;\n  };\n\n  const instance: Clock = {\n    active: false,\n    busy: false,\n    restart: (newFrequency, newCallback) => {\n      frequency = newFrequency ?? frequency;\n      callback = newCallback ?? callback;\n      return reset(true);\n    },\n    toggle: (start, trigger) =>\n      start !== instance.active\n        ? start\n          ? trigger\n            ? (reset(true), instance.trigger(), instance)\n            : reset(true)\n          : reset(false)\n        : instance,\n    trigger: async (skipQueue) =>\n      (await outerCallback(skipQueue)) && (reset(instance.active), true),\n  };\n\n  return instance.toggle(!paused, trigger);\n};\n","import {\n  MaybePromise,\n  Unwrap,\n  Wrapped,\n  isDefined,\n  isFunction,\n  isInteger,\n  isUndefined,\n  now,\n  throwError,\n  createTimer,\n  tryCatchAsync,\n  undefined,\n  unwrap,\n} from \".\";\n\nexport class ResetablePromise<T = void, E = any> implements PromiseLike<T> {\n  private _promise: OpenPromise<T>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public get value() {\n    return this._promise.value;\n  }\n  public get error() {\n    return this._promise.error;\n  }\n  public get pending() {\n    return this._promise.pending;\n  }\n\n  public resolve(value: T, ifPending = false) {\n    this._promise.resolve(value, ifPending);\n    return this;\n  }\n\n  public reject(value?: E, ifPending = false) {\n    this._promise.reject(value, ifPending);\n    return this;\n  }\n\n  public reset() {\n    this._promise = new OpenPromise<T>();\n    return this;\n  }\n\n  public signal(value: T) {\n    this.resolve(value);\n    this.reset();\n    return this;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): PromiseLike<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport class OpenPromise<T = void, E = any> implements PromiseLike<T> {\n  private readonly _promise: Promise<T>;\n\n  public readonly resolve: (value: T, ifPending?: boolean) => this;\n  public readonly reject: (reason: E | undefined, ifPending?: boolean) => this;\n  public readonly value: (T extends void ? true : T) | undefined;\n  public readonly error: E | true;\n  public pending = true;\n\n  constructor() {\n    let captured: any[];\n    this._promise = new Promise((...args: any[]) => {\n      captured = args.map((inner, i) => (value: any, ifPending: boolean) => {\n        if (!this.pending) {\n          if (ifPending) return this;\n          throw new TypeError(\"Promise already resolved/rejected.\");\n        }\n\n        (this as any).pending = false;\n        (this as any)[i ? \"error\" : \"value\"] = !isDefined(value) || value;\n        inner(value);\n        return this;\n      });\n    });\n\n    [this.resolve, this.reject] = captured!;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | null\n      | undefined,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | null\n      | undefined\n  ): Promise<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport type Lock = {\n  (timeout?: number): Promise<() => void>;\n  <T>(action: () => MaybePromise<T>, timeout?: number): Promise<T | undefined>;\n};\n\nexport const createLock = (): Lock => {\n  const semaphore = promise<boolean>(true);\n  let currentLock: (() => void) | undefined;\n  const t0 = createTimer();\n  const wait = async (actionOrMs?: (() => any) | number, ms?: number) => {\n    if (isFunction(actionOrMs)) {\n      const release = await wait(ms);\n      return release\n        ? await tryCatchAsync(actionOrMs, true, release)\n        : undefined;\n    }\n    while (currentLock) {\n      if (\n        isUndefined(\n          await (actionOrMs ? race(delay(actionOrMs), semaphore) : semaphore)\n        )\n      ) {\n        return undefined;\n      }\n      actionOrMs! -= t0(); // If the above did not return undefined we got the semaphore.\n    }\n    return (currentLock = () => semaphore.signal(!(currentLock = undefined)));\n  };\n  return wait;\n};\n\nexport const delay = <T extends Wrapped<any> = void>(\n  ms: number | undefined,\n  value?: T\n): MaybePromise<Unwrap<T>> =>\n  isUndefined(ms) || isInteger(ms)\n    ? !ms || ms <= 0\n      ? unwrap(value)!\n      : new Promise<any>((resolve) =>\n          setTimeout(async () => resolve(await unwrap(value)), ms)\n        )\n    : throwError(`Invalid delay ${ms}.`);\n\nexport const promise: {\n  <T = void>(resetable?: false): OpenPromise<T>;\n  <T = void>(resetable: true): ResetablePromise<T>;\n} = (resetable?: boolean) =>\n  resetable ? new ResetablePromise() : (new OpenPromise() as any);\n\ntype UnwrapPromiseArg<T> = T extends () => infer T ? Awaited<T> : Awaited<T>;\ntype UnwrapPromiseArgs<T extends any[]> = T extends readonly [infer Arg]\n  ? [UnwrapPromiseArg<Arg>]\n  : T extends readonly [infer Arg, ...infer Rest]\n  ? [UnwrapPromiseArg<Arg>, ...UnwrapPromiseArgs<Rest>]\n  : [];\n\nexport type AsyncValue<T> =\n  | undefined\n  | T\n  | PromiseLike<T>\n  | (() => T)\n  | (() => PromiseLike<T>);\n\nexport const waitAll = <Args extends AsyncValue<any>[]>(\n  ...args: Args\n): Promise<UnwrapPromiseArgs<Args>> =>\n  Promise.all(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n\nexport const race = <Args extends AsyncValue<any>[]>(\n  ...args: Args\n): Promise<UnwrapPromiseArgs<Args>[number]> =>\n  Promise.race(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n","import { filter, isUndefined, reduce } from \".\";\n\nexport type Rebinder = () => boolean;\nexport type Unbinder = () => boolean;\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\n\nexport type SourceListener<Args extends any[]> = (...args: Args) => void;\nexport type Listener<Args extends any[]> = (\n  ...args: [...args: Args, unbind: Unbinder]\n) => void;\n\nexport const createEventBinders = <Args extends any[]>(\n  listener: Listener<Args>,\n  attach: (listener: SourceListener<Args>) => void,\n  detach: (listener: SourceListener<Args>) => void\n): Binders => {\n  let bound = false;\n\n  const outerListener = (...args: Args) => listener(...args, unbind);\n\n  const unbind = () =>\n    bound !== (bound = false) && (detach(outerListener), true);\n\n  const rebind = () =>\n    bound !== (bound = true) && (attach(outerListener), true);\n\n  rebind();\n  return [unbind, rebind];\n};\n\nexport const joinEventBinders = (\n  ...binders: (Binders | undefined)[]\n): Binders => (\n  (binders = filter(binders)),\n  [\n    () => reduce(binders, (changed, binder) => binder![0]() || changed, false),\n    () => reduce(binders, (changed, binder) => binder![1]() || changed, false),\n  ]\n);\n\nexport type EventHandler<Args extends any[]> = (...payload: Args) => void;\n\nexport const createEvent = <Args extends any[]>(): [\n  listen: (listener: Listener<Args>, triggerCurrent?: boolean) => Binders,\n  dispatch: (...payload: Args) => void\n] => {\n  const listeners = new Set<SourceListener<Args>>();\n  let dispatchedArgs: Args | undefined;\n  return [\n    (handler, trigger) => {\n      const binders = createEventBinders(\n        handler,\n        (handler) => listeners.add(handler),\n        (handler) => listeners.delete(handler)\n      );\n      trigger && dispatchedArgs && handler(...dispatchedArgs, binders[0]);\n      return binders;\n    },\n    (...payload) => (\n      (dispatchedArgs = payload),\n      listeners.forEach((handler) => handler(...payload))\n    ),\n  ];\n};\n\nexport type ChainedEventHandler<Args extends any[], T> = (\n  ...args: [\n    ...args: Args,\n    next: {\n      (): T;\n      (...args: Args): T;\n    },\n    unbind: Unbinder\n  ]\n) => T;\n\ntype LinkedNode<T> = [\n  prev: LinkedNode<T> | undefined,\n  item: T,\n  next: LinkedNode<T> | undefined\n];\n\nexport const createChainedEvent = <T = void, Args extends any[] = []>(): [\n  register: (\n    handler: ChainedEventHandler<Args, T>,\n    priority?: number\n  ) => Binders,\n  invoke: (...args: Args) => T | undefined\n] => {\n  type Item = [\n    handler: ChainedEventHandler<Args, T>,\n    priority: number,\n    binders: Binders\n  ];\n  type Node = LinkedNode<Item>;\n  let head: Node | undefined;\n  let tail: Node | undefined;\n  let next: Node | undefined;\n\n  const register = (\n    handler: ChainedEventHandler<Args, T>,\n    // Make sure that handler gets rebound at their previous priority without jumping discrete increments.\n    // (It is deseriable to be able to specfiy priority 0 or  10 without having to think about how many 0s there are)\n    priority = (tail?.[1][1] ?? 0) + 0.000001\n  ) => {\n    const registerNode = (node?: Node) => {\n      let bound = true;\n      node ??= [\n        undefined,\n        [\n          handler,\n          priority,\n          [\n            () => {\n              if (!bound) return false;\n              node![0] ? (node![0][2] = node![2]) : (head = node![2]);\n              node![2] ? (node![2][0] = node![0]) : (tail = node![0]);\n              node![0] = node![2] = undefined;\n              return !(bound = false);\n            },\n            () => (bound ? false : (registerNode(node), (bound = true))),\n          ],\n        ],\n        undefined,\n      ];\n      next = head;\n      if (!next) {\n        head = tail = node;\n      } else if (priority >= tail![1][1]) {\n        node[0] = tail;\n        tail = tail![2] = node;\n      } else {\n        // INV: priority < tail.priority, so next will be non-null after loop;\n        while (next![1][1]! <= priority) {\n          next = next[2]!;\n        }\n\n        (node[0] = (node[2] = next)[0]) ? (node[0][2] = node) : (head = node);\n        next[0] = node;\n      }\n\n      return node[1][2];\n    };\n    return registerNode();\n  };\n\n  const invoke = (node: Node | undefined, args: Args) => (\n    (next = node?.[2]),\n    node\n      ? node[1][0](\n          ...args,\n          (...nextArgs: Args) =>\n            invoke(next!, nextArgs.length ? nextArgs : args),\n          node[1][2][0]\n        )\n      : undefined\n  );\n\n  return [register, (...args) => invoke(head, args)];\n};\n","import { now } from \"@tailjs/util\";\n\nexport type UUID = string;\n\nexport let TAB_ID =\n  now().toString(36) +\n  Math.trunc(1296 * Math.random()) //\n    .toString(36)\n    .padStart(2, \"0\");\n\nlet localId = 0;\nexport const nextId = () => TAB_ID + \"_\" + nextLocalId();\nexport const nextLocalId = () => ++localId;\n","import {\n  Binders,\n  Listener,\n  Unbinder,\n  clock,\n  createEvent,\n  createEventBinders,\n  createTimer,\n  isArray,\n  joinEventBinders,\n  map,\n} from \"@tailjs/util\";\n\ntype AllMaps = WindowEventMap &\n  GlobalEventHandlersEventMap &\n  DocumentEventMap &\n  HTMLElementEventMap;\n\nexport const listen = <K extends keyof AllMaps>(\n  target: {\n    addEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions\n    ): void;\n    removeEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | EventListenerOptions\n    ): void;\n  },\n  name: K | K[],\n  listener: (\n    ev: AllMaps[K extends any[] ? K[number] : K],\n    unbind?: Unbinder\n  ) => any,\n  options: AddEventListenerOptions = { capture: true, passive: true }\n): Binders => {\n  return isArray(name)\n    ? joinEventBinders(\n        ...map(name, (name) => listen(target, name as any, listener, options))\n      )\n    : createEventBinders(\n        listener,\n        (listener) => target.addEventListener(name, listener, options),\n        (listener) => target.addEventListener(name, listener, options)\n      );\n};\n\ntype PageLoadListenerArgs = [loaded: boolean];\nconst [addPageLoadedListener, dispatchPageLoaded] =\n  createEvent<PageLoadListenerArgs>();\n\nlet loaded = true;\nlisten(\n  window,\n  \"pagehide\",\n  () => loaded && dispatchPageLoaded((loaded = false))\n);\nlisten(\n  window,\n  \"pageshow\",\n  () => !loaded && dispatchPageLoaded((loaded = true))\n);\nlisten(\n  document,\n  \"visibilitychange\",\n  () =>\n    document.visibilityState === \"visible\" &&\n    !loaded &&\n    dispatchPageLoaded((loaded = true))\n);\n\ndispatchPageLoaded(loaded);\n\ntype PageActivatedListenerArgs = [activated: boolean, totalDuration: number];\nlet activated = false;\nlet activeTime = createTimer(false);\n\nconst [addPageActivatedListener, dispatchPageActivated] =\n  createEvent<PageActivatedListenerArgs>();\n\nconst activationTimeout = clock({\n  callback: () =>\n    activated && dispatchPageActivated((activated = false), activeTime(false)),\n  frequency: 20000,\n  once: true,\n  paused: true,\n});\nconst setActivated = () =>\n  !activated &&\n  (dispatchPageActivated((activated = true), activeTime(true)),\n  activationTimeout.restart());\n\nlisten(window, \"focus\", setActivated);\nlisten(window, \"blur\", () => activationTimeout.trigger());\n\nlisten(document.body, \"keydown\", setActivated);\nlisten(document.body, \"pointermove\", setActivated);\nlisten(window, \"scroll\", setActivated);\n\nsetActivated();\n\nexport const getActiveTime = () => activeTime();\nexport { addPageLoadedListener, addPageActivatedListener };\n","const codes: number[] = [];\nconst chars: number[] = [];\nexport const charCode = (s: string, index = 0) => s.charCodeAt(index);\nexport const fromCharCodes = (chars: number[]) => String.fromCharCode(...chars);\n\n[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"].forEach(\n  (p, i) => (codes[(chars[i] = p.charCodeAt(0))] = i)\n);\n\n/**\n * Encodes an array of bytes to Base64URL without padding (URL safe Base64 using `-` and `_` instead of `+` and `/`).\n *\n * (thanks to Jon Leighton at https://gist.github.com/jonleighton/958841).\n */\nexport const to64u = (bytes: Uint8Array) => {\n  let i = 0;\n  let chunk: number;\n  const n = bytes.length;\n\n  const base64: number[] = [];\n  while (i < n) {\n    chunk = (bytes[i++] << 16) | (bytes[i++] << 8) | bytes[i++];\n    base64.push(\n      chars[(chunk & 16515072) >> 18],\n      chars[(chunk & 258048) >> 12],\n      chars[(chunk & 4032) >> 6],\n      chars[chunk & 63]\n    );\n  }\n  base64.length += n - i;\n\n  return fromCharCodes(base64);\n};\n\n/**\n * Decodes a BaseURL encoded string (without padding).\n */\nexport const from64u = (encoded: string) => {\n  let i = 0;\n  let j = 0;\n  let p: number;\n  const n = encoded.length;\n  const bytes = new Uint8Array(3 * ((n / 4) | 0) + (((n + 3) & 3) % 3));\n  while (i < n) {\n    bytes[j++] =\n      (codes[charCode(encoded, i++)] << 2) |\n      ((p = codes[charCode(encoded, i++)]) >> 4);\n    if (i < n) {\n      bytes[j++] = ((p & 15) << 4) | ((p = codes[charCode(encoded, i++)]) >> 2);\n      if (i < n) {\n        bytes[j++] = ((p & 3) << 6) | codes[charCode(encoded, i++)];\n      }\n    }\n  }\n  return bytes;\n};\n","import { hasValue, isBoolean } from \"..\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  (value: T, bits?: 32 | 64 | 128): string;\n  <B extends boolean>(value: T, numeric: B): B extends true ? number : string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key = \"\"): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (iw = 0; iw < key.length; mixer0 += window0[iw] = key.charCodeAt(iw++));\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero it all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: Uint8Array, numericOrBits: any = 64) => {\n      if (!hasValue(source)) return null;\n      bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n","import msgpack from \"@ygoe/msgpack\";\nconst { deserialize, serialize } = msgpack;\n\nimport { HashFunction, from64u, lfsr, to64u } from \".\";\nimport {\n  IsNever,\n  Nullish,\n  hasValue,\n  isArray,\n  isDefined,\n  isFunction,\n  isIterable,\n  isNumber,\n  isObject,\n  isString,\n  isSymbol,\n  isUndefined,\n  map,\n  tryCatch,\n} from \"..\";\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\nexport type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the constract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properies that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param validate This property has no effect other than letting TypeScript validate whether the value can be deserialized back to its original form without losing properties.\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  (value: any, validate?: false): string;\n  <T = Encodable>(value: T & EncodableContract<T>, validate: true): string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(encoded: string | Nullish) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\nconst floatBuffer = new ArrayBuffer(8);\nconst floatView = new DataView(floatBuffer);\n\n/**\n * Misc. fixes to the msgpack library. For example, it does not handle exponential numbers well.\n */\nconst patchSerialize = (value: any) => {\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number;\n  const patchProperty = (\n    value: any,\n    key: any,\n    val = value[key],\n    patched = inner(val)\n  ) => (\n    (val !== patched || isSymbol(key)) &&\n      ((value[key] = patched), addCleaner(() => (value[key] = val))),\n    val\n  );\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (value == null || isFunction(value) || isSymbol(value)) {\n      return null;\n    }\n\n    if (Number.isFinite(value) && !Number.isSafeInteger(value)) {\n      // A bug in @ygoe/msgpack means floats do not get encoded. We need to encode them in a different way.\n      // This is how it landed, since data structure is highly unlikely to be encountered,\n      // yet it is probably not the best way to do this (apart from fixing the bug ofc.)\n      floatView.setFloat64(0, value, true);\n      return { \"\": [...new Uint32Array(floatBuffer)] };\n    }\n\n    if (!isObject(value, true)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if (isDefined((refIndex = (refs ??= new Map()).get(value)))) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isObject(value)) {\n      refs.set(value, refs.size + 1);\n\n      Object.keys(value).forEach(\n        (k) =>\n          (isUndefined(patchProperty(value, k)) || isSymbol(k)) &&\n          delete value[k]\n      );\n    } else if (isIterable(value)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  const serialized = serialize(inner(value));\n  cleaners?.forEach((cleaner) => cleaner());\n  return serialized;\n};\n\nconst patchDeserialize = (value: Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value, true)) return value;\n\n    if (isArray(value[\"\"]) && (value = value[\"\"]).length === 2) {\n      return new DataView(new Uint32Array(value).buffer).getFloat64(0, true);\n    }\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return hasValue(value)\n    ? tryCatch(\n        () => inner(deserialize(value)),\n        () => undefined\n      )\n    : undefined;\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<any>\n];\n\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lsfr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (\n  key?: null | string,\n  json = false\n): Transport => {\n  const [encrypt, decrypt, hash] = lfsr(key ?? \"\");\n  const fastStringHash = (value: any, bitsOrNumeric: any) => {\n    if (isNumber(value) && bitsOrNumeric === true) return value;\n\n    value = isString(value)\n      ? new Uint8Array(map(value.length, (i) => value.charCodeAt(i) & 255))\n      : json\n      ? JSON.stringify(value)\n      : patchSerialize(value);\n    return hash(value, bitsOrNumeric);\n  };\n  return json\n    ? [\n        (data: any) => JSON.stringify(data),\n        (encoded) =>\n          encoded == null\n            ? undefined\n            : tryCatch(() => JSON.parse(encoded, undefined)),\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ]\n    : [\n        (data: any) => to64u(encrypt(patchSerialize(data))),\n        (encoded: any) =>\n          hasValue(encoded)\n            ? patchDeserialize(decrypt(from64u(encoded)))\n            : null,\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ];\n};\n\nexport const defaultTransport = createTransport();\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\n","(function () {\r\n\t\"use strict\";\r\n\r\n\t// Serializes a value to a MessagePack byte array.\r\n\t//\r\n\t// data: The value to serialize. This can be a scalar, array or object.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple values in data are concatenated to multiple MessagePack arrays.\r\n\t// - invalidTypeReplacement: The value that is used to replace values of unsupported types, or a function that returns such a value, given the original value as parameter.\r\n\tfunction serialize(data, options) {\r\n\t\tif (options && options.multiple && !Array.isArray(data)) {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\r\n\t\t}\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet floatBuffer, floatView;\r\n\t\tlet array = new Uint8Array(128);\r\n\t\tlet length = 0;\r\n\t\tif (options && options.multiple) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tappend(data[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tappend(data);\r\n\t\t}\r\n\t\treturn array.subarray(0, length);\r\n\r\n\t\tfunction append(data, isReplacement) {\r\n\t\t\tswitch (typeof data) {\r\n\t\t\t\tcase \"undefined\":\r\n\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\tappendBoolean(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tappendNumber(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tappendString(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif (data === null)\r\n\t\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\telse if (data instanceof Date)\r\n\t\t\t\t\t\tappendDate(data);\r\n\t\t\t\t\telse if (Array.isArray(data))\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\r\n\t\t\t\t\t\tappendBinArray(data);\r\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\r\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\r\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tappendObject(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\r\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendNull(data) {\r\n\t\t\tappendByte(0xc0);\r\n\t\t}\r\n\r\n\t\tfunction appendBoolean(data) {\r\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\r\n\t\t}\r\n\r\n\t\tfunction appendNumber(data) {\r\n\t\t\tif (isFinite(data) && Math.floor(data) === data) {\r\n\t\t\t\t// Integer\r\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0 && data >= -0x20) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\r\n\t\t\t\t\tappendBytes([0xcc, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\r\n\t\t\t\t\tappendBytes([0xd0, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\r\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\r\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\r\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\r\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\r\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\r\n\t\t\t\t\t// 32 bits for bitwise operations.\r\n\t\t\t\t\tlet hi = data / pow32;\r\n\t\t\t\t\tlet lo = data % pow32;\r\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\r\n\t\t\t\t\tappendByte(0xd3);\r\n\t\t\t\t\tappendInt64(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0) {   // below int64\r\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t\telse {   // above uint64\r\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Float\r\n\t\t\t\tif (!floatView) {\r\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\r\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\r\n\t\t\t\t}\r\n\t\t\t\tfloatView.setFloat64(0, data);\r\n\t\t\t\tappendByte(0xcb);\r\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendString(data) {\r\n\t\t\tlet bytes = encodeUtf8(data);\r\n\t\t\tlet length = bytes.length;\r\n\r\n\t\t\tif (length <= 0x1f)\r\n\t\t\t\tappendByte(0xa0 + length);\r\n\t\t\telse if (length <= 0xff)\r\n\t\t\t\tappendBytes([0xd9, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(bytes);\r\n\t\t}\r\n\r\n\t\tfunction appendArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x90 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let index = 0; index < length; index++) {\r\n\t\t\t\tappend(data[index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendBinArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendBytes([0xc4, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(data);\r\n\t\t}\r\n\r\n\t\tfunction appendObject(data) {\r\n\t\t\tlet length = 0;\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tif (data[key] !== undefined) {\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x80 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tlet value = data[key];\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tappend(key);\r\n\t\t\t\t\tappend(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendDate(data) {\r\n\t\t\tlet sec = data.getTime() / 1000;\r\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\r\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\r\n\t\t\t\tappendInt64(sec);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendByte(byte) {\r\n\t\t\tif (array.length < length + 1) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + 1)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray[length] = byte;\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\tfunction appendBytes(bytes) {\r\n\t\t\tif (array.length < length + bytes.length) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + bytes.length)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray.set(bytes, length);\r\n\t\t\tlength += bytes.length;\r\n\t\t}\r\n\r\n\t\tfunction appendInt64(value) {\r\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\r\n\t\t\t// bitwise operations.\r\n\t\t\tlet hi, lo;\r\n\t\t\tif (value >= 0) {\r\n\t\t\t\t// Same as uint64\r\n\t\t\t\thi = value / pow32;\r\n\t\t\t\tlo = value % pow32;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\r\n\t\t\t\tvalue++;\r\n\t\t\t\thi = Math.abs(value) / pow32;\r\n\t\t\t\tlo = Math.abs(value) % pow32;\r\n\t\t\t\thi = ~hi;\r\n\t\t\t\tlo = ~lo;\r\n\t\t\t}\r\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deserializes a MessagePack byte array to a value.\r\n\t//\r\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple concatenated MessagePack arrays are returned as an array.\r\n\tfunction deserialize(array, options) {\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet pos = 0;\r\n\t\tif (array instanceof ArrayBuffer) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\r\n\t\t}\r\n\t\tif (!array.length) {\r\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\r\n\t\t}\r\n\t\tif (!(array instanceof Uint8Array)) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tlet data;\r\n\t\tif (options && options.multiple) {\r\n\t\t\t// Read as many messages as are available\r\n\t\t\tdata = [];\r\n\t\t\twhile (pos < array.length) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Read only one message and ignore additional data\r\n\t\t\tdata = read();\r\n\t\t}\r\n\t\treturn data;\r\n\r\n\t\tfunction read() {\r\n\t\t\tconst byte = array[pos++];\r\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\r\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\r\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\r\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\r\n\t\t\tif (byte === 0xc0) return null;   // nil\r\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\r\n\t\t\tif (byte === 0xc2) return false;   // false\r\n\t\t\tif (byte === 0xc3) return true;   // true\r\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\r\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\r\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\r\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\r\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\r\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\r\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\r\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\r\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\r\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\r\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\r\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\r\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\r\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\r\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\r\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\r\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\r\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\r\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\r\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\r\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\r\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\r\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\r\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\r\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\r\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\r\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\r\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\r\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\r\n\t\t\tconsole.debug(\"msgpack array:\", array);\r\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\r\n\t\t}\r\n\r\n\t\tfunction readInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\tlet first = true;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tlet byte = array[pos++];\r\n\t\t\t\t\tvalue += byte & 0x7f;\r\n\t\t\t\t\tif (byte & 0x80) {\r\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvalue *= 256;\r\n\t\t\t\t\tvalue += array[pos++];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readUInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tvalue *= 256;\r\n\t\t\t\tvalue += array[pos++];\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readFloat(size) {\r\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\r\n\t\t\tpos += size;\r\n\t\t\tif (size === 4)\r\n\t\t\t\treturn view.getFloat32(0, false);\r\n\t\t\tif (size === 8)\r\n\t\t\t\treturn view.getFloat64(0, false);\r\n\t\t}\r\n\r\n\t\tfunction readBin(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = array.subarray(pos, pos + size);\r\n\t\t\tpos += size;\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readMap(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = {};\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tlet key = read();\r\n\t\t\t\tdata[key] = read();\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readArray(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = [];\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readStr(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet start = pos;\r\n\t\t\tpos += size;\r\n\t\t\treturn decodeUtf8(array, start, size);\r\n\t\t}\r\n\r\n\t\tfunction readExt(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet type = readUInt(1);\r\n\t\t\tlet data = readBin(size);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 255:\r\n\t\t\t\t\treturn readExtDate(data);\r\n\t\t\t}\r\n\t\t\treturn { type: type, data: data };\r\n\t\t}\r\n\r\n\t\tfunction readExtDate(data) {\r\n\t\t\tif (data.length === 4) {\r\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\treturn new Date(sec * 1000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 8) {\r\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\r\n\t\t\t\t\t((data[1] << 14) >>> 0) +\r\n\t\t\t\t\t((data[2] << 6) >>> 0) +\r\n\t\t\t\t\t(data[3] >>> 2);\r\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\r\n\t\t\t\t\t((data[4] << 24) >>> 0) +\r\n\t\t\t\t\t((data[5] << 16) >>> 0) +\r\n\t\t\t\t\t((data[6] << 8) >>> 0) +\r\n\t\t\t\t\tdata[7];\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 12) {\r\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\tpos -= 8;\r\n\t\t\t\tlet sec = readInt(8);\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Encodes a string to UTF-8 bytes.\r\n\tfunction encodeUtf8(str) {\r\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\r\n\t\tlet ascii = true, length = str.length;\r\n\t\tfor (let x = 0; x < length; x++) {\r\n\t\t\tif (str.charCodeAt(x) > 127) {\r\n\t\t\t\tascii = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\r\n\t\tfor (let ci = 0; ci !== length; ci++) {\r\n\t\t\tlet c = str.charCodeAt(ci);\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tbytes[i++] = c;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c < 2048) {\r\n\t\t\t\tbytes[i++] = c >> 6 | 192;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\r\n\t\t\t\t\tif (++ci >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\r\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\r\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\r\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\r\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\r\n\t\t\t\t}\r\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\r\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\r\n\t\t\t}\r\n\t\t\tbytes[i++] = c & 63 | 128;\r\n\t\t}\r\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\r\n\t}\r\n\r\n\t// Decodes a string from UTF-8 bytes.\r\n\tfunction decodeUtf8(bytes, start, length) {\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = start, str = \"\";\r\n\t\tlength += start;\r\n\t\twhile (i < length) {\r\n\t\t\tlet c = bytes[i++];\r\n\t\t\tif (c > 127) {\r\n\t\t\t\tif (c > 191 && c < 224) {\r\n\t\t\t\t\tif (i >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\r\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 223 && c < 240) {\r\n\t\t\t\t\tif (i + 1 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\r\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 239 && c < 248) {\r\n\t\t\t\t\tif (i + 2 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\r\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\r\n\t\t\t}\r\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\r\n\t\t\telse if (c <= 0x10ffff) {\r\n\t\t\t\tc -= 0x10000;\r\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\r\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\r\n\t\t\t}\r\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\r\n\t// The exported functions\r\n\tlet msgpack = {\r\n\t\tserialize: serialize,\r\n\t\tdeserialize: deserialize,\r\n\r\n\t\t// Compatibility with other libraries\r\n\t\tencode: serialize,\r\n\t\tdecode: deserialize\r\n\t};\r\n\r\n\t// Environment detection\r\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\r\n\t\t// Node.js\r\n\t\tmodule.exports = msgpack;\r\n\t}\r\n\telse {\r\n\t\t// Global object\r\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\r\n\t}\r\n\r\n})();\r\n","import {\n  Binders,\n  Listener,\n  clear,\n  clock,\n  createEvent,\n  forEach,\n  isDefined,\n  isString,\n  isUndefined,\n  joinEventBinders,\n  now,\n} from \"@tailjs/util\";\nimport { createTransport } from \"@tailjs/util/transport\";\nimport { DEBUG, TAB_ID, addPageLoadedListener, error, listen, log } from \".\";\n\nexport type Metadata<T = any> = [value: T, source?: string, expires?: number];\n\nexport type StorageProviderObserver<T = any> = (\n  newValue: T | undefined,\n  oldValue: T | undefined,\n  key: string | null\n) => void;\n\nexport interface StorageProvider {\n  getItem<T = any>(key: string): [value: T, source?: string] | undefined;\n  setItem<T = any>(\n    key: string,\n    value: T,\n    source?: string,\n    timeout?: number\n  ): void;\n  removeItem(key: string): void;\n  observe?<T = any>(key: string, observer: StorageProviderObserver<T>): Binders;\n}\n\ntype TypedStorageObserverArgs<T = any> = [\n  newValue: T | undefined,\n  context: {\n    key: string | null;\n    oldValue: string | undefined;\n    source?: string | undefined;\n    self?: boolean;\n  }\n];\nexport type TypedStorageObserver<T = any> = Listener<\n  TypedStorageObserverArgs<T>\n>;\n\nexport interface TypedStorage {\n  get<T = any>(key: string): T | undefined;\n  set<T>(key: string, value: T, timeout?: number): T;\n  delete(key: string): void;\n  update<T = any>(\n    key: string,\n    newValue: (current: T | undefined) => T,\n    timeout?: number\n  ): T;\n  observe?<T = any>(\n    key: string,\n    observer: TypedStorageObserver<T>,\n    includeSelf?: boolean\n  ): Binders;\n}\n\nexport interface BoundStorage<T = any> {\n  get(): T | undefined;\n  set<Undefined extends undefined | never = never>(\n    value: T | undefined,\n    timeout?: number\n  ): T | Undefined;\n  delete(): void;\n  update<Undefined extends undefined | T = T>(\n    newValue: (current: T | undefined) => T | Undefined,\n    timeout?: number\n  ): T | Undefined;\n  observe?(observer: TypedStorageObserver<T>, observeSelf?: boolean): Binders;\n}\n\n// TODO: Initialize from tailjs.init.\nexport const [serialize, deserialize] = createTransport(\"foo\", DEBUG);\n\nexport const mapStorage = <P extends StorageProvider>(\n  provider: P\n): P[\"observe\"] extends undefined ? TypedStorage : Required<TypedStorage> => {\n  const [addOwnListener, dispatchOwn] = createEvent<TypedStorageObserverArgs>();\n\n  const get = (key: string) => provider.getItem(key)?.[0];\n\n  const set = <T>(key: string, value: T | undefined, timeout?: number) => {\n    const oldValue = get(key);\n    if (isUndefined(value)) {\n      provider.removeItem(key);\n      dispatchOwn(undefined, { key, oldValue, source: TAB_ID, self: true });\n    } else {\n      provider.setItem(key, value, TAB_ID, timeout);\n      dispatchOwn(value, { key, oldValue, source: TAB_ID, self: true });\n    }\n    if (timeout! <= 0) {\n      provider.removeItem(key);\n    }\n    return value as any;\n  };\n\n  let retries = 0;\n  const update = <T>(\n    key: string,\n    newValue: (current: T | undefined) => T | undefined,\n    timeout: number\n  ) => {\n    if (retries++ > 3) {\n      error(`Race condition ('${key}').`, true);\n    }\n    const value = set(key, newValue(provider.getItem<T>(key)?.[0]), timeout);\n    const writtenValue = provider.getItem(key);\n    if (writtenValue?.[1] && writtenValue?.[1] !== TAB_ID) {\n      return update(key, newValue, timeout);\n    }\n    retries = 0;\n    return value;\n  };\n\n  return {\n    get,\n    set,\n    delete: (key) => set(key, undefined),\n    update,\n    observe: provider.observe\n      ? (key, listener, observeSelf) => {\n          const [unbind, bind] = joinEventBinders(\n            provider.observe!(key, (newValue, oldValue, key) =>\n              listener(\n                newValue?.[0],\n                { key, oldValue: oldValue?.[0], source: newValue?.[1] },\n                unbind\n              )\n            ),\n            observeSelf\n              ? addOwnListener(\n                  (value, context, unbind) =>\n                    context.key === key && listener(value, context, unbind)\n                )\n              : undefined\n          );\n          return [unbind, bind];\n        }\n      : undefined,\n  } as TypedStorage as any;\n};\n\nconst parsePayload = (value: any): [value: string, timeout?: number] => {\n  if (!isString(value)) return [value];\n\n  const [, payload, parsedTimeout] = value.match(/(.*?)(?:@:([0-9a-z]+))?$/)!;\n  return [\n    payload,\n    isDefined(parsedTimeout) ? parseInt(parsedTimeout, 36) : undefined,\n  ];\n};\nconst purgeIfExpired = (key: string, value: any) => {\n  const [payload, timeout] = parsePayload(value);\n  if (timeout && timeout - now() < 0) {\n    clear(localStorage, key);\n    return undefined;\n  }\n  return payload;\n};\n\nexport const sharedStorage = mapStorage({\n  getItem: (key) => deserialize(purgeIfExpired(key, localStorage.getItem(key))),\n  setItem: (key, value, source, timeout) =>\n    localStorage.setItem(\n      key,\n      serialize([value, source]) +\n        (timeout! > 0 ? `@:${(now() + timeout!).toString(36)}` : \"\")\n    ),\n  removeItem: (key) => localStorage.removeItem(key),\n  observe: (key, observer) => {\n    const [unbind, bind] = listen(\n      window,\n      \"storage\",\n      ({ key: changedKey, newValue, oldValue }) =>\n        key == changedKey &&\n        observer(\n          deserialize(parsePayload(newValue)[0]),\n          deserialize(parsePayload(oldValue)[0]),\n          key\n        )\n    );\n\n    return joinEventBinders(\n      [unbind, bind],\n      addPageLoadedListener((loaded) => (loaded ? bind() : unbind()))\n    );\n  },\n});\n\nconst purgeTask = clock({\n  frequency: 2000,\n  callback: () =>\n    forEach(localStorage, ([key, value]) => !purgeIfExpired(key as any, value)),\n  trigger: true,\n});\naddPageLoadedListener((loaded) => purgeTask.toggle(loaded));\n\nexport const bindStorage: {\n  <T>(\n    key: string,\n    defaultTimeout?: number,\n    storage?: Required<TypedStorage>\n  ): Required<BoundStorage<T>>;\n  <T>(\n    key: string,\n    defaultTimeout?: number,\n    storage?: TypedStorage\n  ): BoundStorage<T>;\n} = <T>(\n  key: string,\n  defaultTimeout?: number,\n  storage: TypedStorage = sharedStorage\n): Required<BoundStorage<T>> => ({\n  get: () => storage.get<T>(key),\n  set: (value, timeout) =>\n    storage.set(key, value as any, timeout ?? defaultTimeout),\n  delete: () => storage.delete(key),\n  update: (updater, timeout) =>\n    storage.update(key, updater as any, timeout ?? defaultTimeout),\n  observe: storage.observe\n    ? (observer, includeSelf) => storage.observe!(key, observer, includeSelf)\n    : undefined!,\n});\n","import {\n  filter,\n  isDefined,\n  isObject,\n  joinEventBinders,\n  map,\n} from \"@tailjs/util\";\nimport { TAB_ID, bindStorage, sharedStorage } from \".\";\n\n/**\n * A channel is used by tabs to communicate with each other.\n */\nexport type Channel<T> = {\n  /**\n   * Posts a message in the channel.\n   *\n   * @param payload The payload of the message.\n   * @param target If specified, on the tab with this ID will get the message.\n   */\n  post(payload: T, target?: string): void;\n\n  /**\n   * Stop receiving messages from the channel.\n   * A tab automatically subscribes/unsubscribes when it enters and leaves bfcache.\n   */\n  unsubscribe: () => void;\n};\n\ntype ChannelPayload<T> = [sender: string, payload: T, target?: string];\n\n/**\n * Subscribes to the channel with the specified id.\n */\nexport const subscribeChannel = <T>(\n  id: string,\n  handler: (sender: string, payload: T, direct: boolean) => void,\n  listenSelf = false,\n  storage = sharedStorage\n): Channel<T> => {\n  const channel = bindStorage<ChannelPayload<T>>(id, 0, storage);\n  return {\n    post: (payload, target) => channel.set([TAB_ID, payload, target]),\n    unsubscribe: channel.observe(\n      (value) =>\n        isDefined(value) &&\n        (!value[2] || value[2] === TAB_ID) &&\n        handler(value[0], value[1], isDefined(value[2])),\n      listenSelf\n    )[0],\n  };\n};\n\nlet chatChannel: Channel<[message: string, error?: string]> | undefined;\nexport const error: {\n  (message: string, fatal: boolean): void;\n  (message: string, cause?: any, fatal?: boolean);\n} = (message: string, error?: any, throwError = false) => {\n  if (typeof error === \"boolean\") {\n    throwError = error;\n    error = null;\n  }\n  log(error ? message : null, error ?? message);\n  if (throwError) {\n    throw new Error(message);\n  }\n};\n\nexport const log = (message: any, error?: any) => {\n  const source = message;\n  if (error) {\n    error = JSON.stringify(\n      (error = isObject(error)\n        ? {\n            message: error.message ?? error,\n            stack: error.stack,\n          }\n        : error)\n    );\n  }\n\n  message = JSON.stringify(message);\n  (chatChannel ??= subscribeChannel<[string, string]>(\n    \"chat\",\n    (sender, parts) =>\n      console[parts[1] ? \"error\" : \"log\"](\n        sender === TAB_ID ? \"This tab\" : `Other tab (${sender})`,\n        ...map(filter(parts), (value) => JSON.parse(value))\n      ),\n    true\n  )).post([message, error]);\n  return source;\n};\n","import { clear, clock, createEvent, forEach, now, assign } from \"@tailjs/util\";\nimport {\n  TAB_HEARTBEAT,\n  TAB_ID,\n  addPageLoadedListener,\n  subscribeChannel,\n} from \".\";\n\nexport type TabState = {\n  id: string;\n  hearbeat: number;\n  viewId?: string;\n  navigated?: number;\n};\n\nexport type State = {\n  knownTabs: Record<string, TabState>;\n  variables: Record<string, any>;\n};\n\nconst tabState: TabState = {\n  id: TAB_ID,\n  hearbeat: now(),\n};\n\nconst state: State = {\n  knownTabs: {\n    [TAB_ID]: tabState,\n  },\n  variables: {},\n};\n\ntype StateMessage =\n  | { type: \"query\"; data?: undefined }\n  | {\n      type: \"set\";\n      data: State;\n    }\n  | {\n      type: \"patch\";\n      data: State[\"variables\"];\n    }\n  | {\n      type: \"tab\";\n      data?: TabState;\n    };\n\nconst initTimeout = clock(() => dispatchState(\"ready\", { state }), -25);\nconst stateChannel = subscribeChannel<StateMessage>(\n  \"state\",\n  (sender, { type, data }) => {\n    if (type === \"query\") {\n      !initTimeout.active &&\n        stateChannel.post({ type: \"set\", data: state }, sender);\n    } else if (type === \"set\" && initTimeout.active) {\n      assign(state, data);\n      initTimeout.trigger();\n    } else if (type === \"patch\") {\n      assign(state, data);\n      dispatchState(\"update\", { state, variables: data });\n    } else if (type === \"tab\") {\n      assign(state.knownTabs, sender, data);\n      dispatchState(\"update\", { state, tab: data });\n    }\n  }\n);\n\nconst [addStateListener, dispatchState] = createEvent<\n  [\n    event: \"ready\" | \"update\",\n    state: {\n      state: State;\n      variables?: State[\"variables\"];\n      tab?: TabState;\n    }\n  ]\n>();\n\nconst heartbeat = clock(() => {\n  const timeout = now() - TAB_HEARTBEAT * 2;\n  forEach(\n    state?.knownTabs,\n    // Remove interval tabs.\n    ([tabId, tabState]) =>\n      tabState[0] < timeout && clear(state!.knownTabs, tabId)\n  );\n  tabState.hearbeat = now();\n  stateChannel.post({ type: \"tab\", data: tabState });\n}, TAB_HEARTBEAT);\n\nconst toggleTab = (loading: boolean) => {\n  stateChannel.post({ type: \"tab\", data: loading ? tabState : undefined });\n  if (loading) {\n    initTimeout.restart();\n    stateChannel.post({ type: \"query\" });\n  } else {\n    initTimeout.toggle(false);\n  }\n  heartbeat.toggle(loading);\n};\n\naddPageLoadedListener((loaded) => toggleTab(loaded), true);\n\nexport { addStateListener };\n","export const DEBUG = true;\nexport const TAB_HEARTBEAT = 5_000;\nexport const STATE_KEY = \"_t.sr\";\n","import { clock } from \"@tailjs/util\";\nimport { listen, log } from \".\";\n\nconst eventQueue: string[] = [];\n\nconst poster = clock(() => {\n  if (eventQueue.length) {\n    //log([\"Posting\", eventQueue.splice(0)]);\n  }\n}, 5000);\n\nexport const enqueueEvent = (event: string) => {\n  eventQueue.push(event);\n};\n\nlisten(\n  document,\n  \"visibilitychange\",\n  () => document.visibilityState === \"hidden\" && poster.trigger()\n);\n\n// const postLock = createLock<string[]>(\"test_queue_lck\", 2000);\n// export const post = async (data: string[]) => {\n//   if (\n//     !(\n//       await postLock(async () => {\n//         let pending: string[] | undefined;\n//         await tryCatchAsync(\n//           async () => {\n//             for (;;) {\n//               postLock.data.update(\n//                 (current) => ((pending = current!), undefined)\n//               );\n//               if (data) {\n//                 pending = [...(pending ?? []), ...data];\n//                 data = undefined as any;\n//               }\n//               if (!pending) {\n//                 break;\n//               }\n\n//               log([\"Posting\", pending]);\n//               await delay(2000);\n//               if (Math.random() < 0.5) {\n//                 throw new Error(\"Eeek!\");\n//               }\n//               log(`Posted ${pending.length} item(s).`);\n//             }\n//           },\n//           async (e, last) => {\n//             if (last) {\n//               error(\n//                 `Post failed 3 times in a row, events will not be sent.`,\n//                 e\n//               );\n//               throw e;\n//             } else {\n//               pending &&\n//                 postLock.data.update(\n//                   (current) => ((current ??= []).unshift(...pending!), current)\n//                 );\n//               error(`Post failed, retrying...`, e);\n//               await delay(250);\n//             }\n//           },\n//           undefined,\n//           3\n//         );\n//       }, 0)\n//     )[1]\n//   ) {\n//     postLock.data.update(\n//       (current) => ((current ??= []).push(...data), current)\n//     );\n//     log(\"Another post is active. Queued data.\");\n//   }\n// };\n","import {\n  addPageActivatedListener,\n  addStateListener,\n  getActiveTime,\n  listen,\n  log,\n  enqueueEvent,\n} from \"./lib2\";\n\n//const lck = createLock(\"test\");\nexport const attach = async () => {\n  addPageActivatedListener((activated) => {\n    // console.log(\n    //   `Activated: ${activated}. Total active time: ${getActiveTime()}.`\n    // );\n  }, true);\n\n  addStateListener((event, state) => {\n    log(state.tab);\n  });\n\n  listen(document.body, \"click\", () => {\n    enqueueEvent(\"Click!\");\n  });\n\n  // let invocations = 0;\n  // let clicked = false;\n  // const pump = clock(\n  //   async () => {\n  //     const capturedClick = clicked;\n  //     if (!clicked && invocations % 2 === 1) {\n  //       await wait(1500);\n  //     }\n  //     console.log(`${++invocations}, clicked: ${capturedClick}.`);\n  //   },\n  //   { frequency: 1000, queue: false }\n  // );\n\n  // let testId = 1;\n  // listen(document.body, \"click\", async (e) => {\n  //   // clicked = true;\n  //   // console.log(pump.active, pump.busy);\n  //   // e.shiftKey && pump.toggle(!pump.active);\n  //   // console.log(await pump.trigger(true));\n  //   // (async () => {\n  //   //   clicked = false;\n  //   // })();\n  //   post([`Test ${testId++}`]);\n  // });\n  // listen(document.body, \"click\", () => {\n  //   updateTabState((tab) => (tab.navigated = now()));\n\n  //   lck(async () => {\n  //     console.log(\"Lock acquired.\");\n  //     await wait(5000);\n  //   });\n  // });\n  // listen(\n  //   window,\n  //   \"pageshow\",\n  //   () =>\n  //     activeTabs.update(\n  //       (current) => (\n  //         ((current = cast(current, isObject) ?? {})[TAB_ID] = now()), current\n  //       )\n  //     )\n  //   //activeStorage.update((current) => (current ?? 0) + 1)\n  // );\n  // listen(\n  //   window,\n  //   \"pagehide\",\n  //   () =>\n  //     activeTabs.update(\n  //       (current) => (isObject(current) && delete current[TAB_ID], current)\n  //     )\n  //   // activeStorage.update((current: any) =>\n  //   //   current > 0 ? current - 1 : current\n  //   // )\n  // );\n};\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\n//import { initializeTracker } from \"./initializeTracker\";\n//import { F, T, define, window } from \"./lib\";\nimport { attach } from \"./pusher\";\n\n// This assumes the script is loaded from the RequestHandler's ?cfg route.\n\n// To prevent external scripts from eaves-dropping and get a hold of the storage key, this is how initialization works:\n// 1: The configuration scripts appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overriden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nwindow[INITIALIZE_TRACKER_FUNCTION] = (callback: any) => {\n  callback(attach);\n};\n\n// let loaded = F;\n// define(window, {\n//   [INITIALIZE_TRACKER_FUNCTION]: [\n//     (callback: (init: typeof initializeTracker) => void) => {\n//       if (loaded === (loaded = T)) return;\n//       callback(initializeTracker);\n//     },\n//   ],\n// });\n"],"names":["setter","undefined","MAX_SAFE_INTEGER","Number","symbolIterator","Symbol","iterator","NO_ARG","isUndefined","value","isDefined","hasValue","isBoolean","isString","isArray","Array","isObject","acceptIterables","isSymbol","isFunction","isIterable","acceptStrings","tryCatch","expression","errorHandler","clean","e","error","Error","console","stopInvoked","sliceAction","action","start","end","index","createIterator","source","item","i","key","step","maxIterations","length","offset","map","projection","mapped","j","n","push","forEachInternal","returnValue","forEach","reduce","reducer","seed","seedFactory","filter","predicate","projected","setSingle","target","delete","set","add","get","initializer","has","assign","clearSingle","current","clear","keys","removed","array","clearStep","parent","parentKey","targetKeys","size","Object","remove","sort","x","y","splice","now","performance","Math","trunc","timeOrigin","Date","clock","callbackOrSettings","frequency","settings","callback","queue","paused","trigger","once","timeoutId","mutex","ResetablePromise","resolve","outerCallback","skipQueue","pending","instance","busy","reset","cancelled","async","retries","await","clearInterval","active","setInterval","restart","newFrequency","newCallback","toggle","_promise","constructor","this","ifPending","reject","OpenPromise","signal","then","onfulfilled","onrejected","captured","Promise","args","inner","TypeError","createEventBinders","listener","attach","detach","bound","outerListener","unbind","rebind","joinEventBinders","binders","changed","binder","createEvent","dispatchedArgs","listeners","Set","handler","payload","TAB_ID","toString","random","padStart","listen","name","options","capture","passive","addEventListener","addPageLoadedListener","dispatchPageLoaded","loaded","activated","window","document","visibilityState","activeTime","t0","createTimer","elapsed","addPageActivatedListener","dispatchPageActivated","activationTimeout","setActivated","codes","body","chars","charCode","s","charCodeAt","FNVs","p","32","64","128","entropy","max","deserialize","serialize","msgpack","data","multiple","floatBuffer","floatView","pow32","Uint8Array","append","subarray","isReplacement","appendNull","appendByte","appendBoolean","lo","isFinite","floor","appendBytes","hi","appendInt64","ArrayBuffer","DataView","setFloat64","bytes","str","ascii","ci","c","c2","encodeUtf8","appendString","ns","sec","getTime","getMilliseconds","appendDate","appendArray","Uint8ClampedArray","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","invalidTypeReplacement","byte","newLength","newArray","abs","pos","read","readMap","readArray","readStr","readBin","readExt","readFloat","readUInt","readInt","debug","first","view","buffer","byteOffset","getFloat32","getFloat64","lengthSize","String","fromCharCode","type","encode","decode","module","exports","msgpackJsName","REF_PROP","patchSerialize","cleaners","refs","refIndex","patchProperty","val","patched","addCleaner","cleaner","isSafeInteger","toJSON","Map","k","_","serialized","createTransport","json","encrypt","decrypt","hash","pad","bits","prime","mixer","mixer255","iw","mixer0","window0","resetMixer","updateMixer","ENTROPY","cipher","numericOrBits","BigInt","asUintN","MIN_SAFE_INTEGER","lfsr","fastStringHash","bitsOrNumeric","JSON","stringify","encoded","parse","chunk","base64","fromCharCodes","to64u","from64u","matchedRef","entries","v","parsePayload","parsedTimeout","match","parseInt","purgeIfExpired","timeout","localStorage","sharedStorage","provider","addOwnListener","dispatchOwn","getItem","oldValue","removeItem","self","setItem","update","newValue","writtenValue","observe","observeSelf","bind","context","observer","changedKey","purgeTask","chatChannel","subscribeChannel","id","listenSelf","storage","channel","defaultTimeout","updater","includeSelf","post","unsubscribe","message","throwError","log","stack","sender","parts","tabState","hearbeat","state","knownTabs","variables","initTimeout","dispatchState","stateChannel","tab","addStateListener","heartbeat","TAB_HEARTBEAT","tabId","poster","loading","event"],"mappings":"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","x_google_ignoreList":[13]}