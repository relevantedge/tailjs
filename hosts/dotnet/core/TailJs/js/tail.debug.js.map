{"version":3,"file":"tail.debug.js","sources":["../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/util/src/types.ts","../../../../../npm/packages/@tailjs/util/src/iterators.ts","../../../../../npm/packages/@tailjs/client/src/lib2/dom.ts","../../../../../npm/packages/@tailjs/util/src/accessors.ts","../../../../../npm/packages/@tailjs/client/src/lib2/concurrency.ts","../../../../../npm/packages/@tailjs/client/src/lib2/time.ts","../../../../../npm/packages/@tailjs/client/src/lib2/ids.ts","../../../../../npm/packages/@tailjs/client/src/lib2/events.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/base64.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/lfsr.ts","../../../../../npm/node_modules/.pnpm/@ygoe+msgpack@1.0.3/node_modules/@ygoe/msgpack/msgpack.js","../../../../../npm/packages/@tailjs/util/src/transport.pkg/transport.ts","../../../../../npm/packages/@tailjs/client/src/lib2/storage.ts","../../../../../npm/packages/@tailjs/client/src/lib2/consts.ts","../../../../../npm/packages/@tailjs/client/src/lib2/channel.ts","../../../../../npm/packages/@tailjs/client/src/lib2/shared-state.ts","../../../../../npm/packages/@tailjs/client/src/lib2/request.ts","../../../../../npm/packages/@tailjs/client/src/pusher.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["// MUST MATCH packages\\@tailjs\\engine\\src\\RequestHandler.ts\nexport const MUTEX_REQUEST_COOKIE = \".tail.rq\";\nexport const MUTEX_RESPONSE_COOKIE = \".tail.rs\";\nexport const CONTEXT_MENU_COOKIE = \".tail.cm\";\n\nexport const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_MENU_QUERY = \"mnt\";\n","import { toObject, type reduce, forEach, update, map } from \".\";\n\nexport type IsNever<T> = [T] extends [never] ? true : false;\n\n/**\n * Shorthand for a value that is optionally awaitable.\n */\nexport type MaybePromise<T> = PromiseLike<T> | T;\n\nexport type ValueOrDefault<T, R, D = undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? D\n  : R;\n\n/** Shorter than writing all this out, and slightly easier to read. */\nexport type Nullish = null | undefined;\n\n/**\n * Removes null'ish values from a union.\n */\nexport type OmitNullish<T> = T extends Nullish ? never : T;\n\n/**\n * Common function type used for projection of [key,value] entries.\n */\nexport type KeyValueProjection<K, V, R> = (\n  entry: [key: K, value: V],\n  index: number\n) => R;\n\n/**\n * Shorthand for a type that is inferred from a parameter and can either be the item in an iterable, or just the type itself.\n */\nexport type IterableOrSelf<T> = IterableOrArrayLike<T> | T;\n\ntype FunctionComparisonEqualsWrapped<T> = T extends (\n  T extends {} ? infer R & {} : infer R\n)\n  ? { [P in keyof R]: R[P] }\n  : never;\n\ntype FunctionComparisonEquals<A, B> = (<\n  T\n>() => T extends FunctionComparisonEqualsWrapped<A> ? 1 : 2) extends <\n  T\n>() => T extends FunctionComparisonEqualsWrapped<B> ? 1 : 2\n  ? true\n  : false;\n\n/**\n * Tests if a type is `any`. The test used is technically impossable to succeed unless the type is in fact `any`.\n */\nexport type IsAny<T> = FunctionComparisonEquals<T, any>;\n\n/**\n * Utility type to allow `as const` to be used on tuples returned from functions without actually making them `readonly` (which is annoying).\n * Normally TypeScript considers the return value of a function like `x=>[10,\"four\"]` to be `(string|number)[]` (which is also annoying).\n */\nexport type ConstToTuples<T> = T extends readonly any[]\n  ? { -readonly [P in keyof T]: ConstToTuples<T[P]> }\n  : Voidefined<T>;\n\n/**\n * Goes with {@link Nulls} to simplify the expression.\n */\nexport type ArgNulls<T, Arg> = (T | Nullish) & Arg;\n\n/**\n *  TypeScript may be very literal when it infers types. The type fo a function parameter with the value `10` may be inferred as `10` and not `number`.\n *  This is an issue in e.g. {@link reduce}.\n */\nexport type GeneralizeContstants<T> = T extends number\n  ? number\n  : T extends string\n  ? string\n  : T extends boolean\n  ? boolean\n  : unknown extends T\n  ? unknown\n  : {\n      [P in keyof T]: GeneralizeContstants<T[P]>;\n    };\n\n/**\n * The eclectic type found everywhere on the Internet.\n * It convers a union like `{a:1}|{b:2}` to the intersection `{a:1, b:2}`\n */\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never;\n\n/**\n * Makes a union of objects like `{a:1}&{b:2}` appear as `{a:1,b:2}` in intellisense.\n */\nexport type PrettifyIntersection<T> = T extends { [P in infer K]: any }\n  ? { [P in K]: T[P] }\n  : never;\n\n/**\n * Makes an array of key/value pairs to an object with the corresponding properties.\n */\nexport type KeyValuePairsToObject<T> = UnionToIntersection<\n  T extends readonly [infer K & keyof any, infer V]\n    ? { [P in K & keyof any]: V }\n    : ((value: T) => never) extends (\n        value: [infer K & keyof any, infer V]\n      ) => never\n    ? { [P in K & keyof any]: ConstToTuples<V> }\n    : unknown\n>;\n\n/**\n * Anything but a function.\n */\nexport type NotFunction =\n  | bigint\n  | boolean\n  | null\n  | number\n  | string\n  | symbol\n  | undefined\n  | {\n      [key: string | number | symbol]: any;\n      [Symbol.hasInstance]?: never;\n    };\n\n/**\n * Trick for having a function that returns a non-null value, if a formal paramter always has a non-null value,\n * simliar to .NET's [NotNullIfNotNull].\n *\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\n/**\n * Typescript has the distinction between `void` and `undefined`.\n * I'm sure there is a theorically sound explanation. Both that and the distinction are annoying so this little utility type maps `void` to `undefined`.\n *\n * The ampersand union trick makes TypeScript relax instead of the \"The type T could be instantiated etc...\" error.\n */\nexport type Voidefined<T> = T extends void ? T & undefined : T;\n\n/**\n * An extension to T[] and Iterable<T> that also correctly captures weird things like NodeListOf<T>\n */\nexport type IterableOrArrayLike<T> =\n  | Iterable<T>\n  | { [item: number]: T; length: number };\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = (value: any, parse?: boolean) => T | undefined;\n\nexport const undefined = void 0;\nexport const nil = null;\n\nconst createConverter =\n  <T>(typeTester: TypeTester<T>, parser?: (value: any) => T | undefined) =>\n  (value: any, parse = true) =>\n    typeTester(value)\n      ? value\n      : parser && parse && isDefined((value = parser(value)))\n      ? value\n      : undefined;\n\nexport const tryCatch = <T, C = undefined>(\n  expression: () => T,\n  errorHandler: boolean | ((error: any) => C) = true as any,\n  clean?: () => void\n): T | C => {\n  try {\n    return expression();\n  } catch (e) {\n    if (!isBoolean(errorHandler)) {\n      return errorHandler?.(e) as any;\n    }\n    if (errorHandler) {\n      throw e;\n    }\n    console.error(e);\n    return undefined as any;\n  } finally {\n    clean?.();\n  }\n};\n\nexport const tryCatchAsync = async <T, C = void>(\n  expression: () => PromiseLike<T> | T,\n  errorHandler:\n    | boolean\n    | ((error: any, last: boolean) => Promise<C> | C) = true as any,\n  clean?: () => void,\n  retries = 1\n): Promise<T | C> => {\n  while (retries--) {\n    try {\n      return await expression();\n    } catch (e) {\n      if (!isBoolean(errorHandler)) {\n        (await errorHandler(e, !retries)) as any;\n      } else if (errorHandler && !retries) {\n        throw e;\n      } else {\n        console.error(e);\n      }\n    } finally {\n      clean?.();\n    }\n  }\n  return undefined as any;\n};\n\nexport const as = <T, D = undefined, Args extends any[] = []>(\n  value: any,\n  converter: (value: any, ...rest: Args) => T | undefined,\n  defaultValue?: D,\n  ...args: Args\n): T | D => ((value = converter(value, ...args)) ?? defaultValue) as any;\n\nexport const cast = <T, V, Args extends any[] = []>(\n  value: V,\n  typeTest: (value: any, ...args: Args) => value is T,\n  ...args: Args\n): V extends T ? V : undefined =>\n  typeTest(value, ...args) ? (value as any) : undefined;\n\nexport const isNull = (value: any): value is null => value === nil;\n\nexport const isUndefined = (value: any): value is undefined | void =>\n  value === undefined;\n\nexport const isDefined = <T>(value: T): value is Exclude<T, undefined | void> =>\n  value !== undefined;\n\nexport const isNullish = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value == nil;\n\nexport const hasValue = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value != nil;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\n\nexport const parseBoolean = createConverter(isBoolean, (value) => !!value);\nexport const isTruish = (value: any) => !!value;\nexport const isFalsish = (value: any) => !value;\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\nexport const parseNumber = createConverter(isNumber, (value) =>\n  parseFloat(value)\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\nexport const parseBigInt = createConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createConverter(isString, (value) =>\n  hasValue(value) ? \"\" + value : value\n);\n\nconst capturedIsArray = Array.isArray;\nexport const isArray = (value: any): value is any[] => capturedIsArray(value);\n\nexport const toArray = <T>(value: T | Iterable<T>, clone = false): T[] =>\n  value == null\n    ? []\n    : !clone && isArray(value)\n    ? value\n    : isIterable(value, true)\n    ? [...value]\n    : ([value] as any);\n\nexport const isObject = (\n  value: any,\n  acceptIterables = false\n): value is { [P in keyof any]: any } =>\n  value && typeof value === \"object\" && (acceptIterables || !isIterable(value));\n\nexport const hasMethod = <T, Name extends keyof any>(\n  value: T,\n  name: Name | keyof T\n): value is T &\n  Record<\n    Name,\n    T extends { [P in Name]?: (...args: infer Args) => infer R }\n      ? (...args: Args) => R\n      : (...args: any) => any\n  > => typeof (value as any)?.[name] === \"function\";\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\n\nexport const isIterable = (\n  value: any,\n  acceptStrings = false\n): value is Iterable<any> =>\n  !!value?.[Symbol.iterator] && (acceptStrings || !isString(value));\n\nexport const toIterable = <T>(value: T | Iterable<T>): Iterable<T> =>\n  isIterable(value) ? value : [value];\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == nil\n    ? value === nil\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\nexport const identity = <T = any>(value: T) => value;\n\nexport const clone = <T>(value: T, deep = true): T =>\n  isArray(value)\n    ? deep\n      ? (map as any)(value, (value: any) => clone(value, true))\n      : [...value]\n    : isObject(value)\n    ? deep\n      ? toObject(map(value as any, ([k, v]) => [k, clone(v, true)]))\n      : { ...value }\n    : isSet(value)\n    ? new Set<any>(\n        (map as any)(value, (value: any) => (deep ? clone(value, true) : value))\n      )\n    : isMap(value)\n    ? new Map<any, any>(\n        (map as any)(value, (value: any) =>\n          // Does not clone keys.\n          deep ? [value[0], clone(value[1], true)] : value\n        )\n      )\n    : (value as any);\n\ntype CaptureCallback<Args extends any[], R> = (\n  ...args: [...args: Args, self: CaptureCallback<Args, R>]\n) => R;\n\n/**\n * Evaluates a function that can be used to capture values using parameter default values.\n *\n * For example `(previous=current)=>(current+=2, previous)\n */\nexport const capture = <R>(capture: (...args: any[]) => R) => capture();\n","import {\n  ConstToTuples,\n  GeneralizeContstants,\n  IsAny,\n  KeyValuePairsToObject,\n  hasMethod,\n  hasValue,\n  isArray,\n  isDefined,\n  isFalsish,\n  isFunction,\n  isIterable,\n  isObject,\n  isTruish,\n  toArray,\n} from \".\";\n\nexport const UTF16MAX = 0xffff;\n\nexport const toCharCodes = (s: string) =>\n  [...new Array(s.length)].map((_, i) => s.charCodeAt(i));\nexport const codePoint = (string: string, index: number = 0) =>\n  string.codePointAt(index)!;\n\nexport type IteratorSource =\n  | any\n  | null\n  | undefined\n  | number\n  | Iterable<any>\n  | { [P in keyof any]: any }\n  | NavigatingIteratorStep;\n\nexport type IteratorSourceOf<T> =\n  | (T extends number ? number : never)\n  | Iterable<T>\n  | (T extends [infer K, infer V]\n      ? K extends keyof any\n        ? { [P in K]: V }\n        : never\n      : never)\n  | NavigatingIteratorStep<T>;\n\ntype IteratorItem<S extends IteratorSource> = IsAny<S> extends true\n  ? any\n  : S extends number\n  ? number\n  : S extends Record<any, any> & { [Symbol.iterator]?: never }\n  ? S extends (...args: any) => infer T | undefined\n    ? T\n    : [keyof S, S[keyof S]]\n  : S extends Iterable<infer T>\n  ? T extends string\n    ? string\n    : T\n  : never;\n\nexport interface IteratorControl<S extends IteratorSource> {\n  source: S;\n  prev: IteratorItem<S> | undefined;\n  skip(): void;\n  end(): void;\n  end<P>(value: P): P;\n}\n\nexport type IteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = IteratorItem<S>\n> = (\n  value: IteratorItem<S>,\n  index: number,\n  control: IteratorControl<S>\n) => Projection | undefined | void;\n\ntype AnyTuple = [any, ...any[]];\n\ntype IteratorProjection<\n  S extends IteratorSource,\n  Projection,\n  TupleProjection extends AnyTuple\n> = unknown extends Projection\n  ? IteratorItem<S>\n  : TupleProjection extends Projection\n  ? ConstToTuples<TupleProjection>\n  : ConstToTuples<Projection>;\n\ntype StartEndArgs<S extends IteratorSource> = S extends number\n  ? [offset?: number]\n  : S extends NavigatingIteratorStep<infer T>\n  ? [offset?: T, maxIterations?: number]\n  : [start?: number, end?: number];\n\nexport type NavigatingIteratorStep<T = any> = (\n  current: T | undefined\n) => T | undefined;\n\nfunction* createRangeIterator(length = 0, offset = 0): Iterable<number> {\n  while (length--) yield offset++;\n}\n\nexport function* createStringIterator(\n  input: string,\n  start: number,\n  end: number\n): Iterable<[char: string, codePoint: number]> {\n  while (start < end) {\n    const codePoint = input.codePointAt(start)!;\n    let p = input[start++];\n    if (codePoint > UTF16MAX) {\n      start++;\n      p = String.fromCodePoint(codePoint);\n    }\n    yield [p, codePoint];\n  }\n}\n\nexport function* createNavigatingIterator<T>(\n  step: NavigatingIteratorStep<T>,\n  start?: T | undefined,\n  maxIterations = Number.MAX_SAFE_INTEGER\n): Iterator<T> {\n  if (isDefined(start)) yield start;\n  while (maxIterations-- && isDefined((start = step(start)))) {\n    yield start;\n  }\n}\n\nconst sliceIterator = <T>(\n  source: Iterable<T>,\n  start = 0,\n  end?: number\n): Iterable<T> => {\n  if (!start && !isDefined(end)) {\n    return source;\n  }\n\n  if (source[\"slice\"]) {\n    return source[\"slice\"](start, end);\n  } else if (start < 0 || (end as any) < 0) {\n    return sliceIterator([...source], start, end);\n  }\n\n  return (function* () {\n    end ??= Number.MAX_SAFE_INTEGER;\n\n    for (const item of source) {\n      if (start--) continue;\n      if (!end--) break;\n      yield item;\n    }\n  })();\n};\n\nexport type Filter<S extends IteratorSource> = (\n  value: IteratorItem<S>,\n  index: number\n) => any;\n\nconst filterIterator = <T>(\n  source: Iterable<T>,\n  filter: (item: T, index: number) => any\n): Iterable<T> => {\n  if (isArray(source)) return source.filter(filter);\n  return (function* () {\n    let i = 0;\n    for (const item of source) {\n      if (filter(item, i++)) {\n        yield item;\n      }\n    }\n  })();\n};\n\nconst enum IterationFlag {\n  Yield = 0,\n  Skip = 1,\n  YieldThenEnd = 2,\n  End = 3,\n}\n\nfunction* createControllableIterator<\n  S extends Iterable<any>,\n  P = IteratorItem<S>\n>(\n  source: S,\n  action: IteratorAction<S, P> = (item) => item as any,\n  collect?: (result: P) => void\n) {\n  let i = 0;\n  let flag = IterationFlag.Yield;\n  let result: P | undefined;\n  const control: IteratorControl<S> = {\n    prev: undefined,\n    source,\n    skip: () => (flag = IterationFlag.Skip),\n    end: (value?: any) => (\n      (flag = isDefined(value)\n        ? IterationFlag.YieldThenEnd\n        : IterationFlag.End),\n      value\n    ),\n  };\n\n  for (const item of source) {\n    if ((result = action(item, i++, control)!) !== undefined && !(flag % 2)) {\n      if (!collect) {\n        yield result;\n      } else {\n        collect(result);\n      }\n      control.prev = item;\n    }\n    if (flag > 1) {\n      break;\n    }\n    flag = IterationFlag.Yield;\n  }\n}\n\nconst mapIterator = <S extends IteratorSource>(\n  source: S,\n  start?: any,\n  end?: any\n) => {\n  if (isIterable(source, true)) {\n    return start || end\n      ? sliceIterator(mapIterator(source), start, end)\n      : source;\n  }\n  if (!isDefined(source)) return [];\n  if (isObject(source)) return mapIterator(Object.entries(source), start, end);\n  if (isFunction(source)) return createNavigatingIterator(source, start, end);\n  return createRangeIterator(source as number, start);\n};\n\nexport const project: {\n  <S extends IteratorSource, R, RT extends AnyTuple>(\n    source: S,\n    projection?: IteratorAction<S, R | RT> | null,\n    ...rest: StartEndArgs<S>\n  ): IteratorProjection<S, R, RT>[];\n} = (source, projection, ...rest) => {\n  return createControllableIterator(\n    mapIterator(source, ...rest),\n    projection as any\n  ) as any;\n};\n\nexport function* flatProject<S extends IteratorSource, R, RT extends AnyTuple>(\n  source: S,\n  projection?: IteratorAction<S, R | RT> | null,\n  ...rest: StartEndArgs<S>\n): Iterable<FlatIteratorItem<IteratorProjection<S, R, RT>>> {\n  for (const item of project(\n    mapIterator(source, ...(rest as any)),\n    projection as any\n  )) {\n    if (isIterable(item)) {\n      yield* item;\n    } else if (isObject(item)) {\n      yield* Object.entries(item) as any;\n    } else {\n      yield item;\n    }\n  }\n}\n\nexport const map: {\n  <S extends IteratorSource, R, RT extends AnyTuple>(\n    source: S,\n    projection?: IteratorAction<S, R | RT> | null,\n    ...rest: StartEndArgs<S>\n  ): IteratorProjection<S, R, RT>[];\n  <S extends IteratorSource, R, RT extends AnyTuple>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): IteratorProjection<S, R, RT>[];\n} = ((source: any, projection: any, ...rest: any[]) => {\n  if (!isFunction(projection) && hasValue(projection)) {\n    // The \"projection\" parameter is the start index.\n    rest.unshift(projection);\n    projection = null;\n  }\n  source = mapIterator(source, ...rest);\n  return projection\n    ? projection.length < 3 && hasMethod(source, \"map\")\n      ? source[\"map\"](projection).filter(isDefined)\n      : [...createControllableIterator(source as any, projection)]\n    : (toArray(source, true) as any);\n}) as any;\n\ntype FlatIteratorItem<S extends IteratorSource> =\n  IteratorItem<S> extends Iterable<infer T>\n    ? T\n    : IteratorItem<S> extends Record<infer K, infer V>\n    ? [K, V]\n    : IteratorItem<S>;\n\nexport const flatMap = <\n  S extends IteratorSourceOf<any | Iterable<any>>,\n  R,\n  RT extends AnyTuple\n>(\n  source: S,\n  action: IteratorAction<S, R> = (item) => item as any,\n  ...rest: StartEndArgs<S>\n): FlatIteratorItem<IteratorProjection<S, R, RT>>[] =>\n  map(flatProject(source, action, ...rest)) as any;\n\nexport const forEach = <S extends IteratorSource, R>(\n  source: S,\n  action: IteratorAction<S, R>,\n  ...rest: StartEndArgs<S>\n): R | undefined => {\n  let returnValue: R | undefined = undefined;\n  let innerReturnValue: any;\n  source = mapIterator(source, ...rest);\n  if (action.length < 3 && hasMethod(source, \"forEach\")) {\n    source.forEach(\n      (item: any, index: any) =>\n        isDefined((innerReturnValue = (action as any)(item, index))) &&\n        (returnValue = innerReturnValue)\n    );\n  } else {\n    for (const _ of createControllableIterator(\n      source as any,\n      action as any,\n      (value) => (returnValue = value as any)\n    ));\n  }\n  return returnValue;\n};\n\nexport const flatForEach = <S extends IteratorSourceOf<any | Iterable<any>>, R>(\n  source: S,\n  action: IteratorAction<FlatIteratorItem<S>, R>,\n  ...rest: StartEndArgs<S>\n): R | undefined =>\n  forEach(\n    flatProject(source, undefined, ...(rest as any)),\n    action as any\n  ) as any;\n\nexport const toObject: {\n  <S extends IteratorSourceOf<[keyof any, any]>>(\n    source: S,\n    selector?: null,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<S>;\n  <S extends IteratorSource, P extends [keyof any, any]>(\n    source: S,\n    selector: IteratorAction<S, P>,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<P[]>;\n} = (source: any, selector: any, ...rest: any[]) =>\n  Object.fromEntries((map as any)(source, selector, ...rest));\n\nexport const reduce = <\n  S extends IteratorSource,\n  Reducer extends (\n    ...args: [\n      accumulator: unknown extends Accumulator\n        ? any\n        : GeneralizeContstants<Accumulator>,\n      ...rest: Parameters<IteratorAction<S, Accumulator>>\n    ]\n  ) => GeneralizeContstants<Accumulator>,\n  Accumulator\n>(\n  source: S,\n  reducer: Reducer,\n  seed?: Accumulator,\n  ...rest: StartEndArgs<S>\n): Reducer extends (...args: any) => infer R\n  ? R | (unknown extends Accumulator ? undefined : never)\n  : never =>\n  forEach(\n    source,\n    (value, index, control) =>\n      (seed =\n        (reducer(seed as any, value, index, control as any) as any) ?? seed),\n    ...rest\n  ) ?? (seed as any);\n\nexport const filter = <\n  S extends IteratorSource,\n  MapToArray extends boolean = false\n>(\n  source: S,\n  filter: Filter<S> = isTruish,\n  map?: MapToArray,\n  ...rest: StartEndArgs<S>\n): S extends any[] | null | undefined | (MapToArray extends true ? any : never)\n  ? IteratorItem<S>[]\n  : Iterable<IteratorItem<S>> =>\n  map\n    ? toArray((filter as any)(source, filter, false, ...rest))\n    : (filterIterator(mapIterator(source, ...rest) as any, filter) as any);\n\nlet filterInternal = filter;\n\nexport const count = <S extends IteratorSource>(\n  source: S,\n  filter?: Filter<S> | null,\n  ...rest: StartEndArgs<S>\n): number => {\n  if (filter) {\n    source = filterInternal(source, filter, false, ...rest) as any;\n  } else {\n    source = mapIterator(source, ...rest);\n  }\n  let n = source![\"length\"] ?? source![\"size\"];\n  return isDefined(n) ? n : reduce(source, (n) => n + 1, 0, ...rest);\n};\n\nexport const sum: {\n  <S extends IteratorSourceOf<number>>(\n    source: S,\n    selector?: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n  <S extends IteratorSource>(\n    source: S,\n    selector: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n} = (source: any, selector: any = (item: any) => item, ...rest: any) =>\n  reduce(\n    source,\n    (sum, value, index, control) =>\n      sum + (selector(value, index, control) ?? 0),\n    0,\n    ...rest\n  );\n\nexport const some = <S extends IteratorSource>(\n  source: S,\n  filter?: Filter<S> | null,\n  ...rest: StartEndArgs<S>\n) =>\n  hasMethod(source, \"some\")\n    ? source.some(\n        filter ? (item: any, index: number) => filter(item, index) : isTruish\n      )\n    : filter\n    ? some(filterInternal(source as any, filter, false, ...rest))\n    : forEach<any, boolean>(source, (item, index, { end }) => end(true)) ??\n      false;\n\nexport const every = <S extends IteratorSource>(\n  source: S,\n  filter?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) =>\n  !some(\n    source,\n    filter ? (item, index) => !filter(item, index) : isFalsish,\n    ...rest\n  );\n","import { isArray, map } from \"@tailjs/util\";\r\nimport {\r\n  Binders,\r\n  Listener,\r\n  Unbinder,\r\n  createBinders,\r\n  createEvent,\r\n  mergeBinders,\r\n} from \".\";\r\n\r\ntype PageListenerArgs = [visible: boolean, loaded: boolean];\r\nconst [addListener, dispatch] = createEvent<PageListenerArgs>();\r\n\r\ntype AllMaps = WindowEventMap &\r\n  GlobalEventHandlersEventMap &\r\n  DocumentEventMap &\r\n  HTMLElementEventMap;\r\n\r\nexport const listen = <K extends keyof AllMaps>(\r\n  target: {\r\n    addEventListener(\r\n      type: string,\r\n      listener: EventListenerOrEventListenerObject,\r\n      options?: boolean | AddEventListenerOptions\r\n    ): void;\r\n    removeEventListener(\r\n      type: string,\r\n      listener: EventListenerOrEventListenerObject,\r\n      options?: boolean | EventListenerOptions\r\n    ): void;\r\n  },\r\n  name: K | K[],\r\n  listener: (\r\n    ev: AllMaps[K extends any[] ? K[number] : K],\r\n    unbind?: Unbinder\r\n  ) => any,\r\n  options: AddEventListenerOptions = { capture: true, passive: true }\r\n): Binders => {\r\n  return isArray(name)\r\n    ? mergeBinders(\r\n        ...map(name, (name) => listen(target, name as any, listener, options))\r\n      )\r\n    : createBinders(\r\n        listener,\r\n        (listener) => target.addEventListener(name, listener, options),\r\n        (listener) => target.addEventListener(name, listener, options)\r\n      );\r\n};\r\n\r\nlet binders: ReturnType<typeof addListener>;\r\nexport const addPageListener = (\r\n  listener: Listener<PageListenerArgs>,\r\n  triggerLoaded = true\r\n) => (\r\n  (binders = addListener(listener)),\r\n  loaded && triggerLoaded && listener(visible, false, binders[0]),\r\n  binders\r\n);\r\n\r\nlet visible = true;\r\nlet loaded = false;\r\n\r\nconst dispatchVisible = () =>\r\n  (!loaded || !visible) &&\r\n  dispatch((visible = true), loaded || !(loaded = true));\r\n\r\nlisten(\r\n  window,\r\n  \"pagehide\",\r\n  () => (visible || loaded) && dispatch((visible = false), (loaded = false))\r\n);\r\nlisten(window, \"pageshow\", dispatchVisible);\r\nlisten(document, \"visibilitychange\", () =>\r\n  document.visibilityState === \"visible\"\r\n    ? dispatchVisible()\r\n    : visible && dispatch((visible = false), loaded)\r\n);\r\n","import {\r\n  GeneralizeContstants,\r\n  IsAny,\r\n  KeyValuePairsToObject,\r\n  NotFunction,\r\n  forEach,\r\n  hasMethod,\r\n  isArray,\r\n  isDefined,\r\n  isFunction,\r\n  isObject,\r\n  isUndefined,\r\n} from \".\";\r\n\r\n// #region Shared types\r\ntype MapLike<K = any, V = any> = {\r\n  has?(key: K): boolean;\r\n  get(key: K): V | undefined;\r\n  set(key: K, value: V): any;\r\n  delete(key: K): any;\r\n};\r\n\r\ntype SetLike<K = any> = {\r\n  has?(key: K): boolean;\r\n  add(key: K): any;\r\n  delete(key: K): any;\r\n};\r\n\r\ntype PropertyContainer<K extends any = any, V extends any = any> =\r\n  | {\r\n      [P in keyof K]: V;\r\n    }\r\n  | MapLike<K, V>\r\n  | SetLike<K>;\r\n\r\nexport type KeyType<T extends PropertyContainer> = T extends MapLike<\r\n  infer K,\r\n  any\r\n>\r\n  ? K\r\n  : T extends SetLike<infer K>\r\n  ? K\r\n  : T extends any[]\r\n  ? number\r\n  : keyof T;\r\n\r\nexport type ValueType<\r\n  T extends PropertyContainer,\r\n  K,\r\n  Default = never\r\n> = IsAny<T> extends true\r\n  ? any\r\n  : T extends MapLike<any, infer V>\r\n  ? V | Default\r\n  : T extends SetLike\r\n  ? boolean | Default\r\n  : T extends (infer T)[]\r\n  ? T | Default\r\n  : K extends keyof T\r\n  ? T[K] | Default\r\n  : any;\r\n\r\n// #endregion\r\n\r\n// #region get\r\n\r\nexport const get = <T extends PropertyContainer, K extends KeyType<T>>(\r\n  target: T,\r\n  key: K,\r\n  initializer?: Updater<T, K, ValueType<T, K>, false, true>\r\n): ValueType<T, K, undefined> => {\r\n  let value = hasMethod(target, \"get\")\r\n    ? target.get(key)\r\n    : hasMethod(target, \"has\")\r\n    ? target.has(key)\r\n    : (target as any)[key];\r\n  if (!isDefined(value) && isDefined(initializer)) {\r\n    isDefined(\r\n      (value = isFunction(initializer) ? (initializer as any)() : initializer)\r\n    ) && set(target, key, value);\r\n  }\r\n  return value;\r\n};\r\n\r\n// #endregion\r\n\r\n// #region set and update\r\n\r\ntype UpdateFunction<\r\n  T extends PropertyContainer,\r\n  Key,\r\n  Current,\r\n  Factory\r\n> = Factory extends false\r\n  ? (\r\n      current: Current,\r\n      key: Key,\r\n      target: T\r\n    ) => GeneralizeContstants<ValueType<T, Key>> | undefined\r\n  : (key: Key, target: T) => GeneralizeContstants<ValueType<T, Key>>;\r\n\r\ntype Updater<\r\n  T extends PropertyContainer,\r\n  Key,\r\n  Current = ValueType<T, Key>,\r\n  SettersOnly = false,\r\n  Factory = false\r\n> = SettersOnly extends true\r\n  ? ValueType<T, Key, Factory extends true ? never : undefined>\r\n  : IsAny<T> extends true\r\n  ? NotFunction | UpdateFunction<any, any, any, Factory>\r\n  :\r\n      | (ValueType<T, Key> extends Function\r\n          ? never\r\n          : ValueType<T, Key, Factory extends true ? never : undefined>)\r\n      | UpdateFunction<T, Key, Current, Factory>;\r\n\r\ntype UpdaterType<T, SettersOnly = false> = SettersOnly extends true\r\n  ? T\r\n  : T extends (...args: any) => infer T\r\n  ? T\r\n  : T;\r\n\r\ntype PropertiesToTuples<T, SettersOnly = false, K = keyof T> = K extends any\r\n  ? [K, UpdaterType<T, SettersOnly>]\r\n  : never;\r\n\r\ntype BulkUpdateObject<\r\n  T extends PropertyContainer,\r\n  SettersOnly = false,\r\n  Factory = false\r\n> = T extends MapLike | SetLike | any[]\r\n  ? {\r\n      [P in KeyType<T>]: Updater<T, P, ValueType<T, P>, SettersOnly, Factory>;\r\n    }\r\n  : { [P in keyof T & KeyType<T>]?: Updater<T, P, T[P], SettersOnly, Factory> };\r\n\r\ntype BulkUpdateKeyValue<\r\n  T extends PropertyContainer,\r\n  SettersOnly = false,\r\n  Factory = false,\r\n  K extends keyof T = keyof T\r\n> = IsAny<T> extends true\r\n  ? [any, Updater<T, any, any, SettersOnly, Factory>]\r\n  : T extends MapLike | SetLike | any[]\r\n  ? [\r\n      KeyType<T>,\r\n      Updater<T, KeyType<T>, ValueType<T, KeyType<T>>, SettersOnly, Factory>\r\n    ]\r\n  : K extends any\r\n  ? [K, Updater<T, KeyType<T>, any, SettersOnly, Factory>]\r\n  : never;\r\n\r\ntype BulkUpdates<\r\n  T extends PropertyContainer,\r\n  SettersOnly = false,\r\n  Factory = false\r\n> =\r\n  | BulkUpdateObject<T, SettersOnly, Factory>\r\n  | Iterable<\r\n      | BulkUpdateKeyValue<T, SettersOnly, Factory>\r\n      | BulkUpdateObject<T, SettersOnly, Factory>\r\n    >;\r\n\r\ntype UnwrapBulkUpdates<T, SettersOnly = false> = T extends (infer T)[]\r\n  ? T extends [infer K, infer V]\r\n    ? [K, UpdaterType<V, SettersOnly>]\r\n    : PropertiesToTuples<T, SettersOnly>\r\n  : PropertiesToTuples<T>;\r\n\r\ntype SetOrUpdateFunction<SettersOnly> = {\r\n  <\r\n    T extends PropertyContainer,\r\n    U extends Updater<T, K, ValueType<T, K>, SettersOnly>,\r\n    K extends KeyType<T>\r\n  >(\r\n    target: T,\r\n    key: K,\r\n    value: U\r\n  ): UpdaterType<U>; //  UpdaterType<U, SettersOnly>;\r\n  <T extends PropertyContainer>(\r\n    target: T,\r\n    values: BulkUpdates<T, SettersOnly>\r\n  ): T;\r\n};\r\n\r\nconst createSetOrUpdateFunction =\r\n  <B extends boolean>(settersOnly: B): SetOrUpdateFunction<B> =>\r\n  (target: PropertyContainer, ...args: any[]) => {\r\n    let bulk: boolean;\r\n    let [key, value] = args;\r\n    const setSingle = ([key, value]: [any, any]) => {\r\n      if (!settersOnly && isFunction(value)) {\r\n        value = value(get(target, key));\r\n      }\r\n\r\n      if (isUndefined(value)) {\r\n        return clear(target, key);\r\n      }\r\n\r\n      if (bulk || get(target, key) !== value) {\r\n        hasMethod(target, \"set\")\r\n          ? target.set(key, value)\r\n          : hasMethod(target, \"add\")\r\n          ? value\r\n            ? target.add(key)\r\n            : target.delete(key)\r\n          : (target[key] = value);\r\n      }\r\n\r\n      return value;\r\n    };\r\n\r\n    if ((bulk = args.length === 1)) {\r\n      // Fast path\r\n      if (settersOnly) {\r\n        if (isArray(key) && key.every((item) => isObject(item))) {\r\n          key = Object.assign({}, ...key);\r\n        }\r\n        if (isObject(key)) {\r\n          Object.assign(target, key);\r\n          Object.entries(key).forEach(\r\n            ([k, v]) => !isDefined(v) && delete target[k]\r\n          );\r\n          return target;\r\n        }\r\n      }\r\n      if (isObject(key)) {\r\n        forEach(key, setSingle);\r\n      } else {\r\n        forEach(key, (item) =>\r\n          isObject(item) ? forEach(item, setSingle) : setSingle(item)\r\n        );\r\n      }\r\n      return target;\r\n    }\r\n    return setSingle([key, value]);\r\n  };\r\n\r\nexport const set = createSetOrUpdateFunction(true);\r\nexport const update = createSetOrUpdateFunction(false);\r\n\r\n// #endregion\r\n\r\nexport const add = <T extends PropertyContainer<any, boolean>>(\r\n  target: T,\r\n  key: KeyType<T>\r\n) => get(target, key) !== set(target, key, true as any);\r\n\r\nexport const has = <T extends PropertyContainer>(target: T, key: KeyType<T>) =>\r\n  hasMethod(target, \"has\")\r\n    ? target.has(key)\r\n    : isDefined((target as any).get?.(key) ?? (target as any)[key]);\r\n\r\nexport const clear: {\r\n  <T extends PropertyContainer>(target: T, key: KeyType<T>): ValueType<\r\n    T,\r\n    KeyType<T>,\r\n    true\r\n  >;\r\n  <T extends PropertyContainer>(target: T, ...keys: KeyType<T>[]): ValueType<\r\n    T,\r\n    KeyType<T>,\r\n    true\r\n  >[];\r\n} = (target: PropertyContainer, key: any, ...keys: any[]) => {\r\n  if (keys.length) {\r\n    return keys.map((key) => clear(target, key));\r\n  }\r\n\r\n  const current = get(target, key);\r\n  hasMethod(target, \"delete\")\r\n    ? target.delete(key)\r\n    : isArray(target)\r\n    ? target.splice(key, 1)\r\n    : delete target[key];\r\n\r\n  return current;\r\n};\r\n","import { isDefined, isUndefined, tryCatchAsync } from \"@tailjs/util\";\r\nimport { bindStorage, clock, sharedStorage, wait } from \".\";\r\n\r\nexport type MaybePromise<T> = T extends PromiseLike<infer T>\r\n  ? MaybePromise<T>\r\n  : T | PromiseLike<T>;\r\n\r\nexport interface OpenPromise<T = void> extends PromiseLike<T> {\r\n  readonly resolved: (T extends void ? boolean : T) | undefined;\r\n  reset(): OpenPromise<T>;\r\n  resolve(value: T, reset?: boolean): OpenPromise<T>;\r\n  reject(error: any): OpenPromise<T>;\r\n  signal(value: T): OpenPromise<T>;\r\n  wait(timeout: number): Promise<T | undefined>;\r\n}\r\n\r\nexport const promise = <T = void>(initialValue?: T): OpenPromise<T> => {\r\n  let capturedResolve: (value: T) => void;\r\n  let capturedReject: (value: T) => void;\r\n  let currentPromise: Promise<T>;\r\n  const resetPromise = () => {\r\n    (instance as any).resolved = undefined;\r\n    currentPromise = new Promise<T>(\r\n      (resolve, reject) => (\r\n        (capturedResolve = (value: any) => {\r\n          (instance as any).resolved = !isDefined(value) || value;\r\n          resolve(value);\r\n        }),\r\n        (capturedReject = reject)\r\n      )\r\n    );\r\n  };\r\n\r\n  const instance: OpenPromise<T> = {\r\n    resolved: undefined,\r\n    reset: () => (resetPromise(), instance),\r\n    resolve: (value) => (capturedResolve(value), instance),\r\n    reject: (value) => (capturedReject(value), instance),\r\n    signal: (value) => (capturedResolve(value), instance.reset()),\r\n    then: (...args) => currentPromise.then(...args),\r\n    wait: (timeout) => Promise.race([wait(timeout), currentPromise]) as any,\r\n  };\r\n  instance.reset();\r\n  return initialValue ? instance.resolve(initialValue) : instance;\r\n};\r\n\r\nexport type Lock<D = any> = {\r\n  <T = void>(action: () => Promise<T> | T): Promise<T>;\r\n  <T = void>(action: () => Promise<T> | T, waitTimeout: number): Promise<\r\n    [value: T | undefined, acquired: boolean]\r\n  >;\r\n  data: {\r\n    get(): D | undefined;\r\n    update<Undefined extends undefined | never = never>(\r\n      newValue: (current: D | undefined) => D | Undefined\r\n    ): D | Undefined;\r\n  };\r\n};\r\n\r\nexport const createLock = <Data = any>(\r\n  id: string,\r\n  timeout = 1000\r\n): Lock<Data> => {\r\n  const storage = bindStorage<[Data | undefined]>(id, timeout);\r\n  let waitHandle = promise();\r\n  storage.observe((value) => {\r\n    if (isUndefined(value)) {\r\n      waitHandle.signal();\r\n    }\r\n  });\r\n\r\n  return Object.assign(\r\n    async <T>(action: () => Promise<T>, waitTimeout?: number) => {\r\n      let timeouts = 0;\r\n      while (storage.get()) {\r\n        if (timeouts > 3) {\r\n          throw new Error(`Could not acquire lock after ${timeouts} attempts.`);\r\n        }\r\n        const waitHandleWait = waitHandle.wait(timeout);\r\n        if (isDefined(waitTimeout)) {\r\n          const waitTimeoutWait = wait(waitTimeout, -1);\r\n          if ((await Promise.race([waitHandleWait, waitTimeoutWait])) === -1) {\r\n            return [undefined, false];\r\n          }\r\n        } else {\r\n          await waitHandleWait;\r\n        }\r\n      }\r\n      const refresher = clock(\r\n        () => {\r\n          storage.update((current) => [current?.[0]]);\r\n        },\r\n        { frequency: timeout / 2, trigger: true }\r\n      );\r\n\r\n      let result = await tryCatchAsync(action, true, () => {\r\n        refresher.toggle(false);\r\n        storage.delete();\r\n      });\r\n\r\n      return isDefined(waitTimeout) ? [result, true] : result;\r\n    },\r\n    {\r\n      data: {\r\n        get: () => storage.get()?.[0],\r\n        update: (newValue: (current: any) => any) =>\r\n          storage.update((current) => [newValue(current?.[0])] as any),\r\n      },\r\n    }\r\n  );\r\n};\r\n","import { isNumber, tryCatchAsync } from \"@tailjs/util\";\r\nimport { MaybePromise, promise } from \".\";\r\n\r\nexport const now = () => Math.trunc(performance.timeOrigin + performance.now());\r\nexport type CancelableCallback = () => MaybePromise<void | boolean>;\r\n\r\nexport interface Clock {\r\n  readonly active: boolean;\r\n  readonly busy: boolean;\r\n  restart(callback?: CancelableCallback, frequency?: number): Clock;\r\n  toggle(start: boolean, trigger?: boolean): Clock;\r\n  trigger(skipQueue?: boolean): Promise<boolean>;\r\n}\r\n\r\nexport interface ClockSettings {\r\n  frequency?: number;\r\n  queue?: boolean;\r\n  paused?: boolean;\r\n  trigger?: boolean;\r\n}\r\n\r\ntype ClockSettingsParameter = ClockSettings & { frequency: number };\r\n\r\nexport const clock: {\r\n  (callback: CancelableCallback, frequency: number): Clock;\r\n  (callback: CancelableCallback, settings: ClockSettingsParameter): Clock;\r\n} = (\r\n  callback: CancelableCallback,\r\n  settings: number | ClockSettingsParameter\r\n): Clock => {\r\n  let {\r\n    queue = true,\r\n    paused = false,\r\n    trigger = false,\r\n    frequency,\r\n  } = isNumber(settings) ? { frequency: settings } : settings;\r\n\r\n  let timeoutId = 0;\r\n  const mutex = promise().resolve();\r\n\r\n  const outerCallback = async (skipQueue?: boolean) => {\r\n    if (!timeoutId || (!queue && !mutex.resolved && skipQueue !== true)) {\r\n      return false;\r\n    }\r\n    (instance as any).busy = true;\r\n    if (skipQueue !== true) {\r\n      await mutex;\r\n    }\r\n\r\n    mutex.reset();\r\n    ((await tryCatchAsync(callback, false, () => mutex.resolve())) === false ||\r\n      frequency < 0) &&\r\n      reset(true);\r\n\r\n    (instance as any).busy = false;\r\n    return true;\r\n  };\r\n\r\n  const reset = (start: boolean) => {\r\n    clearInterval(timeoutId);\r\n    (instance as any).active = !!(timeoutId = start\r\n      ? setInterval(outerCallback, frequency < 0 ? -frequency : frequency)\r\n      : 0);\r\n    return instance;\r\n  };\r\n\r\n  const instance: Clock = {\r\n    active: false,\r\n    busy: false,\r\n    restart: (newCallback, newFrequency) => {\r\n      callback = newCallback ?? callback;\r\n      frequency = newFrequency ?? frequency;\r\n      return newCallback || newFrequency || !timeoutId ? reset(true) : instance;\r\n    },\r\n    toggle: (start, trigger) =>\r\n      start !== instance.active\r\n        ? start\r\n          ? trigger\r\n            ? (reset(true), instance.trigger(), instance)\r\n            : reset(true)\r\n          : reset(false)\r\n        : instance,\r\n    trigger: async (skipQueue) =>\r\n      (await outerCallback(skipQueue)) && (reset(true), true),\r\n  };\r\n\r\n  return instance.toggle(!paused, trigger);\r\n};\r\n\r\nexport const wait = <T = void>(timeout: number = 0, value?: T): Promise<T> =>\r\n  new Promise<any>((resolve) =>\r\n    timeout ? setTimeout(() => resolve(value), timeout) : resolve(value)\r\n  );\r\n","import { now } from \".\";\r\n\r\nexport type UUID = string;\r\n\r\nexport let TAB_ID =\r\n  now().toString(36) +\r\n  Math.trunc(1296 * Math.random()) //\r\n    .toString(36)\r\n    .padStart(2, \"0\");\r\n\r\nlet localId = 0;\r\nexport const nextId = () => TAB_ID + \"_\" + nextLocalId();\r\nexport const nextLocalId = () => ++localId;\r\n","import { filter, some } from \"@tailjs/util\";\r\n\r\nexport type Rebinder = () => boolean;\r\nexport type Unbinder = () => boolean;\r\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\r\n\r\nexport type SourceListener<Args extends any[]> = (...args: Args) => void;\r\nexport type Listener<Args extends any[]> = (\r\n  ...args: [...args: Args, unbind: Unbinder]\r\n) => void;\r\n\r\nexport const createBinders = <Args extends any[]>(\r\n  listener: Listener<Args>,\r\n  attach: (listener: SourceListener<Args>) => void,\r\n  detach: (listener: SourceListener<Args>) => void\r\n): Binders => {\r\n  let bound = false;\r\n\r\n  const outerListener = (...args: Args) => listener(...args, unbind);\r\n\r\n  const unbind = () =>\r\n    bound !== (bound = false) && (detach(outerListener), true);\r\n\r\n  const rebind = () =>\r\n    bound !== (bound = true) && (attach(outerListener), true);\r\n\r\n  rebind();\r\n  return [unbind, rebind];\r\n};\r\n\r\nexport const mergeBinders = (...binders: (Binders | undefined)[]): Binders => (\r\n  (binders = filter(binders)),\r\n  [\r\n    () => some(binders, (binder) => binder![0]()),\r\n    () => some(binders, (binder) => binder![1]()),\r\n  ]\r\n);\r\n\r\nexport type EventHandler<Args extends any[]> = (...payload: Args) => void;\r\n\r\nexport const createEvent = <Args extends any[]>(): [\r\n  listen: (listener: Listener<Args>) => Binders,\r\n  dispatch: (...payload: Args) => void\r\n] => {\r\n  const listeners = new Set<SourceListener<Args>>();\r\n\r\n  return [\r\n    (handler) =>\r\n      createBinders(\r\n        handler,\r\n        (handler) => listeners.add(handler),\r\n        (handler) => listeners.delete(handler)\r\n      ),\r\n    (...payload) => listeners.forEach((handler) => handler(...payload)),\r\n  ];\r\n};\r\n","const codes: number[] = [];\nconst chars: number[] = [];\nexport const charCode = (s: string, index = 0) => s.charCodeAt(index);\nexport const fromCharCodes = (chars: number[]) => String.fromCharCode(...chars);\n\n[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"].forEach(\n  (p, i) => (codes[(chars[i] = p.charCodeAt(0))] = i)\n);\n\n/**\n * Encodes an array of bytes to Base64URL without padding (URL safe Base64 using `-` and `_` instead of `+` and `/`).\n *\n * (thanks to Jon Leighton at https://gist.github.com/jonleighton/958841).\n */\nexport const to64u = (bytes: Uint8Array) => {\n  let i = 0;\n  let chunk: number;\n  const n = bytes.length;\n\n  const base64: number[] = [];\n  while (i < n) {\n    chunk = (bytes[i++] << 16) | (bytes[i++] << 8) | bytes[i++];\n    base64.push(\n      chars[(chunk & 16515072) >> 18],\n      chars[(chunk & 258048) >> 12],\n      chars[(chunk & 4032) >> 6],\n      chars[chunk & 63]\n    );\n  }\n  base64.length += n - i;\n\n  return fromCharCodes(base64);\n};\n\n/**\n * Decodes a BaseURL encoded string (without padding).\n */\nexport const from64u = (encoded: string) => {\n  let i = 0;\n  let j = 0;\n  let p: number;\n  const n = encoded.length;\n  const bytes = new Uint8Array(3 * ((n / 4) | 0) + (((n + 3) & 3) % 3));\n  while (i < n) {\n    bytes[j++] =\n      (codes[charCode(encoded, i++)] << 2) |\n      ((p = codes[charCode(encoded, i++)]) >> 4);\n    if (i < n) {\n      bytes[j++] = ((p & 15) << 4) | ((p = codes[charCode(encoded, i++)]) >> 2);\n      if (i < n) {\n        bytes[j++] = ((p & 3) << 6) | codes[charCode(encoded, i++)];\n      }\n    }\n  }\n  return bytes;\n};\n","import { hasValue, isBoolean } from \"..\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  (value: T, bits?: 32 | 64 | 128): string;\n  <B extends boolean>(value: T, numeric: B): B extends true ? number : string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key = \"\"): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (iw = 0; iw < key.length; mixer0 += window0[iw] = key.charCodeAt(iw++));\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero it all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: Uint8Array, numericOrBits: any = 64) => {\n      if (!hasValue(source)) return null;\n      bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n","﻿(function () {\r\n\t\"use strict\";\r\n\r\n\t// Serializes a value to a MessagePack byte array.\r\n\t//\r\n\t// data: The value to serialize. This can be a scalar, array or object.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple values in data are concatenated to multiple MessagePack arrays.\r\n\t// - invalidTypeReplacement: The value that is used to replace values of unsupported types, or a function that returns such a value, given the original value as parameter.\r\n\tfunction serialize(data, options) {\r\n\t\tif (options && options.multiple && !Array.isArray(data)) {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\r\n\t\t}\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet floatBuffer, floatView;\r\n\t\tlet array = new Uint8Array(128);\r\n\t\tlet length = 0;\r\n\t\tif (options && options.multiple) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tappend(data[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tappend(data);\r\n\t\t}\r\n\t\treturn array.subarray(0, length);\r\n\r\n\t\tfunction append(data, isReplacement) {\r\n\t\t\tswitch (typeof data) {\r\n\t\t\t\tcase \"undefined\":\r\n\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\tappendBoolean(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tappendNumber(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tappendString(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif (data === null)\r\n\t\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\telse if (data instanceof Date)\r\n\t\t\t\t\t\tappendDate(data);\r\n\t\t\t\t\telse if (Array.isArray(data))\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\r\n\t\t\t\t\t\tappendBinArray(data);\r\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\r\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\r\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tappendObject(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\r\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendNull(data) {\r\n\t\t\tappendByte(0xc0);\r\n\t\t}\r\n\r\n\t\tfunction appendBoolean(data) {\r\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\r\n\t\t}\r\n\r\n\t\tfunction appendNumber(data) {\r\n\t\t\tif (isFinite(data) && Math.floor(data) === data) {\r\n\t\t\t\t// Integer\r\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0 && data >= -0x20) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\r\n\t\t\t\t\tappendBytes([0xcc, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\r\n\t\t\t\t\tappendBytes([0xd0, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\r\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\r\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\r\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\r\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\r\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\r\n\t\t\t\t\t// 32 bits for bitwise operations.\r\n\t\t\t\t\tlet hi = data / pow32;\r\n\t\t\t\t\tlet lo = data % pow32;\r\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\r\n\t\t\t\t\tappendByte(0xd3);\r\n\t\t\t\t\tappendInt64(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0) {   // below int64\r\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t\telse {   // above uint64\r\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Float\r\n\t\t\t\tif (!floatView) {\r\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\r\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\r\n\t\t\t\t}\r\n\t\t\t\tfloatView.setFloat64(0, data);\r\n\t\t\t\tappendByte(0xcb);\r\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendString(data) {\r\n\t\t\tlet bytes = encodeUtf8(data);\r\n\t\t\tlet length = bytes.length;\r\n\r\n\t\t\tif (length <= 0x1f)\r\n\t\t\t\tappendByte(0xa0 + length);\r\n\t\t\telse if (length <= 0xff)\r\n\t\t\t\tappendBytes([0xd9, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(bytes);\r\n\t\t}\r\n\r\n\t\tfunction appendArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x90 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let index = 0; index < length; index++) {\r\n\t\t\t\tappend(data[index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendBinArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendBytes([0xc4, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(data);\r\n\t\t}\r\n\r\n\t\tfunction appendObject(data) {\r\n\t\t\tlet length = 0;\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tif (data[key] !== undefined) {\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x80 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tlet value = data[key];\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tappend(key);\r\n\t\t\t\t\tappend(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendDate(data) {\r\n\t\t\tlet sec = data.getTime() / 1000;\r\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\r\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\r\n\t\t\t\tappendInt64(sec);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendByte(byte) {\r\n\t\t\tif (array.length < length + 1) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + 1)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray[length] = byte;\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\tfunction appendBytes(bytes) {\r\n\t\t\tif (array.length < length + bytes.length) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + bytes.length)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray.set(bytes, length);\r\n\t\t\tlength += bytes.length;\r\n\t\t}\r\n\r\n\t\tfunction appendInt64(value) {\r\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\r\n\t\t\t// bitwise operations.\r\n\t\t\tlet hi, lo;\r\n\t\t\tif (value >= 0) {\r\n\t\t\t\t// Same as uint64\r\n\t\t\t\thi = value / pow32;\r\n\t\t\t\tlo = value % pow32;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\r\n\t\t\t\tvalue++;\r\n\t\t\t\thi = Math.abs(value) / pow32;\r\n\t\t\t\tlo = Math.abs(value) % pow32;\r\n\t\t\t\thi = ~hi;\r\n\t\t\t\tlo = ~lo;\r\n\t\t\t}\r\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deserializes a MessagePack byte array to a value.\r\n\t//\r\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple concatenated MessagePack arrays are returned as an array.\r\n\tfunction deserialize(array, options) {\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet pos = 0;\r\n\t\tif (array instanceof ArrayBuffer) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\r\n\t\t}\r\n\t\tif (!array.length) {\r\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\r\n\t\t}\r\n\t\tif (!(array instanceof Uint8Array)) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tlet data;\r\n\t\tif (options && options.multiple) {\r\n\t\t\t// Read as many messages as are available\r\n\t\t\tdata = [];\r\n\t\t\twhile (pos < array.length) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Read only one message and ignore additional data\r\n\t\t\tdata = read();\r\n\t\t}\r\n\t\treturn data;\r\n\r\n\t\tfunction read() {\r\n\t\t\tconst byte = array[pos++];\r\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\r\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\r\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\r\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\r\n\t\t\tif (byte === 0xc0) return null;   // nil\r\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\r\n\t\t\tif (byte === 0xc2) return false;   // false\r\n\t\t\tif (byte === 0xc3) return true;   // true\r\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\r\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\r\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\r\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\r\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\r\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\r\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\r\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\r\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\r\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\r\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\r\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\r\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\r\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\r\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\r\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\r\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\r\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\r\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\r\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\r\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\r\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\r\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\r\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\r\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\r\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\r\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\r\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\r\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\r\n\t\t\tconsole.debug(\"msgpack array:\", array);\r\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\r\n\t\t}\r\n\r\n\t\tfunction readInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\tlet first = true;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tlet byte = array[pos++];\r\n\t\t\t\t\tvalue += byte & 0x7f;\r\n\t\t\t\t\tif (byte & 0x80) {\r\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvalue *= 256;\r\n\t\t\t\t\tvalue += array[pos++];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readUInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tvalue *= 256;\r\n\t\t\t\tvalue += array[pos++];\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readFloat(size) {\r\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\r\n\t\t\tpos += size;\r\n\t\t\tif (size === 4)\r\n\t\t\t\treturn view.getFloat32(0, false);\r\n\t\t\tif (size === 8)\r\n\t\t\t\treturn view.getFloat64(0, false);\r\n\t\t}\r\n\r\n\t\tfunction readBin(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = array.subarray(pos, pos + size);\r\n\t\t\tpos += size;\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readMap(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = {};\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tlet key = read();\r\n\t\t\t\tdata[key] = read();\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readArray(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = [];\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readStr(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet start = pos;\r\n\t\t\tpos += size;\r\n\t\t\treturn decodeUtf8(array, start, size);\r\n\t\t}\r\n\r\n\t\tfunction readExt(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet type = readUInt(1);\r\n\t\t\tlet data = readBin(size);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 255:\r\n\t\t\t\t\treturn readExtDate(data);\r\n\t\t\t}\r\n\t\t\treturn { type: type, data: data };\r\n\t\t}\r\n\r\n\t\tfunction readExtDate(data) {\r\n\t\t\tif (data.length === 4) {\r\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\treturn new Date(sec * 1000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 8) {\r\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\r\n\t\t\t\t\t((data[1] << 14) >>> 0) +\r\n\t\t\t\t\t((data[2] << 6) >>> 0) +\r\n\t\t\t\t\t(data[3] >>> 2);\r\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\r\n\t\t\t\t\t((data[4] << 24) >>> 0) +\r\n\t\t\t\t\t((data[5] << 16) >>> 0) +\r\n\t\t\t\t\t((data[6] << 8) >>> 0) +\r\n\t\t\t\t\tdata[7];\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 12) {\r\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\tpos -= 8;\r\n\t\t\t\tlet sec = readInt(8);\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Encodes a string to UTF-8 bytes.\r\n\tfunction encodeUtf8(str) {\r\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\r\n\t\tlet ascii = true, length = str.length;\r\n\t\tfor (let x = 0; x < length; x++) {\r\n\t\t\tif (str.charCodeAt(x) > 127) {\r\n\t\t\t\tascii = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\r\n\t\tfor (let ci = 0; ci !== length; ci++) {\r\n\t\t\tlet c = str.charCodeAt(ci);\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tbytes[i++] = c;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c < 2048) {\r\n\t\t\t\tbytes[i++] = c >> 6 | 192;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\r\n\t\t\t\t\tif (++ci >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\r\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\r\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\r\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\r\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\r\n\t\t\t\t}\r\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\r\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\r\n\t\t\t}\r\n\t\t\tbytes[i++] = c & 63 | 128;\r\n\t\t}\r\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\r\n\t}\r\n\r\n\t// Decodes a string from UTF-8 bytes.\r\n\tfunction decodeUtf8(bytes, start, length) {\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = start, str = \"\";\r\n\t\tlength += start;\r\n\t\twhile (i < length) {\r\n\t\t\tlet c = bytes[i++];\r\n\t\t\tif (c > 127) {\r\n\t\t\t\tif (c > 191 && c < 224) {\r\n\t\t\t\t\tif (i >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\r\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 223 && c < 240) {\r\n\t\t\t\t\tif (i + 1 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\r\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 239 && c < 248) {\r\n\t\t\t\t\tif (i + 2 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\r\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\r\n\t\t\t}\r\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\r\n\t\t\telse if (c <= 0x10ffff) {\r\n\t\t\t\tc -= 0x10000;\r\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\r\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\r\n\t\t\t}\r\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\r\n\t// The exported functions\r\n\tlet msgpack = {\r\n\t\tserialize: serialize,\r\n\t\tdeserialize: deserialize,\r\n\r\n\t\t// Compatibility with other libraries\r\n\t\tencode: serialize,\r\n\t\tdecode: deserialize\r\n\t};\r\n\r\n\t// Environment detection\r\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\r\n\t\t// Node.js\r\n\t\tmodule.exports = msgpack;\r\n\t}\r\n\telse {\r\n\t\t// Global object\r\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\r\n\t}\r\n\r\n})();\r\n","import { deserialize, serialize } from \"@ygoe/msgpack\";\n\nimport { HashFunction, from64u, lfsr, to64u } from \".\";\nimport {\n  IsNever,\n  Nullish,\n  hasValue,\n  isArray,\n  isDefined,\n  isFunction,\n  isIterable,\n  isNumber,\n  isObject,\n  isString,\n  isSymbol,\n  isUndefined,\n  map,\n  tryCatch,\n} from \"..\";\nimport { isStringObject } from \"util/types\";\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\nexport type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the constract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properies that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param validate This property has no effect other than letting TypeScript validate whether the value can be deserialized back to its original form without losing properties.\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  (value: any, validate?: false): string;\n  <T = Encodable>(value: T & EncodableContract<T>, validate: true): string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(encoded: string | Nullish) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\nconst floatBuffer = new ArrayBuffer(8);\nconst floatView = new DataView(floatBuffer);\n\n/**\n * Misc. fixes to the msgpack library. For example, it does not handle exponential numbers well.\n */\nconst patchSerialize = (value: any) => {\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number;\n  const patchProperty = (\n    value: any,\n    key: any,\n    val = value[key],\n    patched = inner(val)\n  ) => (\n    (val !== patched || isSymbol(key)) &&\n      ((value[key] = patched), addCleaner(() => (value[key] = val))),\n    val\n  );\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (value == null || isFunction(value) || isSymbol(value)) {\n      return null;\n    }\n\n    if (Number.isFinite(value) && !Number.isSafeInteger(value)) {\n      floatView.setFloat64(0, value, true);\n\n      return { \"\": [...new Uint32Array(floatBuffer)] };\n    }\n\n    if (!isObject(value, true)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if (isDefined((refIndex = (refs ??= new Map()).get(value)))) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isObject(value)) {\n      refs.set(value, refs.size + 1);\n\n      Object.keys(value).forEach(\n        (k) =>\n          (isUndefined(patchProperty(value, k)) || isSymbol(k)) &&\n          delete value[k]\n      );\n    } else if (isIterable(value)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  const serialized = serialize(inner(value));\n  cleaners?.forEach((cleaner) => cleaner());\n  return serialized;\n};\n\nconst patchDeserialize = (value: Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value, true)) return value;\n\n    if (isArray(value[\"\"]) && (value = value[\"\"]).length === 2) {\n      return new DataView(new Uint32Array(value).buffer).getFloat64(0, true);\n    }\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return hasValue(value)\n    ? tryCatch(\n        () => inner(deserialize(value)),\n        () => undefined\n      )\n    : undefined;\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<any>\n];\n\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lsfr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (\n  key?: null | string,\n  json = false\n): Transport => {\n  const [encrypt, decrypt, hash] = lfsr(key ?? \"\");\n  const fastStringHash = (value: any, bitsOrNumeric: any) => {\n    if (isNumber(value) && bitsOrNumeric === true) return value;\n\n    value = isString(value)\n      ? new Uint8Array(map(value.length, (i) => value.charCodeAt(i) & 255))\n      : json\n      ? JSON.stringify(value)\n      : patchSerialize(value);\n    return hash(value, bitsOrNumeric);\n  };\n  return json\n    ? [\n        (data: any) => JSON.stringify(data),\n        (encoded) =>\n          encoded == null\n            ? undefined\n            : tryCatch(() => JSON.parse(encoded, undefined)),\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ]\n    : [\n        (data: any) => to64u(encrypt(patchSerialize(data))),\n        (encoded: any) =>\n          hasValue(encoded)\n            ? patchDeserialize(decrypt(from64u(encoded)))\n            : null,\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ];\n};\n\nexport const defaultTransport = createTransport();\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\n","import { clear, forEach, isDefined, isString, isUndefined } from \"@tailjs/util\";\r\nimport { createTransport, hash } from \"@tailjs/util/transport\";\r\nimport {\r\n  Binders,\r\n  DEBUG,\r\n  Listener,\r\n  TAB_ID,\r\n  addPageListener,\r\n  clock,\r\n  createEvent,\r\n  error,\r\n  listen,\r\n  mergeBinders,\r\n  now,\r\n} from \".\";\r\n\r\nexport type Metadata<T = any> = [value: T, source?: string, expires?: number];\r\n\r\nexport type StorageProviderObserver<T = any> = (\r\n  newValue: T | undefined,\r\n  oldValue: T | undefined,\r\n  key: string | null\r\n) => void;\r\n\r\nexport interface StorageProvider {\r\n  getItem<T = any>(key: string): [value: T, source?: string] | undefined;\r\n  setItem<T = any>(\r\n    key: string,\r\n    value: T,\r\n    source?: string,\r\n    timeout?: number\r\n  ): void;\r\n  removeItem(key: string): void;\r\n  observe?<T = any>(key: string, observer: StorageProviderObserver<T>): Binders;\r\n}\r\n\r\ntype TypedStorageObserverArgs<T = any> = [\r\n  newValue: T | undefined,\r\n  context: {\r\n    key: string | null;\r\n    oldValue: string | undefined;\r\n    source?: string | undefined;\r\n    self?: boolean;\r\n  }\r\n];\r\nexport type TypedStorageObserver<T = any> = Listener<\r\n  TypedStorageObserverArgs<T>\r\n>;\r\n\r\nexport interface TypedStorage {\r\n  get<T = any>(key: string): T | undefined;\r\n  set<T>(key: string, value: T, timeout?: number): T;\r\n  delete(key: string): void;\r\n  update<T = any>(\r\n    key: string,\r\n    newValue: (current: T | undefined) => T,\r\n    timeout?: number\r\n  ): T;\r\n  observe?<T = any>(\r\n    key: string,\r\n    observer: TypedStorageObserver<T>,\r\n    includeSelf?: boolean\r\n  ): Binders;\r\n}\r\n\r\nexport interface BoundStorage<T = any> {\r\n  get(): T | undefined;\r\n  set<Undefined extends undefined | never = never>(\r\n    value: T | undefined,\r\n    timeout?: number\r\n  ): T | Undefined;\r\n  delete(): void;\r\n  update<Undefined extends undefined | T = T>(\r\n    newValue: (current: T | undefined) => T | Undefined,\r\n    timeout?: number\r\n  ): T | Undefined;\r\n  observe?(observer: TypedStorageObserver<T>, observeSelf?: boolean): Binders;\r\n}\r\n\r\nconst [serialize, deserialize] = createTransport(\"foo\", DEBUG);\r\n\r\nexport const mapStorage = <P extends StorageProvider>(\r\n  provider: P\r\n): P[\"observe\"] extends undefined ? TypedStorage : Required<TypedStorage> => {\r\n  const [addOwnListener, dispatchOwn] = createEvent<TypedStorageObserverArgs>();\r\n\r\n  const get = (key: string) => provider.getItem(key)?.[0];\r\n\r\n  const set = <T>(key: string, value: T | undefined, timeout?: number) => {\r\n    const oldValue = get(key);\r\n    if (isUndefined(value)) {\r\n      provider.removeItem(key);\r\n      dispatchOwn(undefined, { key, oldValue, source: TAB_ID, self: true });\r\n    } else {\r\n      provider.setItem(key, value, TAB_ID, timeout);\r\n      dispatchOwn(value, { key, oldValue, source: TAB_ID, self: true });\r\n    }\r\n    return value as any;\r\n  };\r\n\r\n  let retries = 0;\r\n  const update = <T>(\r\n    key: string,\r\n    newValue: (current: T | undefined) => T | undefined,\r\n    timeout: number\r\n  ) => {\r\n    if (retries++ > 3) {\r\n      error(`Race condition ('${key}').`, true);\r\n    }\r\n    const value = set(key, newValue(provider.getItem<T>(key)?.[0]), timeout);\r\n    const writtenValue = provider.getItem(key);\r\n    if (writtenValue?.[1] && writtenValue?.[1] !== TAB_ID) {\r\n      return update(key, newValue, timeout);\r\n    }\r\n    retries = 0;\r\n    return value;\r\n  };\r\n\r\n  return {\r\n    get,\r\n    set,\r\n    delete: (key) => set(key, undefined),\r\n    update,\r\n    observe: provider.observe\r\n      ? (key, listener, observeSelf) => {\r\n          const [unbind, bind] = mergeBinders(\r\n            provider.observe!(key, (newValue, oldValue, key) =>\r\n              listener(\r\n                newValue?.[0],\r\n                { key, oldValue: oldValue?.[0], source: newValue?.[1] },\r\n                unbind\r\n              )\r\n            ),\r\n            observeSelf\r\n              ? addOwnListener(\r\n                  (value, context, unbind) =>\r\n                    context.key === key && listener(value, context, unbind)\r\n                )\r\n              : undefined\r\n          );\r\n          return [unbind, bind];\r\n        }\r\n      : undefined,\r\n  } as TypedStorage as any;\r\n};\r\n\r\nconst parsePayload = (value: any): [value: string, timeout?: number] => {\r\n  if (!isString(value)) return [value];\r\n\r\n  const [, payload, parsedTimeout] = value.match(/(.*?)(?:@:([0-9a-z]+))?$/)!;\r\n  return [\r\n    payload,\r\n    isDefined(parsedTimeout) ? parseInt(parsedTimeout, 36) : undefined,\r\n  ];\r\n};\r\nconst purgeExpired = (key: string, value: any) => {\r\n  const [payload, timeout] = parsePayload(value);\r\n  if (timeout && timeout - now() < 0) {\r\n    clear(localStorage, key);\r\n    return undefined;\r\n  }\r\n  return payload;\r\n};\r\n\r\nexport const sharedStorage = mapStorage({\r\n  getItem: (key) => deserialize(purgeExpired(key, localStorage.getItem(key))),\r\n  setItem: (key, value, source, timeout) =>\r\n    localStorage.setItem(\r\n      key,\r\n      serialize([value, source]) +\r\n        (timeout! > 0 ? `@:${(now() + timeout!).toString(36)}` : \"\")\r\n    ),\r\n  removeItem: (key) => localStorage.removeItem(key),\r\n  observe: (key, observer) => {\r\n    const [unbind, bind] = listen(\r\n      window,\r\n      \"storage\",\r\n      ({ key: changedKey, newValue, oldValue }) =>\r\n        key == changedKey &&\r\n        observer(\r\n          deserialize(parsePayload(newValue)[0]),\r\n          deserialize(parsePayload(oldValue)[0]),\r\n          key\r\n        )\r\n    );\r\n\r\n    return mergeBinders(\r\n      [unbind, bind],\r\n      addPageListener(\r\n        (visible, loaded) => !loaded && (visible ? bind() : unbind())\r\n      )\r\n    );\r\n  },\r\n});\r\n\r\nclock(\r\n  () => {\r\n    forEach(localStorage, ([key, value]) => !purgeExpired(key as any, value));\r\n  },\r\n  {\r\n    frequency: 2000,\r\n    trigger: true,\r\n  }\r\n);\r\n\r\nexport const bindStorage: {\r\n  <T>(\r\n    key: string,\r\n    defaultTimeout?: number,\r\n    storage?: Required<TypedStorage>\r\n  ): Required<BoundStorage<T>>;\r\n  <T>(\r\n    key: string,\r\n    defaultTimeout?: number,\r\n    storage?: TypedStorage\r\n  ): BoundStorage<T>;\r\n} = <T>(\r\n  key: string,\r\n  defaultTimeout?: number,\r\n  storage: TypedStorage = sharedStorage\r\n): Required<BoundStorage<T>> => ({\r\n  get: () => storage.get<T>(key),\r\n  set: (value, timeout) =>\r\n    storage.set(key, value as any, timeout ?? defaultTimeout),\r\n  delete: () => storage.delete(key),\r\n  update: (updater, timeout) =>\r\n    storage.update(key, updater as any, timeout ?? defaultTimeout),\r\n  observe: storage.observe\r\n    ? (observer, includeSelf) => storage.observe!(key, observer, includeSelf)\r\n    : undefined!,\r\n});\r\n","export const DEBUG = true;\r\nexport const TAB_HEARTBEAT = 5_000;\r\nexport const STATE_KEY = \"_t.sr\";\r\n","import {\r\n  filter,\r\n  flatMap,\r\n  isArray,\r\n  isDefined,\r\n  isObject,\r\n  map,\r\n} from \"@tailjs/util\";\r\nimport { TAB_ID, bindStorage, sharedStorage } from \".\";\r\n\r\nexport type Channel<T> = {\r\n  post(payload: T): void;\r\n  unsubscribe: () => void;\r\n};\r\n\r\nexport type SynchronizedStorage<T> = {\r\n  get(): T | null;\r\n  update<V extends T | null>(update: (oldValue: T | null) => V): V;\r\n};\r\n\r\ntype ChannelPayload<T> = {\r\n  sender: string;\r\n  payload: T;\r\n  target?: string;\r\n};\r\n\r\nexport const createChannel = <T>(\r\n  id: string,\r\n  handler: (sender: string, payload: T) => void,\r\n  listenSelf = false\r\n): Channel<T> => {\r\n  const storage = bindStorage<ChannelPayload<T>>(id);\r\n\r\n  return {\r\n    post: (payload) => {\r\n      storage.set({ sender: TAB_ID, payload });\r\n      storage.delete();\r\n    },\r\n    unsubscribe: storage.observe((value) => {\r\n      if (isDefined(value) && (!value.target || value.target === TAB_ID)) {\r\n        handler(value.sender, value.payload);\r\n      }\r\n    }, true)[0],\r\n  };\r\n};\r\n\r\nlet chatChannel: Channel<[message: string, error?: string]> | undefined;\r\nexport const error: {\r\n  (message: string, fatal: boolean): void;\r\n  (message: string, cause?: any, fatal?: boolean);\r\n} = (message: string, error?: any, throwError = false) => {\r\n  if (typeof error === \"boolean\") {\r\n    throwError = error;\r\n    error = null;\r\n  }\r\n  log(error ? message : null, error ?? message);\r\n  if (throwError) {\r\n    throw new Error(message);\r\n  }\r\n};\r\n\r\nexport const log = (message: any, error?: any) => {\r\n  const source = message;\r\n  if (error) {\r\n    error = JSON.stringify(\r\n      (error = isObject(error)\r\n        ? {\r\n            message: error.message ?? error,\r\n            stack: error.stack,\r\n          }\r\n        : error)\r\n    );\r\n  }\r\n\r\n  message = JSON.stringify(message);\r\n  (chatChannel ??= createChannel<[string, string]>(\r\n    \"chat\",\r\n    (sender, parts) =>\r\n      console[parts[1] ? \"error\" : \"log\"](\r\n        sender === TAB_ID ? \"This tab\" : `Other tab (${sender})`,\r\n        ...flatMap(filter(parts), (value) => JSON.parse(value))\r\n      ),\r\n    true\r\n  )).post([message, error]);\r\n  return source;\r\n};\r\n","import { clear, forEach, set } from \"@tailjs/util\";\r\nimport {\r\n  STATE_KEY,\r\n  TAB_HEARTBEAT,\r\n  TAB_ID,\r\n  addPageListener,\r\n  bindStorage,\r\n  createEvent,\r\n  now,\r\n  clock,\r\n  sharedStorage,\r\n} from \".\";\r\n\r\nexport type TabState = {\r\n  hearbeat: number;\r\n  view?: number;\r\n  navigated?: number;\r\n};\r\n\r\nexport type State = {\r\n  knownTabs: Record<string, TabState>;\r\n  variables: Record<string, any>;\r\n};\r\n\r\nconst initialState: State = {\r\n  knownTabs: {},\r\n  variables: {},\r\n};\r\n\r\nconst [addStateListener, dispatch] =\r\n  createEvent<[event: \"ready\" | \"update\", state: State]>();\r\n\r\nconst storage = bindStorage<State>(STATE_KEY);\r\n\r\nconst heartbeat = clock(() => toggleTab(true), TAB_HEARTBEAT);\r\nlet tabState: TabState = { hearbeat: now() };\r\n\r\nconst toggleTab = (loading: boolean) => {\r\n  const deadline = now() - TAB_HEARTBEAT * 2;\r\n  heartbeat.toggle(loading, true);\r\n\r\n  return dispatch(\r\n    \"ready\",\r\n    storage.update((state) => {\r\n      forEach(\r\n        state?.knownTabs,\r\n        // Remove interval tabs.\r\n        ([tabId, tabState]) =>\r\n          tabState[0] < deadline && clear(state!.knownTabs, tabId)\r\n      );\r\n\r\n      tabState.hearbeat = now();\r\n\r\n      return (\r\n        set(\r\n          (state ??= initialState).knownTabs,\r\n          TAB_ID,\r\n          loading ? tabState : undefined\r\n        ),\r\n        state\r\n      );\r\n    })\r\n  );\r\n};\r\n\r\naddPageListener((visible, loaded) => !loaded && toggleTab(visible));\r\n\r\nexport const updateTabState = (update: (tabState: TabState) => void) => (\r\n  update(tabState), toggleTab(true)\r\n);\r\n\r\nexport { addStateListener };\r\n","import { tryCatchAsync } from \"@tailjs/util\";\r\nimport { createLock, error, log, wait } from \".\";\r\n\r\nconst postLock = createLock<string[]>(\"test_queue_lck\", 2000);\r\nexport const post = async (data: string[]) => {\r\n  if (\r\n    !(\r\n      await postLock(async () => {\r\n        let pending: string[] | undefined;\r\n        await tryCatchAsync(\r\n          async () => {\r\n            for (;;) {\r\n              postLock.data.update(\r\n                (current) => ((pending = current!), undefined)\r\n              );\r\n              if (data) {\r\n                pending = [...(pending ?? []), ...data];\r\n                data = undefined as any;\r\n              }\r\n              if (!pending) {\r\n                break;\r\n              }\r\n\r\n              log([\"Posting\", pending]);\r\n              await wait(2000);\r\n              if (Math.random() < 0.5) {\r\n                throw new Error(\"Eeek!\");\r\n              }\r\n              log(`Posted ${pending.length} item(s).`);\r\n            }\r\n          },\r\n          async (e, last) => {\r\n            if (last) {\r\n              error(\r\n                `Post failed 3 times in a row, events will not be sent.`,\r\n                e\r\n              );\r\n              throw e;\r\n            } else {\r\n              pending &&\r\n                postLock.data.update(\r\n                  (current) => ((current ??= []).unshift(...pending!), current)\r\n                );\r\n              error(`Post failed, retrying...`, e);\r\n              await wait(250);\r\n            }\r\n          },\r\n          undefined,\r\n          3\r\n        );\r\n      }, 0)\r\n    )[1]\r\n  ) {\r\n    postLock.data.update(\r\n      (current) => ((current ??= []).push(...data), current)\r\n    );\r\n    log(\"Another post is active. Queued data.\");\r\n  }\r\n};\r\n","import {\r\n  clock,\r\n  createLock,\r\n  post,\r\n  listen,\r\n  now,\r\n  updateTabState,\r\n  wait,\r\n  bindStorage,\r\n} from \"./lib2\";\r\n\r\n//const lck = createLock(\"test\");\r\nexport const attach = async () => {\r\n  // let invocations = 0;\r\n  // let clicked = false;\r\n  // const pump = clock(\r\n  //   async () => {\r\n  //     const capturedClick = clicked;\r\n  //     if (!clicked && invocations % 2 === 1) {\r\n  //       await wait(1500);\r\n  //     }\r\n  //     console.log(`${++invocations}, clicked: ${capturedClick}.`);\r\n  //   },\r\n  //   { frequency: 1000, queue: false }\r\n  // );\r\n\r\n  let testId = 1;\r\n  listen(document.body, \"click\", async (e) => {\r\n    // clicked = true;\r\n    // console.log(pump.active, pump.busy);\r\n    // e.shiftKey && pump.toggle(!pump.active);\r\n    // console.log(await pump.trigger(true));\r\n    // (async () => {\r\n    //   clicked = false;\r\n    // })();\r\n    post([`Test ${testId++}`]);\r\n  });\r\n  // listen(document.body, \"click\", () => {\r\n  //   updateTabState((tab) => (tab.navigated = now()));\r\n\r\n  //   lck(async () => {\r\n  //     console.log(\"Lock acquired.\");\r\n  //     await wait(5000);\r\n  //   });\r\n  // });\r\n  // listen(\r\n  //   window,\r\n  //   \"pageshow\",\r\n  //   () =>\r\n  //     activeTabs.update(\r\n  //       (current) => (\r\n  //         ((current = cast(current, isObject) ?? {})[TAB_ID] = now()), current\r\n  //       )\r\n  //     )\r\n  //   //activeStorage.update((current) => (current ?? 0) + 1)\r\n  // );\r\n  // listen(\r\n  //   window,\r\n  //   \"pagehide\",\r\n  //   () =>\r\n  //     activeTabs.update(\r\n  //       (current) => (isObject(current) && delete current[TAB_ID], current)\r\n  //     )\r\n  //   // activeStorage.update((current: any) =>\r\n  //   //   current > 0 ? current - 1 : current\r\n  //   // )\r\n  // );\r\n};\r\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\n//import { initializeTracker } from \"./initializeTracker\";\n//import { F, T, define, window } from \"./lib\";\nimport { attach } from \"./pusher\";\n\n// This assumes the script is loaded from the RequestHandler's ?cfg route.\n\n// To prevent external scripts from eaves-dropping and get a hold of the storage key, this is how initialization works:\n// 1: The configuration scripts appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overriden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nwindow[INITIALIZE_TRACKER_FUNCTION] = (callback: any) => {\n  callback(attach);\n};\n\n// let loaded = F;\n// define(window, {\n//   [INITIALIZE_TRACKER_FUNCTION]: [\n//     (callback: (init: typeof initializeTracker) => void) => {\n//       if (loaded === (loaded = T)) return;\n//       callback(initializeTracker);\n//     },\n//   ],\n// });\n"],"names":["undefined","tryCatch","expression","errorHandler","clean","e","isBoolean","console","error","tryCatchAsync","async","retries","isUndefined","value","isDefined","hasValue","isTruish","isNumber","isString","capturedIsArray","Array","isArray","toArray","clone","isIterable","isObject","acceptIterables","hasMethod","name","isSymbol","isFunction","acceptStrings","Symbol","iterator","sliceIterator","source","start","end","item","Number","MAX_SAFE_INTEGER","createControllableIterator","action","collect","result","i","flag","control","prev","skip","mapIterator","Object","entries","step","maxIterations","createNavigatingIterator","length","offset","createRangeIterator","binders","map","projection","rest","unshift","filter","forEach","innerReturnValue","returnValue","index","_","filterIterator","filterInternal","some","get","target","key","initializer","has","set","args","bulk","setSingle","clear","add","delete","every","assign","k","v","keys","current","splice","promise","initialValue","capturedResolve","capturedReject","currentPromise","instance","resolved","reset","Promise","resolve","reject","signal","then","wait","timeout","race","now","Math","trunc","performance","timeOrigin","clock","callback","settings","queue","paused","trigger","frequency","timeoutId","mutex","outerCallback","skipQueue","busy","clearInterval","active","setInterval","restart","newCallback","newFrequency","toggle","setTimeout","TAB_ID","toString","random","padStart","createBinders","listener","attach","detach","bound","outerListener","unbind","rebind","mergeBinders","binder","createEvent","listeners","Set","handler","payload","addListener","dispatch","listen","options","capture","passive","addEventListener","addPageListener","triggerLoaded","loaded","visible","dispatchVisible","window","document","visibilityState","codes","chars","charCode","s","charCodeAt","p","FNVs","entropy","max","serialize","data","multiple","Error","floatBuffer","floatView","pow32","array","Uint8Array","append","subarray","isReplacement","appendNull","appendByte","appendBoolean","isFinite","floor","appendBytes","hi","lo","appendInt64","ArrayBuffer","DataView","setFloat64","appendNumber","bytes","str","ascii","x","ci","c","c2","encodeUtf8","appendString","Date","sec","getTime","getMilliseconds","ns","appendDate","appendArray","Uint8ClampedArray","appendBinArray","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","appendObject","invalidTypeReplacement","byte","newLength","newArray","abs","deserialize","pos","push","read","readMap","readArray","readStr","readBin","readExt","readFloat","readUInt","readInt","debug","size","first","view","buffer","byteOffset","getFloat32","getFloat64","lengthSize","String","fromCharCode","decodeUtf8","type","readExtDate","msgpack","encode","decode","module","exports","msgpackJsName","REF_PROP","patchSerialize","cleaners","refs","refIndex","patchProperty","val","patched","inner","addCleaner","cleaner","isSafeInteger","toJSON","Map","serialized","createTransport","json","encrypt","decrypt","hash","n","j","pad","bits","prime","mixer","mixer255","iw","mixer0","window0","resetMixer","updateMixer","ENTROPY","cipher","numericOrBits","BigInt","asUintN","MIN_SAFE_INTEGER","lfsr","fastStringHash","bitsOrNumeric","JSON","stringify","encoded","parse","chunk","base64","to64u","from64u","matchedRef","parsePayload","parsedTimeout","match","parseInt","purgeExpired","localStorage","sharedStorage","provider","addOwnListener","dispatchOwn","getItem","oldValue","removeItem","self","setItem","update","newValue","writtenValue","observe","observeSelf","bind","context","mapStorage","observer","changedKey","chatChannel","bindStorage","defaultTimeout","storage","updater","includeSelf","message","throwError","log","stack","id","listenSelf","sender","unsubscribe","createChannel","parts","project","flatProject","flatMap","post","initialState","knownTabs","variables","addStateListener","heartbeat","toggleTab","tabState","hearbeat","loading","deadline","TAB_HEARTBEAT","state","tabId","postLock","waitHandle","waitTimeout","waitHandleWait","waitTimeoutWait","refresher","createLock","testId","body","pending","last"],"mappings":"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","x_google_ignoreList":[11]}