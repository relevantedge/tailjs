{"version":3,"file":"tail.debug.js","sources":["../../../../../constants/constants.ts","../../../util/src/regex.ts","../../../types/src/EventMetadata.ts","../../../types/src/util/parseTags.ts","../../src/lib/dom/dom-util.ts","../../src/lib/dom/dom-data.ts","../../../transport/src/transport.ts","../../src/lib/eventQueue.ts","../../src/initializeTracker.ts","../../src/extensions/view.ts","../../src/extensions/components.ts","../../../util/src/types/validation.ts","../../../util/src/types/types.ts","../../../util/src/iterators.ts","../../../util/src/accessors.ts","../../../util/src/time.ts","../../../util/src/concurrency.ts","../../../util/src/events.ts","../../../util/src/strings.ts","../../../util/src/enums.ts","../../../util/src/parsers.ts","../../../util/src/intervals.ts","../../../util/src/it2/_internal.ts","../../../util/src/it2/iterate.ts","../../../util/src/it2/crud.ts","../../../util/src/it2/strings.ts","../../../types/src/DataClassification.ts","../../../types/src/DataPurposes.ts","../../../types/src/DataUsage.ts","../../../types/src/DataAccess.ts","../../../types/src/EventPatch.ts","../../../types/src/protocol/schema/SchemaObjectTypeDefinition.ts","../../../types/src/protocol/schema/runtime/validation/errors.ts","../../../types/src/protocol/schema/runtime/validation/primitives.ts","../../../types/src/protocol/variables/Variable.ts","../../../types/src/protocol/schema/runtime/TypeResolver.ts","../../../types/src/protocol/variables/VariableResult.ts","../../../types/src/protocol/variables/VariableResultPromise.ts","../../../types/src/events/TrackedEvent.ts","../../../types/src/events/ViewEvent.ts","../../../types/src/util/type-test.ts","../../src/interfaces/LocalVariables.ts","../../src/lib/consts.ts","../../src/lib/dom/dom-alias.ts","../../src/lib/config.ts","../../../transport/src/base64.ts","../../../transport/src/lfsr.ts","../../../../../node_modules/.pnpm/@ygoe+msgpack@https+++codel_fe52f1a9138228bdf215885ce9a9f4d0/node_modules/@ygoe/msgpack/msgpack.js","../../src/lib/env.ts","../../src/lib/cipher.ts","../../src/lib/errors.ts","../../src/lib/page-events.ts","../../src/lib/shared-state.ts","../../src/lib/request.ts","../../src/lib/concurrency.ts","../../src/lib/TrackerVariableStorage.ts","../../src/lib/ImpressionObserver.ts","../../src/lib/debug-listeners.ts","../../src/extensions/userInteraction.ts","../../src/extensions/commerce.ts","../../src/extensions/forms.ts","../../src/extensions/defaultExtensions.ts","../../src/lib/scanComponents.ts","../../src/extensions/scroll.ts","../../src/extensions/consent.ts","../../src/commands/shared.ts","../../src/commands/CartCommand.ts","../../src/commands/ChangeUserCommand.ts","../../src/commands/ConfigCommand.ts","../../src/commands/ToggleCommand.ts","../../src/commands/BoundaryCommand.ts","../../src/commands/ExtensionCommand.ts","../../src/commands/FlushCommand.ts","../../src/commands/GetCommand.ts","../../src/commands/ListenerCommand.ts","../../src/commands/OrderCommand.ts","../../src/commands/ScanComponentsCommand.ts","../../src/commands/SetCommand.ts","../../src/commands/TrackerAvailableCommand.ts","../../src/commands/ConsentCommand.ts","../../src/index.browser.ts","../../src/extensions/user-agent.ts","../../src/extensions/deviceDetection.ts"],"sourcesContent":["export const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\nexport const TRACKER_CONFIG_PLACEHOLDER = \"{{CONFIG}}\";\n\nexport const CLIENT_SCRIPT_QUERY = \"opt\";\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_NAV_QUERY = \"mnt\";\nexport const SCHEMA_QUERY = \"$types\";\nexport const BUILD_REVISION_QUERY = globalThis.REVISION\n  ? \"rev=\" + globalThis.REVISION\n  : \"\";\n\nexport const SCOPE_INFO_KEY = \"@info\";\nexport const CONSENT_INFO_KEY = \"@consent\";\nexport const SESSION_REFERENCE_KEY = \"@session_reference\";\n\nexport const PATCH_EVENT_POSTFIX = \"_patch\";\n\nexport const CLIENT_STORAGE_PREFIX = \"_tail:\";\n\nexport const CLIENT_STATE_CHANNEL_ID = CLIENT_STORAGE_PREFIX + \"state\";\n\nexport const CLIENT_CALLBACK_CHANNEL_ID = CLIENT_STORAGE_PREFIX + \"push\";\n\nexport const PLACEHOLDER_SCRIPT: <Quote extends boolean = false>(\n  trackerName?: string,\n  quote?: Quote\n) => Quote extends true ? string : (...commands: any[]) => void = ((\n  trackerName = \"tail\",\n  quote: boolean\n) => {\n  if (quote) {\n    const reference = `window[${JSON.stringify(trackerName)}]`;\n    return `(${reference}??=c=>${reference}._?.push(c) ?? ${reference}(c))._=[];`;\n  }\n\n  (globalThis[trackerName] ??= (c: any) =>\n    globalThis[trackerName]._?.push(c) ?? globalThis[trackerName](c))._ = [];\n}) as any;\n\nexport const __DEBUG__ = true;\n","import {\n  IDENTITY,\n  If,\n  MaybeUndefined,\n  Nullable,\n  distinct,\n  filter,\n  isArray,\n  isBoolean,\n  isString,\n  join2,\n  map,\n  nil,\n  undefined,\n  type ConstToNormal,\n  type IterableOrSelf,\n  type Nullish,\n} from \".\";\n\n/**\n * Common definition of expressions that are used for string matching.\n *\n * If not already a regular expression, a string that starts with `/` and optionally ends with `/` is parsed as regular expressions with flags `gu` applied (global and Unicode).\n * This enables defining regular expression in text based configuration files that do not have native regular expressions.\n *\n * For convenience an asterisk (`*`) can be used to match any number of characters in strings, and  `,` and white-space ` ` are interpreted as list separators.\n * `\\` is used as the escape character so the string `\\/escaped\\*,and\\ this` will only match the strings, literally, `\\/escaped\\*` and `and this`.\n * This also means that intentional backslashes, commas and spaces must be escaped as `\\\\`, `\\,` and `\\ ` respectively.\n *\n * Arrays of strings and/or regular expressions are evaluated as unions (_string 1_ \"or\" _string 2_ \"or\" ...).\n *\n * The special values `null`, `undefined`, the empty string,  and `false` are interpreted as \"never\", and `true` is \"always\".\n *\n * Regarding separators, they may be different in specific contexts. If so, it will be mentioned there.\n */\nexport type ParsableRegExp =\n  | IterableOrSelf<null | undefined | boolean | string | RegExp>\n  | Iterable<ParsableRegExp>;\n\nexport const testRegex = <Nulls>(\n  s: Nullable<string, Nulls>,\n  match: Nullable<RegExp, Nulls>\n) => (!match || s == null ? undefined : match.test(s));\n\nexport const matches = <R, Nulls>(\n  s: Nullable<string, Nulls>,\n  regex: RegExp | Nullish,\n  selector: (...args: string[]) => R | Nullish\n): MaybeUndefined<Nulls, ConstToNormal<R>[]> => match(s, regex, selector, true);\n\nlet matchProjection: any;\nlet collected: any[];\n\n/**\n * Matches a regular expression against a string and projects the matched parts, if any.\n */\nexport const match: {\n  <R, Nulls, Collect extends boolean = false>(\n    s: Nullable<string, Nulls>,\n    regex: RegExp | Nullish,\n    selector: (...args: (string | undefined)[]) => R | Nullish,\n    collect?: Collect\n  ): MaybeUndefined<Nulls, If<Collect, ConstToNormal<R>[], R | undefined>>;\n  (s: string | Nullish, match: RegExp | Nullish): RegExpMatchArray | undefined;\n} = <R>(\n  s: string,\n  regex: RegExp,\n  selector?: (...args: (string | undefined)[]) => R,\n  collect = false\n) =>\n  (s ?? regex) == nil\n    ? undefined\n    : selector\n    ? ((matchProjection = undefined),\n      collect\n        ? ((collected = []),\n          match(\n            s,\n            regex,\n            (...args) =>\n              (matchProjection = selector(...args)) != null &&\n              collected.push(matchProjection)\n          ))\n        : s.replace(\n            // Replace seems to be a compact way to get the details of each match\n            regex,\n            (...args) => (matchProjection = selector(...args)) as any\n          ),\n      matchProjection)\n    : s.match(regex) ?? undefined;\n\n/**\n * Replaces reserved characters to get a regular expression that matches the string.\n */\nexport const escapeRegEx = <T extends string | Nullish>(\n  input: T\n): MaybeUndefined<T, string> =>\n  input?.replace(/[\\^$\\\\.*+?()[\\]{}|]/g, \"\\\\$&\") as any;\n\nconst REGEX_NEVER = /\\z./g;\nconst unionOrNever = (parts: (string | Nullish)[], joined?: string) =>\n  (joined = join2(distinct(filter(parts, (part) => part?.length)), \"|\"))\n    ? new RegExp(joined, \"gu\")\n    : REGEX_NEVER;\n\nconst stringRuleCache: { [pattern: string]: RegExp } = {};\nexport const isRegEx = (value: any): value is RegExp => value instanceof RegExp;\n\n/**\n * Tests or parses a regular expression accepting the {@link ParsableRegExp} format.\n *\n * Strings are cached, so there is no need to do additional caching outside this function (as far as the caching would only concern strings).\n */\nexport const parseRegex = <T>(\n  input: T,\n  separators: readonly string[] = [\",\", \" \"]\n): T extends ParsableRegExp ? RegExp : undefined =>\n  isRegEx(input)\n    ? input\n    : isArray(input) // Parse individual specifiers, and join them into one long regex. An empty array is interpreted as \"never\".\n    ? unionOrNever(map(input, (part) => parseRegex(part, separators)?.source)!)\n    : isBoolean(input)\n    ? input // `true` is \"always\", `false` is \"never\"\n      ? /./g\n      : REGEX_NEVER // Matches nothing. End of string followed by something is never the case.\n    : isString(input)\n    ? (stringRuleCache[input] ??= match(\n        input || \"\",\n        /^(?:\\/(.+?)\\/?|(.*))$/gu,\n        (_, regex, text) =>\n          regex\n            ? new RegExp(regex, \"gu\")\n            : unionOrNever(\n                map(\n                  split(\n                    text!,\n                    new RegExp(\n                      `(?<!(?<!\\\\\\\\)\\\\\\\\)[${join2(separators, escapeRegEx)}]`\n                    )\n                  ),\n                  (text) =>\n                    text &&\n                    `^${join2(\n                      // Split on non-escaped asterisk (Characterized by a leading backslash that is not itself an escaped backslash).\n                      split(text, /(?<!(?<!\\\\)\\\\)\\*/),\n                      (part) =>\n                        escapeRegEx(\n                          // Remove backslashes used for escaping.\n                          replace(part, /\\\\(.)/g, \"$1\")\n                        ),\n                      // Join the parts separated by non-escaped asterisks with the regex wildcard equivalent.\n                      \".*\"\n                    )}$`\n                )\n              )\n      )!)\n    : (undefined as any);\n\n/**\n * Better minifyable version of `String`'s `split` method that allows a null'ish parameter.\n */\nexport const split = <T extends string | Nullish>(\n  s: T,\n  separator: RegExp | string,\n  trim = true\n): MaybeUndefined<T, string[]> =>\n  s == null\n    ? undefined\n    : trim\n    ? split(s, separator, false)!.filter(IDENTITY)\n    : (s.split(separator) as any);\n\n/**\n * Better minifyable version of `String`'s `replace` method that allows a null'ish parameter.\n */\nexport const replace = <T extends string | Nullish>(\n  s: T,\n  match: RegExp,\n  replaceValue: string | ((...args: string[]) => string)\n): T => s?.replace(match, replaceValue as any) ?? (s as any);\n","import { Nullish } from \"@tailjs/util\";\nimport { TrackedEvent } from \".\";\n\n/** These properties are used to track the state of events as they get collected, and not stored. */\nexport interface EventMetadata {\n  /** Hint to the request handler that new sessions should not be started if all posted events are passive. */\n  passive?: boolean;\n\n  /** Hint that the event has been queued. */\n  queued?: boolean;\n\n  /** Hint to client code, that the event has been posted to the server. */\n  posted?: boolean;\n}\n\nlet metadata: EventMetadata | undefined;\nexport const clearMetadata = <\n  T extends TrackedEvent | Nullish,\n  ClientSide extends boolean\n>(\n  event: T,\n  client: ClientSide\n): T &\n  (ClientSide extends true\n    ? { metadata?: { posted?: undefined } }\n    : { metadata?: undefined }) => (\n  (metadata = event?.metadata) &&\n    (client\n      ? (delete metadata.posted,\n        delete metadata.queued,\n        !Object.entries(metadata).length && delete event.metadata)\n      : delete event.metadata),\n  event as any\n);\n","import {\n  MaybeUndefined,\n  Nullish,\n  array2,\n  forEach2,\n  isIterable,\n  isString,\n  map2,\n  match,\n} from \"@tailjs/util\";\nimport { ParsableTags, Tag } from \"..\";\n\nconst maybeDecode = <S extends string | Nullish>(s: S): S =>\n  // It qualifies:\n  s &&\n  /^(%[A-F0-9]{2}|[^%])*$/gi.test(s) &&\n  // It needs it:\n  /[A-F0-9]{2}/gi.test(s)\n    ? decodeURIComponent(s)\n    : (s as any);\n\nexport type TagCollection = Map<string, Tag>;\n\nexport const parseTags = <Input extends ParsableTags>(\n  tagString: Input,\n  prefix?: string\n): MaybeUndefined<Input, Tag[]> =>\n  array2(collectTags(tagString, prefix)?.values()) as any;\n\nexport const parseTagValue = <Value extends string | Nullish>(\n  value: string | (string | null)[] | null | undefined,\n  tagName = \"tag\"\n): Value => parseTags(tagName + value)?.[0] as any;\n\nlet key: string;\nlet current: Tag | undefined;\nconst collect = (collected: TagCollection, tag: Tag | Nullish) =>\n  tag &&\n  (!(current = collected.get((key = tag.tag + (tag.value ?? \"\")))) ||\n    (current.score ?? 1) < (tag.score ?? 1)) &&\n  collected.set(key, tag);\n\n/**\n * Parses tags from a string or array of strings and collects them in a map to avoid duplicates.\n * In case of ties between tags with the same names and values but with different scores, the highest wins.\n */\nexport const collectTags = <Input extends ParsableTags>(\n  tagString: Input,\n  prefix = \"\",\n  collected: TagCollection = new Map()\n): MaybeUndefined<Input, TagCollection> => {\n  if (!tagString) return undefined as any;\n  if (isIterable(tagString)) {\n    forEach2(tagString, (input) => collectTags(input, prefix, collected));\n    return collected as any;\n  }\n\n  /**\n   * [namespace::]name[ws*][(:|=)[ws*]value][`~`score] [( |,|;|&|#) more tags]\n   *\n   * The parts of a tail.j tag are:\n   * 1. Optional namespace (utm, ai, cms).\n   *   - Anything not whitespace, colon (`:`) or tilde (`~`) followed by double colon `::`.\n   * 2. Tag name:\n   *   - Anything not whitespace, colon (`:`), tilde `~` or equality (`=`).\n   * 3. Optional value.\n   *   - Anything not a separator a other whitespace than space (` `).\n   *   - If the value is supposed to contain one of these characters it must be quoted in either single (`\\`) or double quotes (`\"`).\n   *   - The tag name and value are separated by either:\n   *     - `:` - Follows normal writing convention in many languages (`country: Denmark, name: Glottal sound`), or\n   *     - `=` - Is what you typically write in programming.\n   *   - Escaping values within quotes is not required. The last quote followed by a terminator or score ends the value. (`tag1: \"This \"value\" contains\" quotes\" tag2=...`)\n   * 4. Optional score. How much the tag applies to the target (for example audience:investors~9 audience:consumers~3 - very relevant for investors, a little bit for consumers).\n   *   - You can use decimals in the score (e.g. 5.343).\n   *   - The parsed score gets divided by 10, so you should generally aim for values between 0 and 10 since that corresponds to a percentage between 0 and 100%.\n   *     This also means that if you output machine generated scores (could be from an algorithm) they tend to already be between 0 and 1, so here you must multiply them with 10 when encoding the tag to get the intended result.\n   *   - The default is 10 (100 %).\n   *\n   *  Tags are separated by either:\n   *     - Space (` `) (input friendly)\n   *     - Hash tag (`#`) - Some people might do that without thinking about it since that is how they normally write tags\n   *     - Comma (`,`) - How most would intuitively join strings in code),\n   *     - Semicolon (`;`) - CSS style\n   *     - Ampersand - URL query string style.\n   *     - Repeated separators gets ignored so don't worry about empty entries if you write something like `tag1,,,,tag2`.\n   *\n   *   Both namespace, name and value will be URI decoded if they contain %xx anywhere in them.\n   */\n\n  isString(tagString)\n    ? match(\n        tagString,\n        /(?:([^\\s:~]+)::(?![ :=]))?([^\\s~]+?)(?:\\s*[:=]\\s*(?:\"((?:\"[^\"]*|.)*?)(?:\"|$)|'((?:'[^'~]*|.)*?)(?:'|$)|((?: *(?:(?:[^,&;#\\s~])))*))\\s*)?(?: *~ *(\\d*(?:\\.\\d*)?))?(?:[\\s,&;#~]+|$)/g,\n        (_, ns, localName: string, quoted1, quoted2, unquoted, score) => {\n          const name =\n            (ns ? maybeDecode(ns) + \"::\" : \"\") +\n            prefix +\n            maybeDecode(localName);\n\n          let tag: Tag = {\n            tag: name,\n            value: maybeDecode(quoted1 ?? quoted2 ?? unquoted),\n          };\n          score &&\n            parseFloat(score) !== 10 &&\n            (tag.score = parseFloat(score) / 10);\n          collect(collected, tag);\n        }\n      )\n    : collect(collected, tagString);\n\n  return collected as any;\n};\n\nexport const encodeTag = <T extends Tag | null | undefined>(\n  tag: T\n): T extends Tag ? string : null | undefined =>\n  tag == null\n    ? (tag as any)\n    : tag.tag +\n      (tag.value\n        ? \":\" + (/[,&;#~]/.test(tag.value) ? '\"' + tag.value + '\"' : tag.value)\n        : \"\") +\n      (tag.score && tag.score !== 1 ? \"~\" + tag.score * 10 : \"\");\n","import {\n  type Domain,\n  type Position,\n  type Rectangle,\n  type ScreenPosition,\n  type Size,\n  type Viewport,\n} from \"@tailjs/types\";\nimport {\n  Binders,\n  F,\n  MAX_SAFE_INTEGER,\n  NOOP,\n  Nullable,\n  T,\n  Unbinder,\n  array2,\n  createEventBinders,\n  createTimeout,\n  forEach2,\n  isArray,\n  nil,\n  parseBoolean,\n  parseUri,\n  replace,\n  restrict,\n  round,\n  tryCatch,\n  type MaybeUndefined,\n  type Nullish,\n} from \"@tailjs/util\";\nimport { body, document, httpDecode, httpDecrypt } from \"..\";\n\nexport type NodeWithParentElement = Node | EventTarget;\n\nexport let MAX_ANCESTOR_DISTANCE = MAX_SAFE_INTEGER;\n\nexport const forAncestorsOrSelf = <T = any>(\n  el: NodeWithParentElement | Nullish,\n  action: (\n    el: Element,\n    returnValue: (value: T | undefined, replace?: boolean) => void,\n    distance: number\n  ) => any,\n  stoppingCriterion: (el: Element, distance: number) => boolean = (\n    el,\n    distance\n  ) => distance >= MAX_ANCESTOR_DISTANCE\n): T | undefined => {\n  let i = 0;\n  let returnValue: any;\n  let stop = F;\n  while (\n    el?.[\"nodeType\"] === 1 &&\n    !stoppingCriterion(el as Element, i++) &&\n    action(\n      el as Element,\n      (value, replace) => (\n        value != nil &&\n          ((returnValue = value), (stop = replace !== T && returnValue != nil)),\n        T\n      ),\n      i - 1\n    ) !== F &&\n    !stop\n  ) {\n    const prev = el;\n    el = (el as Element).parentElement;\n    if (el === null && (prev as Element)?.ownerDocument !== document) {\n      el = (prev as Element)?.ownerDocument.defaultView?.frameElement;\n    }\n  }\n\n  return returnValue;\n};\n\nexport type AttributeValueType =\n  /**\n   * The normalized attribute value, int the sense it gets trimmed and lowercased.\n   * The empty spring is considered undefined.\n   *\n   * This is the default.\n   */\n  | true\n  | \"z\"\n\n  /**\n   * The attribute value as a boolean or undefined if it does match `0`, `1`, `true`, `false` or \"\".\n   * The empty string matches existence of an attribute `<tag attribute/>`.\n   * If parsing arrays of booleans, the empty string will be considered undefined since that is an empty element in this context.\n   */\n  | \"b\"\n\n  /** The attribute value as a number or undefined if it does not look like a number. */\n  | \"n\"\n\n  /** The raw attribute value. */\n  | false\n  | \"r\"\n\n  /**  The attribute value parsed as JSON. */\n  | \"j\"\n\n  /**  The attribute value parsed as a HTTP encoded string (from @tailjs/util/transport). */\n  | \"h\"\n\n  /**  The attribute value parsed as a client encrypted value (from @tailjs/util/transport). This also supports JSON. */\n  | \"e\"\n\n  /**\n   * This means the attribute value will be parsed as an array with elements separated by `,`.\n   * Whitespace is trimmed, and empty values are considered undefined.\n   *\n   * A type may be included in the tuple to parse the items as this type. In this case unparsable values will be included in the array\n   * as undefined.\n   */\n  | readonly [type?: AttributeValueType & string];\n\ntype ParsedAttributeValue<\n  T extends AttributeValueType | Nullish,\n  EncodedType = any\n> = T extends readonly [infer T extends AttributeValueType]\n  ? ParsedAttributeValue<T>[]\n  : T extends (boolean | \"z\" | Nullish) | \"r\"\n  ? string\n  : T extends \"b\"\n  ? boolean | undefined\n  : T extends \"n\"\n  ? number | undefined\n  : T extends \"j\" | \"h\" | \"e\"\n  ? EncodedType | undefined\n  : never;\n\nexport const parseAttributeValue: <\n  V,\n  Type extends AttributeValueType | Nullish = \"z\"\n>(\n  value: V,\n  type: Type\n) => MaybeUndefined<\n  V,\n  Type extends \"b\"\n    ? boolean\n    : V extends \"\"\n    ? undefined\n    : ParsedAttributeValue<Type>\n> = (value: any, type = \"z\" as any) => {\n  if (value == null || value === \"null\" || (value === \"\" && type !== \"b\"))\n    return undefined;\n\n  switch (type) {\n    case true:\n    case \"z\":\n      return (\"\" + value).trim()?.toLowerCase();\n    case false:\n    case \"r\":\n      value;\n    case \"b\":\n      return value === \"\" || parseBoolean(value);\n    case \"n\":\n      return parseFloat(value);\n    case \"j\":\n      return tryCatch(() => JSON.parse(value), NOOP);\n    case \"h\":\n      return tryCatch(() => httpDecode(value), NOOP);\n    case \"e\":\n      return tryCatch(() => httpDecrypt?.(value), NOOP);\n    default:\n      return isArray(type)\n        ? value === \"\"\n          ? undefined\n          : (\"\" + value)\n              .split(\",\")\n              .map(\n                (value) =>\n                  (value =\n                    value.trim() === \"\"\n                      ? undefined\n                      : parseAttributeValue(value, type![0]))\n              )\n        : undefined;\n  }\n};\n\nexport const attr = <\n  Node extends NodeWithParentElement | Nullish,\n  Type extends AttributeValueType | Nullish = \"z\"\n>(\n  node: Node,\n  name: string,\n  type?: Type\n) => parseAttributeValue((node as any)?.getAttribute(name), type);\n\nexport const setAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string,\n  value: any\n) =>\n  value === nil\n    ? (node as any)?.removeAttribute(name)\n    : (node as any)?.setAttribute(name, \"\" + value);\n\nexport const scopeAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string,\n  type?: AttributeValueType\n) => forAncestorsOrSelf(node, (el, value) => value(attr(el, name, type)));\n\nexport const inElementScope = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) =>\n  forAncestorsOrSelf(node, (el, value) =>\n    value(tagName(el) === name || undefined)\n  );\n\nexport const normalizedAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) => attr(node, name)?.trim()?.toLowerCase();\n\nlet value: string | undefined;\n\nexport const booleanAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) => (value = attr(node, name)) === \"\" || parseBoolean(value);\n\nexport const numericAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) => parseFloat(\"\" + (value = attr(node, name))) ?? undefined;\n\nexport const attributeNames = <\n  T extends NodeWithParentElement | Nullish | Nullish\n>(\n  node: T\n): MaybeUndefined<T, string[]> => (node as any)?.getAttributeNames();\n\nexport const cssProperty = (el: Element, name: string) =>\n  getComputedStyle(el).getPropertyValue(name) || nil;\n\nexport const tagName = <T extends Element | Nullish>(\n  el: T\n): T extends Nullish ? null : string => (el != nil ? (el.tagName as any) : nil);\n\nlet pos: Position;\nexport const relativeScrollPos = (): Position => (\n  (pos = scrollPos(F)),\n  {\n    x: pos.x / (body.offsetWidth - window.innerWidth) || 0,\n    y: pos.y / (body.offsetHeight - window.innerHeight) || 0,\n  }\n);\n\nexport const scrollPos = (int?: boolean): Position => ({\n  x: round(scrollX, int),\n  y: round(scrollY, int),\n});\n\nexport const matchExHash = (href1: string, href2: string) =>\n  replace(href1, /#.*$/, \"\") === replace(href2, /#.*$/, \"\");\n\nlet screenPos: Position | undefined;\nexport const getScreenPos = <T extends Element | Nullish>(\n  el: T,\n  mouseEvent?: MouseEvent,\n  includeFold = T\n): MaybeUndefined<ScreenPosition> =>\n  (screenPos = getPos(el, mouseEvent)) &&\n  (restrict<ScreenPosition>({\n    xpx: screenPos.x,\n    ypx: screenPos.y,\n    x: round(screenPos.x / body.offsetWidth, 4),\n    y: round(screenPos.y / body.offsetHeight, 4),\n    pageFolds: includeFold ? screenPos.y / window.innerHeight : undefined,\n  }) as any);\n\nlet x: number;\nlet y: number;\nexport const getPos = <Nulls>(\n  el: Nullable<Element, Nulls>,\n  mouseEvent?: MouseEvent\n): MaybeUndefined<Nulls, Position> => {\n  return !!mouseEvent?.[\"pointerType\"] && mouseEvent?.pageY != nil\n    ? { x: mouseEvent.pageX, y: mouseEvent.pageY }\n    : el\n    ? (({ x, y } = getRect(el)!), { x, y })\n    : (undefined as any);\n};\n\nexport const isVisible = (el: Element | Nullish) => {\n  if (!el || !el.isConnected || getRect(el, false).width <= 0) return false;\n  while (el) {\n    const style = (el.ownerDocument.defaultView as Window)?.getComputedStyle(\n      el\n    );\n\n    if (style.visibility === \"hidden\" || style.opacity === \"0\") {\n      return false;\n    }\n    el = el.parentElement;\n  }\n\n  return true;\n};\n\nlet rect: DOMRect;\nexport const getRect = <Nulls>(\n  el: Nullable<Element, Nulls>,\n  includeScroll = true\n): MaybeUndefined<Nulls, Rectangle> =>\n  el\n    ? ((rect = el.getBoundingClientRect()),\n      (pos = includeScroll ? scrollPos(F) : { x: 0, y: 0 }),\n      {\n        x: round(rect.left + pos.x),\n        y: round(rect.top + pos.y),\n        width: round(rect.width),\n        height: round(rect.height),\n      })\n    : (undefined as any);\n\ntype AllMaps = WindowEventMap &\n  GlobalEventHandlersEventMap &\n  DocumentEventMap &\n  HTMLElementEventMap & {\n    freeze: PageTransitionEvent;\n    resume: PageTransitionEvent;\n  };\n\nexport const listen = <K extends keyof AllMaps>(\n  target: {\n    addEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions\n    ): void;\n    removeEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | EventListenerOptions\n    ): void;\n  },\n  name: K | K[],\n  listener: (\n    ev: AllMaps[K extends any[] ? K[number] : K],\n    unbind: Unbinder\n  ) => any,\n  options: AddEventListenerOptions = { capture: true, passive: true }\n): Binders => {\n  name = array2(name) as any;\n  return createEventBinders(\n    listener,\n    (listener) =>\n      forEach2(name, (name) =>\n        target.addEventListener(name, listener, options)\n      ),\n    (listener) =>\n      forEach2(name, (name) =>\n        target.removeEventListener(name, listener, options)\n      )\n  );\n};\n\nexport const parseDomain = (href: string): Domain => {\n  const { host, scheme, port } = parseUri(href, {\n    delimiters: false,\n    requireAuthority: true,\n  });\n  return { host: host + (port ? \":\" + port : \"\"), scheme };\n};\n\nexport const getViewportSize = (): Size => ({\n  width: window.innerWidth,\n  height: window.innerHeight,\n});\n\nexport const getViewport = (): Viewport => (\n  (pos = scrollPos(T)),\n  {\n    ...pos,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    totalWidth: body.offsetWidth,\n    totalHeight: body.offsetHeight,\n  }\n);\n\nexport type Overlay = {\n  move(rect: DOMRect | Element): Overlay;\n  text(text: string): Overlay;\n  toggle(show: boolean): Overlay;\n};\nexport const overlay = (\n  rect?: DOMRect | Element,\n  text?: string,\n  pulse?: boolean\n): Overlay => {\n  let backdropEl: HTMLElement | undefined;\n  let textEl: HTMLElement | undefined;\n\n  let currentText = text;\n  let currentRect: DOMRect | undefined = rect as any;\n  const ensureElements = () => {\n    if (backdropEl) return true;\n\n    backdropEl = document.createElement(\"div\");\n    backdropEl.style.cssText =\n      \"position:absolute;border:4px solid blue;pointer-events:none;z-index:100\";\n    body.appendChild(backdropEl);\n\n    textEl = document.createElement(\"div\");\n    textEl.style.cssText =\n      \"position:absolute; font-family: sans-serif; font-size: 14px; right: 0; top: 0;margin:10px\";\n    backdropEl.appendChild(textEl);\n\n    overlay.move(currentRect).text(currentText);\n    return false;\n  };\n\n  const cleaner = createTimeout();\n\n  const overlay = {\n    move(rect: DOMRect | Element | Nullish) {\n      currentRect = rect = (rect as Element).getBoundingClientRect?.() ??\n        rect ?? {\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0,\n        };\n\n      if (!ensureElements()) {\n        return overlay;\n      }\n\n      if (!currentRect!.width) {\n        return overlay.toggle(false);\n      }\n\n      let offset = body.getBoundingClientRect();\n      [\"top\", \"left\", \"width\", \"height\"].forEach((p, i) => {\n        backdropEl!.style[p] = rect![p] - (i < 2 ? offset[p] : 0) + \"px\";\n      });\n      offset = backdropEl!.getBoundingClientRect();\n      textEl!.style.top = (offset.top < 0 ? -offset.top : 0) + \"px\";\n\n      textEl!.style.right =\n        (offset.right > window.innerWidth\n          ? offset.right - window.innerWidth\n          : 0) + \"px\";\n\n      return overlay;\n    },\n    text: (text: string | Nullish) => (\n      ensureElements() && (textEl!.innerText = currentText = text ?? \"\"),\n      overlay\n    ),\n\n    toggle(show: boolean) {\n      if (!backdropEl) {\n        if (!show) return overlay;\n        ensureElements();\n      }\n      backdropEl!.style.transition = show ? \"\" : \"opacity 1s .5s\";\n      backdropEl!.style.opacity = show ? \"1\" : \"0\";\n\n      show\n        ? cleaner(false)\n        : cleaner(() => {\n            if (!backdropEl) return;\n            body.removeChild(backdropEl);\n            backdropEl = textEl = undefined;\n          }, 1100);\n      return overlay;\n    },\n  };\n\n  currentRect && overlay.move(currentRect).text(currentText);\n  pulse && overlay.toggle(true).toggle(false);\n\n  return overlay;\n};\n","import {\n  ParsableTags,\n  TagCollection,\n  collectTags,\n  type Tag,\n} from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  concat,\n  flatMap,\n  flatMap2,\n  forEach2,\n  isFunction,\n  isIterable,\n  isPlainObject,\n  isRegEx,\n  isString,\n  join2,\n  matches,\n  nil,\n  parseBoolean,\n  parseRegex,\n  replace,\n  stop,\n  testRegex,\n  type Nullish,\n} from \"@tailjs/util\";\n\nimport {\n  NodeWithParentElement,\n  attr,\n  attributeNames,\n  createElement,\n  cssProperty,\n  forAncestorsOrSelf,\n  matchSelector,\n  trackerConfig,\n} from \"..\";\nimport type { BoundaryData, TagMappings } from \"../..\";\n\nexport const boundaryData = new WeakMap<Node, BoundaryData<true>>();\nexport const getBoundaryData = (el: Node) => boundaryData.get(el);\n\nexport const trackerPropertyName = (name: string, css = F) =>\n  (css ? \"--track-\" : \"track-\") + name;\n\n// const trackerProperty = (\n//   el: Element,\n//   name: string,\n//   value = attr(el, trackerPropertyName(name)),\n//   css = cssProperty(el as Element, trackerPropertyName(name, T))\n// ) => (value ? (css ? value + \" \" + css : value) : css);\n\ntype MatchAttributeRule = readonly [\n  match: RegExp,\n  selector?: string,\n  baseRank?: string\n];\n\ntype CacheMatchRules = [\n  eligibleCache: { [name: string]: boolean },\n  rules: MatchAttributeRule[] | Nullish\n];\n\n/**\n * Extracts an element's tags given an attribute name, and a list of rules about how to match..\n * Since this function is external, its local variables are added as local parameters. Don't tamper.\n *\n * An optional `eligibleCache` can be passed along to speed up rejecting attribute names that definitely don't match anything.\n */\nconst matchAttributeNames = (\n  el: Element | Nullish,\n  cached: CacheMatchRules | Nullish,\n  tags: TagCollection,\n  prefix?: string | boolean,\n  value?: string,\n  eligible?: boolean\n) =>\n  cached?.[1] &&\n  forEach2(\n    attributeNames(el),\n    (name) =>\n      (cached[0][name] ??=\n        ((eligible = F),\n        isString(\n          (prefix =\n            // No cache. Let's loop through them then.\n            forEach2(\n              cached[1],\n              ([match, selector, prefix], _) =>\n                testRegex(name, match) &&\n                // Sneakily we \"delete\" the eligible flag, so the skipNameCache's `??=` assignment will always be reevaluated.\n                // If this code branch is never hit, we return the initial value `false`, and this check will never be performed again.\n                // We do this check before the selector check, since this result is not generally cacheable.\n                ((eligible = undefined),\n                !selector || matchSelector(el, selector)) &&\n                stop(prefix ?? name)\n            ))\n        ) && // The empty string is also \"true\" since it means presence of the attribute without a value (as in `<div tag-yes />).\n          (!(value = el!.getAttribute(name)!) || parseBoolean(value)) &&\n          collectTags(value, replace(prefix, /\\-/g, \":\"), tags),\n        eligible))\n  );\n\n// We cache the tracker configuration's rules for tag mappings.\nlet cachedTagMapper: (el: Element, tags: TagCollection) => void = () => {};\nlet cachedMappings: TagMappings | undefined;\nconst parseTagAttributes = (el: Element, tags: TagCollection) => {\n  if (cachedMappings === (cachedMappings = trackerConfig.tags)) {\n    return cachedTagMapper(el, tags);\n  }\n\n  const parse = (rule: TagMappings[string]): MatchAttributeRule[] =>\n      !rule\n        ? []\n        : isRegEx(rule)\n        ? [[rule]]\n        : isIterable(rule)\n        ? flatMap(rule, parse)\n        : [\n            isPlainObject(rule)\n              ? [parseRegex(rule.match)!, rule.selector, rule.prefix]\n              : [parseRegex(rule)!],\n          ],\n    cache: CacheMatchRules = [\n      {},\n      // Start by checking whether we have any of the good ol', documented, \"tail.js official\" tag attributes.\n      [\n        [/^(?:track\\-)?tags?(?:$|\\-)(.*)/],\n        ...parse(flatMap2(cachedMappings, ([, value]) => value, 1)),\n      ],\n    ];\n\n  (cachedTagMapper = (el: Element, tags: TagCollection) =>\n    matchAttributeNames(el, cache, tags))(el, tags);\n};\n\nconst cssPropertyWithBase = (el: Element, name: string) =>\n  join2(\n    concat(\n      cssProperty(el, trackerPropertyName(name, T)),\n      cssProperty(el, trackerPropertyName(\"base-\" + name, T))\n    ),\n    \" \"\n  );\n\n// We cannot cache as broadly for CSS based rules, so we cache per selector instead.\nconst parsedCssRules: {\n  [rule: string]: CacheMatchRules;\n} = {};\n\nconst parseCssMappingRules = (\n  el: Element,\n  tags: TagCollection,\n  rulesString = cssPropertyWithBase(el, \"attributes\")\n) => {\n  rulesString &&\n    matchAttributeNames(\n      el,\n      (parsedCssRules[rulesString] ??= [\n        {},\n        matches(\n          rulesString,\n          /(?:(\\S+)\\:\\s*)?(?:\\((\\S+)\\)|([^\\s,:]+))\\s*(?!\\S*\\:)/g,\n          (_, prefix, rule1, rule2) =>\n            [parseRegex(rule1 || rule2), , prefix] as const\n        ),\n      ]),\n      tags\n    );\n  collectTags(cssPropertyWithBase(el, \"tags\"), undefined, tags);\n};\n\nlet currentBoundaryData: BoundaryData<true> | Nullish;\nexport const trackerProperty = (\n  el: Element,\n  name: string,\n  inherit:\n    | boolean\n    | ((el: NodeWithParentElement, distance: number) => boolean) = F,\n  boundaryData?: (el: BoundaryData<true>) => string | Nullish\n): string | null =>\n  (inherit\n    ? forAncestorsOrSelf(\n        el,\n        (el, r) => r(trackerProperty(el, name, F)),\n        isFunction(inherit) ? inherit : undefined\n      )\n    : join2(\n        concat(\n          attr(el, trackerPropertyName(name)),\n          cssProperty(el, trackerPropertyName(name, T))\n        ),\n        \" \"\n      )) ??\n  (boundaryData &&\n    (currentBoundaryData = getBoundaryData(el)) &&\n    boundaryData(currentBoundaryData)) ??\n  nil;\n\nlet propertyValue: string | Nullish;\nexport const trackerFlag = (\n  el: Element,\n  name: string,\n  inherit:\n    | boolean\n    | ((el: NodeWithParentElement, distance: number) => boolean) = F,\n  boundaryData?: (data: BoundaryData) => boolean | Nullish\n) =>\n  (propertyValue = trackerProperty(el, name, inherit, boundaryData as any)) ===\n    \"\" || (propertyValue == nil ? propertyValue : parseBoolean(propertyValue));\n\nexport type ParsedTags = { tags?: Tag[] };\n\nexport const parseTags = (\n  sourceEl: Element | Nullish,\n  stoppingCriterion?: (el: Element, distance: number) => boolean,\n  elementTagData?: (el: Element) => ParsableTags,\n  tags?: TagCollection\n): ParsedTags =>\n  !sourceEl\n    ? {}\n    : ((tags ??= new Map()),\n      parseCssMappingRules(sourceEl, tags),\n      forAncestorsOrSelf(\n        sourceEl,\n        (el) => {\n          parseTagAttributes(el, tags!);\n          collectTags(elementTagData?.(el), undefined, tags!);\n        },\n        stoppingCriterion\n      ),\n      tags.size ? { tags: [...tags.values()] } : {});\n\nlet styleElement: Node;\nexport const injectCssDefaults = (document: Document) => {\n  document.body.appendChild(\n    (((styleElement =\n      // --track-base-attributes and --track-base-tags are not set, since they are supposed to be inherited.\n      createElement(\"style\")).innerText = `* { ${trackerPropertyName(\n      \"tags\",\n      T\n    )}:; ${trackerPropertyName(\"attributes\", T)}:;}`),\n    styleElement)\n  );\n};\n","import msgpack from \"@ygoe/msgpack\";\nconst { deserialize: msgDeserialize, serialize: msgSerialize } = msgpack;\n\nimport {\n  IDENTITY,\n  IsNever,\n  Nullish,\n  isArray,\n  isFunction,\n  isIterable,\n  isJsonString,\n  isNumber,\n  isObject,\n  isPlainObject,\n  isString,\n  isSymbol,\n  map2,\n  tryCatch,\n  undefined,\n} from \"@tailjs/util\";\nimport { HashFunction, from64u, lfsr, to64u } from \".\";\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\nexport type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the contract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properties that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param binary whether to serialize to a string (URL safe base 64) or Uint8Array. @default false\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  <Binary extends boolean = false>(\n    value: any,\n    binary?: Binary\n  ): Binary extends true ? Uint8Array : string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(\n  encoded: string | Uint8Array | Nullish\n) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\nconst includeValue = (key: any, value: any, includeDefaultValues: boolean) =>\n  isSymbol(key)\n    ? undefined\n    : includeDefaultValues\n    ? value !== undefined\n    : value === null || value;\n\n/**\n * Converts an in-memory object to a format that can be serialized over a wire including cyclic references.\n */\nconst serialize = <Msgpack extends boolean>(\n  value: any,\n  msgpack: Msgpack,\n  { defaultValues = true, prettify = false }\n): Msgpack extends true ? Uint8Array : string => {\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number | undefined;\n  const patchProperty = (\n    target: any,\n    key: any,\n    value = target[key],\n    patched = includeValue(key, value, defaultValues) ? inner(value) : undefined\n  ) => (\n    value !== patched &&\n      (patched === undefined && !isArray(target)\n        ? delete target[key]\n        : (target[key] = patched),\n      addCleaner(() => (target[key] = value))),\n    patched\n  );\n\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (value == null || isFunction(value) || isSymbol(value)) {\n      return undefined;\n    }\n\n    if (!isObject(value)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if ((refIndex = refs?.get(value)) != null) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isPlainObject(value)) {\n      (refs ??= new Map()).set(value, refs.size + 1);\n      for (const key in value) patchProperty(value, key);\n    } else if (isIterable(value) && !(value instanceof Uint8Array)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : // Handle arrays like [value1,,value3,value4,,,value6]. The missing elements does not serialize well with msgpack.\n            ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  return tryCatch(\n    () =>\n      msgpack\n        ? (msgSerialize(inner(value) ?? null) as any)\n        : tryCatch(\n            () => JSON.stringify(value, undefined, prettify ? 2 : 0),\n            () => JSON.stringify(inner(value), undefined, prettify ? 2 : 0)\n          ),\n    true,\n    () => cleaners?.forEach((cleaner) => cleaner())\n  );\n};\n\n/**\n * Hydrates the format returned by {@link serialize} back to its original in-memory format.\n */\nconst deserialize = (value: string | Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value)) return value;\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return inner(\n    isString(value)\n      ? tryCatch(\n          () => JSON.parse(value as any),\n          () => (\n            console.error(`Invalid JSON received.`, value, new Error().stack),\n            undefined\n          )\n        )\n      : value != null\n      ? tryCatch(\n          () => msgDeserialize(value as any),\n          () => (\n            console.error(\n              `Invalid message received.`,\n              value,\n              new Error().stack\n            ),\n            undefined\n          )\n        )\n      : value\n  );\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<any>\n];\n\nexport interface TransportOptions {\n  /**\n   * Serialize/deserialize as JSON.\n   *\n   * @default false\n   */\n  json?: boolean;\n\n  /**\n   * Omit falsish values (`\"\"`, `0` and `false`) unless explicitly set to `null`.\n   *\n   * @default true\n   */\n  defaultValues?: boolean;\n\n  /** Indent JSON encoded strings. @default true */\n  prettify?: boolean;\n\n  /** Allow received messages to be JSON. */\n  decodeJson?: boolean;\n}\n\nlet _defaultTransports: [cipher: Transport, json: Transport] | undefined;\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lfsr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (\n  key?: string | Nullish,\n  options: TransportOptions = {}\n): Transport => {\n  const factory = (\n    key: string | Nullish,\n    { json = false, decodeJson = false, ...serializeOptions }: TransportOptions\n  ): Transport => {\n    const fastStringHash = (value: any, bitsOrNumeric: any) => {\n      if (isNumber(value) && bitsOrNumeric === true) return value;\n\n      value = isString(value)\n        ? new Uint8Array(map2(value.length, (i) => value.charCodeAt(i) & 255))\n        : json\n        ? tryCatch(\n            () => JSON.stringify(value),\n            () => JSON.stringify(serialize(value, false, serializeOptions))\n          )\n        : serialize(value, true, serializeOptions);\n      return hash(value, bitsOrNumeric);\n    };\n    const jsonDecode = (encoded: any) =>\n      encoded == null\n        ? undefined\n        : tryCatch(() => deserialize(encoded), undefined);\n    if (json) {\n      return [\n        (data: any) => serialize(data, false, serializeOptions) as any,\n        jsonDecode,\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ];\n    }\n    const [encrypt, decrypt, hash] = lfsr(key);\n\n    return [\n      (data: any, binary) =>\n        (binary ? IDENTITY : to64u)(\n          encrypt(serialize(data, true, serializeOptions))\n        ) as any,\n      (encoded: any) =>\n        encoded != null\n          ? deserialize(\n              decrypt(\n                encoded instanceof Uint8Array\n                  ? encoded\n                  : decodeJson && isJsonString(encoded)\n                  ? jsonDecode(encoded)\n                  : from64u(encoded)\n              )\n            )\n          : null,\n      (value: any, numericOrBits?: any) =>\n        fastStringHash(value, numericOrBits) as any,\n    ];\n  };\n\n  if (!key) {\n    let json = +(options.json ?? 0);\n    if (json && options.prettify !== false) {\n      return (_defaultTransports ??= [\n        factory(null, { json: false }),\n        factory(null, { json: true, prettify: true }),\n      ])[+json];\n    }\n  }\n  return factory(key, options);\n};\n\nexport const defaultTransport = createTransport();\n/** A transport that encrypts and decrypts messages, but also allows plain JSON message to be decoded.  */\nexport const defaultJsonDecodeTransport = createTransport(null, {\n  json: true,\n  decodeJson: true,\n});\nexport const defaultJsonTransport = createTransport(null, {\n  json: true,\n  prettify: true,\n});\n\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\nexport const [jsonEncode, jsonDecode] = defaultJsonTransport;\n","import { PATCH_EVENT_POSTFIX } from \"@constants\";\n\nimport {\n  EventPatch,\n  PostRequest,\n  PostResponse,\n  TrackedEvent,\n  clearMetadata,\n  isEventPatch,\n} from \"@tailjs/types\";\nimport {\n  F,\n  Nullish,\n  ToggleArray,\n  array2,\n  clock,\n  clone,\n  concat,\n  count,\n  diff,\n  forEach2,\n  isString,\n  itemize2,\n  map2,\n  merge,\n  merge2,\n  now,\n  pluralize,\n  push,\n  skip2,\n  structuralEquals,\n  throwError,\n  unshift,\n} from \"@tailjs/util\";\nimport {\n  EVENT_POST_FREQUENCY,\n  TrackerContext,\n  addPageVisibleListener,\n  childGroups,\n  debug,\n  request,\n} from \".\";\nimport { UnlockApiCommand } from \"..\";\n\nexport interface EventQueuePostOptions {\n  flush?: boolean;\n  async?: boolean;\n  variables?: PostRequest[\"variables\"];\n}\n\nexport type ProtectedEvent = TrackedEvent & UnlockApiCommand;\n\nconst postCallbacks = Symbol();\nexport const registerPostCallback = <T extends TrackedEvent>(\n  ev: T,\n  callback: (ev: T) => boolean | void\n) => ((ev[postCallbacks] ??= new Set()).add(callback), ev);\n\nexport interface EventQueue {\n  /**\n   * Posts events to the server. Do not post event patches using this method. Use {@link postPatch} instead.\n   * If flush is not explicitly requested, the event will eventually get posted, either by the configured post frequency, or when the user leaves the tab.\n   */\n  post<\n    T extends ToggleArray<ProtectedEvent>,\n    Options extends EventQueuePostOptions | undefined\n  >(\n    events: T,\n    options?: Options\n  ): Promise<Options extends { async: false } ? PostResponse : void>;\n\n  /**\n   *  Posts a patch to an existing event.\n   */\n  postPatch<T extends ProtectedEvent>(\n    target: T,\n    patch: EventPatchData<T>,\n    flush?: boolean\n  ): Promise<void>;\n\n  /**\n   * Registers a passive event.\n   *\n   * The source will get invoked whenever the tab becomes deactivated. If the source returns undefined or false, the source is unregistered.\n   * The return value is a function to manually unregister the source.\n   */\n  registerEventPatchSource<T extends ProtectedEvent>(\n    sourceEvent: T,\n    source: EventPatchSource<T>,\n    initialPost?: boolean,\n    relatedNode?: Node\n  ): () => undefined;\n}\n\nexport type EventPatchData<T extends ProtectedEvent> = Omit<\n  EventPatch<T>,\n  \"patchTargetId\" | \"metadata\" | \"type\"\n> & { type?: undefined };\n\nexport type EventPatchSource<T extends ProtectedEvent = ProtectedEvent> = (\n  current: EventPatchData<T>,\n  unbind: () => undefined\n) => EventPatchData<T> | undefined;\n\nexport const createEventQueue = (\n  url: string,\n  context: TrackerContext,\n  postFrequency = EVENT_POST_FREQUENCY\n): EventQueue => {\n  type Factory = () => [event: EventPatch | undefined, unbinding: boolean];\n  const queue: ProtectedEvent[] = [];\n\n  const snapshots = new WeakMap<ProtectedEvent, any>();\n  const sources = new Map<ProtectedEvent, Factory>();\n\n  const mapPatchTarget = <T extends ProtectedEvent>(\n    sourceEvent: T,\n    patch: EventPatchData<T> | undefined\n  ): EventPatch<T> =>\n    !sourceEvent.metadata?.queued\n      ? throwError(\"Source event not queued.\")\n      : (merge(patch, {\n          type: sourceEvent.type + PATCH_EVENT_POSTFIX,\n          patchTargetId: sourceEvent.clientId,\n        }) as any);\n\n  const updateSnapshot = (ev: ProtectedEvent) => {\n    snapshots.set(ev, clone(ev));\n  };\n\n  const registerEventPatchSource = <T extends ProtectedEvent>(\n    sourceEvent: ProtectedEvent,\n    source: EventPatchSource<T>,\n    initialPost = false,\n    relatedNode?: Node\n  ) => {\n    let unbinding = false;\n    const unbind = (): undefined => {\n      unbinding = true;\n    };\n    updateSnapshot(sourceEvent);\n    registerPostCallback(sourceEvent, updateSnapshot);\n    const factory: Factory = () => {\n      if (relatedNode?.isConnected === false) {\n        unbind();\n      } else {\n        const snapshot = snapshots.get(sourceEvent);\n        const patched = source(snapshot, unbind);\n        debug(\n          { diff: { snapshot, patched }, stack: new Error().stack },\n          \"Patch \" + snapshot.type\n        );\n\n        let [delta, current] = diff(patched, snapshot) ?? [];\n\n        if (delta && !structuralEquals(current, snapshot)) {\n          // The new \"current\" differs from the previous.\n\n          snapshots.set(sourceEvent, clone(current));\n          // Add patch target ID and the correct event type to the delta data before we return it.\n          return [mapPatchTarget(sourceEvent, delta) as any, unbinding];\n        }\n      }\n\n      return [undefined, unbinding];\n    };\n    sources.set(sourceEvent, factory);\n    if (initialPost) {\n      post(sourceEvent);\n    }\n    return unbind;\n  };\n\n  const postEvents = async <Beacon>(\n    events:\n      | ProtectedEvent[]\n      | [apiKey: string | Nullish, events: ProtectedEvent[]],\n    beacon: Beacon = true as any,\n    variables: any\n  ): Promise<Beacon extends true ? void : PostResponse> => {\n    let key: string | Nullish;\n    if (!events[0] || isString(events[0])) {\n      key = events[0];\n      events = events.slice(1) as any;\n    }\n    events = map2(events, (ev: any) => {\n      context?.validateKey(key ?? ev.key);\n      // Update metadata in the source event,\n      // and send a clone of the event without client metadata, and its timestamp in relative time\n      // (the server expects this, and will adjust accordingly to its own time).\n      merge(ev, { metadata: { posted: true } });\n      if (ev[postCallbacks]) {\n        const abort = forEach2(\n          ev[postCallbacks],\n          (callback, _, abort) => callback(ev) === false || abort,\n          false\n        );\n        if (abort) {\n          return undefined;\n        }\n        delete ev[postCallbacks];\n      }\n\n      return merge(clearMetadata(clone(ev), true), {\n        timestamp: ev.timestamp! - now(),\n      });\n    }) as ProtectedEvent[];\n\n    debug(\n      { [childGroups]: map2(events, (ev: ProtectedEvent) => [ev, ev.type, F]) },\n      \"Posting \" +\n        itemize2([\n          pluralize(\"new event\", [\n            count(events, (ev) => !isEventPatch(ev)) || undefined,\n          ]),\n          pluralize(\"event patch\", [\n            count(events, (ev) => isEventPatch(ev)) || undefined,\n          ]),\n        ]) +\n        (beacon ? \" asynchronously\" : \" synchronously\") +\n        \".\"\n    );\n\n    return request<PostRequest>(\n      url,\n      {\n        events,\n        variables,\n        deviceSessionId: context?.deviceSessionId,\n      },\n      { beacon: beacon as any }\n    ) as any;\n  };\n\n  const post = async (\n    events: ToggleArray<ProtectedEvent>,\n    { flush = false, async = true, variables }: EventQueuePostOptions = {}\n  ): Promise<any> => {\n    const newEvents: ProtectedEvent[] = [];\n\n    events = map2(\n      array2(events),\n      (event) => (\n        !event.metadata?.queued && push(newEvents, event),\n        merge2(context.applyEventExtensions(event), {\n          metadata: { queued: true },\n        }) ?? skip2\n      )\n    ) as ProtectedEvent[];\n\n    forEach2(newEvents, (event) => debug(event, event.type));\n\n    if (!async) {\n      return postEvents(events, false, variables);\n    }\n    if (!flush) {\n      events.length && push(queue, ...events);\n      return;\n    }\n\n    if (queue.length) {\n      unshift(events as any, ...queue.splice(0));\n    }\n\n    if (!events.length) return;\n\n    await postEvents(events, true, variables);\n  };\n\n  postFrequency > 0 && clock(() => post([], { flush: true }), postFrequency);\n\n  addPageVisibleListener((visible, unloading, delta) => {\n    // Don't do anything if the tab has only been visible for less than a second and a half.\n    // More than that the user is probably just switching between tabs moving past this one.\n    // NOTE: (This number should preferably be better qualified. We could also look into user activation events).\n    if (!visible && (queue.length || unloading || delta > 1500)) {\n      const updatedEvents = map2(sources, ([sourceEvent, source]) => {\n        const [event, unbinding] = source();\n        unbinding &&\n          (sources.delete(sourceEvent), snapshots.delete(sourceEvent));\n        return event ?? skip2;\n      });\n\n      if (queue.length || updatedEvents.length) {\n        post(concat(queue.splice(0), updatedEvents)!, { flush: true });\n      }\n    }\n  });\n\n  return {\n    post,\n    postPatch: (target, patch, flush) =>\n      post(mapPatchTarget(target, patch), { flush: true }),\n    registerEventPatchSource,\n  };\n};\n","import { CONSENT_INFO_KEY, SCOPE_INFO_KEY } from \"@constants\";\n\nimport { createTransport } from \"@tailjs/transport\";\nimport { isTrackedEvent } from \"@tailjs/types\";\nimport {\n  F,\n  FOREVER,\n  T,\n  array2,\n  assign,\n  filter2,\n  flatMap2,\n  forEach2,\n  isArray,\n  isJsonString,\n  isString,\n  map2,\n  merge2,\n  nil,\n  now,\n  push,\n  remove,\n  sort,\n  stop2,\n  throwError,\n  tryCatch,\n  type Nullish,\n} from \"@tailjs/util\";\nimport {\n  Listener,\n  Tracker,\n  TrackerClientConfiguration,\n  TrackerCommand,\n  TrackerExtension,\n  TrackerExtensionFactory,\n  defaultExtensions,\n  isExtensionCommand,\n  isFlushCommand,\n  isGetCommand,\n  isListenerCommand,\n  isSetCommand,\n  isTagAttributesCommand,\n  isToggleCommand,\n  isTrackerAvailableCommand,\n  postUserAgentEvent,\n} from \".\";\nimport {\n  ERR_INTERNAL_ERROR,\n  ERR_INVALID_COMMAND,\n  TrackerContext,\n  VAR_URL,\n  addDebugListeners,\n  addStateListener,\n  createEventQueue,\n  createVariableStorage,\n  errorLogger,\n  httpDecode,\n  isTracker,\n  logError,\n  nextId,\n  setStorageKey,\n  trackerConfig,\n  window,\n} from \"./lib\";\n\nexport let tracker: Tracker;\nexport const initializeTracker = (\n  config: TrackerClientConfiguration | string\n) => {\n  if (tracker) return tracker;\n  let clientEncryptionKey: string;\n  if (isString(config)) {\n    // Decode the temporary key for decrypting the configuration payload.\n    [clientEncryptionKey, config] =\n      httpDecode<[key: string, configuration: any]>(config)!;\n\n    // Decrypt\n    config = createTransport(clientEncryptionKey, { decodeJson: true })[1](\n      config as any\n    )!;\n  }\n\n  merge2(trackerConfig, [config as TrackerClientConfiguration], {\n    overwrite: true,\n  });\n\n  setStorageKey(remove(trackerConfig, \"encryptionKey\"));\n\n  const apiProtectionKey = remove(trackerConfig, \"key\");\n\n  const queuedCommands = window[trackerConfig.name]?._ ?? [];\n  if (!isArray(queuedCommands)) {\n    throwError(\n      `The global variable for the tracker \"${trackerConfig.name}\" is used for something else than an array of queued commands.`\n    );\n    return;\n  }\n\n  // Extensions / listeners\n  const extensions: [\n    priority: number,\n    extension: TrackerExtension,\n    source: TrackerExtensionFactory\n  ][] = [];\n  let listeners: Listener[] = [];\n  // Extensions may post commands when constructed and while the tracker is initializing\n\n  const callListeners = (event: string, ...args: any[]) => {\n    let keep = T;\n    listeners = filter2(listeners, (listener) =>\n      tryCatch(\n        () => (\n          listener[event]?.(...args, {\n            tracker: tracker,\n            unsubscribe: () => (keep = F),\n          }),\n          keep // Will be set synchronously in the unsubscribe handler before this value is returned.\n        ),\n        errorLogger(listener)\n      )\n    );\n  };\n\n  const pendingStateCommands: TrackerCommand[] = [];\n\n  const trackerContext: TrackerContext = {\n    applyEventExtensions(event) {\n      event.clientId ??= nextId();\n      event.timestamp ??= now();\n\n      insertArgs = T;\n      const skip = forEach2(\n        extensions,\n        ([, extension]) => extension.decorate?.(event) === F && stop2(true)\n      );\n\n      return skip ? undefined : event;\n    },\n    validateKey: (key: string | Nullish, throwIfInvalid = true) =>\n      (!apiProtectionKey && !key) ||\n      key === apiProtectionKey ||\n      ((throwIfInvalid\n        ? throwError(`'${key}' is not a valid key.`)\n        : false) as any),\n  };\n  // Variables\n  const variables = createVariableStorage(VAR_URL, trackerContext);\n\n  // Main\n  const events = createEventQueue(VAR_URL, trackerContext);\n\n  let mainArgs: TrackerCommand[] | null = nil;\n  let currentArg = 0;\n  let insertArgs = F;\n\n  let globalStateResolved = F;\n\n  let ready = false;\n  tracker = ((...commands: (TrackerCommand | string)[]) => {\n    if (!ready) {\n      queuedCommands.push(...commands);\n      return;\n    }\n\n    if (!commands.length) {\n      return;\n    }\n\n    let key: string | Nullish;\n    if (commands.length > 1 && (!commands[0] || isString(commands[0]))) {\n      key = commands[0];\n      commands = commands.slice(1);\n    }\n\n    if (isString(commands[0])) {\n      const payload = commands[0];\n      commands = isJsonString(payload)\n        ? JSON.parse(payload)\n        : httpDecode(payload);\n    }\n\n    let flush = F; // // Flush after these commands, optionally without waiting for other requests to finish (because the page is unloading and we have no better option even though it may split sessions.)\n\n    commands = filter2(\n      flatMap2(commands, (command) =>\n        isString(command) ? httpDecode<TrackerCommand>(command) : command\n      ) as TrackerCommand[],\n      (command) => {\n        if (!command) return F;\n\n        if (isTagAttributesCommand(command)) {\n          trackerConfig.tags = assign(\n            {} as any,\n            trackerConfig.tags,\n            command.tagAttributes\n          );\n        } else if (isToggleCommand(command)) {\n          trackerConfig.disabled = command.disable;\n          return F;\n        } else if (isFlushCommand(command)) {\n          flush = T;\n          return F;\n        } else if (isTrackerAvailableCommand(command)) {\n          command(tracker);\n          return F;\n        }\n        if (\n          !globalStateResolved &&\n          !isListenerCommand(command) &&\n          !isExtensionCommand(command)\n        ) {\n          pendingStateCommands.push(command);\n          return F;\n        }\n        // #endregion\n        return T;\n      }\n    );\n\n    if (!commands.length && !flush) {\n      return;\n    }\n\n    const getCommandRank = (cmd: TrackerCommand) =>\n      isExtensionCommand(cmd)\n        ? -100\n        : isListenerCommand(cmd)\n        ? -50\n        : isSetCommand(cmd)\n        ? -10\n        : isTrackedEvent(cmd)\n        ? 90\n        : 0;\n\n    // Put events last to allow listeners and interceptors from the same batch to work on them.\n    // Sets come before gets to avoid unnecessary waiting\n    // Extensions then listeners are first so they can evaluate the rest.\n    const expanded: TrackerCommand[] = sort(commands, getCommandRank);\n\n    // Allow nested calls to tracker.push from listeners and interceptors. Insert commands in the currently processed main batch.\n    if (\n      mainArgs &&\n      mainArgs.splice(\n        insertArgs ? currentArg + 1 : mainArgs.length,\n        0,\n        ...expanded\n      )\n    )\n      return;\n\n    mainArgs = expanded;\n\n    for (currentArg = 0; currentArg < mainArgs.length; currentArg++) {\n      const command = mainArgs![currentArg];\n\n      if (!command) continue;\n\n      trackerContext.validateKey(key ?? command.key),\n        tryCatch(\n          () => {\n            const command = mainArgs![currentArg];\n            callListeners(\"command\", command);\n            insertArgs = F;\n            if (isTrackedEvent(command)) {\n              events.post(command);\n            } else if (isGetCommand(command)) {\n              variables.get(array2(command.get));\n            } else if (isSetCommand(command)) {\n              variables.set(array2(command.set));\n            } else if (isListenerCommand(command)) {\n              push(listeners, command.listener);\n            } else if (isExtensionCommand(command)) {\n              let extension: TrackerExtension | Nullish;\n              if (\n                (extension = tryCatch(\n                  () => command.extension.setup(tracker),\n                  (e) => logError(command.extension.id, e)\n                )!)\n              ) {\n                push(extensions, [\n                  command.priority ?? 100,\n                  extension,\n                  command.extension,\n                ]);\n                sort(extensions, ([priority]) => priority);\n              }\n            } else if (isTrackerAvailableCommand(command)) {\n              command(tracker); // Variables have already been loaded once.\n            } else {\n              let success = F;\n              for (const [, extension] of extensions) {\n                if ((success = extension.processCommand?.(command) ?? F)) {\n                  break;\n                }\n              }\n              !success &&\n                logError(\n                  ERR_INVALID_COMMAND,\n                  command,\n                  \"Loaded extensions:\",\n                  map2(extensions, (extension) => extension[2].id)\n                );\n            }\n          },\n          (e) => logError(tracker, ERR_INTERNAL_ERROR, e)\n        );\n    }\n\n    mainArgs = nil;\n    if (flush) {\n      events.post([], { flush });\n    }\n  }) as any;\n\n  Object.defineProperty(window, trackerConfig.name, {\n    value: Object.freeze(\n      Object.assign(tracker, {\n        id: \"tracker_\" + nextId(),\n        events,\n        variables,\n        [isTracker]: T,\n      })\n    ),\n    configurable: false,\n    writable: false,\n  });\n\n  // TODO: Add conditional compiler flag.\n  addDebugListeners();\n\n  addStateListener(async (event, _1, _2, unbind) => {\n    // Make sure we have a session on the server before posting anything.\n    // As part of this, we also get the device session ID.\n    if (event === \"ready\") {\n      const [session, consent] = await variables\n        .get([\n          {\n            scope: \"session\",\n            key: SCOPE_INFO_KEY,\n            refresh: true,\n          },\n          {\n            scope: \"session\",\n            key: CONSENT_INFO_KEY,\n            // Refresh the consent status at every new page view in the case the server made changes in the background.\n            // After that, cache it indefinitely since it is presumably only changed by the client until the next page view (in any tab).\n            refresh: true,\n            cache: FOREVER,\n          },\n        ])\n        .values(true);\n\n      trackerContext.deviceSessionId = session.deviceSessionId;\n\n      if (!session.hasUserAgent) {\n        postUserAgentEvent(tracker);\n        session.hasUserAgent = true;\n      }\n      globalStateResolved = true;\n      pendingStateCommands.length && tracker(pendingStateCommands);\n\n      unbind();\n\n      // Now we accept commands.\n      ready = true;\n      tracker(\n        ...map2(defaultExtensions, (extension) => ({ extension })),\n        ...queuedCommands\n      );\n      tracker({ set: { scope: \"view\", key: \"loaded\", value: true } });\n    }\n  }, true);\n\n  return tracker;\n};\n","import { SCOPE_INFO_KEY } from \"@constants\";\n\nimport {\n  LocalID,\n  View,\n  ViewEvent,\n  ViewTimingData,\n  isEventPatch,\n  isViewEvent,\n} from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  add2,\n  array2,\n  clock,\n  createEvent,\n  createTimer,\n  forEach2,\n  map2,\n  nil,\n  now,\n  parseQueryString,\n  parseUri,\n  replace,\n  skip2,\n} from \"@tailjs/util\";\nimport { TrackerExtensionFactory, isChangeUserCommand } from \"..\";\nimport { tracker } from \"../initializeTracker\";\nimport {\n  TAB_ID,\n  addPageVisibleListener,\n  debug,\n  getActiveTime,\n  getViewport,\n  isInternalUrl,\n  listen,\n  matchExHash,\n  nextId,\n  parseDomain,\n  setLocalVariables,\n  tryGetVariable,\n} from \"../lib\";\n\nexport let currentViewEvent: ViewEvent | undefined;\n\nexport const getCurrentViewId = () => currentViewEvent?.clientId;\n\nlet pushPopNavigation: ViewEvent[\"navigationType\"] | undefined;\n\nconst referrerKey = {\n  scope: \"shared\",\n  key: \"referrer\",\n} as const;\n\nexport const pushNavigationSource = (\n  navigationEventId: LocalID,\n  consumed?: () => void\n) => {\n  tracker.variables.set({\n    ...referrerKey,\n    value: [getCurrentViewId()!, navigationEventId],\n  });\n\n  consumed &&\n    tracker.variables.get({\n      // Grr! Intellisense won't use the constant scope and key values if `...referrerKey`.\n      scope: referrerKey.scope,\n      key: referrerKey.key,\n      poll: (current, _, previous) =>\n        current\n          ? true\n          : previous?.[1] === navigationEventId && consumed() && false,\n    });\n};\n\nconst totalDuration = createTimer();\nconst visibleDuration = createTimer();\n\nlet activations = 1;\n\nexport const getVisibleDuration = () => visibleDuration();\n\nconst [addViewChangedListener, dispatchViewChanged] =\n  createEvent<[viewEvent: ViewEvent]>();\n\nexport { addViewChangedListener };\n\nexport const createViewDurationTimer = (started?: boolean) => {\n  const totalTime = createTimer(started, totalDuration);\n  const visibleTime = createTimer(started, visibleDuration);\n  const activeTime = createTimer(started, getActiveTime);\n  const activationsCounter = createTimer(started, () => activations);\n  return (toggle?: boolean, reset?: boolean): ViewTimingData => ({\n    totalTime: totalTime(toggle, reset),\n    visibleTime: visibleTime(toggle, reset),\n    activeTime: activeTime(toggle, reset),\n    activations: activationsCounter(toggle, reset),\n  });\n};\n\nconst timer = createViewDurationTimer();\nexport const getViewTimeOffset = () => timer();\n\nconst [addFrameListenerInternal, callOnFrame] =\n  createEvent<[frame: HTMLIFrameElement]>();\nexport const onFrame: typeof addFrameListenerInternal = (\n  listener,\n  triggerCurrent\n) => {\n  triggerCurrent && forEach2(frames, (frame) => listener(frame, () => false));\n  return addFrameListenerInternal(listener);\n};\n//export { addFrameListener as onFrame };\n\nconst knownFrames = new WeakSet<any>();\nconst frames = document.getElementsByTagName(\"iframe\");\n\nexport const context: TrackerExtensionFactory = {\n  id: \"context\",\n  setup(tracker) {\n    clock(\n      () =>\n        forEach2(\n          frames,\n          (frame) => add2(knownFrames, frame) && callOnFrame(frame)\n        ),\n      500\n    ).trigger();\n\n    // View definitions may be loaded asynchronously both before and after navigation happens.\n    // This means the `definition` property of the current view event is updated independently of its creation.\n    // If the event has already been sent, and additional patch event is sent with the definition.\n    // When a definition has been associated with the current view event, it will not be changed.\n    // Instead any new view definition that arrives before the next navigation is assumed to be for the next view event.\n\n    let pendingViewDefinition: View | undefined;\n\n    tracker.variables.get({\n      scope: \"view\",\n      key: \"view\",\n      poll: (definition) => {\n        if (\n          currentViewEvent == null ||\n          !definition ||\n          currentViewEvent?.definition\n        ) {\n          // Buffer for next navigation.\n          pendingViewDefinition = definition;\n          if (definition?.navigation) {\n            // Post view registered. This was custom navigation that we are not normally intercepting.\n            postView(true);\n          }\n        } else {\n          currentViewEvent.definition = definition;\n          if (currentViewEvent.metadata?.posted) {\n            // Send the definition as a patch because the view event has already been posted.\n            tracker.events.postPatch(currentViewEvent, {\n              definition: pendingViewDefinition,\n            });\n          } else {\n            debug(\n              currentViewEvent,\n              currentViewEvent.type + \" (definition updated)\"\n            );\n          }\n        }\n\n        return true;\n      },\n    });\n\n    let viewIndex =\n      tryGetVariable({ scope: \"tab\", key: \"viewIndex\" })?.value ?? 0;\n    let tabIndex = tryGetVariable({ scope: \"tab\", key: \"tabIndex\" })?.value;\n\n    if (tabIndex == null) {\n      tabIndex =\n        tryGetVariable({ scope: \"shared\", key: \"tabIndex\" })?.value ??\n        // If we are the only tab, we'll see if we can get the number of previous tabs in the session\n        // from the session info variable.\n        (tryGetVariable({ scope: \"session\", key: SCOPE_INFO_KEY })?.value\n          ?.tabs as number) ??\n        0;\n      setLocalVariables(\n        {\n          scope: \"tab\",\n          key: \"tabIndex\",\n          value: tabIndex,\n        },\n        {\n          scope: \"shared\",\n          key: \"tabIndex\",\n          value: tabIndex + 1,\n        }\n      );\n    }\n\n    let currentLocation: string | null = nil;\n\n    const postView = (force = F) => {\n      if (\n        matchExHash(\"\" + currentLocation, (currentLocation = location.href)) &&\n        !force\n      ) {\n        return;\n      }\n\n      const {\n        source: href,\n        scheme,\n        host,\n      } = parseUri(location.href + \"\", { requireAuthority: true });\n      currentViewEvent = {\n        type: \"view\",\n        timestamp: now(),\n        clientId: nextId(),\n        tab: TAB_ID,\n        href,\n        path: location.pathname,\n        hash: location.hash || undefined,\n        domain: { scheme, host },\n        tabNumber: tabIndex + 1,\n        tabViewNumber: viewIndex + 1,\n        viewport: getViewport(),\n        duration: timer(undefined, true),\n      };\n\n      tabIndex === 0 && (currentViewEvent.firstTab = T);\n      tabIndex === 0 && viewIndex === 0 && (currentViewEvent.landingPage = T);\n\n      setLocalVariables({ scope: \"tab\", key: \"viewIndex\", value: ++viewIndex });\n\n      const qs = parseQueryString(location.href);\n      map2(\n        [\"source\", \"medium\", \"campaign\", \"term\", \"content\"],\n        (p, _) =>\n          ((currentViewEvent!.utm ??= {})[p] = array2(qs[`utm_${p}`])?.[0]) ??\n          skip2\n      );\n\n      !(currentViewEvent.navigationType = pushPopNavigation) &&\n        performance &&\n        forEach2(\n          performance.getEntriesByType(\"navigation\"),\n          (entry: PerformanceNavigationTiming) => {\n            currentViewEvent!.redirects = entry.redirectCount;\n            currentViewEvent!.navigationType = replace(\n              entry.type,\n              /\\_/g,\n              \"-\"\n            ) as any;\n          }\n        );\n\n      pushPopNavigation = undefined;\n\n      if ((currentViewEvent.navigationType ??= \"navigate\") === \"navigate\") {\n        // Try find related event and parent tab context if any.\n        // And only if navigating (not back/forward/refresh)\n\n        const referrer = tryGetVariable(referrerKey)?.value;\n\n        if (referrer && isInternalUrl(document.referrer)) {\n          currentViewEvent.view = referrer?.[0];\n          currentViewEvent.relatedEventId = referrer?.[1];\n          tracker.variables.set({ ...referrerKey, value: undefined });\n        }\n      }\n\n      // Referrer\n      const referrer = document.referrer || nil;\n      referrer &&\n        !isInternalUrl(referrer) &&\n        (currentViewEvent!.externalReferrer = {\n          href: referrer,\n          domain: parseDomain(referrer),\n        });\n\n      // If we already have a view definition ready, set this on the event, and reset the buffer.\n      currentViewEvent.definition = pendingViewDefinition;\n      pendingViewDefinition = undefined;\n\n      tracker.events.post(currentViewEvent);\n\n      tracker.events.registerEventPatchSource(currentViewEvent!, () => ({\n        duration: getViewTimeOffset(),\n      }));\n\n      dispatchViewChanged(currentViewEvent);\n    };\n\n    addPageVisibleListener((visible) => {\n      if (visible) {\n        visibleDuration(T);\n        ++activations;\n      } else {\n        visibleDuration(F);\n      }\n    });\n\n    listen(\n      window,\n      \"popstate\",\n      () => ((pushPopNavigation = \"back-forward\"), postView())\n    );\n    forEach2([\"push\", \"replace\"], (name) => {\n      const inner = history[(name += \"State\")];\n      history[name] = (...args: any) => {\n        inner.apply(history, args);\n        pushPopNavigation = \"navigate\";\n        postView();\n      };\n    });\n\n    postView();\n\n    return {\n      processCommand: (command) =>\n        isChangeUserCommand(command) &&\n        (tracker(\n          command.username\n            ? { type: \"login\", username: command.username }\n            : { type: \"logout\" }\n        ),\n        T),\n\n      decorate: (event) => {\n        currentViewEvent &&\n          !isViewEvent(event) &&\n          !isEventPatch(event) &&\n          (event.view = currentViewEvent.clientId);\n      },\n    };\n  },\n};\n","import {\n  ComponentClickIntentEvent,\n  type ActivatedComponent,\n  type ActivatedContent,\n  type ConfiguredComponent,\n  type Rectangle,\n  type UserInteractionEvent,\n} from \"@tailjs/types\";\nimport {\n  F,\n  MaybeUndefined,\n  Nullish,\n  T,\n  array2,\n  concat,\n  filter2,\n  flatMap,\n  forEach2,\n  isString,\n  join2,\n  map2,\n  max,\n  push,\n  set2,\n  some,\n  unshift,\n  update,\n} from \"@tailjs/util\";\nimport {\n  BoundaryCommand,\n  BoundaryData,\n  TrackerExtensionFactory,\n  isDataBoundaryCommand,\n  isScanComponentsCommand,\n} from \"..\";\nimport {\n  NodeWithParentElement,\n  boundaryData,\n  createImpressionObserver,\n  forAncestorsOrSelf,\n  getRect,\n  parseTags,\n  scanAttributes,\n  trackerProperty,\n} from \"../lib\";\nexport type ActivatedDomComponent = ConfiguredComponent & ActivatedComponent;\n\nexport const componentDomConfiguration = Symbol(\"DOM configuration\");\n\nexport const parseActivationTags = (el: Element) =>\n  parseTags(el, undefined, (el) => filter2(array2(boundaryData.get(el)?.tags)));\n\nconst hasComponentOrContent = (boundary?: BoundaryData<true> | null) =>\n  boundary?.component || boundary?.content;\n\nlet entry: BoundaryData<true> | undefined;\nexport const parseBoundaryTags = (el: Element) => {\n  return parseTags(\n    el,\n    (ancestor) =>\n      ancestor !== el && !!hasComponentOrContent(boundaryData.get(ancestor)),\n    (el) => {\n      entry = boundaryData.get(el)!;\n      return (\n        (entry = boundaryData.get(el)) &&\n        flatMap(concat(entry.component, entry.content, entry), \"tags\")\n      );\n    }\n  );\n};\n\nlet content: ActivatedContent[] | undefined;\nconst stripRects = (\n  component: ActivatedDomComponent,\n  keep?: boolean\n): ActivatedDomComponent =>\n  keep\n    ? component\n    : {\n        ...component,\n        rect: undefined,\n        content:\n          (content = component.content) &&\n          map2(content, (content) => ({ ...content, rect: undefined })),\n      };\n\nconst enum IncludeState {\n  Secondary = 0,\n  Primary = 1,\n  Promoted = 2,\n}\n\nexport const getComponentContext = (\n  el: NodeWithParentElement,\n  directOnly = F,\n  includeRegion?: boolean | Nullish\n) => {\n  let collectedContent: ActivatedContent[] = [];\n\n  type Area = {} & string; // For clarity.\n  let collected: (ActivatedDomComponent | Area)[] = [];\n\n  let includeState = IncludeState.Secondary;\n  let rect: Rectangle | undefined;\n\n  forAncestorsOrSelf(el, (el) => {\n    const entry = boundaryData.get(el);\n    if (!entry) {\n      return;\n    }\n\n    if (hasComponentOrContent(entry)) {\n      const components =\n        filter2(array2(entry.component), (entry) => {\n          return (\n            includeState === IncludeState.Secondary ||\n            (!directOnly &&\n              ((includeState === IncludeState.Primary &&\n                entry.track?.secondary !== T) ||\n                entry.track?.promote))\n          );\n        }) ?? [];\n\n      rect =\n        ((includeRegion ?? some(components, (item) => item.track?.region)) &&\n          getRect(el)) ||\n        undefined;\n      const tags = parseBoundaryTags(el);\n      entry.content &&\n        unshift(\n          collectedContent,\n          ...map2(entry.content, (item) => ({\n            ...item,\n            rect,\n            ...tags,\n          }))\n        );\n\n      components?.length &&\n        (unshift(\n          collected,\n          ...map2(\n            components,\n            (item) => (\n              (includeState = max(\n                includeState,\n                item.track?.secondary // INV: Secondary components are only included here if we did not have any components from a child element.\n                  ? IncludeState.Primary\n                  : IncludeState.Promoted\n              )),\n              stripRects(\n                {\n                  ...item,\n                  content: collectedContent.length\n                    ? collectedContent\n                    : undefined,\n                  rect,\n                  ...tags,\n                },\n                !!rect\n              )\n            )\n          )\n        ),\n        (collectedContent = []));\n    }\n\n    const area = entry.area || trackerProperty(el, \"area\");\n    area && unshift(collected, area);\n  });\n\n  let areaPath: string[] | undefined;\n  let components: ActivatedComponent[] | undefined;\n\n  if (collectedContent.length) {\n    // Content without a containing component is gathered in an ID-less component.\n    push(collected, stripRects({ id: \"\", rect, content: collectedContent }));\n  }\n\n  forEach2(collected, (item) => {\n    if (isString(item)) {\n      push((areaPath ??= []), item);\n    } else {\n      item.area ??= join2(areaPath, \"/\");\n      unshift((components ??= []), item);\n    }\n  });\n\n  return components || areaPath\n    ? { components: components, area: join2(areaPath, \"/\") }\n    : undefined;\n};\n\nexport const components: TrackerExtensionFactory = {\n  id: \"components\",\n  setup(tracker) {\n    const impressions = createImpressionObserver(tracker);\n\n    const normalizeBoundaryData = <T extends BoundaryData | Nullish>(\n      data: T\n    ): MaybeUndefined<T, BoundaryData<true>> =>\n      data == null\n        ? (undefined as any)\n        : ({\n            ...data,\n            component: array2(data.component),\n            content: array2(data.content),\n            tags: array2(data.tags),\n          } as BoundaryData<true>);\n\n    const registerComponent = ({\n      boundary: el,\n      ...command\n    }: BoundaryCommand) => {\n      update(boundaryData, el, (current) => {\n        return normalizeBoundaryData(\n          \"add\" in command\n            ? {\n                ...current,\n                component: concat(current?.component, command.component),\n                content: concat(current?.content, command.content),\n                area: command?.area ?? current?.area,\n                tags: concat(current?.tags, command.tags),\n                cart: command.cart ?? current?.cart,\n                track: command.track ?? current?.track,\n              }\n            : \"update\" in command\n            ? command.update(current)\n            : command\n        );\n      });\n\n      impressions(el, boundaryData.get(el));\n    };\n\n    return {\n      decorate(eventData) {\n        // Strip tracking configuration.\n        forEach2(\n          (eventData as UserInteractionEvent).components,\n          (component) => {\n            set2(component as any, \"track\", undefined);\n            forEach2(\n              (eventData as ComponentClickIntentEvent).clickables,\n              (clickable) => set2(clickable as any, \"track\", undefined)\n            );\n          }\n        );\n      },\n      processCommand(cmd) {\n        return isDataBoundaryCommand(cmd)\n          ? (registerComponent(cmd), T)\n          : isScanComponentsCommand(cmd)\n          ? (forEach2(\n              scanAttributes(cmd.scan.attribute, cmd.scan.components),\n              registerComponent\n            ),\n            T)\n          : F;\n      },\n    };\n  },\n};\n","import {\n  Defined,\n  Falsish,\n  If,\n  IsAny,\n  MaybePromiseLike,\n  NotFunction,\n  Nullish,\n  OmitNullish,\n  TogglePromise,\n  UnwrapPromiseLike,\n  Wrapped,\n  delay,\n  isArray,\n  isAwaitable,\n  isBoolean,\n  isError,\n  isFunction,\n  isPlainObject,\n  isString,\n  unwrap,\n} from \"..\";\n\nexport type ErrorGenerator = string | Error | (() => string | Error);\n\nexport const throwError = (\n  error: ErrorGenerator,\n  transform: (string: string) => Error = (message) => new Error(message)\n): never => {\n  throw isString((error = unwrap(error))) ? transform(error) : error;\n};\nexport const throwTypeError = (message: string): never =>\n  throwError(new TypeError(message));\n\ntype CombineTypeTests<T> = T extends []\n  ? {}\n  : T extends [infer F, ...infer Rest]\n  ? F extends (value: any) => value is infer R\n    ? (IsAny<R> extends true ? T : R) & CombineTypeTests<Rest>\n    : never\n  : never;\n\nexport const validate = <\n  T,\n  Validator extends\n    | ((candidate: T) => candidate is any)\n    | ((candidate: T) => R)\n    | [\n        validate: (candidate: T) => any,\n        ...typeTests: ((candidate: T) => candidate is any)[]\n      ]\n    | (R & NotFunction),\n  R\n>(\n  value: T,\n  validate: Validator | R,\n  validationError?: ErrorGenerator,\n  undefinedError?: ErrorGenerator\n): Defined<\n  If<\n    IsAny<Validator>,\n    T,\n    Validator extends readonly [any, ...infer TypeTests]\n      ? CombineTypeTests<TypeTests>\n      : Validator extends ((value: any) => infer R) | infer R\n      ? R extends Falsish\n        ? never\n        : Validator extends (value: any) => value is infer R\n        ? Defined<R>\n        : T\n      : never\n  >\n> =>\n  (\n    isArray(validate)\n      ? validate.every((test) => test(value))\n      : isFunction(validate)\n      ? validate(value)\n      : validate\n  )\n    ? value\n    : required(value, undefinedError ?? validationError) &&\n      (throwError(validationError ?? \"Validation failed.\") as any);\n\nexport class InvariantViolatedError extends Error {\n  constructor(invariant?: string) {\n    super(invariant ? \"INV: \" + invariant : \"An invariant was violated.\");\n  }\n}\n\nexport const structuralEquals = (\n  value1: any,\n  value2: any,\n  depth = -1\n): boolean => {\n  if (value1 === value2) return true;\n  // interpret `null` and `undefined` as the same.\n  if ((value1 ?? value2) == null) return true;\n\n  if (\n    (isArray(value1) || isPlainObject(value1)) &&\n    (isArray(value2) || isPlainObject(value2)) &&\n    value1.length === value2.length\n  ) {\n    let n = 0;\n    for (const key in value1) {\n      if (\n        value1[key] !== value2[key] &&\n        !structuralEquals(value1[key], value2[key], depth - 1)\n      ) {\n        return false;\n      }\n      ++n;\n    }\n    return n === Object.keys(value2).length;\n  }\n  return false;\n};\n\n/** Tests whether a value equals at least one of some other values.  */\nexport const equalsAny: <T extends readonly any[]>(\n  target: any,\n  ...values: T\n) => target is T[number] = ((\n  target: any,\n  singleValue: any,\n  ...otherValues: any\n) =>\n  target === singleValue ||\n  (otherValues.length > 0 &&\n    otherValues.some((value: any) => equalsAny(target, value)))) as any;\n\n/**\n * States an invariant.\n */\nexport const invariant = <T>(\n  test: Wrapped<T | false>,\n  description?: string\n): Defined<T> => {\n  const valid = unwrap(test);\n  return valid != null && valid !== false\n    ? (valid as any)\n    : throwError(new InvariantViolatedError(description));\n};\n\nexport const required = <T>(value: T, error?: ErrorGenerator): OmitNullish<T> =>\n  value != null\n    ? (value as any)\n    : throwError(\n        error ?? \"A required value is missing\",\n        (text) => new TypeError(text.replace(\"...\", \" is required.\"))\n      );\n\nexport const tryCatch = <T, E = true>(\n  expression: () => T,\n  errorHandler: E | (boolean | ((error?: any) => any) | Nullish) = true as any,\n  always?: () => void\n):\n  | T\n  | (E extends Nullish | true\n      ? never\n      : E extends false\n      ? undefined\n      : E extends (...args: any) => infer R\n      ? R extends Error\n        ? never\n        : R extends void\n        ? undefined\n        : R\n      : E) => {\n  try {\n    return expression();\n  } catch (e) {\n    return isFunction(errorHandler)\n      ? isError((e = errorHandler(e)))\n        ? throwError(e)\n        : e\n      : isBoolean(errorHandler)\n      ? console.error(errorHandler ? throwError(e) : e)\n      : (errorHandler as any);\n  } finally {\n    always?.();\n  }\n};\n\nexport type ErrorHandler = Nullish | boolean | ((error: any) => any);\ntype ErrorHandlerResult<Handler> = Handler extends true\n  ? never\n  : Handler extends (...args: any) => infer R\n  ? TogglePromise<UnwrapPromiseLike<R> extends Error ? never : R, R>\n  : void;\n\nconst maybeAwait = <T, R>(\n  value: MaybePromiseLike<T>,\n  action: (value: T) => R\n): R => (value as any)?.then(action) ?? action(value as any);\n\nconst handleError = <Handler extends ErrorHandler>(\n  errorHandler: Handler,\n  error: any,\n  log = true\n): ErrorHandlerResult<Handler> =>\n  errorHandler === false\n    ? undefined\n    : errorHandler === true ||\n      errorHandler == null ||\n      isError((error = errorHandler(error)))\n    ? maybeAwait(\n        error,\n        (error) => (log && console.error(error), throwError(error))\n      )\n    : error;\n\ntype DeferredProperties<T> = { resolved?: Awaited<T> };\n\ntype NotDeferred = { resolved?: undefined };\n\nexport type Deferred<T> = (() => T) & DeferredProperties<T>;\n\nexport type DeferredAsync<T> = Deferred<MaybePromiseLike<T>>;\n\nexport type MaybeDeferred<T> = (T & NotDeferred) | Deferred<T>;\nexport type MaybeDeferredAsync<T> =\n  | ((T | PromiseLike<T>) & NotDeferred)\n  | DeferredAsync<T>;\n\nexport const resolveDeferred: {\n  <T>(value: Deferred<T>): T;\n  <T>(value: T): T;\n} = (value: Deferred<any>) =>\n  isFunction(value) ? (value as any)?.resolved ?? value() : value;\n\n/** A value that is initialized lazily on-demand. */\nexport const deferred = <T>(\n  expression: Wrapped<T>\n): T extends PromiseLike<infer T> ? DeferredAsync<T> : Deferred<T> => {\n  let result: any;\n  const getter = (() => {\n    if (getter.initialized || result) {\n      // Result may either be the resolved value or a pending promise for the resolved value.\n      return result;\n    }\n    result = unwrap(expression) as any;\n    if (result.then) {\n      return (result = result.then((resolvedValue: any) => {\n        getter.initialized = true;\n        return (getter.resolved = result = resolvedValue);\n      }));\n    }\n    getter.initialized = true;\n    return (getter.resolved = result);\n  }) as any;\n  return getter;\n};\n\nexport const asDeferred = <T extends MaybeDeferred<any>>(\n  deferredOrResolved: T\n): T extends Deferred<any> ? T : Deferred<T> =>\n  isFunction(deferredOrResolved)\n    ? deferredOrResolved\n    : (Object.assign(() => deferredOrResolved, {\n        resolved: isAwaitable(deferredOrResolved)\n          ? undefined\n          : deferredOrResolved,\n      }) as any);\n\nclass DeferredPromise<T> extends Promise<T> {\n  private readonly _action: () => Promise<T>;\n  private _result: Promise<T>;\n\n  public get initialized() {\n    return this._result != null;\n  }\n\n  constructor(action: () => Promise<T>) {\n    super(() => {});\n    this._action = action;\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | null\n      | undefined,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | null\n      | undefined\n  ): Promise<TResult1 | TResult2> {\n    return (this._result ??= this._action()).then(onfulfilled, onrejected);\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: any) => TResult | PromiseLike<TResult>)\n      | null\n      | undefined\n  ): Promise<T | TResult> {\n    return (this._result ??= this._action()).catch(onrejected);\n  }\n\n  finally(onfinally?: (() => void) | null | undefined): Promise<T> {\n    return (this._result ??= this._action()).finally(onfinally);\n  }\n}\n\nexport type MaybeDeferredPromise<T> =\n  | (T & { initialized?: boolean })\n  | DeferredPromise<T>;\n\n/**\n * A promise that is initialized lazily on-demand.\n * For promises this is more convenient than {@link deferred}, since it just returns a promise instead of a function.\n */\nexport const deferredPromise = <T>(\n  expression: Wrapped<MaybePromiseLike<T>>\n): DeferredPromise<T> => new DeferredPromise(async () => unwrap(expression));\n\nexport const formatError = (error: any, includeStackTrace?: boolean): string =>\n  !error\n    ? \"(unspecified error)\"\n    : includeStackTrace && error?.stack\n    ? `${formatError(error, false)}\\n${error?.stack}`\n    : error.message\n    ? `${error.name}: ${error.message}`\n    : \"\" + error;\n\nexport const tryCatchAsync = async <\n  T,\n  C,\n  E extends boolean | ((error: any) => MaybePromiseLike<C>),\n  T1 = T\n>(\n  expression: Wrapped<MaybePromiseLike<T>>,\n  errorHandler: E = true as any,\n  always?: () => MaybePromiseLike<any>\n): Promise<T1 | (E extends true ? never : C)> => {\n  try {\n    return (await unwrap(expression)) as any;\n  } catch (e) {\n    if (!isBoolean(errorHandler)) {\n      return (await errorHandler(e)) as any;\n    } else if (errorHandler) {\n      throw e;\n    }\n    // `false` means \"ignore\".\n    console.error(e);\n  } finally {\n    await always?.();\n  }\n\n  return undefined as any;\n};\n\nexport interface RetrySettings<ErrorResult = never> {\n  retries?: number;\n  retryDelay?: number | ((retry: number) => number);\n  errorFilter?: (\n    error: any,\n    retry: number\n  ) => \"throw\" | \"reset\" | \"none\" | void;\n  errorHandler?: (error: any, retry: number) => MaybePromiseLike<ErrorResult>;\n}\nexport const withRetry = async <T, ErrorResult = never>(\n  action: (retry: number, previousError: any) => MaybePromiseLike<T>,\n  {\n    retries = 3,\n    retryDelay = 200,\n    errorFilter,\n    errorHandler,\n  }: RetrySettings<ErrorResult> = {}\n): Promise<T | ErrorResult> => {\n  if (retries <= 0) {\n    retries = 1;\n  }\n  let previousError: any = undefined;\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await action(i, previousError);\n    } catch (error) {\n      previousError = error;\n      const filterAction =\n        i === retries - 1 ? \"throw\" : errorFilter?.(error, i);\n      if (filterAction === \"throw\") {\n        if (errorHandler) {\n          return await errorHandler(error, i);\n        }\n        throw error;\n      } else {\n        await delay(\n          typeof retryDelay === \"function\"\n            ? retryDelay(i + 1)\n            : retryDelay * (0.8 + 0.4 * Math.random())\n        );\n        if (filterAction === \"reset\") {\n          i = -1;\n          previousError = undefined;\n        }\n      }\n    }\n  }\n  return void 0 as never;\n};\n\n/**\n *  No-op function to validate types in TypeScript. Because function parameters are contravariant, passing an event that does not match on all properties will get red wiggly lines)\n */\nexport const restrict: {\n  <T>(item: T): T;\n} = (item: any) => item as any;\n","import { AllKeys, Extends, MaybeUndefined, tryCatch } from \"..\";\n\n/**\n * The ECMAScript primitive types.\n */\nexport type Primitives =\n  | null\n  | undefined\n  | void\n  | boolean\n  | number\n  | bigint\n  | string\n  | symbol\n  | Date;\n\nexport type NonAsync =\n  | Primitives\n  | Iterable<any>\n  | ((...args: any[]) => any)\n  | SimpleObject;\n\n/**\n * Common function type used for projection of [key,value] entries.\n */\nexport type KeyValueProjection<K, V, R> = (\n  entry: [key: K, value: V],\n  index: number\n) => R;\n\n/**\n * Anything but a promise.\n */\nexport type NotPromise = { then?: never };\n\n/**\n * Anything but a function.\n */\nexport type NotFunction =\n  | bigint\n  | boolean\n  | null\n  | number\n  | string\n  | symbol\n  | undefined\n  | {\n      [key: string | number | symbol]: any;\n      [Symbol.hasInstance]?: never;\n    };\n\n/** Shorter than writing all this out, and slightly easier to read. */\nexport type Nullish = null | undefined;\nexport type CaptureNullish<Parameter, Nulls> = (Parameter | Nullish) & Nulls;\nexport type MaybeNullish<ReturnType, Nulls = ReturnType> = Nulls extends Nullish\n  ? Nulls\n  : ReturnType;\n\nexport type PromiseIfPromiseLike<\n  Value,\n  ParameterValue = Value\n> = ParameterValue extends PromiseLike<any>\n  ? Promise<UnwrapPromiseLike<Value>>\n  : Value;\n\nexport const isTruish = <T>(value: T): value is Exclude<T, Falsish> => !!value;\nexport const isTrue = (value: any): value is true => value === T;\nexport const isNotTrue = <T>(value: T): value is Exclude<T, true> =>\n  value !== T;\n\nexport type Falsish = void | null | undefined | 0 | \"\" | false;\nexport type CaptureFalsish<Parameter, Nulls> = (Parameter | Falsish) & Nulls;\nexport type MaybeFalsish<\n  ReturnType,\n  Value = ReturnType\n> = ReturnType extends Falsish\n  ? ReturnType extends Nullish\n    ? ReturnType\n    : undefined\n  : Value;\n\nexport type NullishOrFalse = void | null | undefined | false;\nexport type CaptureNullishOrFalse<Parameter, Nulls> = (\n  | Parameter\n  | NullishOrFalse\n) &\n  Nulls;\n\nexport type MaybeNullishOrFalse<\n  ReturnType,\n  Parameter = ReturnType\n> = Parameter extends NullishOrFalse\n  ? Parameter extends Nullish\n    ? Parameter\n    : undefined\n  : ReturnType;\n\n/** A record type that is neither iterable or a function. */\nexport type SimpleObject<K extends keyof any = keyof any, V = any> = object & {\n  readonly [P in K]?: V;\n} & {\n  [Symbol.iterator]?: never;\n  [Symbol.asyncIterator]?: never;\n  [Symbol.hasInstance]?: never;\n\n  then?(\n    onfulfilled?: ((value: any) => any) | undefined | null,\n    onrejected?: ((reason: any) => any) | undefined | null\n  ): never;\n};\n\nexport type UnwrapPromiseLike<T> = T extends PromiseLike<infer T>\n  ? UnwrapPromiseLike<T>\n  : T;\n\nexport type MaybePromiseLike<T> = T | PromiseLike<T>;\n\nexport type MaybePromise<T> = T | Promise<T>;\n\n/**\n * Shorthand for a value that is optionally awaitable.\n */\nexport type TogglePromise<T, Toggle = boolean> = Toggle extends\n  | true\n  | PromiseLike<any>\n  ? T extends PromiseLike<any>\n    ? T\n    : PromiseLike<T>\n  : T extends PromiseLike<infer T>\n  ? UnwrapPromiseLike<T>\n  : T;\n\n/**\n * Trick for having a function that returns a non-null value, if a formal parameter always has a non-null value,\n * similar to .NET's [NotNullIfNotNull].\n *\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n *\n * @obsolete\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\n/** If any type in a union has a value for the given property that cannot be null'ish.*/\nexport type HasRequiredProperty<T, P> = true extends (\n  T extends infer T\n    ? true extends Extends<\n        Nullish,\n        keyof T extends P ? T[P & keyof T] : P extends keyof T ? T[P] : never\n      >\n      ? false\n      : true\n    : never\n)\n  ? true\n  : false;\n\nexport type IfNever<T, Default> = [T] extends [never] ? Default : T;\nexport type IfNotNever<Test, Value, Default = never> = [Test] extends [never]\n  ? Default\n  : Value;\n\nexport type Filter<T, FilterTypes, Default = never> = IfNever<\n  T extends infer T ? (T extends FilterTypes ? T : never) : never,\n  Default\n>;\n\n/** Returns the type of a property for each type in a union when the type has the given property. */\nexport type Property<T, P> = T extends infer T\n  ? keyof T extends P\n    ? T[P & keyof T]\n    : P extends keyof T\n    ? T[P]\n    : never\n  : never;\n\n/**\n * Creates a new type where with all the properties from any of the specified types.\n * This can make life easier for code working with polymorphic types.\n */\n\nexport type CommonTypeTemplate<Ts> = {\n  [P in AllKeys<Ts>]?: Ts extends infer T\n    ? P extends keyof T\n      ? T[P]\n      : never\n    : never;\n};\n\n/**\n * Maps all null'ish types to `undefined`.\n */\nexport type Undefined<T> = T extends Nullish | void ? undefined : T;\n\nexport type ExpandTypes<\n  Ts,\n  Common = CommonTypeTemplate<Ts>\n> = Ts extends infer T\n  ? {\n      [P in keyof Common]: P extends keyof T ? T[P] : Common[P];\n    }\n  : never;\n\n/* JSON */\n\n/** Merges properties in a union which makes it look prettier in Intellisense. */\nexport type Pretty<T> = T extends infer T ? { [P in keyof T]: T[P] } : never;\n\n/**\n * Use for function parameters where you want an array to be interpreted as as tuple with a finite number of elements.\n *\n * By suggesting a parameter may be a one-tuple, TypeScript will treat the argument as a tuple,\n * also if there are more than one element.\n */\nexport type TupleParameter<T> = readonly T[] | readonly [T];\n\n/** Minify friendly version of `false`. */\nexport const undefined = void 0;\n\n/** Caching this value potentially speeds up tests rather than using `Number.MAX_SAFE_INTEGER`. */\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/** Caching this value potentially speeds up tests rather than using `Number.MAX_SAFE_INTEGER`. */\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\n\n/** Minify friendly version of `false`. */\nexport const F = false;\n\n/** Minify friendly version of `true`. */\nexport const T = true;\n\n/** Minify friendly version of `null`. */\nexport const nil = null;\n\nexport type NoOpFunction = (...args: any) => void;\n\n/** A function that does nothing. */\nexport const NOOP: NoOpFunction = () => {};\n\nexport type IdentityFunction = <T>(item: T, ...args: any) => T;\n\n/** The identity function (x)=>x. */\nexport const IDENTITY: IdentityFunction = (item: any) => item;\n\nexport type NullFilterFunction = <T>(item: T | Nullish) => boolean;\n\n/** A function that filters out values != null. */\nexport const FILTER_NULLISH: NullFilterFunction = (item: any) => item != nil;\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = <V, P extends boolean = true>(\n  value: V,\n  parse?: P\n) => T extends Nullish\n  ? undefined\n  : V extends T\n  ? V\n  : (true extends P ? T : never) | undefined;\n\n/** Using this cached value speeds up testing if an object is iterable seemingly by an order of magnitude. */\nexport const symbolIterator = Symbol.iterator;\n\n/** Using this cached value speeds up testing if an object is iterable seemingly by an order of magnitude. */\nexport const symbolAsyncIterator = Symbol.asyncIterator;\n\nexport const createTypeConverter =\n  /*#__PURE__*/\n\n    <T>(\n      typeTester: TypeTester<T>,\n      parser?: (value: any) => T | undefined\n    ): TypeConverter<T> =>\n    (value: any, parse = true as any) =>\n      typeTester(value)\n        ? value\n        : parser && parse && value != null && (value = parser(value)) != null\n        ? value\n        : (undefined as any);\n\nexport const ifDefined = <T, P, R>(\n  value: T,\n  resultOrProperty: (\n    | (AllKeys<T> & (keyof any & {}))\n    | ((value: Exclude<T, Nullish>) => R)\n  ) &\n    P\n): MaybeUndefined<T, P extends keyof any ? Exclude<T, Nullish> : R> =>\n  isFunction(resultOrProperty)\n    ? value !== undefined\n      ? (resultOrProperty(value as any) as any)\n      : undefined\n    : value?.[resultOrProperty as any] !== undefined\n    ? value\n    : undefined;\n\nexport const isNullish = (value: any): value is undefined | void | null =>\n  value == null;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\n\nexport const parseBoolean = createTypeConverter(isBoolean, (value) =>\n  value == 0 // Both numbers and string with the value 0 or 1\n    ? false\n    : value == 1\n    ? true\n    : value === \"false\"\n    ? false\n    : value === \"true\"\n    ? true\n    : undefined\n);\n\nexport type FalsishToUndefined<\n  T,\n  Undefined = undefined\n> = T extends readonly any[]\n  ? { [P in keyof T]: FalsishToUndefined<T[P]> }\n  : T extends Falsish\n  ? Undefined\n  : T;\n\nexport const isFalsish = (value: any): value is Falsish => !value;\n\nexport const isFalse = (value: any): value is false => value === F;\nexport const isNotFalse = <T>(value: T): value is Exclude<T, false> =>\n  value !== F;\n\nexport const truish: {\n  <T>(items: Iterable<T | Falsish>, keepUndefined?: false): T[];\n  <T>(items: Iterable<T>, keepUndefined: true): (T extends Falsish\n    ? undefined\n    : T)[];\n  <T extends { [Symbol.iterator]?: never } | string>(\n    value: T | Falsish\n  ): T extends Falsish ? undefined : Exclude<T, Falsish>;\n} = (value: any, keepUndefined?: boolean) =>\n  isArray(value)\n    ? keepUndefined\n      ? value.map((item) => (!!item ? item : undefined))\n      : value.filter((item: any) => !!item)\n    : !!value\n    ? (value as any)\n    : undefined;\n\nexport const isInteger: (value: any) => value is number =\n  Number.isSafeInteger as any;\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\n\nexport const isFinite: (value: any) => value is number = Number.isFinite as any;\n\nexport const parseNumber = createTypeConverter(isNumber, (value) =>\n  isNaN((value = parseFloat(value))) ? undefined : value\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\n\nexport const parseBigInt = createTypeConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createTypeConverter(isString, (value) =>\n  value?.toString()\n);\n\nexport const isArray: <T>(\n  value: readonly any[] | T\n) => value is T extends any[]\n  ? any[]\n  : unknown extends T\n  ? any[]\n  : readonly any[] = Array.isArray as any;\n\nexport const isError = /*#__PURE__*/ (value: any): value is Error =>\n  value instanceof Error;\n\n/**\n * Returns the value as an array following these rules:\n * - If the value is undefined (this does not include `null`), so is the return value.\n * - If the value is already an array its original value is returned unless `clone` is true. In that case a copy of the value is returned.\n * - If the value is iterable, an array containing its values is returned\n * - Otherwise, an array with the value as its single item is returned.\n */\nexport const array: {\n  // <T>(value: AsyncIterable<T>, clone?: boolean): MaybeUndefined<\n  //   [T][0],\n  //   Promise<T[]>\n  // >;\n  <T>(value: T, clone?: boolean): T extends any\n    ? unknown[] extends T\n      ? any[]\n      : T extends Nullish\n      ? undefined\n      : T extends Iterable<infer Item>\n      ? T extends Item[]\n        ? T\n        : Item[]\n      : T[]\n    : never;\n} = /*#__PURE__*/ (value: any, clone = false as any): any =>\n  value == null\n    ? undefined\n    : !clone && isArray(value)\n    ? value\n    : isIterable(value)\n    ? [...value]\n    : ([value] as any);\n\nexport const isObject = /*#__PURE__*/ (\n  value: any\n): value is object & Record<any, any> => value && typeof value === \"object\";\n\nexport const isPlainObject = /*#__PURE__*/ (\n  value: any\n): value is SimpleObject<keyof any, any> => value?.constructor === Object;\n\nexport const hasProperty = /*#__PURE__*/ <P extends keyof any>(\n  value: any,\n  property: P\n): value is { [Prop in P]: any } => isObject(value) && property in value;\n\nexport const hasMethods = /*#__PURE__*/ <Names extends readonly (keyof any)[]>(\n  value: any,\n  ...names: Names\n): value is {\n  [P in Names[number]]: (...args: any) => any;\n} =>\n  value == null\n    ? false\n    : names.every((name) => typeof value[name] === \"function\");\n\nexport const hasMethod = /*#__PURE__*/ <Name extends keyof any>(\n  value: any,\n  name: Name\n): value is {\n  [P in Name]: (...args: any) => any;\n} => typeof (value as any)?.[name] === \"function\";\n\nexport const isDate = /*#__PURE__*/ (value: any): value is Date =>\n  value instanceof Date;\nexport const parseDate = createTypeConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = /*#__PURE__*/ (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = /*#__PURE__*/ (\n  value: any\n): value is (...args: any) => any => typeof value === \"function\";\n\nexport const isPromiseLike = /*#__PURE__*/ (\n  value: any\n): value is PromiseLike<any> => !!value?.[\"then\"];\n\nexport const isIterable = /*#__PURE__*/ (\n  value: any,\n  acceptStrings = false\n): value is Iterable<any> =>\n  !!(value?.[symbolIterator] && (typeof value !== \"string\" || acceptStrings));\n\nexport const isAsyncIterable = /*#__PURE__*/ (\n  value: any\n): value is AsyncIterable<any> => !!value?.[symbolAsyncIterator];\n\nexport const toIterable = /*#__PURE__*/ <T>(\n  value: T | Iterable<T>\n): Iterable<T> => (isIterable(value) ? value : [value]);\n\nexport const asMap: <T extends Iterable<readonly [any, any]> | Nullish>(\n  values: T\n) => T extends Iterable<readonly [infer Key, infer Value]>\n  ? Map<Key, Value>\n  : undefined = /*#__PURE__*/ (values: any): any =>\n  values == null ? undefined : new Set(values);\n\nexport const isMap = /*#__PURE__*/ (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const asSet: <T extends Iterable<any> | Nullish>(\n  values: T\n) => T extends Iterable<infer T> ? Set<T> : undefined = /*#__PURE__*/ (\n  values: any\n): any => (values == null ? undefined : new Set(values));\n\nexport const isSet = /*#__PURE__*/ (value: any): value is Set<any> =>\n  value instanceof Set;\n\nexport const isAwaitable = /*#__PURE__*/ (value: any): value is Promise<any> =>\n  !!value?.then;\n\n/**\n * If the value is a promise, it will be awaited.\n */\nexport const awaitIfAwaitable = <T, R>(\n  value: T,\n  action: (value: T extends PromiseLike<infer T> ? T : T) => R\n): TogglePromise<R, T> =>\n  (value as any)?.then?.((value: any) => action(value)) ?? action(value as any);\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == null\n    ? value === null\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\n/**\n * Round a number of to the specified number of decimals.\n */\nexport const round = <T extends number | Nullish>(\n  number: T,\n  decimals?: number | boolean\n): MaybeUndefined<T, number> =>\n  number == null\n    ? (undefined as any)\n    : decimals === false\n    ? number\n    : ((decimals = Math.pow(10, !decimals || decimals === true ? 0 : decimals)),\n      Math.round(number * decimals) / decimals);\n\nconst testFirstLast = (s: string, first: string, last: string) =>\n  s[0] === first && s[s.length - 1] === last;\n\nexport const isJsonString = (value: any): boolean =>\n  isString(value) &&\n  (testFirstLast(value, \"{\", \"}\") || testFirstLast(value, \"[\", \"]\"));\n\nexport type Mutable<T> = T extends\n  | Map<any, any>\n  | WeakMap<any, any>\n  | Set<any>\n  | WeakSet<any>\n  ? T\n  : T extends ReadonlyMap<infer K, infer V>\n  ? Map<K, V>\n  : T extends ReadonlySet<infer K>\n  ? Set<K>\n  : T extends Primitives\n  ? T\n  : { -readonly [P in keyof T]: Mutable<T[P]> };\n\n/** For when an object that contains internal state that needs to be changed is exposed as read-only public property. */\nexport const mutate2 = /*#__PURE__*/ <T>(target: T): Mutable<T> =>\n  target as any;\n","import {\n  AllKeys,\n  AnyAll,\n  ArraysAsEmpty,\n  Entries,\n  Extends,\n  FILTER_NULLISH,\n  Falsish,\n  GeneralizeConstants,\n  If,\n  IfNot,\n  IterableOrArrayLike,\n  KeyValuePairsToObject,\n  KeyValueSource,\n  KeyValueSourcesToObject,\n  MAX_SAFE_INTEGER,\n  MaybeUndefined,\n  Nullish,\n  OmitNullish,\n  Property,\n  SimpleObject,\n  StrictUndefined,\n  Subtract,\n  UndefinedIfEmpty,\n  UnionToIntersection,\n  add,\n  array,\n  array2,\n  get,\n  ifDefined,\n  isArray,\n  isBoolean,\n  isFalsish,\n  isFunction,\n  isIterable,\n  isMap,\n  isNumber,\n  isObject,\n  isPlainObject,\n  isSet,\n  isString,\n  isTruish,\n  symbolIterator,\n  undefined,\n} from \".\";\n\nexport const UTF16MAX = 0xffff;\n\nlet stopInvoked = false;\nexport const stop = (yieldValue?: any) => ((stopInvoked = true), yieldValue);\n\nexport const toCharCodes = (s: string) =>\n  [...new Array(s.length)].map((_, i) => s.charCodeAt(i));\nexport const codePoint = (string: string, index: number = 0) =>\n  string.codePointAt(index)!;\n\nexport type ProperIteratorSource = Iterable<any> | SimpleObject;\nexport type IteratorSource =\n  | Nullish\n  | number\n  | Iterable<any>\n  | SimpleObject\n  | NavigatingIteratorStep;\n\nexport type IteratorSourceOf<T> =\n  | (T extends number ? number : never)\n  | Iterable<T>\n  | (T extends readonly [infer K, infer V]\n      ? K extends keyof any\n        ? SimpleObject<K, V>\n        : never\n      : never)\n  | NavigatingIteratorStep<T>;\n\nexport type IteratorItem<S extends IteratorSource> = unknown extends S\n  ? any\n  : S extends number\n  ? number\n  : S extends Iterable<infer T>\n  ? T\n  : S extends SimpleObject<infer K, infer V>\n  ? readonly [K, V]\n  : S extends ArrayLike<infer T>\n  ? T\n  : S extends (...args: any) => infer T | Nullish\n  ? T\n  : never;\n\nexport type IteratorItems<S extends readonly IteratorSource[]> =\n  S extends readonly [infer S]\n    ? IteratorItem<S & IteratorSource>\n    : S extends readonly [infer S, ...infer Rest]\n    ? IteratorItem<S & IteratorSource> | IteratorItems<Rest & IteratorSource[]>\n    : S extends readonly (infer S)[]\n    ? IteratorItem<S & IteratorSource>\n    : never;\n\nexport interface IteratorControl<S extends IteratorSource> {\n  source: S;\n  prev: IteratorItem<S> | undefined;\n  skip(): void;\n  end(): void;\n  end<P>(value: P): P;\n}\n\nexport type FunctionalIteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = any,\n  Value = IteratorItem<S>\n> = (\n  value: Value,\n  index: number\n) => Projection | readonly [any, any] | typeof stop | Nullish;\n\nexport type IteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = unknown,\n  Value = IteratorItem<S>\n> = AllKeys<Value> | FunctionalIteratorAction<S, Projection, Value>;\n\n// We need both the inferred return value from the IteratorAction and the IteratorAction itself used as the parameter\n// in functions like `<S extends IteratorSource, Return, Action>(source: S, action: IteratorAction<S,Return> | P)=>IteratorProjection<S,Return,Action>.\n// It is important to set the generic type for Action's default value to undefined\n// This seems to be the only way we can both automatically infer non-readonly tuples from `()=>[\"test\", 1]` as tuples, and at the same time\n// allow property names from the source's items. If we did not include the parameter itself it would not be possible to differentiate\n// between property names and return values.\ntype IteratorProjection<\n  S extends IteratorSource,\n  Return,\n  Action,\n  Default = IteratorItem<S>\n> = Action extends Nullish\n  ? Default\n  : unknown extends Action\n  ? Default\n  : Action extends keyof any\n  ? Exclude<Property<IteratorItem<S>, Action>, Nullish>\n  : Return;\n\ntype IteratorProjectionWithUndefined<\n  S extends IteratorSource,\n  Return,\n  Action,\n  Default = IteratorItem<S>\n> =\n  | IteratorProjection<S, Return, Action, Default>\n  | (Action extends (...args: any) => infer R\n      ? R extends typeof stop\n        ? undefined\n        : StrictUndefined<R>\n      : Action extends keyof any\n      ? StrictUndefined<Property<IteratorItem<S>, Action>>\n      : never) extends infer T\n  ? T\n  : never;\n\ntype StartEndArgs<S extends IteratorSource> =\n  | []\n  | (S extends number\n      ? [offset?: number | Nullish]\n      : S extends NavigatingIteratorStep<infer T>\n      ? [seed?: T, maxIterations?: number]\n      : [start: number | Nullish, end?: number | Nullish]);\n\nexport type NavigatingIteratorStep<T = any> = (\n  current: T | undefined\n) => T | undefined;\n\ntype FlatIteratorItem<T, D extends number = 1, Object = false> = T extends\n  | undefined\n  | void\n  ? never\n  : D extends 0\n  ? T\n  : T extends\n      | Iterable<any>\n      | (Object extends true ? Record<keyof any, any> : never)\n  ? D extends 1\n    ? IteratorItem<T>\n    : FlatIteratorItem<IteratorItem<T>, Subtract<D, 1>, Object>\n  : T;\n\nconst wrapProjection = <P>(\n  projection: P | undefined\n): undefined | ((item: any, index: number) => any) =>\n  projection == null\n    ? undefined\n    : isFunction(projection)\n    ? (projection as any)\n    : (item) => item[projection as any];\n\nfunction* createFilteringIterator<S extends IteratorSource, R, P>(\n  source: S,\n  projection?: IteratorAction<S, R> | P\n): Iterable<IteratorProjection<S, R, P>> {\n  if (source == null) return;\n  if (projection) {\n    projection = wrapProjection(projection)!;\n    let i = 0;\n    for (let item of source as any) {\n      if ((item = projection(item, i++)) != null) {\n        yield item;\n      }\n      if (stopInvoked) {\n        stopInvoked = false;\n        break;\n      }\n    }\n  } else {\n    for (let item of source as any) {\n      if (item != null) yield item;\n    }\n  }\n}\n\nfunction* createObjectIterator<S extends Record<keyof any, any>, R, P>(\n  source: S,\n  action?: IteratorAction<S, R> | P\n): Iterable<IteratorProjection<S, P, R>> {\n  action = wrapProjection(action);\n  let i = 0;\n  for (const key in source) {\n    let value = [key, source[key]] as any;\n    action && (value = action(value, i++));\n\n    if (value != null) {\n      yield value;\n    }\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n}\n\nfunction* createRangeIterator(length = 0, offset?: number): Iterable<number> {\n  if (length < 0) {\n    offset ??= -length - 1;\n    while (length++) yield offset--;\n  } else {\n    offset ??= 0;\n    while (length--) yield offset++;\n  }\n}\n\nexport function* createStringIterator(\n  input: string,\n  start: number,\n  end: number\n): Iterable<[char: string, codePoint: number]> {\n  while (start < end) {\n    const codePoint = input.codePointAt(start)!;\n    let p = input[start++];\n    if (codePoint > UTF16MAX) {\n      start++;\n      p = String.fromCodePoint(codePoint);\n    }\n    yield [p, codePoint];\n  }\n}\n\nexport function* createNavigatingIterator<T>(\n  step: NavigatingIteratorStep<T>,\n  start?: T | undefined,\n  maxIterations = Number.MAX_SAFE_INTEGER\n): Iterator<T> {\n  if (start != null) yield start;\n  while (maxIterations-- && (start = step(start)) != null) {\n    yield start;\n  }\n}\n\nconst sliceAction = <S extends IteratorSource, R, P>(\n  action: IteratorAction<S, R> | P,\n  start: any,\n  end: any\n): P =>\n  (start ?? end) !== undefined\n    ? ((action = wrapProjection(action)!),\n      (start ??= 0),\n      (end ??= MAX_SAFE_INTEGER),\n      (value, index) =>\n        start--\n          ? undefined\n          : end!--\n          ? action\n            ? (action as any)(value, index)\n            : value\n          : end)\n    : (action as any);\n\nexport type IteratorFilter<S extends IteratorSource> = (\n  value: IteratorItem<S>,\n  index: number\n) => unknown;\n\n/** Faster way to exclude null'ish elements from an array than using {@link filter} or {@link map} */\nexport const filterArray = <T extends readonly any[] | undefined>(\n  array: T\n): T extends readonly (infer Item)[] ? OmitNullish<Item>[] : undefined =>\n  array?.filter(FILTER_NULLISH) as any;\n\nconst createIterator = <S extends IteratorSource, R, P>(\n  source: S,\n  projection?: IteratorAction<S, R> | P,\n  start?: any,\n  end?: any\n): Iterable<IteratorProjection<S, R, P>> =>\n  source == null\n    ? ([] as any)\n    : !projection && isArray(source)\n    ? filterArray(source)\n    : source[symbolIterator]\n    ? createFilteringIterator(\n        source,\n        start === undefined\n          ? projection\n          : sliceAction(projection, start as any, end)\n      )\n    : isObject(source)\n    ? createObjectIterator(\n        source as any,\n        sliceAction(projection, start as any, end)\n      )\n    : createIterator(\n        isFunction(source)\n          ? createNavigatingIterator(source, start, end)\n          : (createRangeIterator(source as number, start as any) as any),\n        projection\n      );\n\nconst mapToArray = <T, M>(\n  projected: Iterable<T>,\n  map: M\n): true extends M ? T[] : Iterable<T> =>\n  map && !isArray(projected) ? [...projected] : (projected as any);\n\ntype ProjectFunction = {\n  <S extends IteratorSource, R, P extends IteratorAction<S, R>>(\n    source: S,\n    projection?: P,\n    ...rest: StartEndArgs<S>\n  ): Iterable<IteratorProjection<S, R, P>>;\n};\n\ntype MapFunction = {\n  <S extends IteratorSource, R, P extends FunctionalIteratorAction<S, R>>(\n    source: S,\n    projection?: undefined,\n    ...rest: StartEndArgs<S>\n  ): MaybeUndefined<S, Exclude<IteratorItem<S>, Nullish>[]>;\n  <S extends IteratorSource, R>(\n    source: S,\n    projection: FunctionalIteratorAction<S, R>,\n    ...rest: StartEndArgs<S>\n  ): MaybeUndefined<S, Exclude<R, Nullish>[]>;\n\n  <S extends IteratorSource, Key extends AllKeys<S>>(\n    source: S,\n    projection: Key,\n    ...rest: StartEndArgs<S>\n  ): MaybeUndefined<S, Exclude<Property<IteratorItem<S>, Key>, Nullish>[]>;\n};\n\ntype FlatProjectFunction = <\n  S extends IteratorSource,\n  R,\n  P,\n  D extends number = 1,\n  O extends boolean = false\n>(\n  source: S,\n  projection?: IteratorAction<S, R> | P,\n  depth?: D,\n  expandObjects?: O,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<\n  S,\n  Iterable<FlatIteratorItem<IteratorProjection<S, R, P>, D, O>>\n>;\n\nexport const project: ProjectFunction = ((\n  source: any,\n  projection: any,\n  start: any,\n  end: any\n) => createIterator(source, projection, start, end)) as any;\n\nfunction* flattenInternal(\n  value: any,\n  depth: number,\n  expandObjects: boolean,\n  nested: boolean\n) {\n  if (value != null) {\n    if (value[symbolIterator] || (expandObjects && isObject(value))) {\n      for (const item of nested ? createIterator(value) : value) {\n        if (depth !== 1) {\n          yield* flattenInternal(item, depth - 1, expandObjects, true);\n        } else {\n          yield item;\n        }\n      }\n    } else {\n      yield value;\n    }\n  }\n}\nexport const flatten: FlatProjectFunction = (\n  source,\n  projection?,\n  depth = 1 as any,\n  expandObjects: any = false,\n  start?: any,\n  end?: any\n) =>\n  flattenInternal(\n    createIterator(source, projection as any, start, end),\n    depth + 1,\n    expandObjects,\n    false\n  ) as any;\n\nexport const map: MapFunction = (\n  source: any,\n  projection?: any,\n  start?: any,\n  end?: any\n) => {\n  projection = wrapProjection(projection);\n  if (isArray(source)) {\n    let i = 0;\n    const mapped: any[] = [];\n    start = start! < 0 ? source.length + start! : start ?? 0;\n    end = end! < 0 ? source.length + end! : end ?? source.length;\n    for (; start < end && !stopInvoked; start++) {\n      let value = source[start];\n      if ((projection ? (value = projection(value, i++)) : value) != null) {\n        mapped.push(value);\n      }\n    }\n    stopInvoked = false;\n    return mapped;\n  }\n  return source != null\n    ? array2(project(source, projection, start, end))\n    : (undefined as any);\n};\n\nexport const mapAsync: <S extends IteratorSource, R, P>(\n  source: S,\n  projection: IteratorAction<S, R> | P,\n  ...rest: StartEndArgs<S>\n) => Promise<\n  MaybeUndefined<S, Exclude<Awaited<IteratorProjection<S, R, P>>, Nullish>[]>\n> = async (source: any, projection?: any, start?: any, end?: any) => {\n  projection = wrapProjection(projection);\n  const mapped: any = [];\n  await forEachAsync(\n    source,\n    async (item) => (item = await projection(item)) != null && mapped.push(item)\n  );\n  return mapped as any;\n};\n\nexport const zip = <Lhs extends IteratorSource, Rhs extends IteratorSource>(\n  lhs: Lhs,\n  rhs: Rhs\n): Iterable<[IteratorItem<Lhs>, IteratorItem<Rhs> | undefined]> => {\n  const it2 = createIterator(rhs)[Symbol.iterator]();\n  return createIterator(lhs, (lhs) => [lhs, it2.next()?.value] as [any, any]);\n};\n\nexport const distinct: {\n  <S extends IteratorSource, R, P>(\n    source: S,\n    projection?: IteratorAction<S, R>,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorProjection<S, R, P>>;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorItem<S>>;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  source != null\n    ? new Set<any>([...project(source, projection, start, end)])\n    : undefined;\n\nexport const single: {\n  <S extends IteratorSource, R, P>(\n    source: S,\n    projection?: IteratorAction<S, R> | P,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorProjection<S, R, P> | undefined;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorItem<S> | undefined;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  source == null\n    ? undefined\n    : (source = mapDistinct(source, projection, start, end) as any).length > 1\n    ? undefined\n    : source[0];\n\nexport const mapDistinct: MapFunction = (\n  source: any,\n  projection?: any,\n  start?: any,\n  end?: any\n) =>\n  source != null\n    ? [...(distinct as any)(source, projection, start, end)]\n    : source;\n\nexport function* concatIterators<S extends IteratorSource[]>(\n  ...iterators: S\n): Iterable<IteratorItems<S>> {\n  for (const iterator of iterators) {\n    if (!iterator) continue;\n    yield* createIterator(iterator);\n  }\n}\n\nexport const intersection = <\n  T,\n  A extends Iterable<T> | undefined,\n  B extends Iterable<T> | undefined\n>(\n  a: A,\n  b: B\n): T[] => {\n  if (!a || !b) return [];\n  isSet(b) && ([b, a] = [a, b] as any);\n  const lookup = isSet(a) ? a : new Set(a);\n  return filter(b, (value) => lookup.has(value)) as any;\n};\n\nexport const intersects = (\n  a: Iterable<any> | undefined,\n  b: Iterable<any> | undefined\n) => !!count(intersection(a, b));\n\nexport const flatMapKv = <S extends IteratorSource, R, P, D extends number = 1>(\n  source: S,\n  action?: IteratorAction<S, R> | P,\n  depth: D = 1 as any\n): FlatIteratorItem<IteratorProjection<S, R, P>, D, true>[] =>\n  flatMap(source, action, depth, true);\n\nexport const flatMap: <\n  S extends IteratorSource,\n  R,\n  P,\n  D extends number = 1,\n  O extends boolean = false\n>(\n  source: S,\n  action?: IteratorAction<S, R> | P,\n  depth?: D,\n  expandObjects?: O,\n  ...rest: StartEndArgs<S>\n) => FlatIteratorItem<IteratorProjection<S, R, P>, D, O>[] = (\n  source,\n  action,\n  depth = 1 as any,\n  expandObjects = false as any,\n  start?: any,\n  end?: any\n) =>\n  array2(\n    (flatten as any)(source, action, depth, expandObjects, start, end) as any\n  ) as any;\n\nconst traverseInternal = <T>(\n  root: T | T[] | undefined,\n  selector: (current: T) => Iterable<T> | undefined,\n  include: boolean,\n  results: T[],\n  seen: Set<T>\n) => {\n  if (isArray(root)) {\n    forEachInternal(root, (item) =>\n      traverseInternal(item, selector, include, results, seen)\n    );\n    return results;\n  }\n  if (!root || !add(seen, root)) {\n    return undefined;\n  }\n  include && results.push(root);\n  forEachInternal(selector(root), (item) =>\n    traverseInternal(item, selector, true, results, seen)\n  );\n\n  return results;\n};\n\ntype ConcatResult_<T> = T extends readonly []\n  ? never\n  : T extends readonly [infer Item, ...infer Rest]\n  ?\n      | Exclude<Item extends Iterable<infer T> ? T : Item, Nullish>\n      | ConcatResult_<Rest>\n  : T extends Iterable<infer Item>\n  ? Exclude<Item extends Iterable<infer T> ? T : Item, Nullish>\n  : never;\n\ntype ConcatResult<T> = ConcatResult_<T> extends never\n  ? undefined\n  : ConcatResult_<T>[];\n\ntype FinalIteratorItem<\n  T,\n  ArraysOnly = false,\n  MaxDepth extends number = -1\n> = MaxDepth extends 0\n  ? T\n  : T extends string\n  ? string\n  : T extends (\n      [ArraysOnly] extends [true]\n        ? readonly (infer T)[]\n        : IterableOrArrayLike<infer T>\n    )\n  ? FinalIteratorItem<\n      T,\n      ArraysOnly,\n      -1 extends MaxDepth ? -1 : Subtract<MaxDepth, 1>\n    >\n  : T;\n\nexport const unnest = <\n  T extends readonly any[],\n  ArraysOnly extends boolean = false,\n  Depth extends number = -1\n>(\n  items: T,\n  arraysOnly: ArraysOnly,\n  depth: Depth = -1 as any\n): FinalIteratorItem<T, ArraysOnly>[] => {\n  if (!depth) return items as any;\n\n  const results: any[] = [];\n  const test = arraysOnly ? isArray : isIterable;\n  forEach(items, (item) =>\n    test(item)\n      ? results.push(...unnest(item, arraysOnly, depth - 1))\n      : item != null && results.push(item)\n  );\n  return results;\n};\n\nexport const unarray: {\n  <T extends readonly any[], Depth extends number = -1>(\n    items: T\n  ): FinalIteratorItem<T, true>[];\n  <T extends readonly any[]>(...items: T): FinalIteratorItem<T, true>[];\n} = (...items: any[]) => unnest(items.length === 1 ? items[0] : items, true);\n\nexport const concat: {\n  <T extends readonly any[]>(items: T):\n    | ConcatResult<T>\n    | IfNot<AnyAll<ArraysAsEmpty<T[number]>, false>>;\n  <T extends readonly any[]>(...items: T):\n    | ConcatResult<T>\n    | IfNot<AnyAll<ArraysAsEmpty<T[number]>, false>>;\n} = (...items: any[]) => {\n  let merged: any[] | undefined;\n  forEach(\n    items.length === 1 ? items[0] : items,\n    (item) => item != null && (merged ??= []).push(...(array2(item) as any))\n  );\n  return merged as any;\n};\n\ntype ExpandItem<T> = Exclude<T extends readonly (infer T)[] ? T : T, Nullish>;\n\ntype ItemOrSelf<T> = Exclude<\n  T extends string ? T : T extends Iterable<infer T> ? T : T,\n  Nullish\n>;\n\nexport function collect<T, R>(\n  source: T,\n  selector: (source: ItemOrSelf<T>) => R | Nullish,\n  includeSelf?: false,\n  depth?: 0 | 1,\n  collected?: Set<unknown>\n): Iterable<ItemOrSelf<R>>;\nexport function collect<T, R>(\n  source: T | R | Nullish,\n  selector: (source: ItemOrSelf<T>) => R | Nullish,\n  includeSelf?: boolean,\n  depth?: number,\n  collected?: Set<unknown>\n): Iterable<ItemOrSelf<T> | ItemOrSelf<R>>;\nexport function* collect(\n  source: any,\n  selector: (source: any) => any,\n  includeSelf = false,\n  depth = -1,\n  collected: Set<any> = new Set()\n): Iterable<any> {\n  if (isIterable(source)) {\n    for (const item of source) {\n      if (!collected.has(item)) {\n        yield* collect(item, selector, includeSelf, depth, collected);\n      }\n    }\n  } else if (source != null && !collected.has(source)) {\n    if (includeSelf) {\n      collected.add(source);\n      yield source as any;\n    }\n    if (depth--) {\n      yield* collect(\n        selector(source as any) as any,\n        selector,\n        includeSelf,\n        depth,\n        collected\n      );\n    }\n  }\n}\n\nexport const expand = <\n  T,\n  IncludeSelfParameter extends boolean | readonly [boolean] = [true]\n>(\n  root: T,\n  selector: (\n    current: ExpandItem<T>\n  ) => Iterable<ExpandItem<T> | Nullish> | ExpandItem<T> | Nullish,\n  includeSelf: IncludeSelfParameter = [true] as any\n): T extends undefined\n  ? undefined\n  : IncludeSelfParameter extends readonly [boolean]\n  ? ExpandItem<T>[]\n  : Set<T> => {\n  const [asArray, self] = isBoolean(includeSelf)\n    ? [false, includeSelf]\n    : [true, includeSelf[0]];\n  const seen = new Set<T>();\n  expandInternal(isArray(root) ? root : [root], selector, seen, self);\n  return asArray ? [...seen] : (seen as any);\n};\n\nconst expandInternal = (\n  value: unknown,\n  selector: (current: unknown) => Iterable<unknown> | unknown | Nullish,\n  seen: Set<any>,\n  include = true\n) => {\n  if (value == null) return;\n  if (value[symbolIterator]) {\n    for (const item of value as any)\n      expandInternal(item, selector, seen, include);\n  }\n  include && seen.add(value);\n  expandInternal(selector(value), selector, seen, include);\n};\n\nconst forEachArray = (\n  source: readonly any[],\n  action: any,\n  start: any,\n  end: any\n) => {\n  let returnValue: any;\n  let i = 0;\n  start = start! < 0 ? source.length + start! : start ?? 0;\n  end = end! < 0 ? source.length + end! : end ?? source.length;\n  for (; start < end; start++) {\n    if (\n      source[start] != null &&\n      ((returnValue = action(source[start], i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachIterable = (source: Iterable<any>, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let value of source as any) {\n    if (\n      value != null &&\n      ((returnValue = action(value, i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachObject = (source: any, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let key in source) {\n    if (\n      ((returnValue = action([key, source[key]], i++) ?? returnValue),\n      stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nexport const apply: <S, R, Args extends readonly any[]>(\n  source: S,\n  action: (\n    item: S extends IteratorSource ? IteratorItem<S> : OmitNullish<S>,\n    ...args: Args\n  ) => R,\n  ...args: Args\n) => S extends undefined ? undefined : Exclude<R, Nullish>[] = (\n  source,\n  action,\n  ...args\n) =>\n  source == null\n    ? undefined\n    : isIterable(source)\n    ? map(source, (item) => action(item as any, ...args))\n    : (action(source as any, ...args) as any);\n\nexport const applyAsync: <\n  S extends IteratorSource,\n  R extends PromiseLike<any>,\n  Args extends readonly any[]\n>(\n  source: S,\n  action: (item: IteratorItem<S>, ...args: Args) => R,\n  ...args: Args\n) => Promise<S extends undefined ? undefined : Exclude<R, Nullish>[]> = (\n  source,\n  action,\n  ...args\n) => mapAsync(source, (item) => action(item, ...args)) as any;\n\nconst forEachInternal: <S extends IteratorSource, R>(\n  source: S,\n  action?: IteratorAction<S, R>,\n  start?: any,\n  end?: any\n) => R | undefined = (source, action, start?: any, end?: any) => {\n  if (source == null) return;\n\n  if (isArray(source)) return forEachArray(source, action, start, end);\n  if (start === undefined) {\n    if (source[symbolIterator]) return forEachIterable(source as any, action);\n    if (typeof source === \"object\") return forEachObject(source, action);\n  }\n  let returnValue: any;\n  for (const value of createIterator(source, action, start, end)) {\n    value != null && (returnValue = value);\n  }\n\n  return returnValue;\n};\n\nexport const forEach = forEachInternal as {\n  <S extends IteratorSource, R>(\n    source: S,\n    action: FunctionalIteratorAction<S, R>,\n    ...rest: StartEndArgs<S>\n  ): R | undefined;\n};\n\nexport const forEachAsync: <\n  S extends IteratorSource,\n  R extends PromiseLike<any>\n>(\n  source: S,\n  action: IteratorAction<S, R>,\n  ...rest: StartEndArgs<S>\n) => Promise<R | undefined> = async (\n  source: any,\n  action: any,\n  start?: any,\n  end?: any\n) => {\n  if (source == null) return undefined;\n  let returnValue: any;\n  for (let item of project(source, action, start, end)) {\n    (item = (await item) as any) != null && (returnValue = item);\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nexport const flatForEach = <\n  S extends IteratorSource,\n  R,\n  P,\n  Depth extends number,\n  O extends boolean = false\n>(\n  source: S,\n  action: IteratorAction<S, R> | P,\n  depth: Depth = 1 as any,\n  expandObjects: O = false as any,\n  ...rest: StartEndArgs<S>\n): FlatIteratorItem<IteratorProjection<S, R, P>, Depth, O> | undefined =>\n  forEachInternal(\n    flatten(source, undefined, depth, expandObjects, ...(rest as any)),\n    action as any\n  ) as any;\n\ntype KeyValueParts<T> = T extends readonly [infer Key, infer Value]\n  ? [Key, Value]\n  : [undefined, undefined];\n\ntype ObjectEntryType<T> = T extends infer T\n  ? { [P in keyof T]-?: [P, T[P]] }[keyof T]\n  : never;\n\ntype ObjectFromEntries<EntryType extends readonly [keyof any, any]> =\n  UnionToIntersection<\n    EntryType extends readonly [infer Key extends keyof any, infer Value]\n      ? { [P in Key]: Value }\n      : never\n  >;\n\n/** Fast version of `obj`. */\nexport const fromEntries: {\n  <Source extends Iterable<readonly [keyof any, any] | Falsish> | Nullish>(\n    source: Source\n  ): Source extends Iterable<infer Entry extends readonly [keyof any, any]>\n    ? ObjectFromEntries<Entry>\n    : undefined;\n  <\n    Source extends Record<keyof any, any> | Nullish,\n    Mapped extends readonly [keyof any, any] | Falsish = ObjectEntryType<Source>\n  >(\n    source: Source,\n    map: (entry: ObjectEntryType<Source>, index: number) => Mapped | Nullish\n  ): Source extends Nullish\n    ? undefined\n    : ObjectFromEntries<\n        Mapped extends readonly [keyof any, any] ? Mapped : never\n      >;\n} = (source: any, map?: any) => {\n  if (source == null) return undefined;\n  const result: any = {};\n  if (map) {\n    let i = 0;\n    let value: any;\n    for (const key in source) {\n      (value = map([key, source[key]], i++)) && (result[value[0]] = value[1]);\n    }\n  } else {\n    for (const entry of source) {\n      entry && (result[entry[0]] = entry[1]);\n    }\n  }\n  return result;\n};\n\n/**\n * Like Object.fromEntries, but accepts any iterable source and a projection instead of just key/value pairs.\n * Properties with undefined values are not included in the resulting object.\n */\nexport const obj: {\n  <S extends KeyValueSource | Nullish>(source: S): MaybeUndefined<\n    S,\n    KeyValuePairsToObject<IteratorItem<S>>\n  >;\n  <S extends Iterable<KeyValueSource> | Nullish, G extends boolean>(\n    source: S,\n    group: G\n  ): S extends Nullish\n    ? undefined\n    : KeyValueSourcesToObject<IteratorItem<S>, G>;\n\n  <S extends IteratorSource | Nullish, R extends readonly [any, any], P>(\n    source: S,\n    selector: IteratorAction<S, R> | P,\n    merge?: (\n      current: KeyValueParts<IteratorProjection<S, R, P>>[1] | undefined,\n      value: KeyValueParts<IteratorProjection<S, R, P>>[1]\n    ) => KeyValueParts<IteratorProjection<S, R, P>>[1] | Nullish\n  ): KeyValuePairsToObject<IteratorProjection<S, R, P>>;\n} = ((source: any, selector?: any, merge?: any) => {\n  if (source == null) return undefined;\n\n  if (isBoolean(selector) || merge) {\n    let result = {} as any;\n    forEach(\n      source,\n      merge\n        ? (item, i) =>\n            (item = selector(item, i)) != null &&\n            (item[1] = merge(result[item[0]], item[1])) != null &&\n            (result[item[0]] = item[1])\n        : (source) =>\n            forEach(\n              source,\n              selector\n                ? (item) =>\n                    item?.[1] != null &&\n                    ((result[item[0]] ??= []).push(item[1]), result)\n                : (item) =>\n                    item?.[1] != null && ((result[item[0]] = item[1]), result)\n            )\n    );\n    return result;\n  }\n  return fromEntries(\n    map(\n      source,\n      selector\n        ? (item, index) => ifDefined(selector(item, index), 1)\n        : (item) => ifDefined(item, 1)\n    )!\n  );\n}) as any;\n\nexport const groupReduce: <\n  S extends IteratorSource,\n  Key,\n  Accumulator = unknown\n>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  reducer: (\n    accumulator: GeneralizeConstants<Accumulator>,\n    item: IteratorItem<S>,\n    index: number\n  ) => Accumulator,\n  seed?: Accumulator | (() => Accumulator),\n  ...reset: StartEndArgs<S>\n) => Map<Key, Accumulator> = (\n  source,\n  keySelector,\n  reducer,\n  seed,\n  start?: any,\n  end?: any\n) => {\n  const groups = new Map<any, any>();\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  const action: IteratorAction<any, any> = (item, index) => {\n    const key = keySelector(item, index);\n    let acc = groups.get(key) ?? seedFactory();\n    const value = reducer(acc, item, index);\n    if (value != null) {\n      groups.set(key, value);\n    }\n  };\n  forEachInternal(source, action, start, end);\n  return groups as any;\n};\n\nexport const group: <S extends IteratorSource, Key, R = IteratorItem<S>>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  valueSelector?: (item: IteratorItem<S>, index: number) => R,\n  ...rest: StartEndArgs<S>\n) => S extends undefined ? undefined : Map<Key, R[]> = (\n  source,\n  keySelector,\n  valueSelector = (item: any) => item,\n  start?: any,\n  end?: any\n) => {\n  if (source == null) return undefined as any;\n  const groups = new Map<any, any[]>();\n  (forEachInternal as any)(\n    source,\n    (item: any, index: number) => {\n      const key = keySelector(item, index);\n      const value = valueSelector(item, index);\n      get(groups, key as any, () => []).push(value);\n    },\n    start,\n    end\n  );\n  return groups as any;\n};\n\nexport const reduce: <\n  S extends IteratorSource,\n  Reducer extends (\n    ...args: [\n      accumulator: unknown extends Accumulator\n        ? any\n        : GeneralizeConstants<Accumulator>,\n      item: IteratorItem<S>,\n      index: number\n    ]\n  ) => GeneralizeConstants<Accumulator>,\n  Accumulator\n>(\n  source: S,\n  reducer: Reducer,\n  seed?: Accumulator | (() => Accumulator),\n  ...rest: StartEndArgs<S>\n) => Reducer extends (...args: any) => infer R\n  ? R | (unknown extends Accumulator ? undefined : never)\n  : never = (source, reducer, seed, start?: any, end?: any) => {\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  return (\n    forEachInternal(\n      source,\n      (value, index) =>\n        (seed =\n          ((reducer as any)(seed as any, value, index) as any) ??\n          seedFactory()),\n      start,\n      end\n    ) ?? (seedFactory() as any)\n  );\n};\n\nexport const filter: {\n  <S extends IteratorSource, P extends IteratorFilter<S>>(\n    source: S,\n    predicate?: P,\n    ...args: StartEndArgs<S>\n  ): MaybeUndefined<S, Exclude<Exclude<IteratorItem<S>, Falsish>[], never[]>>;\n} = (source, predicate, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    (value: any, index: any) =>\n      value && predicate?.(value, index) ? value : undefined,\n    start,\n    end\n  ) as any;\n\nlet filterInternal = filter;\n\nexport const count: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, number> = (\n  source: IteratorSource,\n  filter?: IteratorFilter<IteratorSource>\n) => {\n  if (source == null) return undefined as any;\n\n  let n: number;\n  if (!filter) {\n    if ((n = source![\"length\"] ?? source![\"size\"]) != null) {\n      return n;\n    }\n    if (!source[symbolIterator]) {\n      return Object.keys(source).length;\n    }\n  }\n\n  n = 0;\n  return (\n    forEachInternal(\n      source,\n      filter ? (item, index) => (filter!(item, index) ? ++n : n) : () => ++n\n    ) ?? (0 as any)\n  );\n};\n\nexport const sum: {\n  <S extends IteratorSourceOf<number>>(\n    source: S,\n    selector?: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n  <S extends IteratorSource>(\n    source: S,\n    selector: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n} = (\n  source: any,\n  selector: any = (item: any) => item,\n  start?: any,\n  end?: any\n) =>\n  reduce(\n    source,\n    (sum, value, index) => sum + (selector(value, index) ?? 0),\n    0,\n    start,\n    end\n  );\n\ntype CanBeEmptySource<S extends IteratorSource> = any[] extends S\n  ? true\n  : S extends { length: 0 } | 0 // Zero length range.\n  ? true\n  : S extends readonly any[] | number\n  ? false\n  : true;\n\ntype MinMaxFunction = {\n  <S extends readonly number[]>(...numbers: S | readonly [number]):\n    | (S extends readonly [] ? undefined : number)\n    | UndefinedIfEmpty<S>;\n  <S extends IteratorSource, R, P>(\n    source: S | readonly [number],\n    selector?: IteratorAction<S, R> | P,\n    ...rest: StartEndArgs<S>\n  ): true extends CanBeEmptySource<S>\n    ? number | undefined\n    : If<\n        Extends<IteratorProjectionWithUndefined<S, R, P>, number>,\n        number,\n        undefined\n      >;\n};\n\nexport const min: MinMaxFunction = (source: any, ...args: any[]) =>\n  source == null\n    ? undefined\n    : isNumber(source)\n    ? Math.min(source, ...args)\n    : reduce(\n        source,\n        (\n          min,\n          value,\n          index,\n          projected = args[1] ? args[1](value, index) : value\n        ) =>\n          min == null || (isNumber(project) && projected < min)\n            ? projected\n            : max,\n        undefined,\n        args[2],\n        args[3]\n      );\n\nexport const maxBy = <T>(\n  source: Iterable<T>,\n  selector: (item: T, currentMax?: number) => number | false | Nullish\n) => {\n  let best: [T, number] | undefined;\n  let selected: number | boolean | Nullish;\n  for (const item of source) {\n    selected = selector(item, best?.[1]);\n    if (selected === false) return best;\n    if (!best || selected! > best[1]) {\n      best = [item, selected!];\n    }\n  }\n  return best;\n};\n\nexport const max: MinMaxFunction = (source: any, ...args: any[]) =>\n  source == null\n    ? undefined\n    : isNumber(source)\n    ? Math.max(source, ...args)\n    : reduce(\n        source,\n        (\n          max,\n          value,\n          index,\n          projected = args[1] ? args[1](value, index) : value\n        ) =>\n          max == null || (isNumber(projected) && projected > max)\n            ? projected\n            : max,\n        undefined,\n        args[2],\n        args[3]\n      );\n\nexport const values: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<\n  S,\n  (IteratorItem<S> extends readonly [any, infer Item]\n    ? Item\n    : IteratorItem<S>)[]\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isPlainObject(source) || isMap(source)\n      ? (item: any) => item[1]\n      : (item: any) => item,\n    start,\n    end\n  );\n\nexport const entries: <S extends Iterable<any> | SimpleObject>(\n  target: S\n) => Entries<S> = (target) =>\n  !isArray(target) && isIterable(target)\n    ? map(\n        target,\n        isMap(target)\n          ? (value) => value\n          : isSet(target)\n          ? (value) => [value, true]\n          : (value, index) => [index, value]\n      )\n    : isObject(target)\n    ? (Object.entries(target) as any)\n    : undefined;\n\nexport const keys: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<\n  S,\n  IteratorItem<S> extends readonly [infer Key, any] ? Key : number\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isPlainObject(source)\n      ? (item: any) => item[0]\n      : (_item: any, i: number) => i,\n    start,\n    end\n  );\n\nexport const mapFirst: <S extends IteratorSource, R, P>(\n  source: S,\n  projection: IteratorAction<S, R> | P,\n  ...rest: StartEndArgs<S>\n) => IteratorProjection<S, R, P> | undefined = (\n  source,\n  projection,\n  start?: any,\n  end?: any\n) =>\n  source == null\n    ? undefined\n    : ((projection = wrapProjection(projection)!),\n      forEachInternal(\n        source,\n        (value, i) =>\n          !projection || (value = (projection as any)(value, i))\n            ? stop(value)\n            : undefined,\n        start,\n        end\n      ));\n\nexport const first: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: IteratorFilter<any>,\n  start?: any,\n  end?: any\n) =>\n  source == null\n    ? undefined\n    : forEachInternal(\n        source,\n        (value, i) =>\n          !predicate || predicate(value, i) ? stop(value) : undefined,\n        start,\n        end\n      );\n\nexport const last: <S extends IteratorSource | undefined>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: any,\n  start?: any,\n  end?: any\n) =>\n  source == null\n    ? undefined\n    : isArray(source) || isString(source)\n    ? source[source.length - 1]\n    : forEachInternal(\n        source,\n        (item, i) => (!predicate || predicate(item, i) ? item : undefined),\n        start,\n        end\n      );\n\nexport const rank = <S extends IteratorSource>(source: S) =>\n  createIterator(source, (item, i) => [item, i] as const);\n\nexport const some: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, boolean> = (source, predicate, start?: any, end?: any) =>\n  source == null\n    ? undefined\n    : isPlainObject(source) && !predicate\n    ? Object.keys(source).length > 0\n    : (source as any).some?.(predicate ?? isTruish) ??\n      forEachInternal<any, boolean>(\n        source,\n        predicate\n          ? (item, index) => (predicate(item, index) ? stop(true) : false)\n          : () => stop(true),\n        start,\n        end\n      ) ??\n      false;\n\nexport const every: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, boolean> = (source, predicate, start?: any, end?: any) =>\n  source == null\n    ? undefined\n    : (!(some as any)(\n        source,\n        predicate\n          ? (item: any, index: number) => !predicate(item, index)\n          : isFalsish,\n        start,\n        end\n      ) as any);\n\n/**\n * Array's `sort` function that offers a single function that is applied on each element instead of having to do it twice (`[...].sort(x,y)=>f(x)-f(y)`).\n * Default is to use the value directly.\n */\nexport const sort = <\n  T extends Iterable<any> | Nullish,\n  Item extends IteratorItem<T>\n>(\n  items: T,\n  rank: (item: Item) => number = (item) => item as any\n): MaybeUndefined<T, Item[]> =>\n  (array(items)?.sort((lhs, rhs) => rank(lhs) - rank(rhs)), items) as any;\n\nexport const binarySearch: {\n  (arr: Array<number>, find: number): number;\n  <T = number>(arr: Array<T>, find: T, compare: (x: T, y: T) => number): number;\n} = <T = number>(\n  arr: Array<T>,\n  find: T,\n  compare: (x: T, y: T) => number = ((x: any, y: any) => x - y) as any\n) => {\n  let m = 0;\n  let n = arr.length - 1;\n  let cmp: number;\n  let k: number;\n  while (m <= n) {\n    k = (n + m) >> 1;\n    cmp = compare(find, arr[k]);\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return k;\n    }\n  }\n  return ~m;\n};\n","import {\n  And,\n  Extends,\n  GeneralizeConstants,\n  If,\n  IsAny,\n  IteratorItem,\n  IteratorSourceOf,\n  KeyValuePairsToObject,\n  MaybeUndefined,\n  MethodOverloads,\n  NotFunction,\n  Nullish,\n  PrettifyIntersection,\n  Primitives,\n  SimpleObject,\n  Subtract,\n  UnionToIntersection,\n  count,\n  forEach,\n  hasMethod,\n  isArray,\n  isFunction,\n  isMap,\n  isNumber,\n  isObject,\n  isPlainObject,\n  isSet,\n  map,\n  obj,\n  structuralEquals,\n  throwError,\n} from \".\";\n\ntype ReadonlyMapLike<K = any, V = any> = {\n  has?(key: K): boolean;\n  get(key: K): V | undefined;\n};\n\ntype MapLike<K = any, V = any> = ReadonlyMapLike<K, V> & {\n  set(key: K, value: V): any;\n  delete(key: K): any;\n  clear(): any;\n};\n\ntype ReadonlySetLike<K = any> = {\n  has(key: K): boolean;\n};\ntype SetLike<K = any> = ReadonlySetLike<K> & {\n  add(key: K): any;\n  delete(key: K): any;\n  clear(): any;\n};\n\ntype ReadonlyPropertyContainer<K extends any = any, V extends any = any> =\n  | SimpleObject\n  | readonly any[]\n  | ReadonlyMapLike<K, V>\n  | ReadonlySetLike<K>;\n\ntype PropertyContainer<K extends any = any, V extends any = any> =\n  | ReadonlyPropertyContainer<K, V>\n  | MapLike<K, V>\n  | SetLike<K>;\n\nexport type TupleIndices<T extends readonly any[]> = T extends readonly []\n  ? never\n  : number extends T[\"length\"]\n  ? number\n  : T extends readonly [any, ...infer Rest]\n  ? TupleIndices<Rest> | Rest[\"length\"]\n  : never;\n\nexport type KeyType<T extends ReadonlyPropertyContainer | Nullish> =\n  T extends Primitives\n    ? never\n    : T extends ReadonlyMapLike<infer K, any> | ReadonlySetLike<infer K>\n    ? K\n    : T extends readonly any[]\n    ? TupleIndices<T>\n    : keyof T;\n\nexport type ValueType<\n  T extends ReadonlyPropertyContainer | Nullish,\n  K = KeyType<T>,\n  Context extends undefined | \"get\" | \"set\" = undefined\n> = IsAny<T> extends true\n  ? any\n  : T extends Nullish\n  ? never\n  : K extends KeyType<T>\n  ? T extends ReadonlyMapLike<K, infer V>\n    ? V | If<Extends<Context, \"get\" | \"set\">, undefined>\n    : T extends ReadonlySetLike<K>\n    ? boolean\n    :\n        | T[K]\n        | If<And<Extends<T, SimpleObject>, Extends<Context, \"set\">>, undefined>\n  : never;\n\nconst set = (target: any, key: any, value: any) => {\n  if (target.constructor === Object || isArray(target)) {\n    value === undefined ? delete target[key] : (target[key] = value);\n    return value;\n  }\n\n  value === undefined\n    ? target.delete\n      ? target.delete(key)\n      : delete target[key]\n    : target.set\n    ? target.set(key, value)\n    : target.add\n    ? value\n      ? target.add(key)\n      : target.delete(key)\n    : (target[key] = value);\n\n  return value;\n};\n\nexport const setSingleIfNotDefined = (\n  target: any,\n  key: any,\n  value: any,\n  error: (\n    key: string,\n    currentValue: any,\n    newValue: any,\n    target: any\n  ) => string | Error\n) => {\n  const currentValue = get(target, key);\n  if (currentValue != null) {\n    throwError(error(key, currentValue, value, target));\n  }\n  return set(target, key, value);\n};\n\nexport const tryAdd: {\n  <T extends PropertyContainer, K extends KeyType<T>>(\n    target: T,\n    key: K,\n    value: Wrapped<ValueType<T, K, \"set\">>,\n    conflict?: (current: ValueType<T, K>) => void\n  ): boolean;\n} = (target, key, value, conflict) => {\n  const current = get(target, key);\n  if (current != null) {\n    conflict?.(current as any);\n    return false;\n  }\n  set(target, key, unwrap(value));\n  return true;\n};\n\nexport const get: {\n  <T extends ReadonlyPropertyContainer | Nullish, K extends KeyType<T>>(\n    target: T,\n    key: K\n  ): ValueType<T, K, \"get\">;\n  <\n    T extends ReadonlyPropertyContainer | Nullish,\n    K extends KeyType<T>,\n    R extends\n      | ValueType<T, K>\n      | (() => ValueType<T, K>)\n      | undefined\n      | (() => ValueType<T, K> | undefined)\n  >(\n    target: T,\n    key: K,\n    init: R\n  ): ValueType<\n    T,\n    K,\n    R extends ValueType<T, K> | (() => ValueType<T, K>) ? undefined : \"get\"\n  >;\n} = <\n  T extends ReadonlyPropertyContainer | Nullish,\n  K extends KeyType<T>,\n  R extends ValueType<T, K> | undefined = undefined\n>(\n  target: T,\n  key: K | undefined,\n  init?: Wrapped<R>\n) => {\n  if (!target) return undefined as any;\n\n  let value = (target as any).get\n    ? (target as any).get(key)\n    : (target as any).has\n    ? (target as any).has(key)\n    : target[key as any];\n\n  if (value === undefined && init != null) {\n    (value = isFunction(init) ? (init as any)() : init) != null &&\n      set(target, key, value);\n  }\n  return value;\n};\n\ntype UpdateFunction<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current,\n  Factory\n> = Factory extends false\n  ? (\n      current: Current,\n      key: Key,\n      target: T\n    ) => GeneralizeConstants<ValueType<T, Key>> | undefined\n  : (key: Key, target: T) => GeneralizeConstants<ValueType<T, Key>>;\n\ntype Updater<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current = ValueType<T, Key>,\n  SettersOnly = false,\n  Factory = false\n> = SettersOnly extends true\n  ? ValueType<T, Key> | (Factory extends true ? never : undefined)\n  : IsAny<T> extends true\n  ? NotFunction | UpdateFunction<any, any, any, Factory>\n  :\n      | (ValueType<T, Key> extends Function\n          ? never\n          : ValueType<T, Key> | (Factory extends true ? never : undefined))\n      | UpdateFunction<T, Key, Current, Factory>;\n\ntype UpdaterType<T, SettersOnly = false> = SettersOnly extends true\n  ? T\n  : T extends (...args: any) => infer T\n  ? T\n  : T;\n\ntype BulkUpdateObject<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> = T extends MapLike | SetLike | any[]\n  ? {\n      [P in KeyType<T>]: Updater<T, P, ValueType<T, P>, SettersOnly, Factory>;\n    }\n  : { [P in keyof T & KeyType<T>]?: Updater<T, P, T[P], SettersOnly, Factory> };\n\ntype BulkUpdateKeyValue<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false,\n  K extends keyof T = keyof T\n> = IsAny<T> extends true\n  ? readonly [any, Updater<T, any, any, SettersOnly, Factory>]\n  : T extends MapLike | SetLike | any[]\n  ? readonly [\n      KeyType<T>,\n      Updater<T, KeyType<T>, ValueType<T, KeyType<T>>, SettersOnly, Factory>\n    ]\n  : K extends any\n  ? readonly [K, Updater<T, KeyType<T>, any, SettersOnly, Factory>]\n  : never;\n\ntype BulkUpdates<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> =\n  | BulkUpdateObject<T, SettersOnly, Factory>\n  | Iterable<\n      | BulkUpdateKeyValue<T, SettersOnly, Factory>\n      | BulkUpdateObject<T, SettersOnly, Factory>\n    >\n  | readonly (readonly BulkUpdateKeyValue<T, SettersOnly, Factory>[])[];\n\ntype MergeResult_<Updates> = Updates extends Iterable<\n  infer Item extends readonly [keyof any, any]\n>\n  ? KeyValuePairsToObject<Item>\n  : Updates;\n\ntype MergeResult<T, Updates> = T extends SimpleObject\n  ? PrettifyIntersection<\n      T &\n        UnionToIntersection<\n          MergeResult_<\n            Updates extends Iterable<infer Updates> ? Updates : Updates\n          >\n        >\n    >\n  : T &\n      UnionToIntersection<\n        MergeResult_<\n          Updates extends Iterable<infer Updates> ? Updates : Updates\n        >\n      >;\n\ntype SetErrorHandler<T extends ReadonlyPropertyContainer | Nullish> = (\n  key: KeyType<T>,\n  currentValue: ValueType<T>,\n  newValue: ValueType<T>,\n  target: T\n) => string | Error;\n\ntype SettableKeyType<T extends PropertyContainer> = T extends readonly any[]\n  ? // `KeyType<T>` won't do.\n    // If this `keyof` constraint is not set TypeScript will only constrain values for readonly tuple items to T[number] and not T[K].\n    keyof T\n  : T extends SimpleObject\n  ? keyof any\n  : KeyType<T>;\n\ntype SettableValueType<T extends PropertyContainer, K> = K extends KeyType<T>\n  ?\n      | ValueType<T, K>\n      // `undefined` removes elements from maps and sets so also allowed.\n      | (T extends MapLike | SetLike ? undefined : never)\n  : T extends SimpleObject\n  ? any\n  : never;\n\ntype IsGeneralKey<T, S = keyof any> = S extends T ? true : false;\n\n/** List of keys in T that has undefined values. If Template does not allow undefined values for a key it is excluded from the results. */\ntype UndefinedKeys<\n  T,\n  Template = {},\n  K extends keyof T = keyof T\n> = K extends keyof T\n  ? T[K] extends undefined\n    ? K extends keyof Template\n      ? undefined extends Template[K]\n        ? K\n        : never\n      : K\n    : never\n  : never;\n\ntype AllKeys<T> = T extends infer T ? keyof T : never;\n\ntype AnyValue<T, K> = T extends infer T\n  ? K extends keyof T\n    ? T[K]\n    : never\n  : never;\n\ntype MergeObjects<T> = {\n  [P in AllKeys<T>]: AnyValue<T, P>;\n};\n\ntype KeyValueTupleToRecord<Item> = Item extends readonly [infer K, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : Item extends readonly (infer KV)[]\n  ? { [P in KV & keyof any]: KV }\n  : Item extends SimpleObject\n  ? Item\n  : never;\n\ntype AssignRecord<T, S> = {\n  [P in Exclude<\n    keyof T | keyof S,\n    IsGeneralKey<keyof T | keyof S> extends true ? never : UndefinedKeys<S, T>\n  >]: P extends keyof S\n    ? IsGeneralKey<P> extends true\n      ? AnyValue<S | T, P>\n      : P extends keyof T\n      ? S[P] extends T[P]\n        ? GeneralizeConstants<S[P]> extends T[P]\n          ? GeneralizeConstants<S[P]>\n          : S[P]\n        : never\n      : GeneralizeConstants<S[P]>\n    : P extends keyof T\n    ? T[P]\n    : never;\n};\n\ntype SetOrUpdateFunction<\n  SettersOnly,\n  ErrorHandler = false,\n  Readonly = false\n> = {\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined,\n    U extends Updater<\n      T extends Nullish ? never : T,\n      K,\n      ValueType<T, K>,\n      SettersOnly\n    >,\n    K extends KeyType<T>\n  >(\n    target: T,\n    key: K,\n    value: U,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): UpdaterType<U>;\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined,\n    U\n  >(\n    target: T,\n    values: BulkUpdates<T extends Nullish ? never : T, SettersOnly> & U,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): T;\n};\n\nexport const merge = <\n  Target,\n  Values extends readonly IteratorSourceOf<readonly [keyof any, any]>[]\n>(\n  target: Target,\n  ...values: Values\n): MaybeUndefined<Target, MergeResult<Target, Values>> => (\n  forEach(values, (values) =>\n    forEach(values, ([key, value]) => {\n      if (value != null) {\n        if (isPlainObject(target[key]) && isPlainObject(value)) {\n          merge(target[key], value);\n        } else {\n          target[key] = value;\n        }\n      }\n    })\n  ),\n  target as any\n);\n\nconst createSetOrUpdateFunction =\n  <SettersOnly, Error>(\n    setter: (target: any, key: any, value: any, error?: any) => any\n  ): SetOrUpdateFunction<SettersOnly, Error> =>\n  (target: PropertyContainer, key: any, value?: any, error?: any) => {\n    if (!target) return undefined;\n    if (value != undefined) {\n      return setter(target, key, value, error);\n    }\n\n    forEach(key, (item) =>\n      isArray(item)\n        ? setter(target, item[0], item[1])\n        : forEach(item, ([key, value]) => setter(target, key, value))\n    );\n\n    return target;\n  };\n\nexport const assign = createSetOrUpdateFunction<true, false>(set);\nexport const update: <\n  T extends PropertyContainer | Nullish,\n  K extends KeyType<T>\n>(\n  target: T,\n  key: K,\n  update: (current: ValueType<T, K> | undefined) => ValueType<T, K> | undefined\n) => T = (target, key, update) => {\n  let value: any;\n  if (hasMethod(target, \"set\")) {\n    (value = update(target.get(key))) === undefined\n      ? target.delete(key)\n      : target.set(key, value);\n  } else if (hasMethod(target, \"add\")) {\n    value = target.has(key);\n    update(value) ? target.add(key) : target.delete(key);\n  } else if (target) {\n    value = (target as any)[key] = update((target as any)[key]);\n    if (value === undefined && isPlainObject(target)) {\n      delete target[key];\n    }\n  }\n\n  return target;\n};\nexport const assignIfUndefined = createSetOrUpdateFunction<false, true>(\n  setSingleIfNotDefined\n);\n\nexport const swap = <T extends PropertyContainer, K extends KeyType<T>>(\n  target: T,\n  key: K,\n  value: ValueType<T, K>\n): ValueType<T, K, \"get\"> => {\n  const current = get(target, key) as any;\n  if (value !== current) set(target, key, value);\n  return current as any;\n};\n\nexport const add = <T extends PropertyContainer<any, boolean>>(\n  target: T,\n  key: KeyType<T>\n) =>\n  target instanceof Set || target instanceof WeakSet\n    ? !target.has(key) && (target.add(key), true)\n    : !get(target, key) && (set(target, key, true), true);\n\nexport const has = <T extends ReadonlyPropertyContainer>(\n  target: T,\n  key: KeyType<T>\n) =>\n  hasMethod(target, \"has\")\n    ? target.has(key)\n    : ((target as any).get?.(key) ?? (target as any)[key]) != null;\n\ntype RemoveDeepArgs<\n  T,\n  Current extends any[] = [],\n  Depth extends number = 20\n> = T extends PropertyContainer\n  ? Depth extends 0\n    ? Current\n    :\n        | (Depth extends 20 ? never : Current)\n        | RemoveDeepArgs<\n            ValueType<T>,\n            [...Current, KeyType<T>[] | KeyType<T>],\n            Subtract<Depth, 1>\n          >\n  : Current;\n\ntype RemoveDeepValue<\n  T,\n  Args extends any[],\n  ArrayIt = false\n> = T extends PropertyContainer\n  ? ArrayIt extends true\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>[]]\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>]\n    ? ValueType<T> | undefined\n    : Args extends [infer R, ...infer Rest]\n    ? RemoveDeepValue<ValueType<T>, Rest, R extends any[] ? true : ArrayIt>\n    : never\n  : never;\n\ntype KeysArg<T extends PropertyContainer | Nullish> = T extends SimpleObject\n  ? readonly (keyof T | undefined)[]\n  : readonly (KeyType<T> | undefined)[];\n\nconst clearSingle = (target: any, key: any) => {\n  if ((target ?? key) == null) return undefined;\n\n  let current = get(target, key);\n\n  if (hasMethod(target, \"delete\")) {\n    target.delete(key);\n  } else {\n    delete target[key];\n  }\n  return current;\n};\n\n/**\n * Deletes the specified keys from the target and returns the target.\n */\nexport const del: {\n  <T extends PropertyContainer | undefined, K extends KeysArg<T>>(\n    target: T,\n    ...keys: K\n  ): T extends SimpleObject ? { [P in Exclude<keyof T, K[number]>]: T[P] } : T;\n} = (target: any, ...keys: any) =>\n  target &&\n  (assign(target, map(keys, (key) => [key, undefined]) as any) as any);\n\n/**\n * Removes one or more values from a property container specified by the provided key or array of keys.\n *\n * If more than one level of key arguments are specified, values will be removed from the property container at the deepest level.\n * If a property container becomes empty along the path of keys, it will be removed from its parent.\n *\n */\nexport const clear = <\n  T extends PropertyContainer | Nullish,\n  Args extends RemoveDeepArgs<T>\n>(\n  target: T,\n  ...keys: Args\n): RemoveDeepValue<T, Args> => {\n  const removed: any[] = [];\n  let array = false;\n\n  const clearStep = (\n    target: any,\n    index: number,\n    parent?: any,\n    parentKey?: any\n  ) => {\n    if (!target) return;\n    const targetKeys = keys[index];\n    if (index === keys.length - 1) {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) => removed.push(clearSingle(target, key)));\n      } else {\n        removed.push(clearSingle(target, targetKeys));\n      }\n    } else {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) =>\n          clearStep(get(target, key), index + 1, target, key)\n        );\n      } else {\n        clearStep(get(target, targetKeys), index + 1, target, targetKeys);\n      }\n      if (!count(target) && parent) {\n        remove(parent, parentKey);\n      }\n    }\n  };\n  clearStep(target, 0);\n  return array ? removed : removed[0];\n};\n\n/** Removes all entries from a set or map, and returns them. */\nexport const empty = <S extends SetLike | MapLike | undefined>(\n  target: S\n): MaybeUndefined<S, IteratorItem<S>[]> => {\n  if (!target) return undefined as any;\n\n  const entries = map(target);\n  target.clear();\n  return entries as any;\n};\n\n/**\n * Removes the specified key(s) from a property container and returns their value, or undefined if the container did not have the specified key.\n *\n * The difference between {@link clear} and this function is that it does not consider nested property containers and that arrays will be spliced (as opposed to `clear` where the index will be set to `undefined`).\n */\nexport const remove: {\n  <T extends PropertyContainer | Nullish, K extends KeyType<T> | undefined>(\n    target: T,\n    key: K\n  ): T extends Nullish ? T : ValueType<T, K, \"get\">;\n  <T extends PropertyContainer | Nullish, K extends KeysArg<T>>(\n    target: T,\n    keys: K\n  ): (T extends Nullish ? T : ValueType<T, K[number], \"get\">)[];\n} = (target: PropertyContainer, keys: any) => {\n  if (!target) return undefined;\n\n  if (isArray(keys)) {\n    // Sort array keys descending as they would otherwise not match their offset as the array is spliced along the way.\n    return (\n      isArray(target) && target.length > 1 ? keys.sort((x, y) => y - x) : keys\n    ).map((key) => remove(target, key));\n  }\n\n  return isArray(target)\n    ? keys < target.length\n      ? (target as any[]).splice(keys, 1)[0]\n      : undefined\n    : clearSingle(target, keys);\n};\n\ntype EntryToObject<Item> = Item extends readonly [infer K & keyof any, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : never;\n\ntype EntriesToObject<Entries> = UnionToIntersection<\n  InlinePropertyDescriptors<\n    Entries extends Nullish | boolean\n      ? {}\n      : Entries extends readonly [\n          Partial<Readonly<PropertyDescriptor>>,\n          ...infer Rest\n        ]\n      ? EntriesToObject<Rest[number]>\n      : Entries extends readonly [infer Item, ...infer Rest]\n      ? EntryToObject<Item> & EntriesToObject<Rest>\n      : Entries extends readonly (infer Items)[]\n      ? EntryToObject<Items>\n      : Entries\n  >\n>;\n\ntype InlinePropertyDescriptors<T> = {\n  [P in keyof T]: T[P] extends () => infer V | { value: infer V }\n    ? V\n    : T[P] extends { get(): infer V }\n    ? V\n    : T[P];\n};\n\ntype PropertyList =\n  | boolean\n  | null\n  | undefined\n  | readonly [defaults: Partial<PropertyDescriptor>, ...items: PropertyList[]]\n  | readonly (readonly [key: keyof any, value: any])[]\n  | SimpleObject;\n\nexport const define: {\n  <T, P extends readonly PropertyList[]>(\n    target: T,\n    ...properties: P\n  ): (T extends Function ? T : {}) &\n    PrettifyIntersection<T & EntriesToObject<P[number]>>;\n} = (target: any, ...args: readonly any[]) => {\n  const add = (arg: any, defaults?: any) => {\n    if (!arg) return;\n    let properties: readonly any[];\n    if (isArray(arg)) {\n      if (isPlainObject(arg[0])) {\n        // Tuple with the first item the defaults and the next the definitions with those defaults,\n        // ([{enumerable: false, ...}, ...])\n        (arg as any[]).splice(1).forEach((items) => add(items, arg[0]));\n        return;\n      }\n      // ([[key1, value1], [key2, value2], ...])\n      properties = arg;\n    } else {\n      // An object.\n      properties = map(arg)!;\n    }\n\n    properties.forEach(([key, value]) =>\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        writable: false,\n        ...defaults,\n        ...(isPlainObject(value) && (\"get\" in value || \"value\" in value)\n          ? value\n          : isFunction(value) && !value.length\n          ? { get: value }\n          : { value }),\n      })\n    );\n  };\n\n  args.forEach((arg) => add(arg));\n  return target as any;\n};\n\ntype PropertySelector<T> =\n  | keyof T\n  | {\n      [P in keyof T]?: PropertySelector<T[P]>;\n    }\n  | readonly (keyof T)[];\n\ntype SinglePickResult<T, Selected> = Selected extends\n  | (string & infer K)\n  | (infer K)[]\n  ? unknown extends K\n    ? T\n    : { [P in keyof T & K]: T[P] }\n  : keyof Selected extends infer Keys\n  ? {\n      [P in Keys & keyof any & keyof Selected]: P extends keyof T\n        ? Selected[P] extends true\n          ? T[P]\n          : SinglePickResult<T[P], Selected[P]>\n        : never;\n    }\n  : never;\n\ntype PickResults<T, Selectors> = PrettifyIntersection<\n  Selectors extends [infer Item, ...infer Rest]\n    ? unknown extends Item\n      ? T\n      : SinglePickResult<T, Item> & SinglePickResult<T, Rest>\n    : never\n>;\n\nexport const pick = <T, Selectors extends PropertySelector<T>[], U>(\n  source: T | (null | (undefined & U)),\n  ...args: Selectors\n): U extends undefined ? undefined : PickResults<T, Selectors> => {\n  if (source === undefined) return undefined as any;\n\n  return Object.fromEntries(\n    args\n      .flatMap((arg) =>\n        isObject(arg)\n          ? isArray(arg)\n            ? arg.map((args) =>\n                isArray(args)\n                  ? args.length === 1\n                    ? [args[0], source![args[0]]]\n                    : pick(source![args[0]], ...(args[1] as any[]))\n                  : [args, source![args]]\n              )\n            : Object.entries(args).map(([key, value]) => [\n                key,\n                value === true ? source![key] : pick(source![key], value),\n              ])\n          : ([[arg, source![arg]]] as any)\n      )\n      .filter((arg) => arg[1] != null)\n  ) as any;\n};\n\nexport type Wrapped<T> = T | (() => T);\n\nexport type Unwrap<T> = T extends () => infer R ? R : T;\n\nexport const unwrap: {\n  <T>(value: Wrapped<T>): T;\n} = (value: Wrapped<any>): any => (isFunction(value) ? value() : value);\n\nexport const unlock = <T extends ReadonlyPropertyContainer>(\n  readonly: T\n): T extends ReadonlyMapLike<infer K, infer V>\n  ? MapLike<K, V>\n  : T extends ReadonlySetLike<infer T>\n  ? SetLike<T>\n  : T => readonly as any;\n\nexport const wrap = <T>(\n  original: T,\n  wrap: (\n    original: T extends (...args: any) => any ? T : () => T,\n    ...args: T extends (...args: infer Args) => any ? Args : []\n  ) => T extends (...args: any) => infer R ? R : T\n): T =>\n  original == null\n    ? original\n    : isFunction(original)\n    ? (...args: any) => wrap(original as any, ...args)\n    : (wrap as any)(() => original as any);\n\n/** Creates a clone of an object (including arrays, sets and maps) at the specified depth. -1 means \"any depth\". */\nexport const clone = <T>(value: T, depth = -1): T =>\n  isArray(value)\n    ? depth\n      ? value.map((value) => clone(value, depth - 1))\n      : [...value]\n    : isPlainObject(value)\n    ? depth\n      ? obj(value as any, ([k, v]) => [k, clone(v, depth - 1)])\n      : { ...value }\n    : isSet(value)\n    ? new Set<any>(\n        depth\n          ? (map as any)(value, (value: any) => clone(value, depth - 1))\n          : value\n      )\n    : isMap(value)\n    ? new Map<any, any>(\n        depth\n          ? (map as any)(value, (value: any) =>\n              // Does not clone keys.\n              [value[0], clone(value[1], depth - 1)]\n            )\n          : value\n      )\n    : (value as any);\n\n/**\n * Very much like `Array.push` except it accepts anything with a `push ` method  (including non-generic overloads),\n * and returns the target so chaining is easier. Suitable for tight minification.\n */\nexport const push = <T extends { push: (...args: any) => any } | Nullish>(\n  target: T,\n  ...items: MethodOverloads<T, \"push\">[0]\n): T => target?.push(...(items as any))!;\n\n/**\n * Very much like `Array.pop` except it accepts anything with a `pop` method.\n * (Included or the sake of generality since we have {@link push}). Suitable for tight minification.\n */\nexport const pop = <T extends { pop(): R } | undefined, R>(\n  target: T\n): MaybeUndefined<T, R> => target?.pop() as any;\n\n/**\n * Very much like `Array.unshift` except it accepts anything with a `push ` method  (including non-generic overloads),\n * and returns the target so chaining is easier. Suitable for tight minification\n */\nexport const unshift = <T extends { unshift: (...args: any) => any } | Nullish>(\n  target: T,\n  ...items: MethodOverloads<T, \"unshift\">[0]\n): T => target?.unshift(...(items as any))!;\n\n/**\n * Very much like `Array.shift` except it accepts anything with a `shift` method.\n * (Included or the sake of generality since we have {@link unshift}). Suitable for tight minification. */\nexport const shift = <T extends { shift(): R } | undefined, R>(\n  target: T\n): MaybeUndefined<T, R> => target?.shift() as any;\n\n/**\n * Calculates the difference between the current version of an object, and the changed values specified.\n * If an updated property is numeric, the delta will be the difference between the updated and current number.\n * If an updated property is the same as the current value, it will not be included in the diff result,\n * otherwise this algorithm is no more sophisticated than just returning the new value in the diff (e.g. nothing special about strings).\n *\n * @returns A tuple with the first element being the differences between the updates and the current version,\n *  and the second element a clone of the current value with the changes applied.\n *  The latter should be passed as the second argument, next time the diff is calculated.\n */\nexport const diff = <T>(\n  updated: T,\n  previous: T | undefined\n): [delta: T, current: T] | undefined => {\n  if (!updated) return undefined;\n  if (!isPlainObject(previous)) return [updated, updated];\n\n  const delta: any = {};\n  let patchedValue: any;\n  let previousValue: number | undefined;\n\n  // If there are changes, this will be a clone of the previous value with the delta changes applied.\n  let patched: any;\n\n  if (isPlainObject(updated)) {\n    forEach(updated, ([key, value]) => {\n      if (structuralEquals(value, previous[key], -1)) {\n        // No changes.\n        return;\n      }\n\n      if (isPlainObject((patchedValue = value))) {\n        // deltaValue will be undefined if there are no changed in the child object.\n        if (!(value = diff(value, previous[key]))) {\n          return;\n        }\n        [value, patchedValue] = value;\n      } else if (isNumber(value) && isNumber(previousValue)) {\n        value = (patchedValue = value) - previousValue;\n      }\n\n      delta[key] = value;\n      (patched ??= clone(previous))[key] = patchedValue;\n    });\n    return patched ? [delta, patched] : undefined;\n  }\n\n  return undefined;\n};\n","import {\n  F,\n  MAX_SAFE_INTEGER,\n  MaybePromiseLike,\n  T,\n  isBoolean,\n  isFunction,\n  isNotFalse,\n  isTrue,\n  promise,\n  tryCatchAsync,\n} from \".\";\n\nexport const MILLISECOND = 1;\nexport const SECOND = MILLISECOND * 1000;\nexport const MINUTE = SECOND * 60;\nexport const HOUR = MINUTE * 60;\nexport const DAY = HOUR * 24;\nexport const FOREVER = MAX_SAFE_INTEGER;\n\nexport let now: (round?: boolean) => number =\n  typeof performance !== \"undefined\"\n    ? (round = T) =>\n        round ? Math.trunc(now(F)) : performance.timeOrigin + performance.now()\n    : Date.now;\n\nexport type Timer = {\n  (toggle?: boolean, reset?: boolean): number;\n};\n\nexport const reset = Symbol();\n\nexport const createTimer = (\n  started = true,\n  timeReference = () => now()\n): Timer => {\n  let t0: number = +started * timeReference();\n  let elapsed = 0;\n  let capturedElapsed: number;\n  return (toggle = started, reset?: boolean) => {\n    capturedElapsed = started\n      ? (elapsed += -t0 + (t0 = timeReference()))\n      : elapsed;\n    reset && (elapsed = 0);\n\n    (started = toggle) && (t0 = timeReference());\n\n    return capturedElapsed;\n  };\n};\n\n/**\n * The callback invoked when a {@link Clock} ticks.\n * If it returns `false` the clock will stop. Any other return value has no effect.\n */\nexport type ClockCallback = (\n  elapsed: number,\n  delta: number\n) => MaybePromiseLike<any>;\n\nexport interface Clock {\n  readonly active: boolean;\n  readonly busy: boolean;\n  restart(frequency?: number, callback?: ClockCallback): Clock;\n  toggle(start: boolean, trigger?: boolean): Clock;\n  trigger(skipQueue?: boolean): Promise<boolean>;\n}\n\nexport interface ClockSettings {\n  frequency?: number;\n  queue?: boolean;\n  paused?: boolean;\n  trigger?: boolean;\n  once?: boolean;\n  callback?: ClockCallback;\n  raf?: boolean;\n}\n\n/** Light-weight version of {@link clock}. The trigger and cancel overloads returns true to enable chaining like `timeout(false)&&...` */\nexport const createTimeout = (\n  defaultTimeout = 0\n): {\n  (callback: () => void, timeout?: number): void;\n  (cancel: false): true;\n  (trigger: true): true;\n  (): boolean;\n} => {\n  let handle: any;\n  let currentCallback: (() => void) | undefined;\n\n  const stickyTimeout = (arg?: any, timeout = defaultTimeout) => {\n    if (arg === undefined) {\n      return !!currentCallback;\n    }\n    clearTimeout(handle);\n    if (isBoolean(arg)) {\n      arg && (timeout < 0 ? isNotFalse : isTrue)(currentCallback?.())\n        ? stickyTimeout(currentCallback, timeout)\n        : (currentCallback = undefined);\n    } else {\n      currentCallback = arg;\n      handle = setTimeout(\n        () => stickyTimeout(true, timeout),\n        timeout < 0 ? -timeout : timeout\n      );\n    }\n  };\n  return stickyTimeout as any;\n};\n\nexport const clock: {\n  (callback: ClockCallback, frequency: number): Clock;\n  (settings: ClockSettings): Clock;\n} = (\n  callbackOrSettings: ClockCallback | ClockSettings,\n  frequency = 0\n): Clock => {\n  const settings = isFunction(callbackOrSettings)\n    ? {\n        frequency,\n        callback: callbackOrSettings,\n      }\n    : callbackOrSettings;\n\n  let {\n    queue = true,\n    paused = false,\n    trigger = false,\n    once = false,\n    callback = () => {},\n    raf,\n  } = settings;\n  frequency = settings.frequency ?? 0;\n\n  let timeoutId = 0;\n  const mutex = promise(true).resolve();\n  const timer = createTimer(!paused);\n  let delta = timer();\n\n  const outerCallback = async (skipQueue?: boolean) => {\n    if (!timeoutId || (!queue && mutex.pending && skipQueue !== true)) {\n      return false;\n    }\n    (instance as any).busy = true;\n    if (skipQueue !== true) {\n      while (mutex.pending) {\n        await mutex;\n      }\n    }\n\n    !skipQueue && mutex.reset();\n\n    if (\n      (await tryCatchAsync(\n        () => callback!(timer(), -delta + (delta = timer())),\n        false,\n        () => !skipQueue && mutex.resolve()\n      )) === false ||\n      frequency <= 0 ||\n      once\n    ) {\n      reset(false);\n    }\n\n    return !((instance as any).busy = false);\n  };\n\n  const updateTimeout = () =>\n    (timeoutId = setTimeout(\n      () => (raf ? requestAnimationFrame(timeoutCallback) : timeoutCallback()),\n      frequency < 0 ? -frequency : frequency\n    ) as any);\n\n  const timeoutCallback = () => {\n    instance.active && outerCallback();\n    instance.active && updateTimeout();\n  };\n\n  const reset = (start: boolean, resetTimer = !start) => {\n    timer(start, resetTimer);\n    clearTimeout(timeoutId);\n    (instance as any).active = !!(timeoutId = start ? updateTimeout() : 0);\n    return instance;\n  };\n\n  const instance: Clock = {\n    active: false,\n    busy: false,\n    restart: (newFrequency, newCallback) => {\n      frequency = newFrequency ?? frequency;\n      callback = newCallback ?? callback;\n      return reset(true, true);\n    },\n    toggle: (start, trigger) =>\n      start !== instance.active\n        ? start\n          ? trigger\n            ? (reset(true), instance.trigger(), instance)\n            : reset(true)\n          : reset(false)\n        : instance,\n    trigger: async (skipQueue) =>\n      (await outerCallback(skipQueue)) && (reset(instance.active), true),\n  };\n\n  return instance.toggle(!paused, trigger);\n};\n","import {\n  If,\n  MaybePromiseLike,\n  MaybeUndefined,\n  Nullish,\n  TogglePromise,\n  Unwrap,\n  Wrapped,\n  isFunction,\n  now,\n  throwError,\n  tryCatchAsync,\n  undefined,\n  unwrap,\n} from \".\";\n\nexport class ResettablePromise<T = void, E = any> implements PromiseLike<T> {\n  private _promise: OpenPromise<T>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public get value() {\n    return this._promise.value;\n  }\n  public get error() {\n    return this._promise.error;\n  }\n  public get pending() {\n    return this._promise.pending;\n  }\n\n  public resolve(value: T, ifPending = false) {\n    this._promise.resolve(value, ifPending);\n    return this;\n  }\n\n  public reject(value?: E, ifPending = false) {\n    this._promise.reject(value, ifPending);\n    return this;\n  }\n\n  public reset() {\n    this._promise = new OpenPromise<T>();\n    return this;\n  }\n\n  public signal(value: T) {\n    this.resolve(value);\n    this.reset();\n    return this;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): PromiseLike<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport class OpenPromise<T = void, E = any> implements PromiseLike<T> {\n  private readonly _promise: Promise<T>;\n\n  public readonly resolve: (value: T, ifPending?: boolean) => this;\n  public readonly reject: (reason: E | undefined, ifPending?: boolean) => this;\n  public readonly value: (T extends void ? true : T) | undefined;\n  public readonly error: E | true;\n  public pending = true;\n\n  constructor() {\n    let captured: any[];\n    this._promise = new Promise((...args: any[]) => {\n      captured = args.map((inner, i) => (value: any, ifPending: boolean) => {\n        if (!this.pending) {\n          if (ifPending) return this;\n          throw new TypeError(\"Promise already resolved/rejected.\");\n        }\n\n        (this as any).pending = false;\n        (this as any)[i ? \"error\" : \"value\"] = value === undefined || value;\n        inner(value);\n        return this;\n      });\n    });\n\n    [this.resolve, this.reject] = captured!;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | null\n      | undefined,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | null\n      | undefined\n  ): Promise<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport interface Lock {\n  /**\n   * Wait until the lock is available. If a timeout is not specified or negative, the calling thread will wait indefinitely.\n   * If a owner ID is specified the lock will be reentrant for that ID.\n   */\n  <Ms extends number | undefined = undefined>(\n    timeout?: Ms,\n    ownerId?: string\n  ): Promise<(() => void) | If<Ms, undefined>>;\n\n  /**\n   * Performs the specified action when the lock becomes available.\n   * If a timeout is not specified or negative, the calling thread will wait indefinitely.\n   * If a owner ID is specified the lock will be reentrant for that ID.\n   */\n  <T, Ms extends number | undefined = undefined>(\n    action: () => MaybePromiseLike<T>,\n    timeout?: Ms,\n    ownerId?: string\n  ): Promise<T | If<Ms, undefined>>;\n}\n\nexport type LockState = [owner: string | boolean, expires?: number];\n\nexport const createLock = (timeout?: number): Lock => {\n  const semaphore = promise<LockState | boolean>(true);\n  let state: LockState | undefined;\n\n  const wait = async (\n    arg1?: (() => any) | number,\n    arg2?: number | string,\n    arg3?: string\n  ) => {\n    if (isFunction(arg1)) {\n      const release = await wait(arg2 as number, arg3);\n      return release ? await tryCatchAsync(arg1, true, release) : undefined;\n    }\n    const ownerId = arg2 as string;\n\n    let ms = arg1 as number;\n    let renewInterval: any = 0;\n    while (state && ownerId !== state[0] && (state[1] ?? 0)! < now()) {\n      if (\n        (await (ms >= 0 ? race(delay(ms), semaphore) : semaphore)) === undefined\n      ) {\n        return undefined;\n      }\n      // If the above did not return undefined we got the semaphore.\n    }\n\n    const release = () => {\n      clearTimeout(renewInterval);\n      state = undefined;\n      semaphore.signal(false);\n    };\n\n    const renew = () => {\n      state = [ownerId ?? true, timeout ? now() - timeout : undefined];\n      timeout &&\n        (renewInterval = setTimeout(() => state && renew(), timeout / 2));\n    };\n    renew();\n\n    return release;\n  };\n  return wait;\n};\n\nexport const defer = (f: VoidFunction, ms = 0) =>\n  ms > 0 ? setTimeout(f, ms) : window.queueMicrotask(f);\n\nexport const delay = <\n  Delay extends number | Nullish,\n  T extends Wrapped<any> = void\n>(\n  ms: Delay,\n  value?: T\n): MaybeUndefined<Delay, TogglePromise<Unwrap<T>, true>> =>\n  ms == null || isFinite(ms)\n    ? !ms || ms <= 0\n      ? unwrap(value)!\n      : new Promise<any>((resolve) =>\n          setTimeout(async () => resolve(await unwrap(value)), ms)\n        )\n    : (throwError(`Invalid delay ${ms}.`) as any);\n\nexport const promise: {\n  <T = void>(resettable?: false): OpenPromise<T>;\n  <T = void>(resettable: true): ResettablePromise<T>;\n} = (resettable?: boolean) =>\n  resettable ? new ResettablePromise() : (new OpenPromise() as any);\n\ntype UnwrapPromiseArg<T> = T extends () => infer T ? Awaited<T> : Awaited<T>;\ntype UnwrapPromiseArgs<T extends any[]> = T extends readonly [infer Arg]\n  ? [UnwrapPromiseArg<Arg>]\n  : T extends readonly [infer Arg, ...infer Rest]\n  ? [UnwrapPromiseArg<Arg>, ...UnwrapPromiseArgs<Rest>]\n  : [];\n\nexport type AsyncValue<T> =\n  | undefined\n  | T\n  | PromiseLike<T>\n  | (() => T)\n  | (() => PromiseLike<T>);\n\nexport const waitAll = <Args extends AsyncValue<any>[]>(\n  ...args: Args\n): Promise<UnwrapPromiseArgs<Args>> =>\n  Promise.all(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n\nexport const race = <Args extends AsyncValue<any>[]>(\n  ...args: Args\n): Promise<UnwrapPromiseArgs<Args>[number]> =>\n  Promise.race(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n","import { filter, reduce } from \".\";\n\nexport type Rebinder = () => boolean;\nexport type Unbinder = () => boolean;\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\n\nexport type SourceListener<Args extends readonly any[]> = (\n  ...args: Args\n) => void;\nexport type Listener<Args extends readonly any[]> = (\n  ...args: [...args: Args, unbind: Unbinder]\n) => void;\n\nexport const createEventBinders = <Args extends any[]>(\n  listener: Listener<Args>,\n  attach: (listener: SourceListener<Args>) => void,\n  detach: (listener: SourceListener<Args>) => void\n): Binders => {\n  let bound = false;\n\n  const outerListener = (...args: Args) => listener(...args, unbind);\n\n  const unbind = () =>\n    bound !== (bound = false) && (detach(outerListener), true);\n\n  const rebind = () =>\n    bound !== (bound = true) && (attach(outerListener), true);\n\n  rebind();\n  return [unbind, rebind];\n};\n\nexport const joinEventBinders = (\n  ...binders: (Binders | undefined)[]\n): Binders => (\n  (binders = filter(binders)),\n  [\n    () => reduce(binders, (changed, binder) => binder![0]() || changed, false),\n    () => reduce(binders, (changed, binder) => binder![1]() || changed, false),\n  ]\n);\n\nexport type EventHandler<Args extends readonly any[]> = (\n  ...payload: Args\n) => void;\n\nexport const createEvent = <Args extends readonly any[]>(): [\n  listen: (listener: Listener<Args>, triggerCurrent?: boolean) => Binders,\n  dispatch: (...payload: Args) => void\n] => {\n  const listeners = new Set<SourceListener<Args>>();\n  let dispatchedArgs: Args | undefined;\n  return [\n    (handler, trigger) => {\n      const binders = createEventBinders(\n        handler as any,\n        (handler) => listeners.add(handler as any),\n        (handler) => listeners.delete(handler as any)\n      );\n      trigger &&\n        dispatchedArgs &&\n        (handler as any)(...dispatchedArgs, binders[0]);\n      return binders;\n    },\n    (...payload) => (\n      (dispatchedArgs = payload),\n      listeners.forEach((handler) => handler(...payload))\n    ),\n  ];\n};\n\nexport type ChainedEventHandler<Args extends any[], T> = (\n  ...args: [\n    ...args: Args,\n    next: {\n      (): T;\n      (...args: Args): T;\n    },\n    unbind: Unbinder\n  ]\n) => T;\n\ntype LinkedNode<T> = [\n  prev: LinkedNode<T> | undefined,\n  item: T,\n  next: LinkedNode<T> | undefined\n];\n\nexport const createChainedEvent = <T = void, Args extends any[] = []>(): [\n  register: (\n    handler: ChainedEventHandler<Args, T>,\n    priority?: number\n  ) => Binders,\n  invoke: (...args: Args) => T | undefined\n] => {\n  type Item = [\n    handler: ChainedEventHandler<Args, T>,\n    priority: number,\n    binders: Binders\n  ];\n  type Node = LinkedNode<Item>;\n  let head: Node | undefined;\n  let tail: Node | undefined;\n  let next: Node | undefined;\n\n  const register = (\n    handler: ChainedEventHandler<Args, T>,\n    // Make sure that handler gets rebound at their previous priority without jumping discrete increments.\n    // (It is deseriable to be able to specfiy priority 0 or  10 without having to think about how many 0s there are)\n    priority = (tail?.[1][1] ?? 0) + 0.000001\n  ) => {\n    const registerNode = (node?: Node) => {\n      let bound = true;\n      node ??= [\n        undefined,\n        [\n          handler,\n          priority,\n          [\n            () => {\n              if (!bound) return false;\n              node![0] ? (node![0][2] = node![2]) : (head = node![2]);\n              node![2] ? (node![2][0] = node![0]) : (tail = node![0]);\n              node![0] = node![2] = undefined;\n              return !(bound = false);\n            },\n            () => (bound ? false : (registerNode(node), (bound = true))),\n          ],\n        ],\n        undefined,\n      ];\n      next = head;\n      if (!next) {\n        head = tail = node;\n      } else if (priority >= tail![1][1]) {\n        node[0] = tail;\n        tail = tail![2] = node;\n      } else {\n        // INV: priority < tail.priority, so next will be non-null after loop;\n        while (next![1][1]! <= priority) {\n          next = next[2]!;\n        }\n\n        (node[0] = (node[2] = next)[0]) ? (node[0][2] = node) : (head = node);\n        next[0] = node;\n      }\n\n      return node[1][2];\n    };\n    return registerNode();\n  };\n\n  const invoke = (node: Node | undefined, args: Args) => (\n    (next = node?.[2]),\n    node\n      ? (node[1][0](\n          ...args,\n          (...nextArgs: Args) =>\n            invoke(next!, nextArgs.length ? nextArgs : args),\n          node[1][2][0]\n        ) as any)\n      : undefined\n  );\n\n  return [register, (...args) => invoke(head, args)];\n};\n","import {\n  MINUTE,\n  MaybeUndefined,\n  Nullish,\n  forEach2,\n  isArray,\n  isBoolean,\n  isIterable,\n  isNumber,\n  isObject,\n  isString,\n  map,\n  push,\n  replace,\n  round,\n  symbolIterator,\n  undefined,\n} from \".\";\n\nexport const changeCase = <S extends string | null | undefined>(\n  s: S,\n  upper: boolean\n): S => (s == null ? s : upper ? s.toUpperCase() : s.toLowerCase()) as S;\n\nexport const changeIdentifierCaseStyle = (\n  identifier: string,\n  type: \"camel\" | \"pascal\" | \"kebab\" | \"snake\"\n) =>\n  identifier.replace(\n    /([_-]*)(\\$*(?:[A-Z]+|[a-z]))([a-z0-9]*)/g,\n    (_, underscores, initial, rest, index) =>\n      (underscores && (!index || type === \"kebab\" || type === \"snake\")\n        ? underscores.replace(/./g, type === \"snake\" ? \"-\" : \"_\")\n        : \"\") +\n      ((index && (type === \"kebab\" || type === \"snake\") && !underscores\n        ? type === \"snake\"\n          ? \"-\"\n          : \"_\"\n        : \"\") +\n        changeCase(initial, type === \"pascal\" || (type === \"camel\" && index)) +\n        changeCase(\n          type === \"kebab\" || type === \"snake\"\n            ? rest.replace(\n                /(?<=\\D)\\d|(?<=\\d)\\D/g,\n                type === \"kebab\" ? \"_$&\" : \"-$&\"\n              )\n            : rest,\n          false\n        ))\n  );\n\n/**\n * Pluralizes a noun using standard English rules.\n * It is not very smart, so if the plural form is not just adding an \"s\" in the end unless the singular form already ends with \"s\",\n * it must be specified manually.\n *\n * @param singular - The singular form of the noun\n * @param n - The number of items that decides if the noun should be pluralized. If given an array the number will be postfixed.\n * @param plural - The plural form if it is different from adding an \"s\" to the singular form.\n * @returns The noun, pluralized if needed.\n */\nexport const pluralize = <\n  T extends string | Nullish,\n  N extends number | Nullish,\n  Plural extends string = string\n>(\n  singular: T,\n  n: N | [count: N],\n  plural?: Plural\n): T extends Nullish ? undefined : N extends Nullish ? undefined : string =>\n  singular == null\n    ? (undefined as any)\n    : isArray(n)\n    ? (n = n[0]) == null\n      ? undefined\n      : n + \" \" + pluralize(singular, n, plural)\n    : n == null\n    ? undefined!\n    : n === 1\n    ? singular\n    : plural ?? (singular === \"is\" ? \"are\" : singular + \"s\");\n\nlet ansiSupported = true;\n\n/** Enables or disables ANSI formatting in console output. */\nexport const toggleAnsi = (toggle = true) => (ansiSupported = toggle);\n\n/**\n * Can colorize text using ANSI escape sequences.\n * See e.g. https://developer.chrome.com/docs/devtools/console/format-style for options.\n */\nexport const ansi = <Buffer extends string[] | undefined = undefined>(\n  value: string | string[],\n  ps: string | number,\n  buffer?: Buffer\n): Buffer extends undefined ? string : string[] =>\n  buffer\n    ? (ansiSupported && push(buffer, \"\\x1B[\", ps, \"m\"),\n      isArray(value) ? push(buffer, ...value) : push(buffer, value),\n      ansiSupported && push(buffer, \"\\x1B[m\"),\n      buffer)\n    : (ansi(value, ps, []).join(\"\") as any);\n\nconst indent = (buffer: string[], n: number, ...values: string[]) => (\n  push(buffer, \"  \".repeat(n), ...values), buffer\n);\nconst br = (buffer: string[], indents = 0) => (\n  indents > 0 && indent(buffer, indents), push(buffer, \"\\n\"), buffer\n);\n\nconst prettyPrint = (\n  value: any,\n  buffer: string[] = [],\n  indents = 0,\n  terminator = \"\"\n) => {\n  const wrap = (\n    start: string,\n    end: string,\n    content: (buffer: string[]) => void\n  ) => {\n    ansi(start, 90, buffer);\n    const subBuffer: string[] = [];\n    content(subBuffer);\n    subBuffer.length &&\n      (br(buffer, indents), push(buffer, ...subBuffer)) &&\n      indent(buffer, indents);\n\n    ansi(end, 90, buffer);\n  };\n\n  if (value == null) {\n    ansi(value === undefined ? \"(undefined)\" : \"(null)\", \"37;2\", buffer);\n  } else if (isIterable(value)) {\n    wrap(\"[\", \"]\", (buffer) =>\n      forEach2(\n        value,\n        (value) => (\n          indent(buffer, indents),\n          prettyPrint(value, buffer, indents + 1, \",\\n\")\n        )\n      )\n    );\n  } else if (isObject(value)) {\n    wrap(\"{\", \"}\", (buffer) =>\n      forEach2(\n        value,\n        ([key, value]) => (\n          indent(buffer, indents + 1),\n          ansi([\"\" + (key as any), \":\"], \"90;3\", buffer),\n          push(buffer, \" \"),\n          prettyPrint(value, buffer, indents + 1, \",\\n\")\n        )\n      )\n    );\n  } else if (isString(value)) {\n    ansi(value, 36, buffer);\n  } else if (isNumber(value) || isBoolean(value)) {\n    ansi(\"\" + value, 33, buffer);\n  } else {\n    push(buffer, value);\n  }\n  terminator && push(buffer, terminator);\n  return buffer;\n};\n\ntype UppercaseLetter =\n  | \"A\"\n  | \"B\"\n  | \"C\"\n  | \"D\"\n  | \"E\"\n  | \"F\"\n  | \"G\"\n  | \"H\"\n  | \"I\"\n  | \"J\"\n  | \"K\"\n  | \"L\"\n  | \"M\"\n  | \"N\"\n  | \"O\"\n  | \"P\"\n  | \"Q\"\n  | \"R\"\n  | \"S\"\n  | \"T\"\n  | \"U\"\n  | \"V\"\n  | \"W\"\n  | \"X\"\n  | \"Y\"\n  | \"Z\";\n\n/**\n * This is intended for prettifying enum names (like ServerWrite becomes 'server-write'), alas it does currently not work with\n * ts-json-schema-generator. Kept in the hope this will be supported one day.\n */\nexport type SnakeCase<\n  S extends string | Nullish,\n  First = true\n> = S extends Nullish\n  ? undefined\n  : S extends `${infer P}${infer Rest}`\n  ? [P, First] extends [UppercaseLetter, false]\n    ? `-${Lowercase<P>}${SnakeCase<Rest, false>}`\n    : `${Lowercase<P>}${SnakeCase<Rest, false>}`\n  : S extends string\n  ? Lowercase<S>\n  : undefined;\n\nexport const snakeCase = <S extends string | Nullish>(\n  s: S\n): MaybeUndefined<S, SnakeCase<S>> =>\n  replace(s, /(.)?([A-Z])/g, (_, prev, p) =>\n    ((prev ? prev + \"-\" : \"\") + p).toLowerCase()\n  ) as any;\n\nexport const quote = <T>(\n  item: T,\n  quoteChar = \"'\"\n): MaybeUndefined<T, T extends Iterable<any> ? string[] : string> =>\n  item == null\n    ? (undefined as any)\n    : item[symbolIterator]\n    ? map(item, (item) => quote(item, quoteChar))\n    : quoteChar + item + quoteChar;\n\nexport const ellipsis = <T extends string | Nullish>(\n  text: T,\n  maxLength: number,\n  debug = false\n): T =>\n  text &&\n  ((text.length > maxLength\n    ? debug\n      ? `${text.slice(0, maxLength)}... [and ${text.length - maxLength} more]`\n      : text.slice(0, maxLength - 1) + \"\"\n    : text) as any);\n\n/** Word statistics for a text. */\nexport type TextStats = {\n  /** The source text. */\n  text: string;\n\n  /** The number of characters in the text. */\n  length: number;\n\n  /** The number of word characters (a letter or number followed by any number of letters, numbers or apostrophes) in the text. */\n  characters: number;\n\n  /** The number of words in the text. A word is defined as a group of consecutive word characters. */\n  words: number;\n\n  /**\n   * The number of sentences in the text.\n   * A sentence is defined as any group of characters where at least one of them is a word character\n   * terminated by `.`, `!`, `?` or the end of the text.\n   */\n  sentences: number;\n\n  /**\n   * The LIX index for the text. The measure gives an indication of how difficult it is to read.\n   * (https://en.wikipedia.org/wiki/Lix_(readability_test))\n   */\n  lix: number;\n\n  /**\n   * The estimated time it will take for an average user to read all the text.\n   * The duration is in milliseconds since that is the time precision for ECMAScript timestamps.\n   *\n   * The estimate is assuming \"Silent reading time\" which seems to be 238 words per minute according\n   * to [Marc Brysbaert's research] (https://www.sciencedirect.com/science/article/abs/pii/S0749596X19300786?via%3Dihub)\n   *\n   */\n  readTime: number;\n\n  /**\n   * The character indices in the source text that demarcates specific fractions of the total numbers of word characters.\n   *\n   * Defaults to 0 %, 25 %, 50 %, 75 % and 100 % of the total number of letters respectively.\n   * The index is for the character after the last letter that that does not exceed the boundary.\n   * For example, the 25 % boundary of \"abcd\" is 1 (between a and b).\n   */\n  boundaries: { offset: number; wordsBefore: number; readTime: number }[];\n};\n\nexport const getTextStats = (\n  text: string,\n  boundaryLimits = [0, 0.25, 0.5, 0.75, 1]\n): TextStats => {\n  let charMatcher = /[\\p{L}\\p{N}][\\p{L}\\p{N}']*|([.!?]+)/gu;\n  let match: RegExpMatchArray | null;\n  let chars = 0;\n  let words = 0;\n  let longWords = 0;\n  let sentences = 0;\n\n  let hasWord = false;\n  while ((match = charMatcher.exec(text))) {\n    if (match[1]) {\n      hasWord && ++sentences;\n      hasWord = false;\n    } else {\n      hasWord = true;\n      chars += match[0].length;\n      match[0].length > 6 && ++longWords;\n      ++words;\n    }\n  }\n  hasWord && ++sentences;\n  charMatcher = /[\\p{L}\\p{N}]|([^\\p{L}\\p{N}]+)/gu;\n\n  const limits = boundaryLimits.map((boundary) => (boundary * chars) | 0);\n  const boundaries: TextStats[\"boundaries\"] = [];\n\n  let index = 0;\n  let prevIndex: number | undefined;\n  let wordsBefore = 0;\n  let inSentence = false;\n\n  do {\n    match = charMatcher.exec(text)!;\n    if (match?.[1]) {\n      // Word delimiter\n      inSentence && ++wordsBefore;\n    } else {\n      index = match?.index!;\n      let wasBoundary = false;\n      for (let i = 0; i < limits.length; i++) {\n        if (!limits[i]--) {\n          boundaries[i] = {\n            offset: prevIndex ?? index,\n            wordsBefore,\n            readTime: round(MINUTE * (wordsBefore / 238)),\n          };\n          wasBoundary = true;\n        }\n      }\n      (inSentence = !wasBoundary) || (wordsBefore = 0);\n      prevIndex = index + 1;\n    }\n  } while (match);\n\n  return {\n    text,\n    length: text.length,\n    characters: chars,\n    words,\n    sentences,\n    lix: round(words / sentences + (100 * longWords) / words),\n    readTime: round(MINUTE * (words / 238)),\n    boundaries,\n  };\n};\n","import { Nullish, isNumber, map2, skip2, throwError, undefined } from \".\";\n\nexport type EnumParser<Values> = _EnumParser<FilterEnumValues<Values>>;\n\nexport const createEnumParser: <Values>(\n  name: string,\n  values: Values\n) => EnumParser<Values> = (name, values) => {\n  const levels: string[] = [];\n  const ranks: Record<string, number> = {};\n  const parser: Record<string, string> = {};\n\n  let rank = 0;\n  for (let key in values) {\n    if (key === values[key]) {\n      Object.defineProperty(parser, key, {\n        value: key,\n        writable: false,\n        enumerable: true,\n        configurable: false,\n      });\n      ranks[key] = rank++;\n      levels.push(key);\n    }\n  }\n\n  const parse = (value: any, validate = true) =>\n    value == null\n      ? undefined\n      : ranks[value] != null\n      ? value\n      : validate\n      ? throwError(`The ${name} \"${value}\" is not defined.`)\n      : undefined;\n\n  const propertySettings = {\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  };\n  Object.defineProperties(parser, {\n    parse: {\n      value: parse,\n      ...propertySettings,\n    },\n    ranks: {\n      value: ranks,\n      ...propertySettings,\n    },\n    levels: {\n      value: levels,\n      ...propertySettings,\n    },\n    compare: {\n      value: (lhs: any, rhs: any) => {\n        const rank1 = ranks[parse(lhs)],\n          rank2 = ranks[parse(rhs)];\n        return rank1 < rank2 ? -1 : rank1 > rank2 ? 1 : 0;\n      },\n      ...propertySettings,\n    },\n  });\n\n  return parser as any;\n};\n\ntype FilterEnumValues<T> = Pick<\n  T,\n  {\n    [P in keyof T]: [T[P]] extends [P] ? T[P] : never;\n  }[keyof T]\n>;\n\ntype _EnumParser<\n  Values,\n  Keys extends string = keyof Values & string\n> = Values & {\n  parse<\n    T extends Keys | (string & {}) | number | Nullish,\n    Validate extends boolean = true\n  >(\n    value: T,\n    validate?: Validate\n  ): T extends Nullish\n    ? undefined\n    : Keys | (Validate extends true ? never : undefined);\n\n  readonly levels: Keys[];\n  readonly ranks: { [P in Keys]: number };\n\n  compare(lhs: Keys, rhs: Keys): number;\n};\n","import {\n  MaybeUndefined,\n  Nullish,\n  PickRequired,\n  PrettifyIntersection,\n  SimpleObject,\n  concat2,\n  forEach2,\n  group2,\n  isArray,\n  isString,\n  join2,\n  map,\n  map2,\n  match,\n  nil,\n  obj2,\n  skip2,\n  stop2,\n  undefined,\n} from \".\";\n\ntype QueryStringDelimiterValue =\n  | boolean\n  | string\n  | readonly string[]\n  | readonly [];\n\nexport type ParsedUri<\n  QueryStringDelimiters extends QueryStringDelimiterValue = QueryStringDelimiterValue\n> = {\n  /** The original URI that was parsed. */\n  source: string;\n  /** The name of the scheme excluding colon and slashes. */\n  scheme?: string;\n\n  /**\n   * Whether the scheme includes two slashes or not (in which case it is a urn).\n   * Slashes are only included when formatting the URI if this value is explicity `false`,\n   * or {@link scheme} has a value and it is not explicitly `true`.\n   *\n   * @default false\n   */\n  urn?: boolean;\n\n  /**\n   * User name, password, host and port as much as any of these are part of the URI.\n   * When formatting a parsed URI, this is not used, but rather the individual parts.\n   */\n  authority?: string;\n\n  user?: string;\n  password?: string;\n  host?: string;\n  port?: number;\n  path?: string;\n  query?: QueryStringDelimiters extends false\n    ? string\n    : ParsedQueryString<Exclude<QueryStringDelimiters, null>>;\n  fragment?: string;\n};\n\nexport const parameterListSymbol = Symbol();\nexport type ParsedQueryString<Delimiters extends QueryStringDelimiterValue> =\n  Record<\n    string,\n    Delimiters extends Nullish | readonly [] | false\n      ? string\n      : string | string[]\n  > & {\n    [parameterListSymbol]?: [\n      string,\n      Delimiters extends Nullish | readonly [] | false\n        ? string\n        : string | string[]\n    ];\n  };\n\nexport const uriEncode = (value: any) =>\n  value != nil ? encodeURIComponent(value) : undefined;\n\nexport const parseKeyValue = <\n  Delimiters extends QueryStringDelimiterValue = [\"|\", \";\", \",\"]\n>(\n  value: string | Nullish,\n  {\n    delimiters = [\"|\", \";\", \",\"] as any,\n    decode = true,\n    lowerCase,\n  }: QueryStringParseOptions<Delimiters> = {}\n):\n  | readonly [key: string, value: string | undefined, values: string[]]\n  | undefined => {\n  if (!value) return undefined;\n  const parts: [string, string, string[]] = value.split(\"=\").map((v) => {\n    v = decode ? decodeURIComponent(v.trim()).replaceAll(\"+\", \" \") : v.trim();\n    return lowerCase ? v.toLowerCase() : v;\n  }) as any;\n  let split: string[];\n  parts[1] ??= \"\";\n  parts[2] =\n    (parts[1] &&\n      ((isString(delimiters) && (delimiters = [delimiters] as any)) ||\n        isArray(delimiters)) &&\n      forEach2(delimiters as string[], (delim) =>\n        (split = parts[1]!.split(delim)).length > 1 ? stop2(split) : undefined\n      )) ||\n    (parts[1] ? [parts[1]] : []);\n\n  return parts;\n};\n\n// // Browsers accepts `//` as \"whatever the protocol is\" is links.\n// // A scheme can only be letters, digits, `+`, `-` and `.`.\n// // The slashes are captured so we can put the parsed URI correctly back together.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1\n// Scheme (group 1 and 2) = `//` or `name:` or `name://` = (?:(?:([\\w+.-]+):)?(\\/\\/)?)\n\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.1\n// User Information (groups 4 and 5) = `user@` or `user:password@` = (?:([^:@]+)(?:\\:([^@]*))?@)\n\n// // If an IPv6 address is used with a port it is wrapped in square brackets.\n// // Otherwise a host is anything until port, path or query string.\n// // Se also https://serverfault.com/questions/205793/how-can-one-distinguish-the-host-and-the-port-in-an-ipv6-url about the brackets.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2\n// Host (group 6 or 7) = `[ IPv6 or IPvFuture ]:port` or IPv6 or `IPv4:port` or `domain:port`  = (?:\\[([^\\]]+)\\]|([0-9:]+|[^/+]+?))\n\n// //Port is included in the optional host group to separate `about:blank` like schemes from `localhost:1337` like hosts\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.3\n// Port (group 8) = (?::(\\d*))?\n\n// Authority (group 3) = User Information + Host + Port\n\n// // Anything until an optional query or fragment\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3\n// Path and  (group 9) = (\\/[^#?]*)\n\n// // Anything following a `?` until an optional fragment.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.4\n// Query (group 10) = (?:\\?([^#]*))\n\n// // Anything following a pound sign until end.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\n// Fragment (group 11) = (?:#.*)\n\n// Everything put together\n// ^(?:(?:([\\w+.-]+):)?(?:\\/\\/)?)?((?:([^:@]+)(?:\\:([^@]*))?@)?(?:\\[([^\\]]+)\\]|([0-9:]+|[^/+]+?))?(?::(\\d*))?)?(\\/[^#?]*)?(?:\\?([^#]*))?(?:#(.*))?$\n\n/**\n * Parses an URI according to https://www.rfc-editor.org/rfc/rfc3986#section-2.1.\n * The parser is not pedantic about the allowed characters in each group\n *\n * @param uri The URI to parse\n * @param query Whether to parse the query into a record with each parameter and its value(s) or just the string.\n *  If an array is provided these are the characters that are used to split query string values. If this is empty, arrays are not parsed.\n * @returns A record with the different parts of the URI.\n */\nexport const parseUri = <\n  Uri extends string | Nullish,\n  Delimiter extends QueryStringDelimiterValue = true,\n  RequireAuthority extends boolean = false\n>(\n  uri: Uri,\n  {\n    delimiters = true as any,\n    requireAuthority,\n    ...options\n  }: QueryStringParseOptions<Delimiter> & {\n    requireAuthority?: RequireAuthority;\n  } = {}\n):\n  | PrettifyIntersection<\n      RequireAuthority extends true\n        ? PickRequired<ParsedUri<Delimiter>, \"scheme\" | \"host\" | \"urn\" | \"path\">\n        : ParsedUri<Delimiter>,\n      true\n    >\n  | (Uri extends Nullish ? undefined : never) =>\n  uri == nil\n    ? undefined\n    : (match(\n        uri,\n        /^(?:(?:([\\w+.-]+):)?(\\/\\/)?)?((?:([^:@]+)(?:\\:([^@]*))?@)?(?:\\[([^\\]]+)\\]|([0-9:]+|[^/+]+?))?(?::(\\d*))?)?(\\/[^#?]*)?(?:\\?([^#]*))?(?:#(.*))?$/g,\n        (\n          source: string,\n          scheme,\n          slashes,\n          authority,\n          user,\n          password,\n          bracketHost,\n          host,\n          port,\n          path,\n          queryString,\n          fragment\n        ) => {\n          const parsed: ParsedUri = {\n            source,\n            scheme,\n            urn: scheme ? !slashes : slashes ? false : undefined,\n            authority,\n            user,\n            password,\n            host: bracketHost ?? host,\n            port: port != null ? parseInt(port) : undefined,\n            path,\n            query:\n              delimiters === false\n                ? queryString\n                : queryString\n                ? parseQueryString(queryString, { ...options, delimiters })\n                : undefined,\n            fragment,\n          };\n          parsed.path =\n            parsed.path ||\n            (parsed.authority ? (parsed.urn ? \"\" : \"/\") : undefined);\n          return parsed;\n        }\n      ) as any);\n\nexport type QueryStringParseOptions<\n  Delimiters extends QueryStringDelimiterValue = [\",\"]\n> = {\n  /** Setting this to false disables parsing of query string parameters, and instead gives the raw query string in the URI parse result. */\n  delimiters?: Delimiters;\n  decode?: boolean;\n  lowerCase?: boolean;\n};\n\nexport const parseHttpHeader = <\n  V extends string | Nullish,\n  Delimiter extends QueryStringDelimiterValue = \",\"\n>(\n  query: V,\n  options?: QueryStringParseOptions<Delimiter>\n): PrettifyIntersection<ParsedQueryString<Delimiter>> =>\n  parseParameters(query, \"; \", options);\n\nexport const parseQueryString = <\n  V extends string | Nullish,\n  Delimiters extends QueryStringDelimiterValue = true\n>(\n  query: V,\n  options?: QueryStringParseOptions<Delimiters>\n): PrettifyIntersection<ParsedQueryString<Delimiters>> =>\n  parseParameters(query, \"&\", options);\n\nexport const parseParameters = <\n  V extends string | Nullish,\n  Delimiters extends QueryStringDelimiterValue = true\n>(\n  query: V,\n  separator: string,\n  {\n    delimiters = true as any,\n    ...options\n  }: QueryStringParseOptions<Delimiters> = {}\n): PrettifyIntersection<ParsedQueryString<Delimiters>> => {\n  const parameters = map2(\n    query?.match(/(?:^.*?\\?|^)([^#]*)/)?.[1]?.split(separator),\n    (part) => {\n      let [key, value, values] =\n        parseKeyValue(part, {\n          ...options,\n          delimiters:\n            delimiters === false\n              ? []\n              : delimiters === true\n              ? undefined\n              : delimiters,\n        }) ?? [];\n      return (key = key?.replace(/\\[\\]$/, \"\")) != null\n        ? delimiters !== false\n          ? [key, values!.length > 1 ? values! : value!]\n          : [key, value!]\n        : skip2;\n    }\n  );\n\n  const results = obj2(group2(parameters, false), ([key, values]) => [\n    key,\n    delimiters !== false\n      ? values.length > 1\n        ? concat2(values)\n        : values[0]\n      : values.join(\",\"),\n  ]) as any;\n\n  return results\n    ? ((results[parameterListSymbol] = parameters), results)\n    : results;\n};\n\nexport const toQueryString = <\n  P extends\n    | Iterable<readonly [string, any]>\n    | SimpleObject<string, any>\n    | undefined\n>(\n  parameters: P,\n  delimiter = \",\"\n): MaybeUndefined<P, string> =>\n  parameters == nil\n    ? undefined\n    : (map(parameters, ([key, value]) => {\n        return isString(key)\n          ? key +\n              \"=\" +\n              (isArray(value)\n                ? map(value, uriEncode).join(delimiter)\n                : uriEncode(value) ?? \"\")\n          : undefined;\n      })?.join(\"&\") as any);\n\nexport const appendQueryString = <Uri extends string | undefined>(\n  baseUri: Uri,\n  parameters:\n    | Record<string, any>\n    | Iterable<readonly [key: string, value: any]>\n    | undefined\n): MaybeUndefined<Uri, string> => {\n  if (!baseUri) return undefined!;\n  const qs = toQueryString(parameters);\n  return (baseUri.match(/^[^?]*/)![0] + (qs ? \"?\" + qs : \"\")) as any;\n};\n\nexport const mergeQueryString = <Uri extends string | undefined>(\n  currentUri: Uri,\n  parameters:\n    | Record<string, any>\n    | Iterable<readonly [key: string, value: any]>\n    | undefined\n): MaybeUndefined<Uri, string> => {\n  if (!currentUri) return undefined!;\n  const current = parseQueryString(currentUri);\n  forEach2(\n    parameters,\n    ([key, value]) => (current[key] = current[key] ?? value)\n  );\n  return appendQueryString(currentUri, current) as any;\n};\n\nexport const formatUri = <Uri extends Omit<ParsedUri, \"source\">>(\n  uri: Uri\n): MaybeUndefined<Uri, string> =>\n  uri == nil\n    ? (undefined as any)\n    : join2(\n        [\n          uri.scheme || uri.urn === false\n            ? (uri.scheme ? uri.scheme + \":\" : \"\") + (!uri.urn ? \"//\" : \"\")\n            : \"\",\n          uri.user,\n          uri.password ? \":\" + uri.password : undefined,\n          uri.user && \"@\",\n          uri.host,\n          uri.port ? \":\" + uri.port : undefined,\n          uri.path === \"/\" ? \"\" : uri.path,\n          uri.query &&\n            \"?\" + (isString(uri.query) ? uri.query : toQueryString(uri.query)),\n          uri.fragment && \"#\" + uri.fragment,\n        ],\n        \"\"\n      ) || undefined!;\n","import { assign } from \".\";\r\n\r\nexport type Interval<T> = [start: T, end: T];\r\nexport type Intervals<T = number> = ReadonlyArray<[start: T, end: T]> & {\r\n  /**\r\n   * Updates the intervals to include the specified start and end,\r\n   * and returns the updated total width.\r\n   *\r\n   */\r\n  push: (start: T, end: T) => number;\r\n\r\n  /** The total width of the intervals. */\r\n  width: number;\r\n};\r\n\r\nexport const createIntervals = <T = number>(\r\n  cmp: (x: T, y: T) => number = (x: any, y: any) => (x - y) as any,\r\n  width: (interval: Interval<T>) => number = (interval: any) =>\r\n    (interval[1] - interval[0]) as any\r\n): Intervals<T> => {\r\n  const ranges: Interval<T>[] = [];\r\n\r\n  return assign(ranges, {\r\n    push(start: T, end: T) {\r\n      let pending: Interval<T> | undefined = [start, end];\r\n\r\n      const finalize = (update: any = true) =>\r\n        update\r\n          ? ((ranges as any).width = ranges.reduce(\r\n              (sum, interval) => sum + width(interval),\r\n              0\r\n            ))\r\n          : (ranges as any).width;\r\n\r\n      let changed: any;\r\n      for (let i = 0; i < ranges.length; i++) {\r\n        let current = ranges[i];\r\n        if (cmp(pending[1], current[0]) < 0) {\r\n          // Ends before next start. Insert before.\r\n          return finalize(ranges.splice(i, 0, pending));\r\n        } else if (cmp(pending[0], current[1]) <= 0) {\r\n          if (cmp(pending[0], current[0]) < 0) {\r\n            // Expand left (changed).\r\n            changed = current[0] = pending[0];\r\n          }\r\n          if (cmp(pending[1], current[1]) > 0) {\r\n            // Expand right (changed).\r\n            changed = current[1] = pending[1];\r\n          }\r\n          if (ranges[i + 1]?.[0] < current[1]) {\r\n            // Detach the current range since it is to be merged with the next.\r\n            changed = pending = ranges.splice(i--, 1)[0];\r\n          } else {\r\n            // Only update the total width if the current range was expanded or merged.\r\n            return finalize(changed != null);\r\n          }\r\n        }\r\n      }\r\n\r\n      // If there still is a pending range it means its start comes after the current end.\r\n      // Only update width in that case.\r\n      return finalize(pending && (ranges[ranges.length] = pending));\r\n    },\r\n    width: 0,\r\n  }) as any;\r\n};\r\n","import {\r\n  Falsish,\r\n  IteratorItem2,\r\n  MaybeNullishOrFalse,\r\n  Nullish,\r\n  SimpleObject,\r\n  UnionToIntersection,\r\n} from \"..\";\r\n\r\n/** Encourages TypeScript to treat a return value as a tuple (for some reason also, if the tuple has more than one element). */\r\nexport type AnyTuple =\r\n  | readonly [any]\r\n  | readonly [any][]\r\n  | readonly [any][][]\r\n  | readonly [any][][][]\r\n  | readonly [any][][][][];\r\n\r\nexport type EncourageTuples<T> = T | (T & AnyTuple);\r\n\r\nexport type AllowAdditionalElements<T extends readonly any[]> =\r\n  number extends T[\"length\"] ? T : [...T, ...any];\r\n\r\nexport type KeyValueType<K = keyof any, V = any> = readonly [K, V];\r\nexport type KeyValueTypeLike<K = keyof any, V = any> = readonly [K, V, ...any];\r\n\r\nexport type UnknownIsOkay<R, V> = R extends undefined\r\n  ? R\r\n  : unknown extends V\r\n  ? any\r\n  : R extends V\r\n  ? R\r\n  : V & R extends never[]\r\n  ? R\r\n  : never;\r\n\r\nexport type NeverIsAny<T> = T extends never[]\r\n  ? any[]\r\n  : unknown extends T\r\n  ? any\r\n  : [T] extends [never]\r\n  ? any\r\n  : T;\r\n\r\nexport type NotMapOrSet<T> = T extends\r\n  | ReadonlyMap<any, any>\r\n  | WeakMap<any, any>\r\n  | ReadonlySet<any>\r\n  | WeakSet<any>\r\n  ? never\r\n  : T;\r\n\r\nexport type RecordKeyOf<T> = T extends infer T ? keyof T : never;\r\n\r\nexport type Selector<T = any> =\r\n  | RecordKeyOf<T>\r\n  | ((item: T, ...args: any) => any)\r\n  | Nullish;\r\n\r\nexport type EntriesOf<T> = { [P in keyof T]-?: [P, T[P]] }[keyof T];\r\n\r\ntype StringOrNumber<Z> =\r\n  | Z\r\n  | (Z extends `${infer N extends number}` ? N : never);\r\n\r\nexport type KeyTypeOf<T> = unknown extends T\r\n  ? any\r\n  : T extends Nullish\r\n  ? never\r\n  : T extends Map<infer K, any>\r\n  ? K\r\n  : T extends WeakMap<infer K, any>\r\n  ? K\r\n  : T extends Set<infer K>\r\n  ? K\r\n  : T extends WeakSet<infer K>\r\n  ? K\r\n  : T extends readonly any[]\r\n  ? StringOrNumber<keyof T & `${number}`>\r\n  : keyof T;\r\n\r\nexport type InputValueTypeOf<T, K = KeyTypeOf<T>> = unknown extends T\r\n  ? any\r\n  : T extends Set<any>\r\n  ? unknown\r\n  : ValueTypeOf<T, K>;\r\n\r\nexport type ValueTypeOf<T, K = KeyTypeOf<T>> = unknown extends T\r\n  ? any\r\n  : T extends Map<infer MapKey, infer V>\r\n  ? K extends MapKey\r\n    ? V | undefined\r\n    : never\r\n  : T extends WeakMap<infer MapKey, infer V>\r\n  ? K extends MapKey\r\n    ? V | undefined\r\n    : never\r\n  : T extends Set<any> | WeakSet<any>\r\n  ? boolean\r\n  : T extends Nullish\r\n  ? never\r\n  : unknown extends K\r\n  ? T[KeyTypeOf<T> & keyof T]\r\n  : K extends KeyTypeOf<T>\r\n  ? T[K & keyof T]\r\n  : never;\r\n\r\nexport type EntryTypeOf<Source> = unknown extends Source\r\n  ? readonly [any, any]\r\n  : KeyTypeOf<Source> extends infer K\r\n  ? readonly [K, ValueTypeOf<Source, K>]\r\n  : never;\r\n\r\nexport type ObjectFromEntries<\r\n  Entries extends KeyValueTypeLike<any, any> | Nullish\r\n> = UnionToIntersection<\r\n  Entries extends readonly [infer Key extends keyof any, infer Value, ...any]\r\n    ? { [P in Key]: Value }\r\n    : {}\r\n> extends infer T\r\n  ? { [P in keyof T]: T[P] }\r\n  : never;\r\n\r\nexport type MapFromEntries<Entries extends readonly [any, any] | Nullish> = [\r\n  Entries extends readonly [infer Key, infer Value]\r\n    ? [Key, Value]\r\n    : [never, never]\r\n] extends [[infer Key, infer Value]]\r\n  ? Map<Key, Value>\r\n  : never;\r\n\r\nexport type ObjectSourceToObject<Source> = Source extends Falsish\r\n  ? {}\r\n  : Source extends Iterable<Falsish | infer Kv extends KeyValueTypeLike>\r\n  ? ObjectFromEntries<Kv>\r\n  : Source;\r\n\r\nexport type IterationResultArray<It> = MaybeNullishOrFalse<\r\n  [IteratorItem2<It>] extends [never] ? undefined : IteratorItem2<It>[],\r\n  It\r\n>;\r\n\r\nexport type DefaultAssignValue<\r\n  T,\r\n  K extends KeyTypeOf<T> = KeyTypeOf<T>\r\n> = T extends Set<any> | WeakSet<any>\r\n  ? true\r\n  : undefined extends ValueTypeOf<T, K>\r\n  ? undefined\r\n  : never;\r\n\r\n/** Converts generic types with `any` parameters to their specific types. E.g. Map<any,any> to Map<string,number>.  */\r\nexport type ToSpecificGenericType<Value, SpecificType> =\r\n  SpecificType extends infer SpecificType\r\n    ? Value extends SpecificType\r\n      ? SpecificType\r\n      : never\r\n    : never;\r\n\r\n/** Wraps the value in a promise if the function is async.  */\r\nexport type PromiseIfAsync<Value, F> = F extends (...args: any) => infer R\r\n  ? unknown extends R\r\n    ? any\r\n    : R extends PromiseLike<any>\r\n    ? Promise<Value>\r\n    : Value\r\n  : never;\r\n\r\n// #region region_simple_objects\r\n\r\ntype SpecificKeys<K extends keyof any> = K extends keyof any\r\n  ? string extends K\r\n    ? never\r\n    : number extends K\r\n    ? never\r\n    : symbol extends K\r\n    ? never\r\n    : K\r\n  : never;\r\n\r\ntype GenericKeys<K extends keyof any> = K extends keyof any\r\n  ? string extends K\r\n    ? K\r\n    : number extends K\r\n    ? K\r\n    : symbol extends K\r\n    ? K\r\n    : never\r\n  : never;\r\n\r\ntype OptionalKeys<T, K extends keyof T = keyof T> = K extends keyof T\r\n  ? { [P in K]?: T[K] } extends Pick<T, K>\r\n    ? K\r\n    : never\r\n  : never;\r\n\r\ntype RequiredKeys<T> = Exclude<keyof T, OptionalKeys<T>>;\r\n\r\ntype _DispatchMergeRecords<T1, T2, MergeRecords, Overwrite, OverwriteNulls> =\r\n  T1 extends Falsish\r\n    ? T2\r\n    : T2 extends Falsish\r\n    ? T1\r\n    : _MergeRecords2<T1, T2, MergeRecords, Overwrite, OverwriteNulls>;\r\n\r\ntype _MergeRecordsIfRecords<\r\n  T1P,\r\n  T2P,\r\n  Deep,\r\n  Overwrite,\r\n  OverwriteNulls,\r\n  Default\r\n> = Deep extends true\r\n  ? T1P extends SimpleObject\r\n    ? T2P extends SimpleObject\r\n      ? _DispatchMergeRecords<T1P, T2P, true, Overwrite, OverwriteNulls>\r\n      : Default\r\n    : Default\r\n  : Default;\r\n\r\ntype _OverwriteNull<V1, V2, Toggle> = Toggle extends true\r\n  ? V1 extends null\r\n    ? V2\r\n    : V1\r\n  : V1;\r\ntype _MergeRecords2<\r\n  T1,\r\n  T2,\r\n  Deep,\r\n  Overwrite,\r\n  OverwriteNulls,\r\n  O1 extends keyof T1 = OptionalKeys<T1>,\r\n  O2 extends keyof T2 = OptionalKeys<T2>,\r\n  R1 extends keyof T1 = RequiredKeys<T1>,\r\n  R2 extends keyof T2 = RequiredKeys<T2>\r\n> = Pick<T1, Exclude<keyof T1, SpecificKeys<keyof T2>>> &\r\n  Pick<T2, Exclude<keyof T2, SpecificKeys<keyof T1>>> & {\r\n    // Resulting property may be optional only if both optional in T1 and T2\r\n    [P in O1 & O2]?:\r\n      | _OverwriteNull<T1[P], T2[P], OverwriteNulls>\r\n      | T2[P]\r\n      | _MergeRecordsIfRecords<\r\n          T1[P],\r\n          T2[P],\r\n          Deep,\r\n          Overwrite,\r\n          OverwriteNulls,\r\n          never\r\n        >;\r\n  } & {\r\n    // Can only be T1 if overwrite=false\r\n    [P in O1 & R2]:\r\n      | T2[P]\r\n      | _MergeRecordsIfRecords<\r\n          T1[P],\r\n          T2[P],\r\n          Deep,\r\n          Overwrite,\r\n          OverwriteNulls,\r\n          Overwrite extends false\r\n            ? Exclude<\r\n                _OverwriteNull<T1[P], T2[P], OverwriteNulls>,\r\n                SimpleObject | undefined\r\n              >\r\n            : never\r\n        >;\r\n  } & {\r\n    // Will never be T2 if overwrite=false\r\n    [P in R1 & O2]:\r\n      | _OverwriteNull<T1[P], T2[P], OverwriteNulls>\r\n      | _MergeRecordsIfRecords<\r\n          T1[P],\r\n          T2[P],\r\n          Deep,\r\n          Overwrite,\r\n          OverwriteNulls,\r\n          Overwrite extends false ? never : Exclude<T2[P], SimpleObject>\r\n        >;\r\n  } & {\r\n    // Overwrite decides whether the value is T1 or T2\r\n    [P in R1 & R2]: _MergeRecordsIfRecords<\r\n      T1[P],\r\n      T2[P],\r\n      Deep,\r\n      Overwrite,\r\n      OverwriteNulls,\r\n      Exclude<\r\n        Overwrite extends false\r\n          ?\r\n              | _OverwriteNull<T1[P], T2[P], OverwriteNulls>\r\n              | T2[GenericKeys<R1> & keyof T2]\r\n          :\r\n              | _OverwriteNull<\r\n                  T1[GenericKeys<R2> & keyof T1],\r\n                  T2[P],\r\n                  OverwriteNulls\r\n                >\r\n              | T2[P],\r\n        SimpleObject\r\n      >\r\n    >;\r\n  } extends infer T\r\n  ? { [P in keyof T]: T[P] }\r\n  : never;\r\n\r\nexport type MergeObjectSources<\r\n  Target,\r\n  Sources,\r\n  Deep,\r\n  Overwrite,\r\n  OverwriteNulls\r\n> = (\r\n  Sources extends readonly [infer T, ...infer Rest]\r\n    ? T extends infer T\r\n      ? MergeObjectSources<\r\n          _DispatchMergeRecords<\r\n            Target,\r\n            ObjectSourceToObject<T>,\r\n            Deep,\r\n            Overwrite,\r\n            OverwriteNulls\r\n          >,\r\n          Rest,\r\n          Deep,\r\n          Overwrite,\r\n          OverwriteNulls\r\n        >\r\n      : never\r\n    : Sources extends Falsish | readonly []\r\n    ? Target\r\n    : _DispatchMergeRecords<\r\n        Target,\r\n        ObjectSourceToObject<Sources>,\r\n        Deep,\r\n        Overwrite,\r\n        OverwriteNulls\r\n      >\r\n) extends infer T\r\n  ? { [P in keyof T]: T[P] }\r\n  : never;\r\n\r\n// #endregion\r\n\r\nconst getRootPrototype = (value: any) => {\r\n  let proto = value;\r\n  while (proto) {\r\n    proto = Object.getPrototypeOf((value = proto));\r\n  }\r\n  return value;\r\n};\r\nconst findPrototypeFrame = (\r\n  frameWindow: Window | null,\r\n  matchPrototype: any\r\n) => {\r\n  if (!frameWindow || getRootPrototype(frameWindow) === matchPrototype) {\r\n    return frameWindow;\r\n  }\r\n  for (const frame of frameWindow.document.getElementsByTagName(\"iframe\")) {\r\n    try {\r\n      if (\r\n        (frameWindow = findPrototypeFrame(frame.contentWindow, matchPrototype))\r\n      ) {\r\n        return frameWindow;\r\n      }\r\n    } catch (e) {\r\n      // Cross domain issue.\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * When in iframes, we need to copy the prototype methods from the global scope's prototypes since,\r\n * e.g., `Object` in an iframe is different from `Object` in the top frame.\r\n */\r\nexport const findDeclaringScope = (target: any) =>\r\n  target == null\r\n    ? target\r\n    : globalThis.window\r\n    ? findPrototypeFrame(window, getRootPrototype(target))\r\n    : globalThis;\r\n","import {\r\n  AsyncIterationItem,\r\n  AsyncIterationProjection2,\r\n  AsyncIterationSource,\r\n  AsyncIterationSourceOf,\r\n  AsyncItProjection,\r\n  Falsish,\r\n  get2,\r\n  isArray,\r\n  isIterable,\r\n  isPromiseLike,\r\n  itemize2,\r\n  IterationFilterCallback2,\r\n  IterationProjected,\r\n  IterationProjection2,\r\n  IterationSource,\r\n  IterationSourceOf,\r\n  IterationTypeGuardCallback2,\r\n  IteratorItem2,\r\n  MaybeArray,\r\n  MaybeNullish,\r\n  MaybeNullishOrFalse,\r\n  Nullish,\r\n  NullishOrFalse,\r\n  ObjectSource,\r\n  Sortable,\r\n  symbolAsyncIterator,\r\n  throwError,\r\n  ToggleArray,\r\n  TupleOrArray,\r\n  UnwrapPromiseLike,\r\n} from \"..\";\r\nimport {\r\n  EncourageTuples,\r\n  findDeclaringScope,\r\n  IterationResultArray,\r\n  KeyValueType,\r\n  ObjectSourceToObject,\r\n  Selector,\r\n} from \"./_internal\";\r\n\r\nlet stopInvoked = false;\r\nconst stopSymbol = Symbol();\r\n\r\nexport const skip2 = Symbol();\r\nexport const stop2: (<T = any>(value: T) => T) & typeof stopSymbol = (<T>(\r\n  value: T\r\n) => ((stopInvoked = true), value)) as any;\r\n\r\n// #region region_iterator_implementations\r\nconst forEachSymbol = Symbol();\r\nconst asyncIteratorFactorySymbol = Symbol();\r\nconst symbolIterator = Symbol.iterator;\r\n\r\n// Prototype extensions are assigned on-demand to exclude them when tree-shaking code that are not using any of the iterators.\r\nconst ensureForEachImplementations = <R>(\r\n  target: any,\r\n  error: any,\r\n  retry: () => R\r\n): R => {\r\n  if (target == null || target?.[forEachSymbol]) {\r\n    throw error;\r\n  }\r\n  let scope = findDeclaringScope(target);\r\n  if (!scope) {\r\n    throw error;\r\n  }\r\n\r\n  const forEachIterable: () => ForEachFunction =\r\n    // Factory to generate separate functions for each prototype. JavaScript JIT compilers probably like that.\r\n    () => (target, projection, mapped, seed, context) => {\r\n      let projected: any,\r\n        i = 0;\r\n      for (const item of target) {\r\n        if (\r\n          (projected = projection\r\n            ? projection(item, i++, seed, context)\r\n            : item) !== skip2\r\n        ) {\r\n          if (projected === stop2) {\r\n            break;\r\n          }\r\n          seed = projected;\r\n          if (mapped) mapped.push(projected);\r\n          if (stopInvoked) {\r\n            stopInvoked = false;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      return mapped || seed;\r\n    };\r\n\r\n  scope.Array.prototype[forEachSymbol] = ((\r\n    target: any[],\r\n    projection,\r\n    mapped,\r\n    seed,\r\n    context\r\n  ) => {\r\n    let projected: any, item: any;\r\n    for (let i = 0, n = target.length; i < n; i++) {\r\n      item = target[i];\r\n      if (\r\n        (projected = projection ? projection(item, i, seed, context) : item) !==\r\n        skip2\r\n      ) {\r\n        if (projected === stop2) {\r\n          break;\r\n        }\r\n        seed = projected;\r\n        if (mapped) {\r\n          mapped.push(projected);\r\n        }\r\n        if (stopInvoked) {\r\n          stopInvoked = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return mapped || seed;\r\n  }) satisfies ForEachFunction;\r\n\r\n  const genericForEachIterable = forEachIterable();\r\n  scope.Object.prototype[forEachSymbol] = ((\r\n    target,\r\n    projection,\r\n    mapped,\r\n    seed,\r\n    context\r\n  ) => {\r\n    if (target[symbolIterator]) {\r\n      if (target.constructor === Object) {\r\n        return genericForEachIterable(\r\n          target,\r\n          projection,\r\n          mapped,\r\n          seed,\r\n          context\r\n        );\r\n      }\r\n      return (Object.getPrototypeOf(target)[forEachSymbol] = forEachIterable())(\r\n        target,\r\n        projection,\r\n        mapped,\r\n        seed,\r\n        context\r\n      );\r\n    }\r\n    let projected: any,\r\n      item: any,\r\n      i = 0;\r\n    for (const key in target) {\r\n      item = [key, target[key]];\r\n      if (\r\n        (projected = projection\r\n          ? projection(item, i++, seed, context)\r\n          : item) !== skip2\r\n      ) {\r\n        if (projected === stop2) {\r\n          break;\r\n        }\r\n        seed = projected;\r\n        if (mapped) mapped.push(projected);\r\n        if (stopInvoked) {\r\n          stopInvoked = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return mapped || seed;\r\n  }) satisfies ForEachFunction;\r\n\r\n  scope.Object.prototype[asyncIteratorFactorySymbol] = function () {\r\n    if (this[symbolIterator] || this[symbolAsyncIterator]) {\r\n      if (this.constructor === Object) {\r\n        return this[symbolAsyncIterator]() ?? this[symbolIterator]();\r\n      }\r\n      const proto = Object.getPrototypeOf(this);\r\n      proto[asyncIteratorFactorySymbol] =\r\n        proto[symbolAsyncIterator] ?? proto[symbolIterator];\r\n      return this[asyncIteratorFactorySymbol]();\r\n    }\r\n\r\n    return iterateEntries(this);\r\n  };\r\n\r\n  for (const proto of [\r\n    scope.Map.prototype,\r\n    scope.WeakMap.prototype,\r\n    scope.Set.prototype,\r\n    scope.WeakSet.prototype,\r\n    // Generator function\r\n    Object.getPrototypeOf(function* () {}),\r\n  ]) {\r\n    proto[forEachSymbol] = forEachIterable();\r\n    proto[asyncIteratorFactorySymbol] = proto[symbolIterator];\r\n  }\r\n\r\n  scope.Number.prototype[forEachSymbol] = ((\r\n    target,\r\n    projection,\r\n    mapped,\r\n    seed,\r\n    context\r\n  ) =>\r\n    genericForEachIterable(\r\n      range2(target),\r\n      projection,\r\n      mapped,\r\n      seed,\r\n      context\r\n    )) satisfies ForEachFunction;\r\n  scope.Number.prototype[asyncIteratorFactorySymbol] = range2;\r\n\r\n  scope.Function.prototype[forEachSymbol] = ((\r\n    target,\r\n    projection,\r\n    mapped,\r\n    seed,\r\n    context\r\n  ) =>\r\n    genericForEachIterable(\r\n      traverse2(target),\r\n      projection,\r\n      mapped,\r\n      seed,\r\n      context\r\n    )) satisfies ForEachFunction;\r\n\r\n  scope.Function.prototype[asyncIteratorFactorySymbol] = traverse2;\r\n\r\n  return retry();\r\n};\r\n\r\nexport type ForEachFunction = (\r\n  target: any,\r\n  projection: IterationProjection2<any, any, any> | undefined,\r\n  mapped: any[] | undefined,\r\n  seed: any,\r\n  context: any\r\n) => any;\r\n\r\n// #endregion\r\n\r\nexport function* range2(length: number = this) {\r\n  for (let i = 0; i < length; i++) yield i;\r\n}\r\n\r\nexport function* traverse2(\r\n  next: <T>(current: T | undefined) => T | Nullish = this\r\n) {\r\n  let item: any = undefined;\r\n  while ((item = next(item)) !== undefined) yield item;\r\n}\r\n\r\nfunction* iterateEntries(source: any) {\r\n  for (const key in source) {\r\n    yield [key, source[key]];\r\n  }\r\n}\r\n\r\nexport const forEach2: {\r\n  <Source extends IterationSource>(source: Source): MaybeNullishOrFalse<\r\n    IteratorItem2<Source> | undefined,\r\n    Source\r\n  >;\r\n  <\r\n    Source extends IterationSource,\r\n    Projected,\r\n    Accumulator extends Projected,\r\n    Signal extends typeof skip2 | typeof stop2 | never,\r\n    Context = Source\r\n  >(\r\n    source: Source,\r\n    projection:\r\n      | IterationProjection2<Source, Accumulator, Projected | Signal, Context>\r\n      | Nullish,\r\n    seed?: Accumulator,\r\n    context?: Context\r\n  ): MaybeNullishOrFalse<IterationProjected<Projected> | undefined, Source>;\r\n} = (source: any, projection?: any, seed?: any, context?: any) => {\r\n  try {\r\n    return source\r\n      ? source[forEachSymbol](source, projection, undefined, seed, context)\r\n      : source == null\r\n      ? source\r\n      : undefined;\r\n  } catch (e) {\r\n    return ensureForEachImplementations(source, e, () =>\r\n      forEach2(source, projection, seed, context)\r\n    );\r\n  }\r\n};\r\n\r\nexport let map2: {\r\n  <\r\n    Source extends IterationSource,\r\n    Projected,\r\n    Accumulator extends Projected,\r\n    Signal extends typeof skip2 | typeof stop2 | never, // Otherwise Projected may be `symbol`\r\n    Target = undefined,\r\n    Context = Source\r\n  >(\r\n    source: Source,\r\n    projection: IterationProjection2<Source, Accumulator, Projected | Signal>,\r\n    target?: Target & IterationProjected<Projected>[],\r\n    seed?: Accumulator,\r\n    context?: Context\r\n  ): MaybeNullishOrFalse<\r\n    IterationProjected<Projected>[] extends Target\r\n      ? Target\r\n      : IterationProjected<Projected>[],\r\n    Source\r\n  >;\r\n\r\n  <Source extends IterationSourceOf<T>, T, Target = never[]>(\r\n    source: Source,\r\n    projection?: undefined | null,\r\n    target?: Target & T[],\r\n    seed?: any,\r\n    context?: any\r\n  ): Target extends never[] ? IterationResultArray<Source> : Target;\r\n} = (\r\n  source: any,\r\n  projection?: any,\r\n  target = [],\r\n  seed?: any,\r\n  context = source\r\n) => {\r\n  try {\r\n    return !source && source !== 0 && source !== \"\"\r\n      ? source == null\r\n        ? source\r\n        : undefined\r\n      : source[forEachSymbol](source, projection, target, seed, context);\r\n  } catch (e) {\r\n    return ensureForEachImplementations(source, e, () =>\r\n      map2(source, projection, target, seed, context)\r\n    );\r\n  }\r\n};\r\n\r\nexport const batch2 = <T, Arg>(\r\n  source: Arg & Iterable<T>,\r\n  batchSize: number\r\n): MaybeNullish<T[][], Arg> => {\r\n  if (source == null) return source;\r\n\r\n  const batches: T[][] = [];\r\n  let batch: T[] = [];\r\n  for (const item of source) {\r\n    batch.push(item);\r\n    if (batch.length === batchSize) {\r\n      batches.push(batch);\r\n      batch = [];\r\n    }\r\n  }\r\n  if (batch.length > 0) {\r\n    batches.push(batch);\r\n  }\r\n  return batches as any;\r\n};\r\n\r\ntype FilterTruish<T extends readonly any[]> = T extends readonly [\r\n  infer T,\r\n  ...infer Rest\r\n]\r\n  ? T extends Falsish\r\n    ? FilterTruish<Rest>\r\n    : [T, ...FilterTruish<Rest>]\r\n  : T extends readonly []\r\n  ? []\r\n  : T extends readonly (infer T)[]\r\n  ? Exclude<T, Falsish>[]\r\n  : never;\r\n\r\n/** Creates an array with the parameters that are not false'ish */\r\nexport const truish2: {\r\n  <Values extends TupleOrArray<{} | Falsish>>(\r\n    values: Values\r\n  ): FilterTruish<Values>;\r\n  <Values extends readonly ({} | Falsish)[]>(\r\n    ...values: Values\r\n  ): FilterTruish<Values>;\r\n} = (...values: any[]) =>\r\n  filter2(values.length === 1 ? values[0] : values, false) as any;\r\n\r\nexport let filter2: {\r\n  <Source extends IterationSource, Strict extends boolean = true>(\r\n    target: Source,\r\n    /**\r\n     * Whether to filter out only `null` and `undefined` or all false'ish values (`null`, `undefined`, `false`, `\"\"` and `0`).\r\n     * If the latter behavior is preferred, you can also use {@link truish2}.\r\n     *\r\n     * @default true\r\n     */\r\n    strict?: Strict\r\n  ): MaybeNullishOrFalse<\r\n    Exclude<\r\n      IteratorItem2<Source>,\r\n      typeof skip2 | typeof stop2 | (Strict extends true ? Nullish : Falsish)\r\n    >[],\r\n    Source\r\n  >;\r\n  <\r\n    Source extends IterationSource,\r\n    R extends Exclude<\r\n      IteratorItem2<Source>,\r\n      typeof skip2 | typeof stop2 | Falsish\r\n    >\r\n  >(\r\n    target: Source,\r\n    filter: IterationTypeGuardCallback2<Source, R>,\r\n    invert?: boolean\r\n  ): MaybeNullishOrFalse<R[], Source>;\r\n\r\n  <Source extends IterationSource>(\r\n    target: Source,\r\n    filter: IterationFilterCallback2<Source>,\r\n    invert?: boolean\r\n  ): IterationResultArray<Source>;\r\n\r\n  <Source extends IterationSource>(\r\n    target: Source,\r\n    filter: { has(item: Exclude<IteratorItem2<Source>, Nullish>): any },\r\n    invert?: boolean\r\n  ): MaybeNullishOrFalse<\r\n    IteratorItem2<Exclude<Source, NullishOrFalse>>[],\r\n    Source\r\n  >;\r\n} = (items: any, filter: any = true, invert = false) =>\r\n  map2(\r\n    items,\r\n    filter === true\r\n      ? (item) => item ?? skip2\r\n      : !filter\r\n      ? (item) => item || skip2\r\n      : filter.has\r\n      ? (item) => (item == null || filter.has(item) === invert ? skip2 : item)\r\n      : (item, index, prev) =>\r\n          !filter(item, index, prev) === invert ? item : skip2\r\n  );\r\n\r\nexport const take2: {\r\n  <Source extends IterationSource>(\r\n    source: Source,\r\n    count: number,\r\n    projection?: undefined\r\n  ): IterationResultArray<Source>;\r\n  <\r\n    Source extends IterationSource,\r\n    Projected,\r\n    Accumulator extends Projected,\r\n    Signal extends typeof skip2 | typeof stop2 | never\r\n  >(\r\n    source: Source,\r\n    count: number,\r\n    projection: IterationProjection2<Source, Accumulator, Projected | Signal>\r\n  ): MaybeNullishOrFalse<IterationProjected<Projected>[], Source>;\r\n} = (source: any, count: any, projection?: any) =>\r\n  map2(\r\n    source,\r\n    (item, index, prev) => (\r\n      index === count + 1 && (stopInvoked = true),\r\n      projection ? projection(item, index, prev) : item\r\n    )\r\n  );\r\nexport const first2: {\r\n  <Source extends IterationSource, R>(\r\n    source: Source,\r\n    predicate: IterationTypeGuardCallback2<Source, R>\r\n  ): R | undefined;\r\n  <Source extends IterationSource>(\r\n    source: Source,\r\n    predicate?: IterationFilterCallback2<Source>\r\n  ): IteratorItem2<Source> | undefined;\r\n} = (source: any, predicate = source) =>\r\n  forEach2(\r\n    source,\r\n    (item, index, prev) => (\r\n      (!predicate || predicate(item, index, prev, source)) &&\r\n        (stopInvoked = true),\r\n      item\r\n    )\r\n  );\r\n\r\ntype Ones<N extends number, A extends number[] = []> = A[\"length\"] extends N\r\n  ? A\r\n  : Ones<N, [...A, 1]>;\r\n\r\ntype Dec<A extends number> = A extends 0\r\n  ? -1\r\n  : `${A}` extends `-${infer _}`\r\n  ? -1\r\n  : Ones<A> extends [any, ...infer Rest]\r\n  ? Rest[\"length\"]\r\n  : never;\r\n\r\ntype Flat<T, Depth extends number> = Depth extends 0\r\n  ? T\r\n  : T extends string\r\n  ? T\r\n  : T extends Iterable<infer T>\r\n  ? Flat<T, Dec<Depth>>\r\n  : T;\r\n\r\nexport const flatMap2: {\r\n  <\r\n    Source extends IterationSource,\r\n    Projected,\r\n    Accumulator extends Projected,\r\n    Signal extends typeof skip2 | typeof stop2 | never, // Otherwise R may be `symbol`\r\n    Target = undefined,\r\n    Context = Source,\r\n    Depth extends number = -1\r\n  >(\r\n    source: Source,\r\n    projection: IterationProjection2<Source, Accumulator, Projected | Signal>,\r\n    depth?: Depth,\r\n    target?: Target & Flat<IterationProjected<Projected>, Depth>[],\r\n    seed?: Accumulator,\r\n    context?: Context\r\n  ): MaybeNullishOrFalse<\r\n    Flat<IterationProjected<Projected>, Depth>[] extends Target\r\n      ? Target\r\n      : Flat<IterationProjected<Projected>, Depth>[],\r\n    Source\r\n  >;\r\n\r\n  <Source extends IterationSource, Depth extends number = -1>(\r\n    source: Source,\r\n    projection?: Nullish,\r\n    depth?: Depth,\r\n    target?: any[],\r\n    seed?: any,\r\n    context?: any\r\n  ): Source extends Nullish ? Source : Flat<IteratorItem2<Source>, Depth>[];\r\n} = (\r\n  source: any,\r\n  projection?: any,\r\n  depth: any = -1,\r\n  target: any[] = [],\r\n  seed?: any,\r\n  context = source\r\n) =>\r\n  map2(\r\n    source,\r\n    (item, index, previous) =>\r\n      (projection ? (item = projection(item, index, previous)) : item) !=\r\n        null &&\r\n      item[Symbol.iterator] &&\r\n      typeof item !== \"string\" &&\r\n      depth\r\n        ? (flatMap2(item, undefined, depth - 1, target, item), skip2)\r\n        : item,\r\n    target,\r\n    seed,\r\n    context\r\n  );\r\n\r\ntype Group2Result<Source, AsMap, Many = true> = AsMap extends true\r\n  ? Source extends Iterable<infer T extends KeyValueType<any>>\r\n    ? Map<Exclude<T[0], undefined>, ToggleArray<T[1], Many>>\r\n    : Source extends { [P in infer Key]: infer Value }\r\n    ? Map<Key, ToggleArray<Value, Many>>\r\n    : never\r\n  : Source extends Iterable<infer T extends KeyValueType>\r\n  ? { [P in Exclude<T[0], undefined>]: ToggleArray<T[1], Many> }\r\n  : Source extends { [P in infer Key]: infer Value }\r\n  ? { [P in Key]: ToggleArray<Value, Many> }\r\n  : never;\r\n\r\nexport const group2: {\r\n  <\r\n    Source extends ObjectSource<any> | NullishOrFalse,\r\n    AsMap extends boolean = true\r\n  >(\r\n    source: Source,\r\n    map?: AsMap\r\n  ): MaybeNullishOrFalse<\r\n    Group2Result<ObjectSourceToObject<Source>, AsMap>,\r\n    Source\r\n  >;\r\n\r\n  <Source extends Iterable<KeyValueType<any>> | NullishOrFalse>(\r\n    source: Source,\r\n    map?: true\r\n  ): MaybeNullishOrFalse<\r\n    Group2Result<ObjectSourceToObject<Source>, true>,\r\n    Source\r\n  >;\r\n\r\n  <\r\n    Source extends IterationSource,\r\n    Projected extends KeyValueType<keyof any> | Falsish,\r\n    Accumulator extends Projected,\r\n    Signal extends typeof skip2 | typeof stop2 | never,\r\n    AsMap extends boolean = true\r\n  >(\r\n    source: Source,\r\n    projection: IterationProjection2<Source, Accumulator, Projected | Signal>,\r\n    map?: AsMap\r\n  ): MaybeNullishOrFalse<\r\n    Group2Result<IterationProjected<Projected, Falsish>[], AsMap>,\r\n    Source\r\n  >;\r\n  <\r\n    Source extends IterationSource,\r\n    Projected extends KeyValueType<any> | Falsish,\r\n    Accumulator extends Projected,\r\n    Signal extends typeof skip2 | typeof stop2 | never\r\n  >(\r\n    source: Source,\r\n    projection: IterationProjection2<Source, Accumulator, Projected | Signal>,\r\n    map?: true\r\n  ): MaybeNullishOrFalse<\r\n    Group2Result<IterationProjected<Projected, Falsish>[], true>,\r\n    Source\r\n  >;\r\n} = (source: any, projection?: any, map?: any) => {\r\n  if (projection != null && typeof projection !== \"function\") {\r\n    [projection, map] = [undefined, projection];\r\n  }\r\n  let groups: any, kv: [any, any];\r\n  forEach2(\r\n    source,\r\n    map !== false\r\n      ? ((groups = new Map()),\r\n        (item, index, prev) => {\r\n          kv = projection ? projection(item, index, prev) : item;\r\n          if (kv[0] !== undefined) {\r\n            get2(groups, kv[0], () => []).push(kv[1]);\r\n          }\r\n        })\r\n      : ((groups = {}),\r\n        (item, index, prev) =>\r\n          (kv = projection ? projection(item, index, prev) : item) &&\r\n          kv[0] !== undefined &&\r\n          (groups[kv[0]] ??= []).push(kv[1]))\r\n  );\r\n\r\n  return groups;\r\n};\r\n\r\nexport let forEachAwait2: {\r\n  <Source extends AsyncIterationSource | Nullish>(source: Source): Promise<\r\n    MaybeNullish<AsyncIterationItem<Source>, Source> | undefined\r\n  >;\r\n  <\r\n    Source extends AsyncIterationSource | Nullish,\r\n    Projected,\r\n    Accumulated extends UnwrapPromiseLike<Projected>,\r\n    Signal extends typeof skip2 | typeof stop2 | never,\r\n    Context = Source\r\n  >(\r\n    source: Source,\r\n    projection:\r\n      | AsyncIterationProjection2<\r\n          Source,\r\n          Accumulated,\r\n          EncourageTuples<Projected> | Signal,\r\n          Context\r\n        >\r\n      | Nullish,\r\n    seed?: Accumulated,\r\n    context?: Context\r\n  ): Promise<MaybeNullish<AsyncItProjection<Projected>, Source> | undefined>;\r\n} = (source: any, projection?: any, seed?: any, context?: any) => {\r\n  try {\r\n    return iterateAsync2(source, projection, undefined, seed, context);\r\n  } catch (e) {\r\n    return ensureForEachImplementations(source, e, () =>\r\n      forEachAwait2(source, projection, seed, context)\r\n    );\r\n  }\r\n};\r\n\r\nexport let mapAwait2: {\r\n  <\r\n    Source extends IterationSource,\r\n    Projected,\r\n    Accumulator extends UnwrapPromiseLike<Projected>,\r\n    Signal extends typeof skip2 | typeof stop2 | never, // Otherwise R may be `symbol`\r\n    Target = undefined,\r\n    Context = Source\r\n  >(\r\n    source: Source,\r\n    projection: AsyncIterationProjection2<\r\n      Source,\r\n      Accumulator,\r\n      Projected | Signal\r\n    >,\r\n    target?: Target & AsyncItProjection<Projected>[],\r\n    seed?: Accumulator,\r\n    context?: Context\r\n  ): Promise<\r\n    MaybeNullishOrFalse<\r\n      AsyncItProjection<Projected>[] extends Target\r\n        ? Target\r\n        : AsyncItProjection<Projected>[],\r\n      Source\r\n    >\r\n  >;\r\n\r\n  <Source extends AsyncIterationSourceOf<T>, T, Target = never[]>(\r\n    source: Source,\r\n    projection?: undefined | null,\r\n    target?: Target & T[],\r\n    seed?: any,\r\n    context?: any\r\n  ): Promise<\r\n    Target extends never[]\r\n      ? IterationResultArray<Iterable<AsyncIterationItem<Source>>>\r\n      : Target\r\n  >;\r\n} = (source: any, projection: any, target = [], seed: any, context: any) => {\r\n  try {\r\n    return iterateAsync2(source, projection, target, seed, context);\r\n  } catch (e) {\r\n    return ensureForEachImplementations(source, e, () =>\r\n      mapAwait2(source, projection, target, seed, context)\r\n    );\r\n  }\r\n};\r\n\r\nconst iterateAsync2 = async (\r\n  source: any,\r\n  projection?: IterationProjection2<any, any, any, any> | Nullish,\r\n  mapped?: any[],\r\n  seed?: any,\r\n  context?: any\r\n) => {\r\n  if ((source = await source) == null) return source;\r\n  if (source === false) return undefined;\r\n\r\n  const iterator = source[asyncIteratorFactorySymbol]() as AsyncIterator<any>;\r\n\r\n  let result: IteratorResult<any>;\r\n  let projected: any,\r\n    i = 0;\r\n\r\n  while ((result = iterator.next() as any)) {\r\n    if (isPromiseLike(result)) {\r\n      result = await result;\r\n    }\r\n    if (result.done) {\r\n      break;\r\n    }\r\n\r\n    let item = result.value;\r\n    if (isPromiseLike(item)) {\r\n      item = await item;\r\n    }\r\n    if (\r\n      (projected = await (projection\r\n        ? projection(item, i++, seed, context)\r\n        : item)) !== skip2\r\n    ) {\r\n      if (projected === stop2) {\r\n        break;\r\n      }\r\n      seed = projected;\r\n      mapped?.push(projected);\r\n      if (stopInvoked) {\r\n        stopInvoked = false;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return mapped || seed;\r\n};\r\n\r\nexport const collect2 = <T, Nulls>(\r\n  source: T | Iterable<T> | Nulls,\r\n  generator: (item: T) => Iterable<T> | T | typeof skip2 | typeof stop2,\r\n  includeSelf = true,\r\n  collected?: Set<T>\r\n): MaybeNullish<Set<T>, Nulls> => {\r\n  if (source == null) return source as any;\r\n  const root = collected;\r\n  collected ??= new Set();\r\n  if (source[symbolIterator] && typeof source !== \"string\") {\r\n    for (const item of source as Iterable<any>) {\r\n      if (\r\n        (collect2(item, generator, includeSelf, collected) as any) === stop2\r\n      ) {\r\n        break;\r\n      }\r\n    }\r\n  } else if (!collected.has(source as any)) {\r\n    if (includeSelf) {\r\n      collected.add(source as any);\r\n    }\r\n    let generated = generator(source as any);\r\n    if (generated === stop2) return root ? stop2 : (collected as any);\r\n    if (generated !== skip2) {\r\n      collect2(generated, generator, true, collected);\r\n    }\r\n  }\r\n  return collected as any;\r\n};\r\n\r\nexport const distinct2 = <T>(\r\n  source: T\r\n): unknown extends T\r\n  ? any\r\n  : T extends Nullish\r\n  ? T\r\n  : T extends Set<any>\r\n  ? T\r\n  : T extends Iterable<infer T>\r\n  ? Set<T>\r\n  : Set<T> =>\r\n  source == null\r\n    ? source\r\n    : source instanceof Set\r\n    ? source\r\n    : (new Set(\r\n        source[symbolIterator] && typeof source !== \"string\"\r\n          ? source\r\n          : ([source] as any)\r\n      ) as any);\r\n\r\nexport const iterable2 = <T>(\r\n  source: T\r\n): T extends undefined ? [] : T extends Iterable<any> ? T : [T] =>\r\n  source === void 0\r\n    ? []\r\n    : source?.[symbolIterator] && typeof source !== \"string\"\r\n    ? source\r\n    : ([source] as any);\r\n\r\nexport const array2 = <T>(\r\n  source: T\r\n): unknown extends T\r\n  ? any[]\r\n  : T extends Nullish\r\n  ? T\r\n  : T extends readonly any[]\r\n  ? T\r\n  : T extends Iterable<infer Item>\r\n  ? Item[]\r\n  : [T] =>\r\n  source == null\r\n    ? source\r\n    : isArray(source)\r\n    ? source\r\n    : source[symbolIterator] && typeof source !== \"string\"\r\n    ? [...(source as any)]\r\n    : ([source] as any);\r\n\r\nexport const some2: {\r\n  <Source extends IterationSource>(\r\n    source: Source,\r\n    predicate?: IterationFilterCallback2<Source>\r\n  ): boolean;\r\n} = (source, predicate) =>\r\n  forEach2(source, (item, index, prev) =>\r\n    (predicate ? predicate(item, index, prev, source) : item)\r\n      ? (stopInvoked = true)\r\n      : item\r\n  ) === true;\r\n\r\nexport const all2: {\r\n  <Source extends IterationSource>(\r\n    source: Source,\r\n    predicate?: IterationFilterCallback2<Source>\r\n  ): boolean;\r\n} = (source, predicate) =>\r\n  forEach2(source, (item, index, prev) =>\r\n    !(predicate ? predicate(item, index, prev, source) : item)\r\n      ? !(stopInvoked = true)\r\n      : item\r\n  ) !== false;\r\n\r\ntype ConcatResult<T extends readonly any[]> = [Nullish | T[number]] extends [\r\n  Nullish\r\n]\r\n  ? undefined\r\n  : {\r\n      [P in keyof T]: T[P] extends infer T\r\n        ? unknown extends T\r\n          ? any\r\n          : T extends Iterable<infer T>\r\n          ? T\r\n          : T extends Nullish\r\n          ? never\r\n          : T\r\n        : never;\r\n    }[number][];\r\nexport const concat2: {\r\n  <T extends readonly any[]>(args: T): ConcatResult<T>;\r\n  <T extends readonly any[]>(...args: T): ConcatResult<T>;\r\n} = (arg0: any, ...other: any[]) => {\r\n  if (other.length || !isIterable(arg0)) {\r\n    arg0 = [arg0, ...other];\r\n  }\r\n\r\n  let result: any[] | undefined;\r\n  for (const arg of arg0) {\r\n    if (arg == null) continue;\r\n    if (isIterable(arg)) {\r\n      (result ??= []).push(...arg);\r\n      continue;\r\n    }\r\n    (result ??= []).push(arg);\r\n  }\r\n  return result as any;\r\n};\r\n\r\nconst sortCompare = (x: Sortable, y: Sortable, descending: boolean) =>\r\n  (descending ? -1 : 1) *\r\n  (x === y\r\n    ? 0\r\n    : typeof x === \"string\"\r\n    ? typeof y === \"string\"\r\n      ? x.localeCompare(y)\r\n      : 1\r\n    : typeof y === \"string\"\r\n    ? -1\r\n    : x == null\r\n    ? y == null\r\n      ? 0\r\n      : -1\r\n    : y == null\r\n    ? 1\r\n    : (x as any) - (y as any));\r\n\r\nexport const sort2: {\r\n  <T extends Sortable, Source>(\r\n    items: Source & (Iterable<T> | Nullish),\r\n    descending?: boolean\r\n  ): Source extends Nullish ? T : IteratorItem2<T>[];\r\n\r\n  <T, Source>(\r\n    items: Source & (Iterable<T> | undefined),\r\n    selector: MaybeArray<(item: T) => Sortable>,\r\n    descending?: boolean\r\n  ): Source extends Nullish ? T : T[];\r\n} = (items: any, selector: any, descending?: any) =>\r\n  (array2(items) as any[]).sort(\r\n    typeof selector === \"function\"\r\n      ? (x, y) => sortCompare(selector(x), selector(y), descending)\r\n      : isArray(selector)\r\n      ? selector.length\r\n        ? (x, y) => {\r\n            let c = 0;\r\n            for (let i = 0; i < selector.length && !c; i++) {\r\n              c = sortCompare(selector[i](x), selector[i](y), descending);\r\n            }\r\n            return c;\r\n          }\r\n        : (x, y) => sortCompare(x, y, descending)\r\n      : (x, y) => sortCompare(x, y, selector)\r\n  );\r\n\r\nexport const topoSort2 = <Source, T>(\r\n  items: (Iterable<T> | Nullish) & Source,\r\n  dependencies: (item: T) => Iterable<T> | Nullish,\r\n  format?: Selector<T>\r\n): MaybeNullish<T[], Source> => {\r\n  if (items == null) return items as any;\r\n\r\n  type Info = [item: T, dependents: Info[], blockingEdges: Set<T>];\r\n\r\n  let clear: Info[] = [];\r\n  let mapped: T[] = [];\r\n\r\n  const edges = new Map<T, Info>(\r\n    map2(items, (item) => [item, [item, [], null!]])\r\n  );\r\n  for (const [item, info] of edges) {\r\n    for (const dependency of dependencies(item) ?? []) {\r\n      // Ignore dependencies not present.\r\n      edges.get(dependency)?.[1].push(info) &&\r\n        (info[2] ??= new Set()).add(dependency);\r\n    }\r\n    if (!info[2]) {\r\n      clear.push(info);\r\n    }\r\n  }\r\n\r\n  for (const [item, dependents] of clear) {\r\n    mapped.push(item);\r\n    for (const dependent of dependents) {\r\n      dependent[2].delete(item);\r\n      if (!dependent[2].size) {\r\n        clear.push(dependent);\r\n      }\r\n    }\r\n  }\r\n\r\n  return mapped.length === edges.size\r\n    ? (mapped as any)\r\n    : throwError(\r\n        `Cyclic dependencies: ${itemize2(\r\n          map2(edges, ([, info]) =>\r\n            info[2]?.size\r\n              ? (format = normalizeSelector(format))(info[0]) +\r\n                \" depends on \" +\r\n                itemize2(info[2], format)\r\n              : skip2\r\n          )\r\n        )}.`\r\n      );\r\n};\r\n\r\nconst normalizeSelector = (selector: Selector, require = false) =>\r\n  typeof selector === \"function\"\r\n    ? selector\r\n    : selector != null\r\n    ? (item: any) =>\r\n        (item = item[selector]) === undefined && require ? skip2 : item\r\n    : (item: any) => item;\r\n\r\ntype ReduceFunction<Default = undefined, By = false> = {\r\n  <Source>(\r\n    source: Source & Iterable<number | undefined>\r\n  ): Source extends Nullish ? Source : number | Default;\r\n  <\r\n    Source extends IterationSource,\r\n    Projected extends number | undefined,\r\n    Signal extends typeof skip2 | typeof stop2 | never,\r\n    Accumulator extends Projected = any,\r\n    Item extends boolean = false\r\n  >(\r\n    ...args: [\r\n      source: Source,\r\n      projection: IterationProjection2<Source, Accumulator, Projected | Signal>,\r\n      ...(true extends By ? [returnItem?: Item] : [])\r\n    ]\r\n  ): Source extends Nullish\r\n    ? Source\r\n    : Item extends true\r\n    ? IteratorItem2<Source>\r\n    : number | Default;\r\n};\r\n\r\nconst reduce2 = (\r\n  source: any,\r\n  projection: any,\r\n  reduce: (current: number | undefined, value: number) => number | undefined,\r\n  returnItem = false\r\n) => {\r\n  let value: number | undefined;\r\n  let result: any;\r\n  forEach2(\r\n    source,\r\n    returnItem\r\n      ? (item, index, prev: any) =>\r\n          (value = projection ? projection(item, index, prev) : item) !==\r\n            undefined && prev !== (prev = reduce(prev, value))\r\n            ? ((result = item), prev)\r\n            : prev\r\n      : (item, index, prev: any) =>\r\n          (value = projection ? projection(item, index, prev) : item) !==\r\n          undefined\r\n            ? (result = reduce(prev, value))\r\n            : prev\r\n  );\r\n  return result;\r\n};\r\n\r\nexport const min2: ReduceFunction<undefined, true> = (\r\n  source: any,\r\n  projection?: any,\r\n  by?: boolean\r\n) =>\r\n  reduce2(\r\n    source,\r\n    projection,\r\n    (prev, x) => (prev == null || x < prev ? x : prev),\r\n    by\r\n  );\r\n\r\nexport const max2: ReduceFunction<undefined, true> = (\r\n  source: any,\r\n  projection?: any,\r\n  by?: boolean\r\n) =>\r\n  reduce2(\r\n    source,\r\n    projection,\r\n    (prev, x) => (prev == null || x > prev ? x : prev),\r\n    by\r\n  );\r\n\r\nexport const sum2: ReduceFunction<number> = (source: any, projection?: any) =>\r\n  reduce2(source, projection, (prev = 0, x) => {\r\n    return prev + x;\r\n  }) || 0;\r\n\r\nexport const avg2: ReduceFunction<number> = (source: any, projection?: any) => {\r\n  let n = 0;\r\n  let sum = reduce2(source, projection, (prev = 0, x) => (n++, prev + x));\r\n  return n ? sum / n : undefined;\r\n};\r\n\r\nexport const keys2 = Object.keys;\r\n\r\nexport const hasKeys2 = (obj: any) => !!keyCount2(obj, true);\r\nexport const keyCount2 = (obj: any, some = false) => {\r\n  if (!obj) return 0;\r\n  let count = 0;\r\n  for (const _ in obj) {\r\n    if (++count && some) {\r\n      return 1;\r\n    }\r\n  }\r\n  return count;\r\n};\r\n","import {\r\n  AssignSource,\r\n  Falsish,\r\n  forEach2,\r\n  isArray,\r\n  iterable2,\r\n  IterationProjected,\r\n  IterationProjection2,\r\n  IterationSource,\r\n  MapSource,\r\n  MaybeNullish,\r\n  MaybePromiseLike,\r\n  Nullish,\r\n  ObjectSource,\r\n  PromiseIfPromiseLike,\r\n  SimpleObject,\r\n  skip2,\r\n  stop2,\r\n} from \"..\";\r\nimport {\r\n  EncourageTuples,\r\n  findDeclaringScope,\r\n  InputValueTypeOf,\r\n  KeyTypeOf,\r\n  KeyValueType,\r\n  MapFromEntries,\r\n  MergeObjectSources,\r\n  ObjectFromEntries,\r\n  ObjectSourceToObject,\r\n  RecordKeyOf,\r\n  ValueTypeOf,\r\n} from \"./_internal\";\r\n\r\nconst setSymbol = Symbol();\r\nconst getSymbol = Symbol();\r\nconst pushSymbol = Symbol();\r\n\r\nlet ensureAssignImplementations = <R>(\r\n  target: any,\r\n  error: any,\r\n  retry: () => R\r\n): R => {\r\n  if (target == null || target?.[getSymbol]) {\r\n    throw error;\r\n  }\r\n  let scope = findDeclaringScope(target);\r\n  if (!scope) {\r\n    throw error;\r\n  }\r\n\r\n  if (scope.Object.prototype[setSymbol]) throw error;\r\n\r\n  for (const { prototype } of [scope.Map, scope.WeakMap]) {\r\n    prototype[setSymbol] = function (key: any, value: any) {\r\n      return value === void 0\r\n        ? this.delete(key)\r\n        : this.get(key) !== value && !!this.set(key, value);\r\n    };\r\n    prototype[getSymbol] = prototype.get;\r\n  }\r\n\r\n  for (const { prototype } of [scope.Set, scope.WeakSet]) {\r\n    prototype[setSymbol] = function (key: any, value: any, add = false) {\r\n      return value || (add && value === void 0)\r\n        ? this.has(key)\r\n          ? false\r\n          : !!this.add(key)\r\n        : this.delete(key);\r\n    };\r\n    prototype[getSymbol] = prototype.has;\r\n    prototype[pushSymbol] = function (keys: any[]) {\r\n      for (const key of keys) key !== void 0 && this.add(key);\r\n      return this;\r\n    };\r\n  }\r\n  scope.Array.prototype[pushSymbol] = function (values: any[]) {\r\n    this.push(...values);\r\n    return this;\r\n  };\r\n\r\n  for (const { prototype } of [scope.Object, scope.Array]) {\r\n    prototype[setSymbol] = function (key: any, value: any) {\r\n      if (value === undefined) {\r\n        if (this[key] !== undefined) {\r\n          delete this[key];\r\n          return true;\r\n        }\r\n        return false;\r\n      }\r\n      return (this[key] = value) !== value;\r\n    };\r\n    prototype[getSymbol] = function (key: any) {\r\n      return this[key];\r\n    };\r\n  }\r\n\r\n  return retry();\r\n};\r\n\r\ntype GetResult<Source, K, Default> = unknown extends Default\r\n  ? ValueTypeOf<Source, K>\r\n  : undefined extends Default\r\n  ? ValueTypeOf<Source, K>\r\n  : ValueTypeOf<Source, K> & {};\r\n\r\nexport let get2: {\r\n  <\r\n    Source,\r\n    K extends KeyTypeOf<Source>,\r\n    InitializeDefault extends () => MaybePromiseLike<\r\n      InputValueTypeOf<Source, K>\r\n    >\r\n  >(\r\n    source: Source,\r\n    key: K,\r\n    initialize: InitializeDefault\r\n  ): unknown extends InitializeDefault\r\n    ? ValueTypeOf<Source, K> // Assume `any` is not an async function.\r\n    : InitializeDefault extends () => infer Default\r\n    ? Default extends PromiseLike<infer Default>\r\n      ? Promise<GetResult<Source, K, Default>>\r\n      : GetResult<Source, K, Default>\r\n    : never;\r\n  <Source, K extends KeyTypeOf<Source>>(\r\n    source: Source,\r\n    key: K,\r\n    initialize: InputValueTypeOf<Source, K> & {}\r\n  ): ValueTypeOf<Source, K> & {};\r\n  <Source, K extends KeyTypeOf<Source>>(\r\n    source: Source,\r\n    key: K,\r\n    initialize?: InputValueTypeOf<Source, K>\r\n  ): ValueTypeOf<Source, K>;\r\n} = (source: any, key?: any, initialize?: any) => {\r\n  try {\r\n    if (source == null) return source;\r\n\r\n    let value = source[getSymbol](key);\r\n    if (\r\n      value === void 0 &&\r\n      (value = typeof initialize === \"function\" ? initialize() : initialize) !==\r\n        void 0\r\n    ) {\r\n      if (value?.then)\r\n        return value.then((value: any) =>\r\n          value === void 0 ? value : source[setSymbol](key, value)\r\n        );\r\n      source[setSymbol](key, value);\r\n    }\r\n    return value;\r\n  } catch (e) {\r\n    return ensureAssignImplementations(source, e, () =>\r\n      get2(source, key, initialize)\r\n    );\r\n  }\r\n};\r\n\r\nexport let add2: {\r\n  <Target, K extends KeyTypeOf<Target>>(\r\n    target: (Set<K> | WeakSet<K & {}>) & Target,\r\n    key: K,\r\n    value?: InputValueTypeOf<Target>\r\n  ): MaybeNullish<boolean, Target>;\r\n  <Target, K extends KeyTypeOf<Target>>(\r\n    target: Target,\r\n    key: K,\r\n    value: InputValueTypeOf<Target, K>\r\n  ): MaybeNullish<boolean, Target>;\r\n} = (target: any, key: any, value?: any) => {\r\n  try {\r\n    return target?.[setSymbol](key, value, true) === true;\r\n  } catch (e) {\r\n    return ensureAssignImplementations(target, e, () =>\r\n      add2(target, key, value)\r\n    );\r\n  }\r\n};\r\n\r\nexport let set2: {\r\n  <\r\n    Target,\r\n    K extends KeyTypeOf<Target>,\r\n    Value extends InputValueTypeOf<Target, K>\r\n  >(\r\n    target: Target,\r\n    key: K,\r\n    value: Value\r\n  ): MaybeNullish<Value, Target>;\r\n} = (target: any, key: any, value: any) => {\r\n  try {\r\n    target[setSymbol](key, value);\r\n    return value;\r\n  } catch (e) {\r\n    return ensureAssignImplementations(target, e, () =>\r\n      set2(target, key, value)\r\n    );\r\n  }\r\n};\r\n\r\nexport let exchange2: {\r\n  <\r\n    Target,\r\n    K extends KeyTypeOf<Target>,\r\n    Value extends InputValueTypeOf<Target, K>\r\n  >(\r\n    target: Target,\r\n    key: K,\r\n    value: Value\r\n  ): MaybeNullish<Value, Target>;\r\n} = (target: any, key: any, value: any) => {\r\n  try {\r\n    const previous = target[getSymbol](key);\r\n    target[setSymbol](key, value);\r\n    return previous;\r\n  } catch (e) {\r\n    return ensureAssignImplementations(target, e, () =>\r\n      exchange2(target, key, value)\r\n    );\r\n  }\r\n};\r\n\r\nexport const update2: {\r\n  <Target, K, Value extends InputValueTypeOf<Target, K>, UpdateResult>(\r\n    target: Target,\r\n    key: KeyTypeOf<Target> & K,\r\n    update: (\r\n      current: ValueTypeOf<Target, K>\r\n    ) => UpdateResult & MaybePromiseLike<EncourageTuples<Value | undefined>>\r\n  ): PromiseIfPromiseLike<\r\n    MaybeNullish<ValueTypeOf<Target, K>, Target>,\r\n    UpdateResult\r\n  >;\r\n} = (target: any, key: any, update: any) => {\r\n  let updated = update(get2(target, key));\r\n  return typeof updated?.then === \"function\"\r\n    ? updated.then((value: any) => set2(target, key, value))\r\n    : set2(target, key, updated);\r\n};\r\n\r\nexport const clone2: {\r\n  <T extends SimpleObject | readonly any[]>(value: T, depth?: number): T;\r\n} = (template, depth = -1) => {\r\n  const ctor = template?.constructor;\r\n  if (ctor === Object || ctor === Array) {\r\n    const clone: any = ctor();\r\n    for (const p in template) {\r\n      const propValue = template[p];\r\n      clone[p] =\r\n        depth && (propValue?.constructor === Object || isArray(propValue))\r\n          ? clone2(propValue, depth - 1)\r\n          : propValue;\r\n    }\r\n    return clone;\r\n  }\r\n  return template;\r\n};\r\n\r\nexport let push2: {\r\n  <Target, Item>(\r\n    target: Target & (readonly Item[] | Nullish),\r\n    ...values: (Item | undefined)[]\r\n  ): Target;\r\n  <Target, K>(\r\n    target: Target & (Set<K> | WeakSet<K & {}>),\r\n    ...values: (K | undefined)[]\r\n  );\r\n} = (target: any, ...items: any[]) => {\r\n  try {\r\n    return target == null ? target : target[pushSymbol](items);\r\n  } catch (e) {\r\n    return ensureAssignImplementations(target, e, () =>\r\n      push2(target, ...items)\r\n    );\r\n  }\r\n};\r\n\r\nexport const dict2: {\r\n  <Source extends MapSource<K, V>, K, V>(source: Source): Source extends Nullish\r\n    ? Source\r\n    : ObjectSourceToObject<Source>;\r\n  <\r\n    Source extends IterationSource,\r\n    Projected extends readonly [K, V] | Nullish,\r\n    Accumulator extends Projected,\r\n    Signal extends typeof skip2 | typeof stop2 | never,\r\n    K,\r\n    V\r\n  >(\r\n    source: Source,\r\n    projection: IterationProjection2<Source, Accumulator, Projected | Signal>\r\n  ): Source extends Nullish\r\n    ? Source\r\n    : MapFromEntries<IterationProjected<Projected>>;\r\n} = (source: any, projection?: any) => {\r\n  const target = new Map();\r\n  forEach2(\r\n    source,\r\n    projection\r\n      ? (item, index, seed) =>\r\n          (item = projection(item, index, seed)) &&\r\n          (typeof item !== \"symbol\" || (item !== skip2 && item !== stop2))\r\n            ? target.set(item[0], item[1])\r\n            : item\r\n      : (item) =>\r\n          item &&\r\n          (typeof item !== \"symbol\" || (item !== skip2 && item !== stop2))\r\n            ? target.set(item[0], item[1])\r\n            : item\r\n  );\r\n  return target;\r\n};\r\n\r\nexport const obj2: {\r\n  <Source extends ObjectSource<K, V>, K extends keyof any, V>(\r\n    source: Source\r\n  ): Source extends Nullish ? Source : ObjectSourceToObject<Source>;\r\n  <\r\n    Source extends IterationSource,\r\n    Projected extends KeyValueType<K, V> | Nullish,\r\n    Accumulator extends Projected,\r\n    Signal extends typeof skip2 | typeof stop2 | never,\r\n    K extends keyof any,\r\n    V\r\n  >(\r\n    source: Source,\r\n    projection: IterationProjection2<Source, Accumulator, Projected | Signal>\r\n  ): Source extends Nullish\r\n    ? Source\r\n    : ObjectFromEntries<IterationProjected<Projected>>;\r\n} = (source: any, projection?: any) => {\r\n  const target = {};\r\n  forEach2(\r\n    source,\r\n    projection\r\n      ? (item, index, seed) =>\r\n          (item = projection(item, index, seed)) &&\r\n          (typeof item !== \"symbol\" || (item !== skip2 && item !== stop2))\r\n            ? (target[item[0]] = item[1])\r\n            : item\r\n      : (item) =>\r\n          item &&\r\n          (typeof item !== \"symbol\" || (item !== skip2 && item !== stop2))\r\n            ? (target[item[0]] = item[1])\r\n            : item\r\n  );\r\n  return target;\r\n};\r\n\r\nexport let assign2: {\r\n  <Target, Its extends readonly AssignSource<Target>[]>(\r\n    target: Target,\r\n    ...sources: Its\r\n  ): Target;\r\n} = (target, ...sources) => {\r\n  try {\r\n    if (target?.constructor === Object) {\r\n      forEach2(sources, (source) =>\r\n        forEach2(source!, (kv) => kv && (target[kv[0]] = kv[1]))\r\n      );\r\n    } else {\r\n      forEach2(sources, (source) =>\r\n        forEach2(source, (kv) => kv && target[setSymbol](kv[0], kv[1]))\r\n      );\r\n    }\r\n    return target;\r\n  } catch (e) {\r\n    return ensureAssignImplementations(target, e, () =>\r\n      assign2(target, ...sources)\r\n    );\r\n  }\r\n};\r\n\r\nexport interface Merge2Settings<\r\n  Deep extends boolean = boolean,\r\n  Overwrite extends boolean = boolean,\r\n  OverwriteNulls extends boolean = boolean\r\n> {\r\n  /**\r\n   * Merge nested objects if both the target and source values are object.\r\n   *\r\n   * @default true\r\n   */\r\n  deep?: Deep;\r\n\r\n  /**\r\n   * Don't merge the value from the other object(s) if the target already has a value.\r\n   */\r\n  overwrite?: Overwrite;\r\n  /**\r\n   * Overwrite `null` as if it was `undefined` when merging with `overwrite: false`.\r\n   * @default false\r\n   */\r\n  nulls?: boolean;\r\n}\r\nexport const merge2: {\r\n  <\r\n    Target,\r\n    Source extends SimpleObject | Falsish | Iterable<ObjectSource>,\r\n    Deep extends boolean = true,\r\n    Overwrite extends boolean = true,\r\n    OverwriteNulls extends boolean = false\r\n  >(\r\n    target: Target,\r\n    sources: EncourageTuples<Source>,\r\n    options?: Merge2Settings<Deep, Overwrite, OverwriteNulls>\r\n  ): Target extends Nullish\r\n    ? Target\r\n    : MergeObjectSources<Target, Source, Deep, Overwrite, OverwriteNulls>;\r\n} = (\r\n  target: any,\r\n  sources: any,\r\n  options: { deep?: boolean; overwrite?: boolean; nulls?: boolean } = {}\r\n) => {\r\n  if (target == null) {\r\n    return target;\r\n  }\r\n\r\n  const { deep = true, overwrite = true, nulls = false } = options;\r\n\r\n  for (const source of iterable2(sources)) {\r\n    forEach2(source, (kv) => {\r\n      if (!kv) return;\r\n      const [key, value] = kv;\r\n      const current = target[key];\r\n      if (nulls ? current == null : current === void 0) {\r\n        target[key] = value;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        deep &&\r\n        value?.constructor === Object &&\r\n        current?.constructor === Object\r\n      ) {\r\n        merge2(current, value, options);\r\n      } else if (overwrite) {\r\n        target[key] = value;\r\n      }\r\n    });\r\n  }\r\n  return target;\r\n};\r\n\r\nexport const pick2: {\r\n  <\r\n    T extends object | Nullish,\r\n    TK extends keyof (T & {}),\r\n    K extends RecordKeyOf<T>\r\n  >(\r\n    target: T,\r\n    // The `K | G` trick is because TypeScript will consider `[\"prop1\", \"prop2\"]` as `string[]`\r\n    //  without the `K extends keyof T` constraint (in which case it gets it right as (\"prop1\"|\"prop2\")[]).\r\n    // `keyof T` is too restrictive since we also want to support intersection types.\r\n    keys: Iterable<TK | K>\r\n  ): T extends Nullish\r\n    ? T\r\n    : T extends infer T\r\n    ? (TK | K) & keyof T extends infer K extends keyof T\r\n      ? {\r\n          [P in K]: T[P];\r\n        }\r\n      : never\r\n    : never;\r\n} = (target, keys) =>\r\n  target == null\r\n    ? target\r\n    : (obj2(keys, (key) =>\r\n        // The first check is presumably faster than the `in` operator.\r\n        target[key as any] !== void 0 || key in target\r\n          ? [key, target[key as any]]\r\n          : skip2\r\n      ) as any);\r\n","import {\r\n  filter2,\r\n  forEach2,\r\n  isArray,\r\n  isIterable,\r\n  IterationProjection2,\r\n  IterationSource,\r\n  map2,\r\n  Nullish,\r\n  replace,\r\n  skip2,\r\n  stop2,\r\n} from \"..\";\r\n\r\nconst isEmptyString = (s: any) =>\r\n  s == null || typeof s === \"boolean\" || s.toString() === \"\";\r\n\r\nexport const join2: {\r\n  /** Joins the specified values with the specified separator (default \"\"). `null`, `undefined`, empty strings and booleans are omitted. */\r\n  <Source>(source: Source, separator?: string): Source extends Nullish\r\n    ? Source\r\n    : string;\r\n  /** Joins the projection of the specified values with the specified separator (default \"\"). `null`, `undefined`, empty strings and booleans are omitted. */\r\n  <\r\n    Source extends IterationSource,\r\n    Projected,\r\n    Signal extends typeof skip2 | typeof stop2 | never,\r\n    Accumulator extends Projected = any\r\n  >(\r\n    source: Source,\r\n    projection?: IterationProjection2<Source, Accumulator, Projected | Signal>,\r\n    separator?: string\r\n  ): Source extends Nullish ? Source : string;\r\n} = (source: any, arg1: any, arg2?: any) =>\r\n  source == null\r\n    ? source\r\n    : !isIterable(source)\r\n    ? isEmptyString(source)\r\n      ? \"\"\r\n      : source.toString()\r\n    : filter2(\r\n        typeof arg1 === \"function\"\r\n          ? map2(source, arg1)\r\n          : ((arg2 = arg1), source),\r\n        isEmptyString,\r\n        true\r\n      ).join(arg2 ?? \"\");\r\n\r\nexport const indent2 = <T extends string | Nullish>(\r\n  text: T,\r\n  indent = \"  \"\r\n): T extends Nullish ? T : string => {\r\n  if (text == null) return text as any;\r\n  let i = 0;\r\n  let baseIndent = 0;\r\n  return replace(text, /( *)([^\\r\\n]*)(\\r?\\n?)/g, (_, lineIndent, text, br) => {\r\n    if (!text) {\r\n      return br;\r\n    }\r\n    if (!i++) {\r\n      baseIndent = lineIndent.length;\r\n    }\r\n    return `${indent}${\r\n      lineIndent.length >= baseIndent ? lineIndent.slice(baseIndent) : \"\"\r\n    }${text}${br}`;\r\n  }) as any;\r\n};\r\n\r\nexport const stringify2: <T>(value: T) => T extends undefined ? T : string =\r\n  JSON.stringify;\r\n\r\nexport const json2 = <Value = any>(\r\n  value: any\r\n): Value extends Nullish | \"\" ? undefined : Value =>\r\n  value == null || value === \"\"\r\n    ? undefined\r\n    : typeof value === \"object\"\r\n    ? value\r\n    : JSON.parse(value + \"\");\r\n\r\n/**\r\n * Itemizes an array of items by separating them with commas and a conjunction like \"and\" or \"or\".\r\n */\r\nexport const itemize2: {\r\n  <Source extends IterationSource>(\r\n    values: Source,\r\n    conjunction?:\r\n      | null\r\n      | string\r\n      | [comma: string | Nullish, conjunction: string | Nullish],\r\n    result?: (enumerated: string, n: number) => string\r\n  ): Source extends Nullish ? Source : string;\r\n  <\r\n    Source extends IterationSource,\r\n    Projected,\r\n    Accumulator extends Projected,\r\n    Signal extends typeof skip2 | typeof stop2 | never\r\n  >(\r\n    values: Source,\r\n    format: IterationProjection2<Source, Accumulator, Projected | Signal>,\r\n    conjunction?:\r\n      | string\r\n      | [comma: string | Nullish, conjunction: string | Nullish],\r\n    result?: (enumerated: string, n: number) => string\r\n  ): Source extends Nullish ? Source : string;\r\n} = (values: any, separators?: any, result?: any, rest?: any) => {\r\n  if (!values && values !== 0) return values == null ? values : undefined;\r\n\r\n  if (typeof separators === \"function\") {\r\n    return itemize2(map2(values, separators), result, rest);\r\n  }\r\n\r\n  const first: string[] = [];\r\n  const last = forEach2(values, (item, _, prev) =>\r\n    isEmptyString(item) ? skip2 : (prev && first.push(prev), item.toString())\r\n  );\r\n\r\n  let [separator, conjunction] = isArray(separators)\r\n    ? separators\r\n    : [, separators];\r\n\r\n  separator ??= \",\";\r\n  conjunction =\r\n    (conjunction ??= \"and\")[0] === separator\r\n      ? // The conjunction starts with the separator for \"1, 2, or 3\".\r\n        conjunction + \" \"\r\n      : \" \" +\r\n        // Don't add two spaces if the conjunction is the empty string.\r\n        (conjunction ? conjunction + \" \" : \"\");\r\n\r\n  const enumerated = first.length\r\n    ? `${first.join(separator + \" \")}${conjunction}${last}`\r\n    : last ?? \"\";\r\n\r\n  return result\r\n    ? result(enumerated, first.length + +(last != null))\r\n    : (enumerated as any);\r\n};\r\n","import { createEnumParser } from \"@tailjs/util\";\n\n/**\n * Defines to which extend a piece of information relates to a natural individual which is typically someone visiting your app or website.\n *\n * Tail.js requires all data that can be collected to be classified to prevent any data from being stored or otherwise used beyond\n * an individual's consent.\n *\n * Be aware that de default settings in the tail.js schema *do not* guarantee legal compliance, and you are responsible\n * for not using the collected data for other purposes than those intended.\n *\n */\nconst levels = {\n  /**\n   * A \"consent\" for this data classification means that no data will be stored for any reason.\n   *\n   * Likewise, if used in a schema all data with this classification will not be stored.\n   */\n  never: \"never\",\n\n  /**\n   * The data cannot be linked to a specific individual after they leave the website or app, and their session ends.\n   *\n   * This does _not_ include seemingly anonymous data such as the hash of an IP address, since that may still be linked back\n   * to an individual using \"additional information\". As an example, if you want to test if a specific person visited a website at a given time\n   * and you know their IP address at that time by some other means, you can generate a hash with the same algorithm and see if it is\n   * in the data.\n   *\n   * Tail.js will collect this kind of data in a way that does not use cookies or other information persisted in the individual's device. */\n  anonymous: \"anonymous\",\n\n  /**\n   * The data is unlikely to identify an individual by itself, but may link to a specific individual if combined with other data.\n   *\n   * Examples are IP addresses, detailed location data, and randomly generated device IDs persisted over time to track returning visitors.\n   */\n  indirect: \"indirect\",\n\n  /**\n   * The data directly identifies a specific individual.\n   *\n   * Examples are names, email addresses, user names, customer IDs from a CRM system or order numbers that can be linked\n   * to another system where the persons details are available.\n   */\n  direct: \"direct\",\n\n  /**\n   * Not only does the data identify a specific individual but may also reveal sensitive information about the user\n   * such as health data, financial matters, race, political and religious views, or union membership.\n   *\n   * tail.js's default schema does not have any data with this classification. If you intend to capture sensitive data in your events\n   * you may consider pseudonomizing it by hashing it or obfuscating it by some other mechanism.\n   * Whether the data will then classify as \"indirect\" or still be \"sensitive\" depends on context, but it will arguably then be\n   * \"less sensitive\".\n   */\n  sensitive: \"sensitive\",\n} as const;\n\nexport type DataClassification = (typeof levels)[keyof typeof levels];\n\nexport const DataClassification = createEnumParser(\n  \"data classification\",\n  levels\n);\n","import {\n  fromEntries,\n  isArray,\n  isString,\n  keys2,\n  map2,\n  Nullish,\n  obj2,\n  skip2,\n  throwError,\n} from \"@tailjs/util\";\nimport { SCHEMA_TYPE_PROPERTY, type DataUsage } from \".\";\n\nexport type DataPurposeName = keyof DataPurposes | \"necessary\";\nconst DATA_PURPOSES: DataPurposeName[] = [\n  \"necessary\",\n  \"performance\",\n  \"functionality\",\n  \"marketing\",\n  \"personalization\",\n  \"security\",\n];\n\nconst VALID_PURPOSE_NAMES = obj2(DATA_PURPOSES, (purpose) => [\n  purpose,\n  purpose,\n]);\n\nexport const DATA_PURPOSES_ALL: DataPurposes = Object.freeze(\n  fromEntries(DATA_PURPOSES.map((purpose) => [purpose, true]))\n);\n\n/**\n * Optional purposes that must be treated separately.\n */\nexport interface OptionalPurposes {\n  /**\n   * Consider the security purpose different from \"necessary\".\n   * @default false\n   */\n  security: boolean;\n\n  /**\n   * Consider the personalization purpose different from \"functionality\".\n   * @default false\n   */\n  personalization: boolean;\n}\n\nconst mapOptionalPurpose: {\n  <T extends string | Nullish>(\n    purpose: T,\n    optionalPurposes: OptionalPurposes | Nullish\n  ): T extends Nullish ? T : DataPurposeName;\n} = (purpose, optionalPurposes): any =>\n  purpose === \"personalization\" && optionalPurposes?.personalization !== true\n    ? \"functionality\"\n    : purpose === \"security\" && optionalPurposes?.security !== true\n    ? \"necessary\"\n    : purpose;\n\nconst mapOptionalPurposes: {\n  (\n    purposes: DataPurposes,\n    optionalPurposes: OptionalPurposes | Nullish\n  ): DataPurposes;\n} = (purposes, optionalPurposes) => {\n  let mappedPurposes = purposes;\n  if (\n    optionalPurposes?.personalization !== true &&\n    mappedPurposes.personalization != null\n  ) {\n    mappedPurposes === purposes && (mappedPurposes = { ...purposes });\n    if (mappedPurposes.functionality != null) {\n      mappedPurposes.personalization = mappedPurposes.functionality;\n    } else {\n      mappedPurposes.functionality = mappedPurposes.personalization;\n    }\n    delete mappedPurposes.personalization;\n  }\n  if (optionalPurposes?.security !== true && mappedPurposes.security != null) {\n    mappedPurposes === purposes && (mappedPurposes = { ...purposes });\n\n    delete mappedPurposes.security;\n  }\n\n  return mappedPurposes;\n};\n\nexport interface PurposeTestOptions {\n  intersect?: \"some\" | \"all\" | false;\n  targetPurpose?: DataPurposeName;\n  optionalPurposes?: OptionalPurposes | boolean;\n}\n\nexport const DataPurposes: {\n  parse<\n    T extends string | string[] | DataPurposes | DataUsage | Nullish,\n    Names extends boolean = false,\n    IncludeDefault extends boolean = true\n  >(\n    value: T,\n    options?: { names?: Names; includeDefault?: boolean; validate?: boolean }\n  ): T extends Nullish\n    ? T\n    : Names extends true\n    ? ([IncludeDefault] extends true ? DataPurposeName : keyof DataPurposes)[]\n    : DataPurposes;\n\n  readonly all: DataPurposes;\n\n  /**\n   * Compares whether a consent is sufficient for a set of target purposes, or whether\n   * a filter matches all the purposes in a target.\n   *\n   * @param target The target to validate the consent against.\n   * @param test The set of allowed purposes in either a consent or filter.\n   * @param options Options for how to test.\n   *\n   *  The default is \"normal\" consent validation which only requires the target to have one purpose with consent (or no required purposes).\n   *\n   */\n  test(\n    target: DataPurposes,\n    test: DataPurposes,\n    options?: PurposeTestOptions\n  ): boolean;\n\n  names: DataPurposeName[];\n  specificNames: (keyof DataPurposes)[];\n} = {\n  names: DATA_PURPOSES,\n  specificNames: DATA_PURPOSES.filter((purpose) => purpose !== \"necessary\"),\n  parse: (\n    value: any,\n    { names = false, includeDefault = true, validate = true } = {}\n  ) => {\n    if (value == null) return value;\n    if (value.purposes) {\n      // From DataUsage\n      value = value.purposes;\n    }\n\n    if (isString(value)) {\n      value = value.split(\",\");\n    }\n    if (isArray(value)) {\n      const purposes: DataPurposes = {};\n      for (const name of value as any) {\n        if (name === SCHEMA_TYPE_PROPERTY) continue;\n\n        if (!VALID_PURPOSE_NAMES[name]) {\n          validate && throwError(`The purpose name '${name}' is not defined.`);\n          continue;\n        } else if (name !== \"necessary\") {\n          purposes[name as any] = true;\n        }\n      }\n      value = purposes;\n    }\n\n    if (names) {\n      const result = map2(value, ([key, value]) =>\n        VALID_PURPOSE_NAMES[key] && value ? key : skip2\n      );\n      return result.length || !includeDefault ? result : [\"necessary\"];\n    }\n    return value;\n  },\n  get all(): DataPurposes {\n    return {\n      functionality: true,\n      marketing: true,\n      performance: true,\n      personalization: true,\n      security: true,\n    };\n  },\n\n  test(\n    target: DataPurposes,\n    test: DataPurposes,\n    { intersect, optionalPurposes, targetPurpose }: PurposeTestOptions\n  ) {\n    if (typeof optionalPurposes === \"boolean\") {\n      optionalPurposes = {\n        personalization: optionalPurposes,\n        security: optionalPurposes,\n      };\n    }\n    if (\n      targetPurpose &&\n      (targetPurpose = mapOptionalPurpose(targetPurpose, optionalPurposes)) !==\n        \"necessary\" &&\n      !test[mapOptionalPurpose(targetPurpose, optionalPurposes)]\n    ) {\n      return false;\n    }\n\n    target = mapOptionalPurposes(target, optionalPurposes);\n    test = mapOptionalPurposes(test, optionalPurposes);\n\n    if (intersect) {\n      for (let purpose in test) {\n        if (!VALID_PURPOSE_NAMES[purpose]) continue;\n        if (test[purpose] && !target[purpose]) {\n          // At least one purpose in the consent is not present in the target.\n          return false;\n        }\n      }\n\n      if (intersect === \"all\") {\n        for (let purpose in target) {\n          if (!VALID_PURPOSE_NAMES[purpose]) continue;\n          if (target[purpose] && !test[purpose]) {\n            // The target has a purpose that is not included in the consent.\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    let hasAny = false;\n    for (let purpose in target) {\n      if (!VALID_PURPOSE_NAMES[purpose]) continue;\n      if (target[purpose]) {\n        if (test[purpose]) {\n          // Just one of the purposes is good enough.\n          return true;\n        }\n        hasAny = true;\n      }\n    }\n    // The target has at least one required purpose, and the consent does not include any.\n    return !hasAny;\n  },\n};\n\n//\n/**\n * The purposes data can be used for.\n * Non-necessary data requires an individual's consent to be collected and used.\n *\n * Data categorized as \"anonymous\" will be stored regardless of consent since a consent only relates\n * to \"personal data\", and anonymous data is just \"data\".\n *\n * Whether the two purposes \"personalization\" and \"security\" are considered separate purposes\n * is configurable. The default is to consider \"personalization\" the same as \"functionality\", and\n * \"security\" the same as \"necessary\".\n */\nexport interface DataPurposes {\n  /**\n   * Data stored for this purpose is used to gain insights on how individuals interact with a website or app optionally including\n   * demographics and similar traits with the purpose of optimizing the website or app.\n   *\n   * DO NOT use this category if the data may be shared with third parties or otherwise used for targeted marketing outside the scope\n   * of the website or app. Use {@link DataPurposeFlags.Targeting} instead.\n   *\n   * It may be okay if the data is only used for different website and apps that relate to the same product or service.\n   * This would be the case if an individual is able to use an app and website interchangeably for the same service. Different areas of a brand may\n   * also be distributed across multiple domain names.\n   *\n   */\n  performance?: boolean;\n\n  /**\n   * Data stored for this purpose is used for settings that adjust the appearance of a website or app\n   * according to an individual's preferences such as \"dark mode\" or localization of date and number formatting.\n   *\n   * Depending on your configuration, a functionality consent may also include personalization.\n   * Personalization such as suggested articles and videos is per definition functionality,\n   * but a special subcategory may be used to make the distinction between profile settings\n   * and behavioral history depending on your requirements.\n   *\n   * DO NOT use this category if the data may be shared with third parties or otherwise used for targeted marketing outside the scope\n   * of the website or app. Use {@link DataPurposeFlags.Marketing} instead.\n   *\n   * It may be okay if the data is only used for different website and apps that relate to the same product, brand or service, hence\n   * the information is still \"first party\" with respect to the legal entity/brand to whom the consent is made.\n   *\n   * This would be the case if an individual is able to use an app and website interchangeably for the same service. Different areas of a brand may\n   * also be distributed across multiple domain names.\n   *\n   */\n  functionality?: boolean;\n\n  /**\n   * Data stored for this purpose may be similar to both functionality and performance data, however it may be shared with third parties\n   * or otherwise used to perform marketing outside the scope of the specific website or app.\n   *\n   * When tagging data points in a schema it is good practice to also specify whether the data is related to\n   * performance, functionality or both\n   *\n   * If the data is only used for different websites and apps that relate to the same product or service that belongs to your brand,\n   * it might not be necessary to use this category.\n   */\n  marketing?: boolean;\n\n  /**\n   * Personalization is a special subcategory of functionality data that is\n   * for things such as recommending articles and videos.\n   * This purpose is per default synonymous with {@link DataPurposes.functionality}, but can be configured to be a separate purpose\n   * that requires its own consent.\n   */\n  personalization?: boolean;\n\n  /**\n   * Data stored for this purpose is related to security such as authentication, fraud prevention, and other user protection.\n   *\n   * This purpose is per default synonymous with {@link DataPurposes.essential} but can be configured to be a separate purpose\n   * that requires its own consent.\n   */\n  security?: boolean;\n}\n","import { itemize2, MaybeNullish, Nullish } from \"@tailjs/util\";\nimport {\n  DataClassification,\n  DataPurposes,\n  PurposeTestOptions,\n  SchemaDataUsage,\n} from \".\";\n\nexport const formatDataUsage = (usage?: DataUsage) =>\n  `${usage?.classification ?? \"anonymous\"} data for ${itemize2(\n    DataPurposes.parse(usage?.purposes, { names: true })\n  )}  purposes.`;\n\nexport const validateConsent = (\n  target: DataUsage,\n  consent: DataUsage,\n  options: PurposeTestOptions\n) => {\n  if (target.classification === \"never\" || consent.classification === \"never\") {\n    return false;\n  }\n  if (target.classification === \"anonymous\") {\n    // Anonymous data does not require consent (it is not \"_personal_ data\" - just _data_).\n    return true;\n  }\n  if (\n    DataClassification.ranks[target.classification] >\n    DataClassification.ranks[consent.classification]\n  ) {\n    // Too personal.\n    return false;\n  }\n\n  return DataPurposes.test(target.purposes, consent.purposes, options);\n};\n\n/**\n * The combination of the classification and purposes it can be used for determines whether\n * data can be stored or used when compared to an individual's consent.\n */\nexport interface DataUsage {\n  /**\n   * The maximum classification of data a user has consented to be collected and stored.\n   *\n   * Any property with a classification higher than this will be cleared (censored) before an object is stored.\n   * If all properties gets censored, the object is not stored at all.\n   *\n   * Anonymous data does not require active consent, so data is stored regardless of its purposes\n   * since it is not \"personal data\" but just \"data\".\n   * This means you should not annotate all anonymous data as \"necessary\" in your schema, but rather\n   * use the purpose(s) that would require consent had the data not been anonymous.\n   *\n   * In this way you can simply remove the `anonymous` annotation from a field or object if it turns\n   * out it is not truly anonymous. After that the data can no longer be read for purposes without\n   * user consent. However, tail.js does not currently support redacting/purging the data from storage\n   * so this you need to do manually.\n   *\n   * For schema definitions see {@link SchemaDataUsage} for inheritance rules.\n   *\n   * @default anonymous\n   *\n   */\n  classification: DataClassification;\n\n  /**\n   * The purposes the data may be used for.\n   *\n   * If a data point has multiple purposes, consent is only need for one of them\n   * for the data to get stored. However, if some logic tries to read the data for a purpose without consent,\n   * it is not returned, since it is only stored for other purposes.\n   *\n   * Purposes do not restrict anonymous data. If no purposes are explicitly specified it implies \"necessary\".\n   *\n   * For schema definitions see {@link SchemaDataUsage} for inheritance rules.\n   */\n  purposes: DataPurposes;\n}\n\nexport const DataUsage = {\n  anonymous: {\n    classification: \"anonymous\",\n    purposes: {},\n  } as DataUsage,\n  clone: <T extends DataUsage | Nullish>(\n    usage: T\n  ): MaybeNullish<T, DataUsage> =>\n    usage &&\n    ({\n      classification: usage.classification,\n      purposes: { ...usage.purposes },\n    } satisfies DataUsage as any),\n\n  equals: (usage1: DataUsage | Nullish, usage2: DataUsage | Nullish) =>\n    usage1 === usage2 ||\n    (usage1 &&\n      usage2 &&\n      usage1.classification === usage2.classification &&\n      DataPurposes.test(usage1.purposes, usage2.purposes, {\n        intersect: \"all\",\n        optionalPurposes: true,\n      })),\n\n  serialize: (usage: DataUsage): string | null => {\n    const purposes = DataPurposes.parse(usage.purposes, {\n      names: true,\n      includeDefault: false,\n    });\n\n    return (!usage.classification || usage.classification === \"anonymous\") &&\n      !purposes?.length\n      ? null\n      : `${usage.classification}:${purposes}`;\n  },\n\n  deserialize: (\n    usageString: string | Nullish,\n    defaultUsage?: DataUsage\n  ): DataUsage => {\n    if (!usageString)\n      return defaultUsage\n        ? DataUsage.clone(defaultUsage)\n        : { classification: \"anonymous\", purposes: {} };\n    const [classification, purposes] = usageString.split(\":\");\n    return {\n      classification:\n        DataClassification.parse(classification, false) ?? \"anonymous\",\n      purposes: DataPurposes.parse(purposes, { validate: false }) ?? {},\n    };\n  },\n};\n","import { createEnumParser } from \"@tailjs/util\";\n\nconst levels = {\n  /** Data can be read and written from anywhere. */\n  public: \"public\",\n  /** Data can be read from anywhere but can only be written in trusted context. */\n  \"trusted-write\": \"trusted-write\",\n  /** Data is only available in trusted context. */\n  \"trusted-only\": \"trusted-only\",\n} as const;\n\nexport type DataVisibility = (typeof levels)[keyof typeof levels];\n\n/**\n * Defines restrictions on where data is available and when it can be modified.\n */\nexport type DataAccess = {\n  /**\n   * The data cannot be changed once set.\n   *\n   * For schema definitions see {@link SchemaDataUsage} for inheritance rules.\n   */\n  readonly: boolean;\n\n  /**\n   * If data can be accessed outside trusted context.\n   *\n   * For schema definitions see {@link SchemaDataUsage} for inheritance rules.\n   */\n  visibility: DataVisibility;\n};\n\nexport const DataVisibility = createEnumParser(\"data restriction\", levels);\n","import type { TrackedEvent } from \".\";\n\n/** The shape of the patch data for a {@link TrackedEvent} */\nexport type EventPatch<T extends TrackedEvent = TrackedEvent> = Partial<\n  Omit<T, \"type\">\n> & {\n  type: `${T[\"type\"]}_patch`;\n} & Required<Pick<TrackedEvent, \"patchTargetId\">>;\n\nexport const isEventPatch = (value: any): value is EventPatch =>\n  !!value?.patchTargetId;\n","import { SchemaDataUsage, SchemaPropertyDefinition } from \"../..\";\r\n\r\nexport interface SchemaObjectTypeDefinition extends Partial<SchemaDataUsage> {\r\n  /**\r\n   * May be used to override the type name if it does not match the keys in the schema.\r\n   */\r\n  name?: string;\r\n\r\n  /**\r\n   * The type inherits properties from these other types.\r\n   *\r\n   * Data usage will be inherited by these types in order, that is, if both the first and last\r\n   * type has a data classification, the last one wins.\r\n   */\r\n  extends?: string[];\r\n\r\n  /** The properties of the type. */\r\n  properties: {\r\n    [P in string]: SchemaPropertyDefinition;\r\n  };\r\n}\r\n\r\nexport const SCHEMA_TYPE_PROPERTY = \"@schema\";\r\nexport const SCHEMA_PRIVACY_PROPERTY = \"@privacy\";\r\n\r\nexport type SchemaTypedDataTypeInfo = string;\r\n//  {\r\n//   /** The namespace of the schema that defines the type. */\r\n//   ns: string;\r\n//   /** The name of the type (excluding namespace). */\r\n//   name: string;\r\n//   /** The version of the type, if specified. */\r\n//   version?: string;\r\n// }\r\n\r\nexport interface SchemaTypedDataPrivacyInfo {\r\n  /**\r\n   * One or more property values have been removed because they would violate a user's consent.\r\n   * When this is the case, please also checked the {@link invalid} flag since the partial data after censoring\r\n   * may not validate against the schema.\r\n   */\r\n  censored?: boolean;\r\n\r\n  /**\r\n   * The data does not validate against the schema.\r\n   */\r\n  invalid?: boolean;\r\n}\r\n\r\nexport interface SchemaTypedData {\r\n  [SCHEMA_TYPE_PROPERTY]?: SchemaTypedDataTypeInfo;\r\n\r\n  [SCHEMA_PRIVACY_PROPERTY]?: SchemaTypedDataPrivacyInfo;\r\n}\r\n","import { ellipsis, Nullish } from \"@tailjs/util\";\r\nimport { SchemaValidationContext, SchemaValueValidator } from \".\";\r\nimport { SchemaPropertyType } from \"../SchemaPropertyType\";\r\n\r\nexport type ValidationErrorContext = {\r\n  path: string;\r\n  message: string;\r\n  source: any;\r\n  type: SchemaPropertyType | null;\r\n  forbidden?: boolean;\r\n};\r\n\r\nexport const VALIDATION_ERROR_SYMBOL = Symbol();\r\n\r\nexport const joinPath = (prefix: string, current: string) =>\r\n  current?.length ? prefix + (current[0] === \"[\" ? \"\" : \".\") + current : prefix;\r\n\r\nexport const pushInnerErrors = <T>(\r\n  prefix: string,\r\n  value: T,\r\n  current: any,\r\n  context: SchemaValidationContext,\r\n  errors: ValidationErrorContext[],\r\n  validatable: { validate: SchemaValueValidator }\r\n): T | typeof VALIDATION_ERROR_SYMBOL => {\r\n  const innerErrors: ValidationErrorContext[] = [];\r\n  if (\r\n    (value = validatable.validate(\r\n      value,\r\n      current,\r\n      context,\r\n      innerErrors\r\n    ) as any) === VALIDATION_ERROR_SYMBOL ||\r\n    innerErrors.length\r\n  ) {\r\n    errors.push(\r\n      ...innerErrors.map((error) => ({\r\n        ...error,\r\n        path: joinPath(prefix, error.path),\r\n      }))\r\n    );\r\n  }\r\n  return value;\r\n};\r\n\r\nexport class ValidationError extends Error {\r\n  constructor(errors: ValidationErrorContext[], message?: string) {\r\n    super((message ? message + \":\\n\" : \"\") + formatValidationErrors(errors));\r\n  }\r\n}\r\n\r\nexport const formatErrorSource = (value: any) =>\r\n  value === undefined ? \"undefined\" : ellipsis(JSON.stringify(value), 40, true);\r\n\r\nexport const handleValidationErrors = <\r\n  R,\r\n  Collected extends ValidationErrorContext[] | Nullish\r\n>(\r\n  action: (\r\n    errors: ValidationErrorContext[]\r\n  ) => R | typeof VALIDATION_ERROR_SYMBOL,\r\n  collectedErrors?: Collected,\r\n  message?: string\r\n): Collected extends Nullish\r\n  ? Exclude<R, typeof VALIDATION_ERROR_SYMBOL>\r\n  : R => {\r\n  const errors: ValidationErrorContext[] = collectedErrors ?? [];\r\n\r\n  const result = action(errors);\r\n  if (\r\n    !collectedErrors &&\r\n    (result === VALIDATION_ERROR_SYMBOL || errors.length)\r\n  ) {\r\n    throw new ValidationError(errors, message);\r\n  }\r\n  return result as any;\r\n};\r\n\r\nexport const formatValidationErrors = (\r\n  errors: readonly ValidationErrorContext[],\r\n  bullet = \"\"\r\n): string => {\r\n  if (!errors.length) return \"(unspecified error)\";\r\n\r\n  const formatted = (errors.length > 10 ? errors.slice(0, 10) : errors).map(\r\n    ({ path, message }) => `${bullet}${path ? `${path}: ${message}` : message}`\r\n  );\r\n  if (errors.length > 10) {\r\n    formatted.push(\"\", `(and ${errors.length - 10} more)`);\r\n  }\r\n  return formatted.join(\"\\n\");\r\n};\r\n","import { distinct2, itemize2 } from \"@tailjs/util\";\r\nimport {\r\n  SchemaEnumTypeDefinition,\r\n  SchemaPrimitiveTypeDefinition,\r\n  SchemaValidationError,\r\n  VALIDATION_ERROR_SYMBOL,\r\n} from \"../../../..\";\r\nimport { formatErrorSource } from \".\";\r\n\r\nconst REGEX_DATE = /^\\d{4}-\\d{2}-\\d{2}(?:T00:00:00(?:\\.000)?)?Z$/;\r\nconst REGEX_DATETIME =\r\n  /^\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{1,7})?)?Z$/;\r\nconst REGEX_UUID =\r\n  /^\\{?([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})\\}?$/;\r\n\r\nconst REGEX_URI =\r\n  /^(?:(?:([\\w+.-]+):)(\\/\\/)?)((?:([^:@]+)(?:\\:([^@]*))?@)?(?:\\[([^\\]]+)\\]|([0-9:]+|[^/+]+?))(?::(\\d*))?)(\\/[^#?]*)?(?:\\?([^#]*))?(?:#(.*))?$/;\r\nconst REGEX_EMAIL =\r\n  /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:(\\[(([0-9.]+)|([0-9a-f:]+))\\])|(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9]))?$/;\r\n\r\nexport type SchemaPrimitiveValueValidator = (\r\n  value: any,\r\n  errors: SchemaValidationError[]\r\n) => any | null;\r\n\r\nconst addError = (\r\n  errors: SchemaValidationError[],\r\n  value: any,\r\n  message: string\r\n) => (\r\n  errors.push({\r\n    path: \"\",\r\n    type: null,\r\n    source: value,\r\n    message: `${formatErrorSource(value)} ${message}.`,\r\n  }),\r\n  VALIDATION_ERROR_SYMBOL\r\n);\r\n\r\nconst isNumber = (value: any, integer: boolean, allowStrings: boolean) =>\r\n  (typeof value === \"number\" &&\r\n    // Only actual numbers. IEEE 754 stuff like NaN is not supported in JSON so also not here.\r\n    ((!integer && Number.isFinite(value) && !Number.isNaN(value)) ||\r\n      Number.isInteger(value))) ||\r\n  (allowStrings &&\r\n    typeof value === \"string\" &&\r\n    isNumber(integer ? parseInt(value) : parseFloat(value), integer, false));\r\n\r\nconst primitiveValidators: Record<string, SchemaPrimitiveValueValidator> = {};\r\nexport const getPrimitiveTypeValidator = (\r\n  type: SchemaPrimitiveTypeDefinition | SchemaEnumTypeDefinition,\r\n  allowNumericStrings = false\r\n): {\r\n  validator: SchemaPrimitiveValueValidator;\r\n  primitive: SchemaPrimitiveTypeDefinition[\"primitive\"];\r\n  enumValues: Set<string | number> | undefined;\r\n} => {\r\n  let primitive =\r\n    type.primitive ?? (type.primitive = typeof (type.enum?.[0] ?? \"\") as any);\r\n\r\n  let validator = (primitiveValidators[\r\n    type.primitive + \"-\" + (type[\"format\"] ?? \"\") + \"-\" + allowNumericStrings\r\n  ] ??= create(type as SchemaPrimitiveTypeDefinition, allowNumericStrings));\r\n\r\n  const maxLength = type[\"maxLength\"];\r\n  if (maxLength != null) {\r\n    const inner = validator;\r\n    validator = (value, errors) =>\r\n      (value = inner(value, errors)) === VALIDATION_ERROR_SYMBOL\r\n        ? value\r\n        : value.length > maxLength\r\n        ? addError(\r\n            errors,\r\n            value,\r\n            `exceeds the maximum allowed ${maxLength} number of characters`\r\n          )\r\n        : value;\r\n  }\r\n  const min = type[\"min\"],\r\n    max = type[\"max\"];\r\n  if (min != null || max != null) {\r\n    const errorMessage =\r\n      min != null\r\n        ? max != null\r\n          ? `between ${min} and ${max}`\r\n          : `at least ${min}`\r\n        : `at most ${max}`;\r\n    const inner = validator;\r\n    validator = (value, errors) =>\r\n      (value = inner(value, errors)) === VALIDATION_ERROR_SYMBOL\r\n        ? value\r\n        : (min == null || value >= min) && (max == null || value <= max)\r\n        ? value\r\n        : addError(errors, value, errorMessage);\r\n  }\r\n\r\n  let enumValues: Set<any> | undefined;\r\n  if (\"enum\" in type) {\r\n    const inner = validator;\r\n    enumValues = new Set(\r\n      (Array.isArray(type.enum) ? type.enum : [type.enum]).map((value: any) => {\r\n        const errors = [];\r\n        if ((value = inner(value, errors)) === VALIDATION_ERROR_SYMBOL) {\r\n          throw new TypeError(errors[0]);\r\n        }\r\n        return value;\r\n      })\r\n    );\r\n\r\n    if (!enumValues.size) {\r\n      throw new TypeError(\r\n        \"At least one enum value to test against is required.\"\r\n      );\r\n    }\r\n\r\n    const errorMessage =\r\n      \"is not the constant value \" +\r\n      itemize2(\r\n        (type.enum as any[]).map((value: any) => JSON.stringify(value)),\r\n        \"or\"\r\n      );\r\n\r\n    validator = (value, errors) =>\r\n      (value = inner(value, errors)) === VALIDATION_ERROR_SYMBOL\r\n        ? value\r\n        : enumValues!.has(value)\r\n        ? value\r\n        : addError(errors, value, errorMessage);\r\n  }\r\n  return {\r\n    validator,\r\n    primitive,\r\n    enumValues: distinct2(enumValues),\r\n  };\r\n};\r\n\r\nfunction create(\r\n  type: SchemaPrimitiveTypeDefinition,\r\n  allowNumericStrings: boolean\r\n): SchemaPrimitiveValueValidator {\r\n  switch (type.primitive) {\r\n    case \"boolean\":\r\n      return (value, errors) =>\r\n        typeof value === \"boolean\"\r\n          ? value\r\n          : addError(errors, value, \"is not a Boolean\");\r\n\r\n    case \"date\":\r\n      return (value, errors) =>\r\n        value && REGEX_DATE.test(value) && !isNaN(+new Date(value))\r\n          ? value\r\n          : addError(\r\n              errors,\r\n              value,\r\n              \"is not a valid ISO 8601 UTC date (time is not allowed, and the 'Z' postfix must be added to indicate Coordinated Universal Time)\"\r\n            );\r\n\r\n    case \"timestamp\":\r\n    case \"datetime\":\r\n      const iso =\r\n        \"format\" in type\r\n          ? type.format !== \"unix\"\r\n          : type.primitive === \"datetime\";\r\n      return (value, errors) => {\r\n        if (!value || isNumber(value, false, allowNumericStrings)) {\r\n          if (!isNumber(value, true, allowNumericStrings)) {\r\n            return addError(errors, value, \"is not a valid UNIX timestamp\");\r\n          }\r\n          value = +value;\r\n        } else if (!REGEX_DATETIME.test(value) || isNaN(+new Date(value))) {\r\n          return addError(\r\n            errors,\r\n            value,\r\n            \"is not a valid ISO 8601 UTC date/time (the 'Z' postfix must be added to indicate Coordinated Universal Time)\"\r\n          );\r\n        }\r\n\r\n        value = new Date(value);\r\n        return iso ? new Date(value).toISOString() : +value;\r\n      };\r\n\r\n    case \"duration\":\r\n      return (value, errors) =>\r\n        isNumber(value, true, allowNumericStrings)\r\n          ? +value\r\n          : addError(\r\n              errors,\r\n              value,\r\n              \"is not a valid duration (must be provided as milliseconds)\"\r\n            );\r\n\r\n    case \"integer\":\r\n      return (value, errors) =>\r\n        isNumber(value, true, allowNumericStrings)\r\n          ? +value\r\n          : addError(errors, value, \"is not a valid integer\");\r\n\r\n    case \"number\":\r\n      return (value, errors) =>\r\n        isNumber(value, false, allowNumericStrings)\r\n          ? value\r\n          : addError(errors, value, \"is not a number\");\r\n\r\n    case \"string\":\r\n      switch (type.format) {\r\n        case \"uri\":\r\n          return (value, errors) =>\r\n            typeof value === \"string\" && REGEX_URI.test(value)\r\n              ? value\r\n              : addError(errors, value, \"is not a valid URI\");\r\n\r\n        case \"url\":\r\n          return (value, errors) => {\r\n            const match = typeof value === \"string\" && REGEX_URI.exec(value);\r\n            if (!match) return addError(errors, value, \"is not a valid URL\");\r\n            return match[2]\r\n              ? value\r\n              : addError(\r\n                  errors,\r\n                  value,\r\n                  \"is not a valid URL (it is a URI, but a URL is required)\"\r\n                );\r\n          };\r\n        case \"urn\":\r\n          return (value, errors) => {\r\n            const match = typeof value === \"string\" && REGEX_URI.exec(value);\r\n            if (!match) return addError(errors, value, \"is not a valid URN\");\r\n            return match[1] === \"urn\" && !match[2]\r\n              ? value\r\n              : addError(\r\n                  errors,\r\n                  value,\r\n                  \"is not a valid URN (it is a URI, but a URN is required)\"\r\n                );\r\n          };\r\n        case \"email\":\r\n          return (value, errors) =>\r\n            typeof value === \"string\" && REGEX_EMAIL.test(value)\r\n              ? value.toLowerCase()\r\n              : addError(errors, value, \"is not a valid email address\");\r\n      }\r\n      return (value, errors) =>\r\n        typeof value === \"string\"\r\n          ? value\r\n          : addError(errors, value, \"is not a string\");\r\n\r\n    case \"uuid\":\r\n      return (value, errors) =>\r\n        (typeof value === \"string\"\r\n          ? REGEX_UUID.exec(value)?.[1].toLowerCase()\r\n          : null) ?? addError(errors, value, \"is not a valid UUID\");\r\n\r\n    default:\r\n      throw new TypeError(\r\n        `'${formatErrorSource(type)}' is not a supported primitive type.`\r\n      );\r\n  }\r\n}\r\n","import {\n  createEnumParser,\n  itemize2,\n  MaybeNullish,\n  Nullish,\n  pick2,\n} from \"@tailjs/util\";\nimport { Timestamp, VariableKey } from \"../..\";\nimport { SchemaDataUsage } from \"../schema/SchemaDataUsage\";\n\nexport type KnownVariableMap = {\n  [scope: string]: { [key: string]: any };\n};\n\nconst variableScopeNames = {\n  /**\n   * Variables that are not bound to individuals, does not contain personal data, and not subject to censoring.\n   * These may be used for purposes such as shared runtime configuration\n   * or augmenting external entities with real-time data for personalization or testing.\n   */\n  global: \"global\",\n\n  /**\n   * Variables that relates to an individual's current session. These are purged when the session ends.\n   *\n   * Session variables can only be read for the current session from untrusted contexts.\n   */\n  session: \"session\",\n\n  /**\n   * Variables that relates to an individual's device.\n   *\n   * These variables are physically stored in the device where the available space may be very limited.\n   * For example, do not exceed a total of 2 KiB if targeting web browsers.\n   *\n   * To prevent race conditions between concurrent requests, device data may temporarily be loaded into session storage.\n   *\n   * Any data stored here is per definition at least `indirect` since it is linked to a device.\n   */\n  device: \"device\",\n\n  /**\n   * Variables that relates to an individual across devices.\n   *\n   * Associating a user ID with a session can only happen from a trusted context,\n   * but data for the associated user can then be read from untrusted contexts unless a `trusted-only` restriction is put on the data.\n   *\n   * Any data stored here is per definition at least `direct` since it directly linked to an individual.\n   */\n  user: \"user\",\n} as const;\n\nexport type VariableServerScope =\n  (typeof variableScopeNames)[keyof typeof variableScopeNames];\n\nexport type VariableExplicitServerScopes = \"global\";\n\nexport const VariableServerScope = createEnumParser(\n  \"variable scope\",\n  variableScopeNames\n);\n\nexport const VARIABLE_SYNTAX_RULES_TEXT =\n  \"Variables must be lowercase, start with a letter and then only user letters, numbers, underscores, dots and hyphens. (Keys prefixed with '@' are reserved for internal use.)\";\n/** Validates that the syntax for a key, scope or source in a variable conforms to the allowed syntax.  */\nexport const validateVariableKeyComponent = (syntax: string) =>\n  /^[@a-z][a-z0-9_.-]{0,49}$/.test(syntax);\n\n/**\n * Validates that spelling of the components in a variable key conforms to the allowed syntax.\n * If not, it returns the text for an error message, indicating which didn't, so be aware the truthy'ness of the return value is opposite\n * of what one might expect.\n */\nexport const validateVariableKeySyntax = (\n  key: VariableKey | Nullish\n): string | undefined => {\n  if (!key) return undefined;\n  let invalidComponents: string[] | undefined = undefined;\n  if (!validateVariableKeyComponent(key.key)) {\n    (invalidComponents ??= []).push(\"key\");\n  }\n  if (!validateVariableKeyComponent(key.scope)) {\n    (invalidComponents ??= []).push(\"scope\");\n  }\n  if (key.source && !validateVariableKeyComponent(key.source)) {\n    (invalidComponents ??= []).push(\"source\");\n  }\n  return (\n    invalidComponents &&\n    `Invalid ${itemize2(invalidComponents)}. ${VARIABLE_SYNTAX_RULES_TEXT}`\n  );\n};\n\n/**\n * A variable is a specific piece of information that can be classified and changed independently.\n * A variable can either be global or related to a specific entity or tracker scope.\n */\nexport interface Variable<T extends {} = any> extends VariableKey {\n  /**\n   * This information is only provided if the variable is schema bound.\n   */\n  schema?: {\n    type?: string;\n    version?: string;\n    usage: SchemaDataUsage;\n  };\n\n  /**\n   * When the variable was created (Unix timestamp in milliseconds).\n   */\n  created: Timestamp;\n\n  /**\n   * When the variable was last modified. (Unix ms).\n   */\n  modified: Timestamp;\n\n  /**\n   * A unique token that changes every time a variable is updated.\n   *\n   * It follows the semantics of a \"weak\" ETag in the HTTP protocol.\n   * How the value is generated is an internal implementation detail specific to the storage that manages the variable.\n   *\n   *\n   */\n  version: string;\n\n  /**\n   * This is a hint to variable storages that the variable should be deleted after this amount of milliseconds\n   * unless updated or refreshed (via VariableStorage in @tailjs/engine set or refresh methods).\n   *\n   * Variable storages can decide how accurately they want to enforce this in the background,\n   * yet it will be accurate from a client perspective, since tail.js filters out expired variables on read.\n   */\n  ttl?: number;\n\n  /** If the variable has a time-to-live, this is when it should expire. */\n  expires?: number;\n\n  /**\n   * The value of the variable. It must only be undefined in a set operation in which case it means \"delete\".\n   */\n  value: T;\n}\n\n/** Returns a description of a key that can be used for logging and error messages.  */\nexport const formatVariableKey = (\n  {\n    key,\n    scope = \"\",\n    entityId = \"\",\n    source = \"\",\n  }: {\n    source?: string | null;\n    scope?: string;\n    key: string;\n    entityId?: string;\n  },\n  error: string | undefined = \"\"\n) =>\n  [\n    \"'\" + key + \"'\",\n    source && \"from '\" + source + \"'\",\n    error,\n    scope && \"in \" + scope + \" scope\",\n    entityId && \"for '\" + entityId + \"'\",\n  ]\n    .filter((s) => s)\n    .join(\" \");\n\nexport const extractKey = <\n  T extends (Partial<VariableKey> & { key: string }) | Nullish\n>(\n  value: T\n): T extends infer T\n  ? Pick<T, keyof T & (\"source\" | \"key\" | \"scope\" | \"entityId\")> extends infer T\n    ? { [P in keyof T]: T[P] }\n    : never\n  : never =>\n  value == null\n    ? value\n    : ({\n        source: value.source,\n        key: value.key,\n        scope: value.scope,\n        entityId: value.entityId,\n      } as any);\n\nexport const extractVariable = <T extends Partial<Variable> | Nullish>(\n  variable: T\n): MaybeNullish<Pick<Variable, keyof T & keyof Variable>, T> => {\n  if (variable == null) return variable as any;\n  return {\n    scope: variable.scope,\n    key: variable.key,\n    entityId: variable.entityId,\n    created: variable.created,\n    modified: variable.modified,\n    version: variable.version,\n    expires: variable.expires,\n    ttl: variable.ttl,\n    value: variable.value,\n  } satisfies Partial<Variable> as any;\n};\n\nexport const removeLocalScopedEntityId = (variable: Variable) => {\n  if (variable.scope !== \"global\") {\n    variable.entityId = undefined!;\n  }\n  return variable;\n};\n","import {\r\n  array2,\r\n  ellipsis,\r\n  forEach2,\r\n  get2,\r\n  Nullish,\r\n  obj2,\r\n  throwError,\r\n  tryAdd,\r\n} from \"@tailjs/util\";\r\nimport {\r\n  CORE_SCHEMA_NS,\r\n  SCHEMA_DATA_USAGE_ANONYMOUS,\r\n  SchemaTypeDefinition,\r\n  type SchemaDefinition,\r\n  type VariableServerScope,\r\n} from \"../../..\";\r\n\r\nexport const DEFAULT_CENSOR_VALIDATE: ValidatableSchemaEntity = {\r\n  validate: (value: any, _current, _context, _errors) => value,\r\n  censor: (value, _context) => value,\r\n};\r\n\r\nimport {\r\n  CORE_EVENT_DISCRIMINATOR,\r\n  hasEnumValues,\r\n  isSchemaObjectType,\r\n  Schema,\r\n  SchemaDataUsage,\r\n  SchemaObjectType,\r\n  SchemaPropertyType,\r\n  SchemaSystemTypeDefinition,\r\n  SchemaVariable,\r\n} from \"../..\";\r\n\r\nimport {\r\n  createEventPatchDefinition,\r\n  createSchemaTypeMapper,\r\n  parseBaseTypes,\r\n  parseProperty,\r\n  parseType,\r\n  parseTypeProperties,\r\n  SchemaTypeSelector,\r\n  serializeAsDefinitions,\r\n  TypeParseContext,\r\n} from \"./parsing\";\r\nimport {\r\n  createAccessValidator,\r\n  createCensorAction,\r\n  getPrimitiveTypeValidator,\r\n  handleValidationErrors,\r\n  overrideUsage,\r\n  ValidatableSchemaEntity,\r\n  VALIDATION_ERROR_SYMBOL,\r\n  addTypeValidators,\r\n} from \"./validation\";\r\nimport { PATCH_EVENT_POSTFIX } from \"@constants\";\r\n\r\nexport type SchemaDefinitionSource = {\r\n  schema: SchemaDefinition;\r\n  /**\r\n   * Do not add events and variables from this schema to avoid name clashes.\r\n   * Use this if the types from the schema are only referenced by other schemas that provide events and variables.\r\n   */\r\n  typesOnly?: boolean;\r\n};\r\n\r\nconst uriValidator = getPrimitiveTypeValidator({\r\n  primitive: \"string\",\r\n  format: \"uri\",\r\n});\r\nexport class TypeResolver {\r\n  private readonly _schemas = new Map<string, Schema>();\r\n  private readonly _types = new Map<string, SchemaObjectType>();\r\n  private readonly _systemTypes: TypeParseContext[\"systemTypes\"] = {};\r\n  private readonly _eventMapper: SchemaTypeSelector | undefined;\r\n\r\n  private readonly _variables = new Map<string, Map<string, SchemaVariable>>();\r\n\r\n  public readonly schemas: readonly Schema[];\r\n\r\n  private readonly _sourceDefinitions: readonly SchemaDefinitionSource[];\r\n  public readonly definitions: readonly SchemaDefinition[];\r\n  private readonly _defaultUsage: SchemaDataUsage;\r\n\r\n  constructor(\r\n    definitions: readonly SchemaDefinitionSource[],\r\n    defaultUsage = SCHEMA_DATA_USAGE_ANONYMOUS\r\n  ) {\r\n    this._sourceDefinitions = definitions;\r\n    this._defaultUsage = defaultUsage;\r\n    const schemaContexts: [schema: Schema, context: TypeParseContext][] =\r\n      definitions.map(({ schema, typesOnly }) => {\r\n        if (!schema.namespace) {\r\n          throw new Error(\r\n            `${ellipsis(\r\n              JSON.stringify(schema),\r\n              40,\r\n              true\r\n            )} is not a valid schema - namespace is missing.`\r\n          );\r\n        }\r\n        const namespace = handleValidationErrors((errors) =>\r\n          uriValidator.validator(schema.namespace, errors)\r\n        );\r\n        if (this._schemas.has(namespace)) {\r\n          throw new Error(\r\n            `Only one schema can define the namespace '${namespace}'.`\r\n          );\r\n        }\r\n        const parsed: Schema = {\r\n          id: namespace,\r\n          namespace,\r\n          source: schema,\r\n          description: schema.description,\r\n          name: schema.name ?? namespace,\r\n          qualifiedName: namespace,\r\n          typesOnly: !!typesOnly,\r\n          version: schema.version,\r\n          usageOverrides: schema,\r\n          types: new Map(),\r\n          events: new Map(),\r\n          variables: new Map(),\r\n        };\r\n        this._schemas.set(namespace, parsed);\r\n\r\n        return [\r\n          parsed,\r\n          {\r\n            schema: parsed,\r\n            parsedTypes: this._types,\r\n            systemTypes: this._systemTypes,\r\n            defaultUsage: overrideUsage(defaultUsage, parsed.usageOverrides),\r\n            usageOverrides: schema,\r\n            typesOnly: !!typesOnly,\r\n            localTypes: parsed.types,\r\n            typeAliases: new Map(),\r\n          },\r\n        ];\r\n      });\r\n\r\n    for (const [schema, context] of schemaContexts) {\r\n      // Populate the type dictionary with initial type stubs without properties and base types.\r\n      // This allows circular references to be resolved, and schemas and their types be parsed in any order.\r\n      forEach2(\r\n        schema.source.types,\r\n        ([name, type]: [string, SchemaTypeDefinition]) =>\r\n          parseType([name, type], context, null)\r\n      );\r\n    }\r\n    const eventType = this._systemTypes.event;\r\n\r\n    for (const [schema, context] of schemaContexts) {\r\n      // Parse base types so \"extendedBy\" is populated for all types before we parse properties..\r\n      forEach2(schema.types, ([, type]) => parseBaseTypes(type, context));\r\n    }\r\n\r\n    for (const [schema, context] of schemaContexts) {\r\n      forEach2(schema.types, ([, type]) => parseTypeProperties(type, context));\r\n    }\r\n\r\n    if (eventType) {\r\n      // Make a copy of the original event types to avoid infinite loop (that is, patch types for patch types for patch types etc...).\r\n      forEach2(eventType.extendedByAll, (type) => {\r\n        const context = (schemaContexts.find(\r\n          (context) => context[0] === type.schema\r\n        ) ??\r\n          throwError(\r\n            `No parse context for the schema '${type.schema.name}'.`\r\n          ))[1];\r\n\r\n        if (!hasEnumValues(type.properties[CORE_EVENT_DISCRIMINATOR]?.type)) {\r\n          // Event types without a specific const value for `type` are per definition abstract.\r\n          type.abstract = true;\r\n        } else if (\r\n          !type.name.endsWith(PATCH_EVENT_POSTFIX) &&\r\n          !this._types.has(type.id + PATCH_EVENT_POSTFIX)\r\n        ) {\r\n          // Create a corresponding patch type.\r\n          const patchDefinition = createEventPatchDefinition(eventType, type);\r\n          (patchDefinition as SchemaSystemTypeDefinition).system = \"patch\";\r\n          const patchType = parseType(\r\n            [type.name + PATCH_EVENT_POSTFIX, patchDefinition],\r\n            context,\r\n            null\r\n          );\r\n          parseBaseTypes(patchType, context);\r\n          parseTypeProperties(patchType, context);\r\n        }\r\n      });\r\n    }\r\n\r\n    forEach2(this._types, ([, type]) => {\r\n      // Finish the types.\r\n      addTypeValidators(type);\r\n\r\n      forEach2(type.extendedBy, (subtype) => {\r\n        forEach2(type.referencedBy, (prop) => subtype.referencedBy.add(prop));\r\n        forEach2(type.variables, ([scope, keys]) =>\r\n          forEach2(keys, (key) =>\r\n            get2((subtype.variables ??= new Map()), scope, () => new Set()).add(\r\n              key\r\n            )\r\n          )\r\n        );\r\n      });\r\n    });\r\n\r\n    if (eventType) {\r\n      this._eventMapper = createSchemaTypeMapper([eventType]).match;\r\n    }\r\n\r\n    for (const [schema, context] of schemaContexts) {\r\n      if (schema.typesOnly) {\r\n        // Schema only included for type references, do not consider exported variables.\r\n        continue;\r\n      }\r\n      // Find variables.\r\n      forEach2(schema.source.variables, ([scope, keys]) => {\r\n        forEach2(keys, ([key, definition]) => {\r\n          if (!definition) {\r\n            return;\r\n          }\r\n          let variableType: SchemaPropertyType | undefined;\r\n\r\n          if (\"reference\" in definition) {\r\n            // Get the referenced type.\r\n            variableType = parseType(definition, context, null);\r\n          } else if (\"properties\" in definition) {\r\n            // Not a reference, upgrade the anonymous object types to a type definition by giving it a name.\r\n            variableType = parseType(\r\n              [scope + \"_\" + key, definition],\r\n              context,\r\n              null\r\n            );\r\n            parseBaseTypes(variableType, context);\r\n            parseTypeProperties(variableType, context);\r\n            addTypeValidators(variableType);\r\n          }\r\n\r\n          const dummyProperty = parseProperty(\r\n            variableType as any,\r\n            key,\r\n            definition as any,\r\n            context\r\n          );\r\n\r\n          variableType ??= dummyProperty.type;\r\n\r\n          const variable: SchemaVariable = {\r\n            key,\r\n            scope,\r\n            type: variableType,\r\n            description: dummyProperty.description,\r\n            usage: dummyProperty.usage,\r\n            validate: dummyProperty.validate,\r\n            censor: dummyProperty.censor,\r\n            dynamic: !!definition.dynamic,\r\n          };\r\n\r\n          tryAdd(\r\n            get2(this._variables, scope, () => new Map()),\r\n            key,\r\n            variable,\r\n            (current) => {\r\n              throw new Error(\r\n                `The type \"${variableType.toString()}\" cannot be registered for the variable key \"${key}\" in ${scope} scope, since it is already used by \"${\r\n                  current.type.toString\r\n                }\".`\r\n              );\r\n            }\r\n          );\r\n\r\n          get2(schema.variables, scope, () => new Map()).set(key, variable);\r\n\r\n          if (\"properties\" in variableType) {\r\n            get2(\r\n              (variableType.variables ??= new Map()),\r\n              scope,\r\n              () => new Set()\r\n            ).add(key);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    this.types = obj2(this._types);\r\n    this.variables = obj2(this._variables, ([scope, variables]) => [\r\n      scope,\r\n      obj2(variables, ([key, variable]) => {\r\n        const usage = (variable.usage = overrideUsage(\r\n          isSchemaObjectType(variable.type) ? variable.type.usage : undefined,\r\n          variable.usage\r\n        ));\r\n\r\n        const innerValidator = createAccessValidator(\r\n          scope + \".\" + key,\r\n          variable.type,\r\n          usage,\r\n          \"variable\"\r\n        );\r\n\r\n        variable.validate = variable.dynamic\r\n          ? (value, current, context, errors, polymorphic) =>\r\n              handleValidationErrors((errors) => {\r\n                if (context.forResponse) {\r\n                  return innerValidator(\r\n                    value,\r\n                    current,\r\n                    context,\r\n                    errors,\r\n                    polymorphic\r\n                  );\r\n                }\r\n                errors.push({\r\n                  message:\r\n                    \"The value is dynamically calculated and cannot be set\",\r\n                  path: \"\",\r\n                  type: variable.type,\r\n                  source: value,\r\n                  forbidden: true,\r\n                });\r\n                return VALIDATION_ERROR_SYMBOL as any;\r\n              }, errors)\r\n          : innerValidator;\r\n\r\n        variable.censor = createCensorAction(usage, variable.type);\r\n\r\n        return [key, variable];\r\n      }),\r\n    ]);\r\n\r\n    this.schemas = [...this._schemas.values()];\r\n\r\n    this.definitions = serializeAsDefinitions(this.schemas);\r\n  }\r\n\r\n  public getEventType<T>(\r\n    eventData: T\r\n  ): T extends Nullish ? T : SchemaObjectType {\r\n    return !this._eventMapper\r\n      ? throwError(\"System event type has not been configured\")\r\n      : eventData && (this._eventMapper(eventData) as any);\r\n  }\r\n\r\n  public getType<Required extends boolean = true>(\r\n    typeName: string,\r\n    required: Required = true as any,\r\n    defaultNamespace?: string\r\n  ): SchemaObjectType | (Required extends true ? never : undefined) {\r\n    const typeId = typeName.includes(\"#\")\r\n      ? typeName\r\n      : (defaultNamespace ?? CORE_SCHEMA_NS) + \"#\" + typeName;\r\n\r\n    const type = this._types.get(typeId);\r\n    if (required && !type) {\r\n      throw new Error(`The type '${typeId}' is not defined.`);\r\n    }\r\n    return type as any;\r\n  }\r\n\r\n  public getVariable<Required extends boolean = true>(\r\n    scope: string,\r\n    key: string,\r\n    required: Required = true as any\r\n  ): SchemaVariable | (Required extends true ? never : undefined) {\r\n    const variable = this._variables.get(scope)?.get(key);\r\n    if (!variable && required) {\r\n      throw new Error(\r\n        `The variable '${key}' in ${scope} scope is not defined.`\r\n      );\r\n    }\r\n    return variable as any;\r\n  }\r\n\r\n  public readonly types: {\r\n    readonly [P in string]?: Readonly<SchemaObjectType>;\r\n  };\r\n\r\n  public readonly variables: {\r\n    readonly [P in VariableServerScope | (string & {})]?: {\r\n      readonly [P in string]: Readonly<SchemaVariable>;\r\n    };\r\n  };\r\n\r\n  public subset(namespaces: string | string[]) {\r\n    const selectedSchemas = new Set<SchemaDefinitionSource>();\r\n    for (const schemaSelector of Array.isArray(namespaces)\r\n      ? namespaces\r\n      : [namespaces]) {\r\n      let matchedAny = false;\r\n      for (const source of this._sourceDefinitions) {\r\n        if (\r\n          schemaSelector === \"*\" ||\r\n          schemaSelector === source.schema.namespace ||\r\n          schemaSelector === source.schema.name\r\n        ) {\r\n          matchedAny = true;\r\n          selectedSchemas.add(source);\r\n        }\r\n      }\r\n      if (!matchedAny) {\r\n        throw new Error(\r\n          `The schema selector '${schemaSelector}' did not match any schemas currently loaded in the global type resolver.`\r\n        );\r\n      }\r\n    }\r\n\r\n    return new TypeResolver(\r\n      this._sourceDefinitions.map(\r\n        (source) =>\r\n          selectedSchemas.has(source)\r\n            ? { ...source, typesOnly: false }\r\n            : { ...source, typesOnly: true },\r\n        this._defaultUsage\r\n      )\r\n    );\r\n  }\r\n}\r\n","import {\n  Variable,\n  VariableGetResult,\n  VariableKey,\n  VariableSetResult,\n} from \"../..\";\n\nexport enum VariableResultStatus {\n  Success = 200,\n  Created = 201,\n  NotModified = 304,\n  BadRequest = 400,\n  Forbidden = 403,\n  NotFound = 404,\n  Conflict = 409,\n  Error = 500,\n}\n\nexport type VariableSuccessStatusWithValue =\n  | VariableResultStatus.Success\n  | VariableResultStatus.Created;\n\nexport type VariableSuccessStatus =\n  | VariableSuccessStatusWithValue\n  | VariableResultStatus.NotModified;\n\nexport type VariableErrorStatus =\n  | VariableResultStatus.Forbidden\n  | VariableResultStatus.NotFound\n  | VariableResultStatus.BadRequest\n  | VariableResultStatus.Conflict\n  | VariableResultStatus.Error;\n\nexport interface VariableResult extends VariableKey {\n  status: VariableResultStatus;\n}\n\nexport interface VariableNotFoundResult extends VariableResult {\n  status: VariableResultStatus.NotFound;\n  value?: undefined;\n  version?: undefined;\n}\n\nexport interface VariableValueErrorResult extends VariableResult {\n  status: VariableResultStatus.Forbidden | VariableResultStatus.BadRequest;\n  error?: string;\n  transient?: false;\n}\n\nexport interface VariableErrorResult extends VariableResult {\n  status: VariableResultStatus.Error;\n  error: string;\n  transient?: boolean;\n}\n\n/** The variable operation succeeded, and the result represents a variable, or undefined if not found. */\nexport const isVariableResult: {\n  <T extends {} = any>(value: any, requireFound?: true): value is Variable<T>;\n  <T extends {} = any>(value: any, requireFound: boolean): value is\n    | Variable<T>\n    | undefined\n    | {\n        status: VariableResultStatus.NotFound;\n        value?: undefined;\n      };\n} = (value: any, requireFound = true): value is any =>\n  (value as Variable)?.value != null ||\n  (!requireFound &&\n    (!value ||\n      (value as VariableGetResult).status === VariableResultStatus.NotFound));\n\n/**\n * The variable existed so the result has a value,\n * or the variable did not exists, in which case the value can be interpreted as `null`.\n */\n\nexport const isSuccessResult: {\n  <T = any>(\n    value: any,\n    /** Whether \"not found\" is considered a success. */\n    requireFound?: true\n  ): value is\n    | {\n        status: VariableResultStatus.Success | VariableResultStatus.Created;\n        value: T | null;\n      }\n    | { status: VariableResultStatus.NotModified };\n\n  <T extends {} = any>(\n    value: any,\n    /** Whether \"not found\" is considered a success. */\n    requireFound: boolean\n  ): value is\n    | {\n        status: VariableResultStatus.Success | VariableResultStatus.Created;\n        value: T | undefined;\n      }\n    | {\n        status:\n          | VariableResultStatus.NotModified\n          | VariableResultStatus.NotFound;\n      };\n} = (value: any, requireFound = true): value is any =>\n  value &&\n  ((value as VariableResult).status < 400 ||\n    (!requireFound &&\n      (value as VariableResult).status === VariableResultStatus.NotFound));\n\nexport const isTransientError = (\n  value: any\n): value is { status: VariableResultStatus.Error; transient: true } =>\n  (value as any)?.transient;\n\nexport interface VariableConflictResult<T extends {} = any>\n  extends VariableResult,\n    Variable<T> {\n  status: VariableResultStatus.Conflict;\n}\n\nexport interface VariableNotModifiedResult extends VariableResult {\n  status: VariableResultStatus.NotModified;\n  value?: undefined;\n}\n\nexport interface VariableSuccessResult<T extends {} = any>\n  extends VariableResult,\n    Variable<T> {\n  status: VariableResultStatus.Success | VariableResultStatus.Created;\n}\n\nexport type AnyVariableResult<T extends {} = any> =\n  | VariableGetResult<T>\n  | VariableSetResult<T>;\n","import {\r\n  AllKeys,\r\n  ArrayOrSelf,\r\n  deferredPromise,\r\n  Falsish,\r\n  IfNever,\r\n  isArray,\r\n  MaybePromiseLike,\r\n} from \"@tailjs/util\";\r\nimport {\r\n  formatVariableKey,\r\n  isSuccessResult,\r\n  isVariableResult,\r\n  KnownVariableMap,\r\n  MatchScopes,\r\n  RemoveScopeRestrictions,\r\n  RestrictScopes,\r\n  Variable,\r\n  VariableGetResult,\r\n  VariableGetter,\r\n  VariableInitializer,\r\n  VariableInitializerCallback,\r\n  VariableKey,\r\n  VariablePatch,\r\n  VariablePatchFunction,\r\n  VariableResult,\r\n  VariableResultStatus,\r\n  VariableSetResult,\r\n  VariableSetter,\r\n  VariableSuccessStatus,\r\n  VariableValueErrorResult,\r\n  VariableValueSetter,\r\n} from \"../..\";\r\n\r\ntype NotString<S> = string extends S ? never : S;\r\ntype Lookup<T, Source, Key> = unknown extends Key\r\n  ? never\r\n  : T[keyof T & NotString<Source[Key & keyof Source]>];\r\n\r\nexport type KnownTypeFor<\r\n  Operation,\r\n  KnownTypes extends KnownVariableMap,\r\n  Default = unknown\r\n> = IfNever<\r\n  Lookup<Lookup<KnownTypes, Operation, \"scope\">, Operation, \"key\">,\r\n  Default\r\n> & {};\r\n\r\nexport type VariableCallback<Result = VariableResult, Return = any> = (\r\n  result: Result\r\n) => MaybePromiseLike<Return>;\r\n\r\n/**\r\n * If the callback returns `true` the variable will get polled, that is, the callback will be called again if the variable changes.\r\n * If the variable is deleted, the callback will be called with a NotFound get result.\r\n *\r\n * Polling currently only works client-side.\r\n */\r\nexport type VariableGetterCallback<\r\n  KeyType = VariableKey,\r\n  T extends {} = any\r\n> = VariableCallback<\r\n  MatchScopes<\r\n    VariableResultPromiseResult<\"get\", VariableGetResult<T>>,\r\n    KeyType\r\n  >,\r\n  boolean | undefined | void\r\n>;\r\n\r\n/**\r\n * If the callback returns `true` the variable will get polled, that is, the callback will be called again if the variable changes.\r\n * If the variable is deleted or not found, it will be called with `undefined`.\r\n *\r\n * Polling currently only works client-side.\r\n */\r\nexport type VariablePollCallback<T extends {} = any> = (\r\n  result: T | undefined,\r\n  fromSourceOperation: boolean,\r\n  previous: T | undefined\r\n) => MaybePromiseLike<boolean | undefined | void>;\r\n\r\nexport type VariableSetterCallback<\r\n  KeyType = VariableKey,\r\n  T extends {} = any\r\n> = VariableCallback<\r\n  MatchScopes<VariableResultPromiseResult<\"set\", VariableSetResult<T>>, KeyType>\r\n>;\r\n\r\ntype ValidOperationKeys =\r\n  | AllKeys<VariableGetter | VariableSetter | Variable>\r\n  // To suspend client-side polling callbacks\r\n  | \"passive\";\r\n\r\n/**\r\n * Validate types for callbacks.\r\n */\r\nexport type WithCallbacks<\r\n  OperationType extends \"get\" | \"set\",\r\n  Operation,\r\n  KnownVariables extends KnownVariableMap\r\n> = Operation extends readonly any[]\r\n  ? {\r\n      [P in keyof Operation]: WithCallbacks<\r\n        OperationType,\r\n        Operation[P],\r\n        KnownVariables\r\n      >;\r\n    }\r\n  : Operation extends { scope: any }\r\n  ? {\r\n      [P in keyof Operation]: P extends \"patch\"\r\n        ? Operation[P] extends VariablePatchFunction<\r\n            infer Current,\r\n            infer Result\r\n          >\r\n          ? VariablePatchFunction<\r\n              KnownTypeFor<\r\n                Operation,\r\n                KnownVariables,\r\n                unknown extends Current ? Result : Current\r\n              >\r\n            >\r\n          : never\r\n        : P extends \"value\"\r\n        ? KnownTypeFor<Operation, KnownVariables, any> | null | undefined\r\n        : P extends \"init\"\r\n        ?\r\n            | undefined\r\n            | VariableInitializerCallback<\r\n                KnownTypeFor<Operation, KnownVariables, any>\r\n              >\r\n        : P extends \"callback\"\r\n        ?\r\n            | undefined\r\n            | (OperationType extends \"set\"\r\n                ? VariableSetterCallback<\r\n                    Operation,\r\n                    KnownTypeFor<Operation, KnownVariables, any>\r\n                  >\r\n                : VariableGetterCallback<\r\n                    Operation,\r\n                    KnownTypeFor<Operation, KnownVariables, any>\r\n                  >)\r\n        : [P, OperationType] extends [\"poll\", \"get\"]\r\n        ?\r\n            | undefined\r\n            | VariablePollCallback<KnownTypeFor<Operation, KnownVariables, any>>\r\n        : P extends ValidOperationKeys\r\n        ? Operation[P]\r\n        : never;\r\n    }\r\n  : Operation;\r\n\r\ntype TupleOrSelf<T> = T | readonly T[] | readonly [T];\r\n\r\nexport type VariableOperationParameter<\r\n  OperationType extends \"get\" | \"set\",\r\n  Operation\r\n> = TupleOrSelf<\r\n  | Falsish\r\n  | (Operation &\r\n      (OperationType extends \"get\"\r\n        ? {\r\n            callback?: VariableGetterCallback<Operation>;\r\n            poll?: VariablePollCallback;\r\n          }\r\n        : { callback?: VariableSetterCallback<Operation> }))\r\n>;\r\n\r\ntype VariableOperationResultItem<OperationType extends \"get\" | \"set\"> =\r\n  OperationType extends \"get\" ? VariableGetResult : VariableSetResult;\r\n\r\nexport type VariableOperationResult<\r\n  OperationType extends \"get\" | \"set\",\r\n  Operations,\r\n  ScopeTemplate extends { scope: string; entityId?: string },\r\n  KnownTypes extends KnownVariableMap = never\r\n> = VariableResultPromise<OperationType, Operations, ScopeTemplate, KnownTypes>;\r\n\r\ntype GenericVariableValue = unknown;\r\n\r\ntype ReplaceKey<Target, Source> = Target extends infer Target\r\n  ? {\r\n      [P in keyof Target]: P extends keyof VariableKey\r\n        ? Source[P & keyof Source]\r\n        : Target[P];\r\n    } extends infer T\r\n    ? { [P in keyof T]: T[P] }\r\n    : never\r\n  : never;\r\n\r\ntype MapVariableResult<\r\n  Operation,\r\n  Type extends \"success\" | \"all\" | \"value\" = \"success\",\r\n  Require extends boolean = false,\r\n  KnownTypes extends KnownVariableMap = never,\r\n  DefaultType extends {} = {}\r\n> = Operation extends Falsish\r\n  ? undefined\r\n  : Operation extends readonly any[]\r\n  ? {\r\n      -readonly [P in keyof Operation]: MapVariableResult<\r\n        Operation[P],\r\n        Type,\r\n        Require,\r\n        KnownTypes\r\n      >;\r\n    }\r\n  : (\r\n      Operation extends\r\n        | Pick<VariableValueSetter<infer Result>, \"value\">\r\n        | Pick<VariablePatch<infer Current, infer Result>, \"patch\">\r\n        ? [\r\n            \"set\",\r\n            ReplaceKey<\r\n              VariableSetResult<\r\n                unknown extends Current\r\n                  ? unknown extends Result\r\n                    ? KnownTypeFor<Operation, KnownTypes, GenericVariableValue>\r\n                    : Result\r\n                  : Current\r\n              >,\r\n              Operation\r\n            > & {\r\n              // NotModified is only for underlying VariableStorages behind faades that returns result promises.\r\n              status: Exclude<\r\n                VariableResultStatus,\r\n                Result extends null ? never : VariableResultStatus.NotFound\r\n              >;\r\n            }\r\n          ]\r\n        : [Operation] extends [never]\r\n        ? never\r\n        : [\r\n            \"get\",\r\n            ReplaceKey<\r\n              VariableGetResult<\r\n                DefaultType &\r\n                  (Operation extends Pick<\r\n                    VariableInitializer<infer Result>,\r\n                    \"init\"\r\n                  >\r\n                    ? unknown extends Result\r\n                      ? KnownTypeFor<\r\n                          Operation,\r\n                          KnownTypes,\r\n                          GenericVariableValue\r\n                        >\r\n                      : Result\r\n                    : KnownTypeFor<Operation, KnownTypes, GenericVariableValue>)\r\n              > & {\r\n                status: Exclude<\r\n                  VariableResultStatus,\r\n                  | ([Operation] extends [\r\n                      { ifModifiedSince: number } | { ifNoneMatch: string }\r\n                    ]\r\n                      ? never\r\n                      : VariableResultStatus.NotModified)\r\n                  | ([Operation] extends [{ init: any }]\r\n                      ? never\r\n                      :\r\n                          | VariableResultStatus.Created\r\n                          | VariableValueErrorResult[\"status\"])\r\n                >;\r\n              },\r\n              Operation\r\n            >\r\n          ]\r\n    ) extends [infer OperationType, infer Result]\r\n  ? (\r\n      Type extends \"all\"\r\n        ? Result\r\n        : Result extends { status: VariableResultStatus.NotFound }\r\n        ? Require extends true\r\n          ? never\r\n          : OperationType extends \"get\"\r\n          ? undefined\r\n          : never // Not found is an error result for set operations.\r\n        : Result extends { status: VariableResultStatus.NotModified }\r\n        ? Type extends \"value\"\r\n          ? undefined\r\n          : VariableResultPromiseResult<OperationType, Result>\r\n        : Result extends { status: VariableSuccessStatus; value?: any }\r\n        ? OperationType extends \"get\"\r\n          ? Type extends \"value\"\r\n            ? Result[\"value\"]\r\n            : Result\r\n          : Operation extends { value?: null | undefined }\r\n          ? Type extends \"value\"\r\n            ? undefined\r\n            : Result & { value?: undefined }\r\n          : Type extends \"value\"\r\n          ? Result[\"value\"] & Operation[keyof Operation & \"value\"]\r\n          : Result & Pick<Operation, keyof Operation & \"value\">\r\n        : never\r\n    ) extends infer Result\r\n    ? Type extends \"value\"\r\n      ? Result\r\n      : Result extends undefined\r\n      ? undefined\r\n      : Result extends { [x: string]: never }\r\n      ? never\r\n      : VariableResultPromiseResult<OperationType, Result>\r\n    : never\r\n  : never;\r\n\r\nexport type VariableResultPromise<\r\n  OperationType extends \"get\" | \"set\",\r\n  Operations,\r\n  ScopeTemplate extends { scope: string; entityId?: string },\r\n  KnownTypes extends KnownVariableMap = never\r\n> = unknown[] extends Operations\r\n  ? VariableResultPromise<\r\n      OperationType,\r\n      VariableOperationResultItem<OperationType>[],\r\n      ScopeTemplate\r\n    >\r\n  : unknown extends Operations\r\n  ? VariableResultPromise<\r\n      OperationType,\r\n      VariableOperationResultItem<OperationType>,\r\n      ScopeTemplate\r\n    >\r\n  : Promise<\r\n      MatchScopes<\r\n        MapVariableResult<Operations, \"success\", false, KnownTypes>,\r\n        ScopeTemplate\r\n      >\r\n    > & {\r\n      /** Return all variable results with error status codes instead of throwing errors. */\r\n      all<T extends {} = {}>(): Promise<\r\n        MatchScopes<\r\n          MapVariableResult<Operations, \"all\", false, KnownTypes, T>,\r\n          ScopeTemplate\r\n        >\r\n      >;\r\n      require<T extends {} = {}>(): Promise<\r\n        MatchScopes<\r\n          MapVariableResult<Operations, \"success\", true, KnownTypes, T>,\r\n          ScopeTemplate\r\n        >\r\n      >;\r\n      as<T extends {}>(): Promise<\r\n        MatchScopes<\r\n          MapVariableResult<Operations, \"success\", false, KnownTypes, T>,\r\n          ScopeTemplate\r\n        >\r\n      >;\r\n    } & (Operations extends readonly any[]\r\n        ? {\r\n            values<T extends {} = {}>(\r\n              require: true\r\n            ): Promise<\r\n              MapVariableResult<Operations, \"value\", true, KnownTypes, T>\r\n            >;\r\n            values<T extends {} = {}>(\r\n              require?: boolean\r\n            ): Promise<\r\n              MapVariableResult<Operations, \"value\", false, KnownTypes, T>\r\n            >;\r\n          }\r\n        : {\r\n            value<T extends {} = {}>(\r\n              require: true\r\n            ): Promise<\r\n              MapVariableResult<Operations, \"value\", true, KnownTypes, T>\r\n            >;\r\n            value<T extends {} = {}>(\r\n              require?: boolean\r\n            ): Promise<\r\n              MapVariableResult<Operations, \"value\", false, KnownTypes, T>\r\n            >;\r\n          });\r\n\r\nexport const formatVariableResult = (\r\n  result: RestrictScopes<VariableResult, string, any>\r\n) => {\r\n  const key = formatVariableKey(result);\r\n  const error = (result as any).error;\r\n  return result.status < 400\r\n    ? `${key} succeeded with status ${result.status} - ${\r\n        VariableResultStatus[result.status]\r\n      }.`\r\n    : `${key} failed with status ${result.status} - ${\r\n        VariableResultStatus[result.status]\r\n      }${error ? ` (${error})` : \"\"}.`;\r\n};\r\n\r\nexport class VariableStorageError<\r\n  Operations extends undefined | { [Symbol.iterator]?: never } | readonly any[]\r\n> extends Error {\r\n  public readonly succeeded: MapVariableResult<Operations, \"success\">;\r\n\r\n  public readonly failed: Exclude<\r\n    MapVariableResult<Operations, \"all\">,\r\n    MapVariableResult<Operations, \"success\">\r\n  >;\r\n\r\n  constructor(operations: Operations, message: string) {\r\n    super(message ?? \"One or more operations failed.\");\r\n    this.succeeded =\r\n      ((operations as VariableResult[])?.filter((operation) =>\r\n        isSuccessResult(operation, false)\r\n      ) as any) ?? [];\r\n    this.failed =\r\n      ((operations as VariableResult[])?.filter(\r\n        (operation) => !isSuccessResult(operation, false)\r\n      ) as any) ?? [];\r\n  }\r\n}\r\n\r\nconst hasCallback = (op: any): op is { callback: VariableCallback } =>\r\n  !!op[\"callback\"];\r\n\r\nconst hasPollCallback = (op: any): op is { poll: VariablePollCallback } =>\r\n  !!op[\"poll\"];\r\n\r\nconst sourceOperation = Symbol();\r\n\r\nexport const toVariableResultPromise = <\r\n  OperationType extends \"get\" | \"set\",\r\n  Operations,\r\n  Scope\r\n>(\r\n  operationType: OperationType,\r\n  operations: Operations | ArrayOrSelf<Falsish | { scope: Scope }>,\r\n  handler: (\r\n    operations: RemoveScopeRestrictions<\r\n      OperationType extends \"get\" ? VariableGetter : VariableSetter\r\n    >[]\r\n  ) => Promise<\r\n    Map<\r\n      RemoveScopeRestrictions<VariableKey, true>,\r\n      RemoveScopeRestrictions<VariableResult, true>\r\n    >\r\n  >,\r\n  {\r\n    poll,\r\n    logCallbackError,\r\n  }: {\r\n    poll?: (\r\n      source: OperationType extends \"get\" ? VariableGetter : VariableSetter,\r\n      callback: OperationType extends \"get\"\r\n        ? VariableGetterCallback\r\n        : VariableSetterCallback\r\n    ) => void;\r\n    logCallbackError?: (\r\n      message: string,\r\n      operation: OperationType extends \"get\" ? VariableGetter : VariableSetter,\r\n      error: any\r\n    ) => void;\r\n  } = {}\r\n): VariableResultPromise<OperationType, Operations, any> => {\r\n  const ops = isArray(operations) ? (operations as any) : [operations];\r\n  const callbackErrors: string[] = [];\r\n\r\n  const handlerResultPromise = (async () => {\r\n    const results = await handler(ops.filter((op: any) => op));\r\n    const callbacks: [\r\n      op: any,\r\n      initialResult: any,\r\n      callback: (result: VariableResult) => any\r\n    ][] = [];\r\n\r\n    for (const op of ops) {\r\n      if (!op) {\r\n        continue;\r\n      }\r\n\r\n      const result: VariableResult = results.get(op) as any;\r\n\r\n      if (result == null) {\r\n        // This error will be caught, if the result promise is awaited.\r\n        continue;\r\n      }\r\n\r\n      result[sourceOperation] = op;\r\n\r\n      if (hasCallback(op)) {\r\n        callbacks.push([op, result, (result) => op.callback(result) === true]);\r\n      }\r\n      if (hasPollCallback(op)) {\r\n        let previous: any;\r\n        // This is only defined for get operations.\r\n        callbacks.push([\r\n          op,\r\n          result,\r\n          (result) => {\r\n            if (!isVariableResult(result, false)) {\r\n              return true;\r\n            }\r\n            const poll = isVariableResult(result, false)\r\n              ? op.poll(result.value, result[sourceOperation] === op, previous)\r\n              : true;\r\n\r\n            previous = result.value;\r\n            return poll;\r\n          },\r\n        ]);\r\n      }\r\n    }\r\n    for (const [op, initialResult, callback] of callbacks) {\r\n      try {\r\n        const pollingCallback =\r\n          operationType === \"get\"\r\n            ? async (result: any) =>\r\n                (await callback(result)) === true && poll?.(op, pollingCallback)\r\n            : callback;\r\n        await pollingCallback(initialResult);\r\n      } catch (error) {\r\n        const message = `${operationType} callback for ${formatVariableKey(\r\n          op\r\n        )} failed: ${error}.`;\r\n        if (logCallbackError) {\r\n          logCallbackError(message, op, error);\r\n        } else {\r\n          callbackErrors.push(message);\r\n        }\r\n      }\r\n    }\r\n\r\n    return results;\r\n  })();\r\n\r\n  const mapResults = async (\r\n    type:\r\n      | 0 // any\r\n      | 1 // throw on errors\r\n      | 2, // values (also throw on errors)\r\n    require: boolean\r\n  ) => {\r\n    // The raw results from the map function including error results.\r\n    const handlerResults = await handlerResultPromise;\r\n\r\n    // The results we will return if there are no errors;\r\n    const results: any[] = [];\r\n    const errors: string[] = [];\r\n\r\n    for (const op of ops) {\r\n      if (!op) {\r\n        // Falsish to undefined.\r\n        results.push(undefined);\r\n        continue;\r\n      }\r\n      const result: VariableResult = handlerResults.get(op) as any;\r\n\r\n      if (result == null) {\r\n        errors.push(`No result for ${formatVariableKey(op)}.`);\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !type ||\r\n        isSuccessResult(\r\n          result,\r\n          // 404 is an error result for set operations, but not for get.\r\n          require || operationType === \"set\"\r\n        )\r\n      ) {\r\n        results.push(\r\n          type && result.status === VariableResultStatus.NotFound\r\n            ? undefined\r\n            : type > 1\r\n            ? result[\"value\"] ?? undefined\r\n            : result\r\n        );\r\n      } else {\r\n        errors.push(formatVariableResult(result));\r\n      }\r\n    }\r\n\r\n    errors.push(...callbackErrors);\r\n    if (errors.length) {\r\n      if (errors.length > 10) {\r\n        errors.push(`\\n(and ${errors.splice(10).length} more...)`);\r\n      }\r\n      throw new VariableStorageError(results, errors.join(\"\\n\"));\r\n    }\r\n\r\n    return ops === operations ? results : results[0]; // Single value if single value.\r\n  };\r\n\r\n  const resultPromise = Object.assign(\r\n    deferredPromise(() => mapResults(1, false)),\r\n    {\r\n      as: () => mapResults(1, false),\r\n      all: () => mapResults(0, false),\r\n      require: () => mapResults(1, true),\r\n      value: (require = false) => mapResults(2, require),\r\n      values: (require = false) => mapResults(2, require),\r\n    }\r\n  );\r\n\r\n  return resultPromise as any;\r\n};\r\n\r\nexport type VariableResultPromiseResult<OperationType, Result> = Result;\r\n","import type {\n  CartUpdatedEvent,\n  ComponentClickEvent,\n  EventMetadata,\n  LocalID,\n  Session,\n  Tagged,\n  Timestamp,\n  Uuid,\n  ViewEvent,\n} from \"..\";\n\n/**\n * The base type for all events that are tracked.\n *\n * The naming convention is:\n * - If the event represents something that can also be considered an entity like a \"page view\", \"user location\" etc. the name should be that.\n * - If the event indicates something that happened, like \"session started\", \"view ended\" etc. the name should end with a verb in the past tense.\n *\n * @id urn:tailjs:core:event\n * @system_type event\n * @abstract\n */\nexport interface TrackedEvent extends Tagged {\n  /**\n   * The type name of the event.\n   *\n   * All concrete event types must override this property with a constant value, and it is an error to try\n   * to store an event without a constant type.\n   *\n   * Since this is a system property that is ignored during censoring per default,\n   * it automatically becomes anonymous and necessary in custom events without required properties unless the system\n   * annotation is explicitly repeated.\n   *\n   */\n  type: string;\n\n  /**\n   * The ID of the schema the event comes from. It is suggested that the schema ID includes a SemVer version number in the end. (e.g. urn:tailjs:0.9.0 or https://www.blah.ge/schema/3.21.0)\n   */\n  schema?: string;\n\n  /**\n   * This is assigned by the server. Only use {@link clientId} client-side.\n   *\n   */\n  id?: Uuid;\n\n  /**\n   * This is set by the client and used to when events reference each other.\n   */\n  clientId?: LocalID;\n\n  /** These properties are used to track the state of the event as it gets collected, and is not persisted. */\n  metadata?: EventMetadata;\n\n  /**\n   * If set, it means this event contains updates to an existing event with this {@link clientId}, and should not be considered a separate event.\n   * It must have the target event's {@link TrackedEvent.type} postfixed with \"_patch\" (for example \"view_patch\").\n   *\n   * Numbers in patches are considered incremental which means the patch will include the amount to add to an existing number (or zero if it does not yet have a value).\n   * All other values are just overwritten with the patch values.\n   *\n   * Please pay attention to this property when doing analytics lest you may over count otherwise.\n   *\n   * Patches are always considered passive, cf. {@link EventMetadata.passive}.\n   */\n  patchTargetId?: LocalID;\n\n  /**\n   * The client ID of the event that caused this event to be triggered or got triggered in the same context.\n   * For example, a {@link NavigationEvent} may trigger a {@link ViewEvent},\n   * or a {@link CartUpdatedEvent} may be triggered with a {@link ComponentClickEvent}.\n   *\n   */\n  relatedEventId?: LocalID;\n\n  /**\n   * The session associated with the event.\n   */\n  session?: Session;\n\n  /**\n   * When applicable, the view where the event happened (related by {@link ViewEvent}).\n   */\n  view?: LocalID;\n\n  /**\n   * If specified, it must be a negative number when sent from the client (difference between when the event was generated and when is was posted in milliseconds).\n   *\n   * The timestamp is assigned before it reaches a backend.\n   *\n   * @default now\n   */\n  timestamp?: Timestamp;\n}\n\nexport const isTrackedEvent = (ev: any): ev is TrackedEvent =>\n  ev && typeof ev.type === \"string\";\n","import type {\n  Domain,\n  Integer,\n  LocalID,\n  TrackedEvent,\n  View,\n  ViewTimingData,\n  Viewport,\n} from \"..\";\nimport { typeTest } from \"../util/type-test\";\n\nexport interface ClickIds {\n  google?: string;\n  googleDoubleClick?: string;\n  facebook?: string;\n  microsoft?: string;\n  googleAnalytics?: string;\n}\n\n/**\n * This event is sent a user navigates between views. (page, screen or similar).\n *\n * This event does not\n *\n */\nexport interface ViewEvent extends TrackedEvent {\n  type: \"view\";\n\n  /**\n   * @inheritdoc\n   */\n  clientId: LocalID;\n\n  /**\n   * The primary content used to generate the view including the personalization that led to the decision, if any.\n   * If views are loaded asynchronously in a way where they are not available immediately after a user navigates to a URL\n   * on the website, the view definition may follow from a separate patch event.\n   */\n  definition?: View;\n\n  /**\n   * The tab where the view was shown.\n   */\n  tab?: LocalID;\n\n  /**\n   * The fully qualified URL as shown in the address line of the browser excluding the domain.\n   */\n  href: string;\n\n  /**\n   * The hash part of the URL (/about-us#address).\n   */\n  hash?: string;\n\n  /**\n   * The path portion of the URL.\n   */\n  path?: string;\n\n  /** For how long the view was active. This is set via patches */\n  duration?: ViewTimingData;\n\n  /**\n   * The HTTP status for the response associated with the view.\n   *\n   * @default 200\n   */\n  httpStatus?: number;\n\n  /**\n   * Urchin Tracking Module (UTM) parameters as defined by (Wikipedia)[https://en.wikipedia.org/wiki/UTM_parameters].\n   */\n  utm?: {\n    source?: string;\n    medium?: string;\n    campaign?: string;\n    term?: string;\n    content?: string;\n  };\n  /**\n   * The query string parameters in the URL, e.g. utm_campaign.\n   * Each parameter can have multiple values, for example If the parameter is specified more than once.\n   * If the parameter is only specified once pipes, semicolons and commas are assumed to separate values (in that order).\n   * A parameter without a value will get recorded as an empty string.\n   * @example The URL https://www.foo.com/?utm_source=bar&utm_campaign=campaign1,campaign2&flag&gclid=123xyz&p1=a&p1=b&p2=a;b,c;d has these parameters:\n   *  utm_source = [\"bar\"] \\\n   *  utm_campaign = [\"campaign1\", \"campaign2\"] \\\n   *  gclid = [\"123xyz\"] \\\n   *  flag = [\"\"] \\\n   *  gclid=[\"123xyz\"] \\\n   *  p1=[\"a\", \"b\"] \\\n   *  p2=[\"a\", \"b,c\", \"d\"]\n   */\n  queryString?: Record<string, string[]>;\n\n  // queryString?: {\n  //   source: Record<string, string>;\n  //   parsed: Record<string, string[]>;\n  // };\n\n  /**\n   * The domain part of the href, if any.\n   */\n  domain?: Domain;\n\n  /**\n   * Indicates that this was the first view in the first tab the user opened.\n   * Note that this is NOT tied to the session. If a user closes all tabs and windows for the site and then later navigates back to the site in the same session this flag will be set again.\n   * @default false\n   */\n  landingPage?: boolean;\n\n  /**\n   * Indicates that no other tabs were open when the view happened.\n   * This flag allows a backend to extend the definition of a session that can last indefinitely but still restart after inactivity.\n   * By measuring the time between a view with this flag and the previous event from the same device, it is possible to see for how long the device has been away from the site.\n   * @default false\n   */\n  firstTab?: boolean;\n\n  /**\n   * The tab number in the current session.\n   */\n  tabNumber?: Integer;\n\n  /**\n   * The view number in the current tab.\n   * This is kept as a convenience, yet technically redundant since it follows from timestamps and context.\n   * @default 1\n   */\n  tabViewNumber?: Integer;\n\n  /**\n   * Number of redirects that happened during navigation to this view.*/\n  redirects?: Integer;\n\n  /**\n   * Navigation type.\n   */\n  navigationType?: \"navigate\" | \"back-forward\" | \"prerender\" | \"reload\";\n\n  /**\n   * Indicates whether the event was manually triggered through a tracker command, or happened automatically by the tracker's ability to infer navigation.\n   *\n   * @default \"automatic\"\n   */\n  mode?: \"manual\" | \"automatic\";\n\n  /**\n   * External referrer. Internal referrers follows from the event's {@link TrackedEvent[\"relatedView\"]} field.\n   */\n  externalReferrer?: {\n    href?: string;\n    domain?: Domain;\n  };\n\n  /**\n   * The size of the user's viewport (e.g. browser window) and how much it was scrolled when the page was opened.\n   */\n  viewport?: Viewport;\n\n  /**\n   * The type of view, e.g. \"page\" or \"screen\".\n   *\n   * @default \"page\"\n   */\n  viewType?: string;\n}\n\nexport const isViewEvent = typeTest<ViewEvent>(\"view\");\n","import type { TrackedEvent } from \"..\";\n\nexport const typeTest =\n  <T extends TrackedEvent>(...types: string[]) =>\n  (ev: any): ev is T =>\n    ev?.type && types.some((type) => type === ev?.type);\n","import { Variable, VariableKey, VariableServerScope } from \"@tailjs/types\";\nimport { MaybeNullish, Nullish, createEnumParser } from \"@tailjs/util\";\nimport { CONSENT_INFO_KEY, SCOPE_INFO_KEY } from \"@constants\";\nimport type {\n  LocalID,\n  RestrictScopes,\n  ServerScoped,\n  SessionInfo,\n  UserConsent,\n  VariableGetRequest,\n  VariableGetResponse,\n  VariableGetResult,\n  VariableGetter,\n  VariableGetterCallback,\n  VariablePollCallback,\n  VariableResultPromiseResult,\n  VariableSetResult,\n  VariableSetter,\n  VariableSetterCallback,\n  View,\n} from \"@tailjs/types\";\n\nexport type ReferringViewData = [\n  viewId: LocalID,\n  relatedEventId: LocalID | undefined\n];\n\nexport interface CurrentView extends View {\n  /**\n   * If the view is updated, and this is set, it is considered navigation.\n   * Use this if you have implemented custom navigation that does not make use of\n   * history.push/replace.\n   */\n  navigation?: boolean;\n}\n\nexport type ReservedTrackerVariables = {\n  session: {\n    [SCOPE_INFO_KEY]: SessionInfo;\n    [CONSENT_INFO_KEY]: UserConsent;\n  };\n  view: {\n    view: CurrentView;\n    loaded: boolean;\n    referrer: string;\n  };\n  shared: {\n    tabIndex: number;\n    viewIndex: number;\n    referrer: [viewId: string | undefined, navigationEventId: string];\n  };\n};\n\nconst levels = {\n  /**\n   * Variables that are only available in memory in the current view, and lost as soon as the user navigates away (without bf_cache) or closes the browser.\n   *\n   * Data in this scope may be used without user consent (anonymous tracking), however if it is used in logic for event tracking\n   * make sure it does not contain personal information that may identify the user, hence violate the premise for the otherwise anonymously\n   * collected data.\n   *\n   *\n   */\n  view: \"view\",\n\n  /**\n   * Variables that are only available in the current tab, including between views in the same tab as navigation occurs, but lost as soon as the user closes the tab.\n   *\n   * Data is encrypted at rest, yet only available if the user has consented to data being stored for the variables' purposes.\n   */\n  tab: \"tab\",\n\n  /**\n   * Variables that are shared between open tabs, and lost as soon as the last tab is closed.\n   * These variables are kept entirely in memory and shared via messaging which means they are never persisted in the user's\n   * device between browser restarts.\n   *\n   * Use the server-side scopes `session`, `device` or `user` if the data must be persisted for a longer duration.\n   */\n  shared: \"shared\",\n} as const;\n\nexport type LocalVariableScope = (typeof levels)[keyof typeof levels];\n\nexport type AnyVariableScope = VariableServerScope | LocalVariableScope;\n\nexport const localVariableScope = createEnumParser(\n  \"local variable scope\",\n  levels\n);\n\nexport const anyVariableScope = createEnumParser(\"variable scope\", {\n  ...localVariableScope,\n  ...VariableServerScope,\n});\n\nexport type ClientScoped<\n  Target,\n  LocalOnly extends boolean = boolean\n> = LocalOnly extends true\n  ? RestrictScopes<Target, LocalVariableScope, never>\n  : ServerScoped<Target, true>;\n\nexport type ClientVariableKey<LocalOnly extends boolean = boolean> =\n  ClientScoped<VariableKey, LocalOnly>;\n\nexport type ClientVariable<\n  T extends {} = any,\n  LocalOnly extends boolean = boolean\n> = ClientScoped<Variable<T>, LocalOnly>;\n\nexport type ClientVariableGetter<\n  T extends {} = any,\n  LocalOnly extends boolean = boolean\n> = ClientScoped<VariableGetter<T>, LocalOnly> & {\n  /**\n   * This will be called with the result.\n   *\n   * Return `true` from the callback to poll for changes, that is, the callback will be invoked again next time the variable changes\n   * until it returns something else than `true`.\n   */\n  callback?: ClientVariableGetterCallback<T, LocalOnly>;\n\n  /**\n   * This will be called with the value of the variable whenever a change is detected in the local cache\n   * until the callback returns something different than `true`.\n   *\n   */\n  poll?: VariablePollCallback<T>;\n} & Pick<VariableGetRequest, \"passive\"> &\n  VariableCacheSettings;\n\nexport type ClientVariableSetter<\n  T extends {} = any,\n  LocalOnly extends boolean = boolean\n> = ClientScoped<VariableSetter<T>, LocalOnly> & {\n  callback?: ClientVariableSetterCallback<T, LocalOnly>;\n};\n\nexport type ClientVariableGetResult<\n  T extends {} = any,\n  LocalOnly extends boolean = boolean\n> = ClientScoped<\n  VariableResultPromiseResult<\"get\", VariableGetResult<T>> &\n    Pick<VariableGetResponse, \"passive\">,\n  LocalOnly\n>;\n\nexport type ClientVariableSetResult<\n  T extends {} = any,\n  LocalOnly extends boolean = boolean\n> = ClientScoped<\n  VariableResultPromiseResult<\"set\", VariableSetResult<T>>,\n  LocalOnly\n>;\n\nexport type ClientVariableGetterCallback<\n  T extends {} = any,\n  LocalOnly extends boolean = boolean\n> = VariableGetterCallback<ClientScoped<VariableKey, LocalOnly>, T>;\n\nexport type ClientVariableSetterCallback<\n  T extends {} = any,\n  LocalOnly extends boolean = boolean\n> = VariableSetterCallback<ClientScoped<VariableKey, LocalOnly>, T>;\n\nexport type VariableCacheSettings = {\n  /**\n   * The maximum number of milliseconds the value of this variable can be cached.\n   * If omitted or `true` the default value of 3 seconds will be used.\n   * `false` or 0 means the variable will not be cached.\n   */\n  cache?: number | boolean;\n};\n\nexport const maskEntityId = <T extends { scope: string; entityId?: string }>(\n  key: T\n): T & ClientScoped<VariableKey> => (\n  key[\"scope\"] !== \"global\" && key[\"entityId\"] && (key[\"entityId\"] = undefined),\n  key as any\n);\n\nexport const isLocalScopeKey = (\n  key: { scope: string } | Nullish\n): key is {\n  scope: LocalVariableScope;\n} => (key?.scope ? localVariableScope.ranks[key.scope] != null : false);\n\nexport const variableKeyToString: <S extends ClientVariableKey | Nullish>(\n  key: S\n) => MaybeNullish<string, S> = (key: ClientVariableKey | Nullish): any =>\n  key == null ? key : [key.scope, key.key, key.entityId].join(\"\\0\");\n\nexport const stringToVariableKey = (key: string): ClientVariableKey => {\n  const parts = key.split(\"\\0\");\n  return {\n    scope: parts[0] as any,\n    key: parts[1],\n    entityId: parts[2],\n  } satisfies ClientVariableKey;\n};\n","import { CLIENT_STORAGE_PREFIX } from \"@constants\";\n\nimport { TrackedEvent } from \"@tailjs/types\";\nimport { Nullish, throwError } from \"@tailjs/util\";\n\nexport const DEBUG = true;\nexport const HEARTBEAT_FREQUENCY = 5_000;\nexport const REQUEST_LOCK_KEY = CLIENT_STORAGE_PREFIX + \"rq\";\nexport const VARIABLE_POLL_FREQUENCY = 3_000;\nexport const VARIABLE_CACHE_DURATION = 3_000;\nexport const EVENT_POST_FREQUENCY = 5000;\n\nexport const NOT_INITIALIZED = () => () => throwError(\"Not initialized.\");\n\nexport type TrackerContext = {\n  deviceSessionId?: string;\n\n  applyEventExtensions(event: TrackedEvent): TrackedEvent | undefined;\n\n  validateKey: {\n    (key: string | Nullish, throwIfInvalid?: true): true;\n    (key: string | Nullish, throwIfInvalid: false): boolean;\n  };\n};\n","import { toggleAnsi, type Nullish } from \"@tailjs/util\";\n\nexport const SSR = typeof window === \"undefined\";\n\nconst win = window;\nconst doc = document;\nconst nav = navigator;\nconst body = doc.body;\nconst loc = location;\nconst perf = performance;\nconst hist = win.history;\nexport {\n  body,\n  doc as document,\n  hist as history,\n  loc as location,\n  nav as navigator,\n  perf as performance,\n  win as window,\n};\n\nexport const createElement = (tagName: string) => doc.createElement(tagName);\n\nexport const matchSelector = (node: Element | Nullish, selector: string) =>\n  !!node?.matches(selector);\n\ntoggleAnsi(!!(win as any).chrome);\n","import { OmitUnion } from \"@tailjs/util\";\nimport type { TrackerClientConfiguration } from \"..\";\n\nexport const isTracker = \"__isTracker\";\n\nexport const trackerConfig: Required<\n  OmitUnion<TrackerClientConfiguration, \"scriptBlockerAttributes\">\n> = {\n  name: \"tail\",\n  src: \"/_t.js\",\n  disabled: false,\n  postEvents: true,\n  postFrequency: 2000,\n  requestTimeout: 5000,\n  encryptionKey: null,\n  key: null,\n  apiKey: null,\n  json: false,\n\n  /**\n   * Log events to the browser's developer console.\n   */\n  impressionThreshold: 1000,\n  captureContextMenu: true,\n\n  tags: { default: [\"data-id\", \"data-name\"] },\n};\n","const codes: number[] = [];\nconst chars: number[] = [];\nexport const charCode = (s: string, index = 0) => s.charCodeAt(index);\nexport const fromCharCodes = (chars: number[]) => String.fromCharCode(...chars);\n\n[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"].forEach(\n  (p, i) => (codes[(chars[i] = p.charCodeAt(0))] = i)\n);\n\n/**\n * Encodes an array of bytes to Base64URL without padding (URL safe Base64 using `-` and `_` instead of `+` and `/`).\n *\n * (thanks to Jon Leighton at https://gist.github.com/jonleighton/958841).\n */\nexport const to64u = (bytes: Uint8Array) => {\n  let i = 0;\n  let chunk: number;\n  const n = bytes.length;\n\n  const base64: number[] = [];\n  while (i < n) {\n    chunk = (bytes[i++] << 16) | (bytes[i++] << 8) | bytes[i++];\n    base64.push(\n      chars[(chunk & 16515072) >> 18],\n      chars[(chunk & 258048) >> 12],\n      chars[(chunk & 4032) >> 6],\n      chars[chunk & 63]\n    );\n  }\n  base64.length += n - i;\n\n  return fromCharCodes(base64);\n};\n\n/**\n * Decodes a BaseURL encoded string (without padding).\n */\nexport const from64u = (encoded: string) => {\n  let i = 0;\n  let j = 0;\n  let p: number;\n  const n = encoded.length;\n  const bytes = new Uint8Array(3 * ((n / 4) | 0) + (((n + 3) & 3) % 3));\n  while (i < n) {\n    bytes[j++] =\n      (codes[charCode(encoded, i++)] << 2) |\n      ((p = codes[charCode(encoded, i++)]) >> 4);\n    if (i < n) {\n      bytes[j++] = ((p & 15) << 4) | ((p = codes[charCode(encoded, i++)]) >> 2);\n      if (i < n) {\n        bytes[j++] = ((p & 3) << 6) | codes[charCode(encoded, i++)];\n      }\n    }\n  }\n  return bytes;\n};\n\n/**\n * Decodes the specified UTF8 bytes to a string.\n *\n * [Thanks!](https://gist.github.com/Yaffle/5458286)\n */\nexport const decodeUtf8 = <T extends Uint8Array | string | null | undefined>(\n  octets: T\n): T extends null | undefined ? undefined : string => {\n  if (octets == null) return undefined as any;\n  if (typeof octets === \"string\") return octets as any;\n\n  const chars: number[] = [];\n  let i = 0;\n  while (i < octets.length) {\n    let octet = octets[i];\n    let bytesNeeded = 0;\n    let codePoint = 0;\n    if (octet <= 0x7f) {\n      bytesNeeded = 0;\n      codePoint = octet & 0xff;\n    } else if (octet <= 0xdf) {\n      bytesNeeded = 1;\n      codePoint = octet & 0x1f;\n    } else if (octet <= 0xef) {\n      bytesNeeded = 2;\n      codePoint = octet & 0x0f;\n    } else if (octet <= 0xf4) {\n      bytesNeeded = 3;\n      codePoint = octet & 0x07;\n    }\n    if (octets.length - i - bytesNeeded > 0) {\n      var k = 0;\n      while (k < bytesNeeded) {\n        octet = octets[i + k + 1];\n        codePoint = (codePoint << 6) | (octet & 0x3f);\n        k += 1;\n      }\n    } else {\n      codePoint = 0xfffd;\n      bytesNeeded = octets.length - i;\n    }\n    chars.push(codePoint);\n    i += bytesNeeded + 1;\n  }\n\n  return String.fromCodePoint(...chars) as any;\n};\n","import { Nullish, isBoolean } from \"@tailjs/util\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  (value: T, bits?: 32 | 64 | 128): string;\n  <B extends boolean>(value: T, numeric: B): B extends true ? number : string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key?: string | Nullish): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (\n    iw = 0;\n    iw < key?.length!;\n    mixer0 += window0[iw] = key!.charCodeAt(iw++)\n  );\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero, all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: Uint8Array, numericOrBits: any = 64) => {\n      if (source == null) return null;\n      bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n","(function () {\r\n\t\"use strict\";\r\n\r\n\t// Serializes a value to a MessagePack byte array.\r\n\t//\r\n\t// data: The value to serialize. This can be a scalar, array or object.\r\n\t// options: An object that defines additional options.\r\n\t// - multiple: (boolean) Indicates whether multiple values in data are concatenated to multiple MessagePack arrays. Default: false.\r\n\t// - invalidTypeReplacement:\r\n\t//   (any) The value that is used to replace values of unsupported types.\r\n\t//   (function) A function that returns such a value, given the original value as parameter.\r\n\tfunction serialize(data, options) {\r\n\t\tif (options && options.multiple && !Array.isArray(data)) {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\r\n\t\t}\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet floatBuffer, floatView;\r\n\t\tlet array = new Uint8Array(128);\r\n\t\tlet length = 0;\r\n\t\tif (options && options.multiple) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tappend(data[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tappend(data);\r\n\t\t}\r\n\t\treturn array.subarray(0, length);\r\n\r\n\t\tfunction append(data, isReplacement) {\r\n\t\t\tswitch (typeof data) {\r\n\t\t\t\tcase \"undefined\":\r\n\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\tappendBoolean(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tappendNumber(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tappendString(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif (data === null)\r\n\t\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\telse if (data instanceof Date)\r\n\t\t\t\t\t\tappendDate(data);\r\n\t\t\t\t\telse if (Array.isArray(data))\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\r\n\t\t\t\t\t\tappendBinArray(data);\r\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\r\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\r\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tappendObject(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\r\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendNull(data) {\r\n\t\t\tappendByte(0xc0);\r\n\t\t}\r\n\r\n\t\tfunction appendBoolean(data) {\r\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\r\n\t\t}\r\n\r\n\t\tfunction appendNumber(data) {\r\n\t\t\tif (isFinite(data) && Number.isSafeInteger(data)) {\r\n\t\t\t\t// Integer\r\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0 && data >= -0x20) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\r\n\t\t\t\t\tappendBytes([0xcc, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\r\n\t\t\t\t\tappendBytes([0xd0, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\r\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\r\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\r\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\r\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\r\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\r\n\t\t\t\t\t// 32 bits for bitwise operations.\r\n\t\t\t\t\tlet hi = data / pow32;\r\n\t\t\t\t\tlet lo = data % pow32;\r\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\r\n\t\t\t\t\tappendByte(0xd3);\r\n\t\t\t\t\tappendInt64(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0) {   // below int64\r\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t\telse {   // above uint64\r\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Float\r\n\t\t\t\tif (!floatView) {\r\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\r\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\r\n\t\t\t\t}\r\n\t\t\t\tfloatView.setFloat64(0, data);\r\n\t\t\t\tappendByte(0xcb);\r\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendString(data) {\r\n\t\t\tlet bytes = encodeUtf8(data);\r\n\t\t\tlet length = bytes.length;\r\n\r\n\t\t\tif (length <= 0x1f)\r\n\t\t\t\tappendByte(0xa0 + length);\r\n\t\t\telse if (length <= 0xff)\r\n\t\t\t\tappendBytes([0xd9, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(bytes);\r\n\t\t}\r\n\r\n\t\tfunction appendArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x90 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let index = 0; index < length; index++) {\r\n\t\t\t\tappend(data[index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendBinArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xff)\r\n\t\t\t\tappendBytes([0xc4, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(data);\r\n\t\t}\r\n\r\n\t\tfunction appendObject(data) {\r\n\t\t\tlet length = 0;\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tif (data[key] !== undefined) {\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x80 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tlet value = data[key];\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tappend(key);\r\n\t\t\t\t\tappend(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendDate(data) {\r\n\t\t\tlet sec = data.getTime() / 1000;\r\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\r\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\r\n\t\t\t\tappendInt64(sec);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendByte(byte) {\r\n\t\t\tif (array.length < length + 1) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + 1)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray[length] = byte;\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\tfunction appendBytes(bytes) {\r\n\t\t\tif (array.length < length + bytes.length) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + bytes.length)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray.set(bytes, length);\r\n\t\t\tlength += bytes.length;\r\n\t\t}\r\n\r\n\t\tfunction appendInt64(value) {\r\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\r\n\t\t\t// bitwise operations.\r\n\t\t\tlet hi, lo;\r\n\t\t\tif (value >= 0) {\r\n\t\t\t\t// Same as uint64\r\n\t\t\t\thi = value / pow32;\r\n\t\t\t\tlo = value % pow32;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\r\n\t\t\t\tvalue++;\r\n\t\t\t\thi = Math.abs(value) / pow32;\r\n\t\t\t\tlo = Math.abs(value) % pow32;\r\n\t\t\t\thi = ~hi;\r\n\t\t\t\tlo = ~lo;\r\n\t\t\t}\r\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deserializes a MessagePack byte array to a value.\r\n\t//\r\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\r\n\t// options: An object that defines additional options.\r\n\t// - multiple: (boolean) Indicates whether multiple concatenated MessagePack arrays are returned as an array. Default: false.\r\n\tfunction deserialize(array, options) {\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet pos = 0;\r\n\t\tif (array instanceof ArrayBuffer) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\r\n\t\t}\r\n\t\tif (!array.length) {\r\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\r\n\t\t}\r\n\t\tif (!(array instanceof Uint8Array)) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tlet data;\r\n\t\tif (options && options.multiple) {\r\n\t\t\t// Read as many messages as are available\r\n\t\t\tdata = [];\r\n\t\t\twhile (pos < array.length) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Read only one message and ignore additional data\r\n\t\t\tdata = read();\r\n\t\t}\r\n\t\treturn data;\r\n\r\n\t\tfunction read() {\r\n\t\t\tconst byte = array[pos++];\r\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\r\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\r\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\r\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\r\n\t\t\tif (byte === 0xc0) return null;   // nil\r\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\r\n\t\t\tif (byte === 0xc2) return false;   // false\r\n\t\t\tif (byte === 0xc3) return true;   // true\r\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\r\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\r\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\r\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\r\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\r\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\r\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\r\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\r\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\r\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\r\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\r\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\r\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\r\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\r\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\r\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\r\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\r\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\r\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\r\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\r\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\r\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\r\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\r\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\r\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\r\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\r\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\r\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\r\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\r\n\t\t\tconsole.debug(\"msgpack array:\", array);\r\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\r\n\t\t}\r\n\r\n\t\tfunction readInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\tlet first = true;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tlet byte = array[pos++];\r\n\t\t\t\t\tvalue += byte & 0x7f;\r\n\t\t\t\t\tif (byte & 0x80) {\r\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvalue *= 256;\r\n\t\t\t\t\tvalue += array[pos++];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readUInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tvalue *= 256;\r\n\t\t\t\tvalue += array[pos++];\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readFloat(size) {\r\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\r\n\t\t\tpos += size;\r\n\t\t\tif (size === 4)\r\n\t\t\t\treturn view.getFloat32(0, false);\r\n\t\t\tif (size === 8)\r\n\t\t\t\treturn view.getFloat64(0, false);\r\n\t\t}\r\n\r\n\t\tfunction readBin(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = array.subarray(pos, pos + size);\r\n\t\t\tpos += size;\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readMap(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = {};\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tlet key = read();\r\n\t\t\t\tdata[key] = read();\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readArray(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = [];\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readStr(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet start = pos;\r\n\t\t\tpos += size;\r\n\t\t\treturn decodeUtf8(array, start, size);\r\n\t\t}\r\n\r\n\t\tfunction readExt(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet type = readUInt(1);\r\n\t\t\tlet data = readBin(size);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 255:\r\n\t\t\t\t\treturn readExtDate(data);\r\n\t\t\t}\r\n\t\t\treturn { type: type, data: data };\r\n\t\t}\r\n\r\n\t\tfunction readExtDate(data) {\r\n\t\t\tif (data.length === 4) {\r\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\treturn new Date(sec * 1000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 8) {\r\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\r\n\t\t\t\t\t((data[1] << 14) >>> 0) +\r\n\t\t\t\t\t((data[2] << 6) >>> 0) +\r\n\t\t\t\t\t(data[3] >>> 2);\r\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\r\n\t\t\t\t\t((data[4] << 24) >>> 0) +\r\n\t\t\t\t\t((data[5] << 16) >>> 0) +\r\n\t\t\t\t\t((data[6] << 8) >>> 0) +\r\n\t\t\t\t\tdata[7];\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 12) {\r\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\tpos -= 8;\r\n\t\t\t\tlet sec = readInt(8);\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Encodes a string to UTF-8 bytes.\r\n\tfunction encodeUtf8(str) {\r\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\r\n\t\tlet ascii = true, length = str.length;\r\n\t\tfor (let x = 0; x < length; x++) {\r\n\t\t\tif (str.charCodeAt(x) > 127) {\r\n\t\t\t\tascii = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\r\n\t\tfor (let ci = 0; ci !== length; ci++) {\r\n\t\t\tlet c = str.charCodeAt(ci);\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tbytes[i++] = c;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c < 2048) {\r\n\t\t\t\tbytes[i++] = c >> 6 | 192;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\r\n\t\t\t\t\tif (++ci >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\r\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\r\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\r\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\r\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\r\n\t\t\t\t}\r\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\r\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\r\n\t\t\t}\r\n\t\t\tbytes[i++] = c & 63 | 128;\r\n\t\t}\r\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\r\n\t}\r\n\r\n\t// Decodes a string from UTF-8 bytes.\r\n\tfunction decodeUtf8(bytes, start, length) {\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = start, str = \"\";\r\n\t\tlength += start;\r\n\t\twhile (i < length) {\r\n\t\t\tlet c = bytes[i++];\r\n\t\t\tif (c > 127) {\r\n\t\t\t\tif (c > 191 && c < 224) {\r\n\t\t\t\t\tif (i >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\r\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 223 && c < 240) {\r\n\t\t\t\t\tif (i + 1 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\r\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 239 && c < 248) {\r\n\t\t\t\t\tif (i + 2 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\r\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\r\n\t\t\t}\r\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\r\n\t\t\telse if (c <= 0x10ffff) {\r\n\t\t\t\tc -= 0x10000;\r\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\r\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\r\n\t\t\t}\r\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\r\n\t// The exported functions\r\n\tlet msgpack = {\r\n\t\tserialize: serialize,\r\n\t\tdeserialize: deserialize,\r\n\r\n\t\t// Compatibility with other libraries\r\n\t\tencode: serialize,\r\n\t\tdecode: deserialize\r\n\t};\r\n\r\n\t// Environment detection\r\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\r\n\t\t// Node.js\r\n\t\tmodule.exports = msgpack;\r\n\t}\r\n\telse {\r\n\t\t// Global object\r\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\r\n\t}\r\n\r\n})();\r\n","import {\n  CONTEXT_NAV_QUERY,\n  EVENT_HUB_QUERY,\n  VARIABLES_QUERY,\n} from \"@constants\";\n\nimport { jsonEncode } from \"@tailjs/transport\";\nimport {\n  F,\n  T,\n  ansi,\n  isFunction,\n  isObject,\n  join2,\n  parseUri,\n  replace,\n  split,\n  type Nullish,\n} from \"@tailjs/util\";\nimport { document } from \".\";\n\nexport const ERR_BUFFER_OVERFLOW = \"buffer-overflow\";\nexport const ERR_POST_FAILED = \"post-failed\";\nexport const ERR_INVALID_COMMAND = \"invalid-command\";\nexport const ERR_INTERNAL_ERROR = \"internal-error\";\nexport const ERR_ARGUMENT_ERROR = \"invalid-argument\";\nexport const ERR_RESERVED = \"reserved\";\nexport const ERR_CONFIG_LOCKED = \"config-locked\";\nexport const ERR_DUPLICATE_KEY = \"key\";\n\nconst src = split(\"\" + document.currentScript![\"src\"], \"#\");\nconst args = split(\"\" + (src[1] || \"\"), \";\");\n\nexport const SCRIPT_SRC = src[0];\nexport const TRACKER_DOMAIN =\n  args[1] || parseUri(SCRIPT_SRC, { delimiters: false })?.host!;\n\nexport const isInternalUrl = (url: string | Nullish) =>\n  !!(\n    TRACKER_DOMAIN &&\n    parseUri(url, { delimiters: false })?.host?.endsWith(TRACKER_DOMAIN) === T\n  );\n\nexport const mapUrl = (...urlParts: string[]) =>\n  replace(join2(urlParts), /(^(?=\\?))|(^\\.(?=\\/))/, SCRIPT_SRC.split(\"?\")[0]);\n\nexport const VAR_URL = mapUrl(\"?\", EVENT_HUB_QUERY);\nexport const MNT_URL = mapUrl(\"?\", CONTEXT_NAV_QUERY);\nexport const USR_URL = mapUrl(\"?\", VARIABLES_QUERY);\n\nexport const groupValue = Symbol();\nexport const childGroups = Symbol();\n\nexport const debug = (\n  value: any,\n  group?: string,\n  collapsed = T,\n  nested = F\n) => {\n  group &&\n    (collapsed ? console.groupCollapsed : console.group)(\n      (nested ? \"\" : ansi(\"tail.js: \", \"90;3\")) + group\n    );\n  const children = value?.[childGroups];\n  children && (value = value[groupValue]);\n  value != null &&\n    console.log(\n      isObject(value)\n        ? ansi(jsonEncode(value), \"94\")\n        : // ? window[\"chrome\"]\n        //   ? prettyPrint(value).join(\"\")\n        //   : JSON.stringify(value, null, 2)\n        isFunction(value)\n        ? \"\" + value\n        : value\n    );\n  children &&\n    children.forEach(([value, group, collapsed]) =>\n      debug(value, group, collapsed, true)\n    );\n\n  group && console.groupEnd();\n};\n","import { createEvent, type Nullish } from \"@tailjs/util\";\nimport { Decoder, Encoder, createTransport } from \"@tailjs/transport\";\nimport { DEBUG, NOT_INITIALIZED } from \".\";\n\nexport const [httpEncode, httpDecode] = createTransport();\n\nexport let [httpEncrypt, httpDecrypt] = [\n  NOT_INITIALIZED,\n  NOT_INITIALIZED,\n] as any as [Encoder, Decoder];\n\nexport let USE_ENCRYPTION = true;\n\nexport const [addEncryptionNegotiatedListener, dispatchEncryptionNegotiated] =\n  createEvent<[httpEncrypt: Encoder, httpDecrypt: Decoder]>();\n\nexport const setStorageKey = (key: string | Nullish) => {\n  if (httpDecrypt !== NOT_INITIALIZED) return;\n\n  [httpEncrypt, httpDecrypt] = createTransport(key, {\n    json: !key,\n    prettify: false,\n  });\n\n  USE_ENCRYPTION = !!key;\n\n  dispatchEncryptionNegotiated(httpEncrypt, httpDecrypt);\n};\n","import { NonAsync, isString } from \"@tailjs/util\";\r\n\r\nexport const errorLogger = (source: any) => (error: any) =>\r\n  logError(source, error);\r\n\r\nexport const logError: {\r\n  (source: any, message: Error | string | undefined, ...args: any[]): void;\r\n  (source: any, arg1: Exclude<NonAsync, string>, ...args: any[]): void;\r\n} = (...args: any[]) => {\r\n  let source = args.shift();\r\n  let message: string;\r\n  if (args[1] instanceof Error) {\r\n    message = args[1].message;\r\n  } else {\r\n    message = isString(args[1])\r\n      ? args.shift()\r\n      : args[1]?.message ?? \"An error occurred\";\r\n  }\r\n  console.error(message, source.id ?? source, ...args);\r\n};\r\n","import { clock, createEvent, createTimer } from \"@tailjs/util\";\nimport { listen } from \".\";\n\ntype PageLoadListenerArgs = [loaded: boolean, stateDuration: number];\nconst [addPageLoadedListener, dispatchPageLoaded] =\n  createEvent<PageLoadListenerArgs>();\n\nconst [addPageVisibleListener, dispatchPageVisible] =\n  createEvent<[visible: boolean, unloading: boolean, delta: number]>();\n\nconst maybeDispatchPageLoaded = (newLoaded: boolean) =>\n  loaded !== (loaded = newLoaded) &&\n  dispatchPageLoaded(loaded, sleepTimer(true, true));\n\nconst maybeDispatchPageVisible = (loaded: boolean) =>\n  visible !==\n    (visible = loaded ? document.visibilityState === \"visible\" : false) &&\n  dispatchPageVisible(visible, !loaded, visibleTimer(true, true));\n\n// A visibilitychange event may not be triggered if the page BF cache loads/unloads.\naddPageLoadedListener(maybeDispatchPageVisible);\n\nlet loaded = true;\nlet visible = false;\nlet visibleTimer = createTimer(false);\nlet sleepTimer = createTimer(false);\n\nlisten(window, [\"pagehide\", \"freeze\", \"beforeunload\"], () =>\n  maybeDispatchPageLoaded(false)\n);\nlisten(window, [\"pageshow\", \"resume\"], () => maybeDispatchPageLoaded(true));\nlisten(\n  document,\n  \"visibilitychange\",\n  () => (\n    maybeDispatchPageVisible(true), visible && maybeDispatchPageLoaded(true)\n  )\n);\n\ndispatchPageLoaded(loaded, sleepTimer(true, true));\n\ntype PageActivatedListenerArgs = [activated: boolean, totalDuration: number];\nlet activated = false;\nlet activeTime = createTimer(false);\n\nconst [addPageActivatedListener, dispatchPageActivated] =\n  createEvent<PageActivatedListenerArgs>();\n\nconst activationTimeout = clock({\n  callback: () =>\n    activated && dispatchPageActivated((activated = false), activeTime(false)),\n  frequency: 20000,\n  once: true,\n  paused: true,\n});\nconst setActivated = () =>\n  !activated &&\n  (dispatchPageActivated((activated = true), activeTime(true)),\n  activationTimeout.restart());\n\nlisten(window, [\"focus\", \"scroll\"], setActivated);\nlisten(window, \"blur\", () => activationTimeout.trigger());\n\nlisten(\n  document.body,\n  [\"keydown\", \"pointerdown\", \"pointermove\", \"scroll\"],\n  setActivated\n);\n\nsetActivated();\n\nexport const getActiveTime = () => activeTime();\nexport {\n  addPageActivatedListener,\n  addPageLoadedListener,\n  addPageVisibleListener,\n};\n","import { CLIENT_STATE_CHANNEL_ID } from \"@constants\";\n\nimport { UuidV4, VariableGetRequest, extractKey } from \"@tailjs/types\";\nimport {\n  PartialRecord,\n  assign2,\n  clock,\n  concat2,\n  createEvent,\n  filter2,\n  forEach2,\n  isString,\n  map2,\n  now,\n  obj2,\n  replace,\n  set2,\n  skip2,\n} from \"@tailjs/util\";\nimport {\n  HEARTBEAT_FREQUENCY,\n  NOT_INITIALIZED,\n  VARIABLE_CACHE_DURATION,\n  addEncryptionNegotiatedListener,\n  addPageLoadedListener,\n  listen,\n} from \".\";\nimport {\n  ClientVariable,\n  ClientVariableKey,\n  anyVariableScope,\n  stringToVariableKey,\n  variableKeyToString,\n} from \"..\";\n\nexport interface TabState {\n  id: string;\n  heartbeat: number;\n  viewId?: string;\n}\n\nexport interface StateVariableMetadata {\n  cache?: [timestamp: number, ttl?: number];\n}\n\nexport type StateVariable<\n  T extends {} = any,\n  LocalScope extends boolean = boolean\n> = ClientVariable<T, LocalScope> & StateVariableMetadata;\n\nexport type StateVariableEntry = [\n  key: ClientVariableKey,\n  variable: StateVariable | undefined\n];\n\nexport interface State {\n  knownTabs: Map<string, TabState>;\n  /** All variables except local. */\n  variables: Map<string, StateVariable>;\n}\n\nlet localId = 0;\n\nexport let TAB_ID: string = undefined as any;\nexport const nextId = () => (TAB_ID ?? NOT_INITIALIZED()) + \"_\" + nextLocalId();\nexport const nextLocalId = () =>\n  (now(true) - (parseInt(TAB_ID.slice(0, -2), 36) || 0)).toString(36) +\n  \"_\" +\n  (++localId).toString(36);\n\nconst randomValues = (arg: any) => crypto.getRandomValues(arg);\nexport const uuidv4 = (): UuidV4 =>\n  replace(\n    ([1e7] as any) + -1e3 + -4e3 + -8e3 + -1e11,\n    /[018]/g,\n    (c: any) => (\n      (c *= 1),\n      (c ^ (randomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)\n    )\n  );\n\n/** All variables, both local and others. */\nlet tabVariables = new Map<string, StateVariable>();\n\nconst tabState: TabState = {\n  id: TAB_ID,\n  heartbeat: now(),\n};\n\nconst state: State = {\n  knownTabs: new Map([[TAB_ID, tabState]]),\n  variables: new Map(),\n};\n\ntype StateMessage =\n  | { type: \"query\"; payload?: undefined }\n  | {\n      type: \"set\";\n      payload: [\n        knownTabs: [string, TabState][],\n        variables: [string, StateVariable][]\n      ];\n    }\n  | {\n      type: \"patch\";\n      payload: PartialRecord<string, StateVariable>;\n    }\n  | {\n      type: \"tab\";\n      payload: TabState | undefined;\n    };\n\nconst [addStateListener, dispatchState] = createEvent<\n  | [event: \"ready\", state: State, self: boolean]\n  | [event: \"tab\", tab: TabState, self: boolean]\n>();\n\nexport type StateVariableChange = readonly [\n  key: ClientVariableKey,\n  current: (ClientVariable & Pick<VariableGetRequest, \"passive\">) | undefined,\n  previous: ClientVariable | undefined\n];\nconst [addVariablesChangedListener, dispatchVariablesChanged] =\n  createEvent<\n    [\n      changes: StateVariableChange[],\n      all: ReadonlyMap<string, StateVariable>,\n      local: boolean\n    ]\n  >();\n\nexport { addVariablesChangedListener };\n\nlet post: (message: StateMessage, target?: string) => void = NOT_INITIALIZED;\n\nexport const tryGetVariable = (\n  key: ClientVariableKey | string,\n  timestamp = now()\n): StateVariable | undefined => {\n  const variable = tabVariables.get(\n    isString(key) ? key : variableKeyToString(key)\n  );\n  return variable?.cache && variable.cache[0]! + variable.cache[1]! <= timestamp\n    ? undefined\n    : variable;\n};\n\nexport const setLocalVariables = (\n  ...variables: Omit<\n    ClientVariable<any, true>,\n    \"created\" | \"modified\" | \"version\"\n  >[]\n) => {\n  const timestamp = now();\n  return updateVariableState(\n    map2(variables, (variable) => {\n      (variable as StateVariable).cache = [timestamp];\n      return [\n        extractKey(variable),\n        { ...variable, created: timestamp, modified: timestamp, version: \"0\" },\n      ];\n    })\n  );\n};\n\nconst getVariableChanges = (\n  variables: (StateVariableEntry | undefined)[] | undefined\n): [\n  key: string,\n  current: StateVariable | undefined,\n  previous: StateVariable | undefined,\n  sourceKey: ClientVariableKey\n][] =>\n  map2(variables, (current) => {\n    if (!current) return skip2;\n    const key = variableKeyToString(current[0]);\n    const previous = tabVariables.get(key);\n    return previous !== current[1]\n      ? [key, current[1], previous, current[0]]\n      : skip2;\n  }) ?? [];\n\nexport const updateVariableState = (\n  updates: (StateVariableEntry | undefined)[] | undefined\n) => {\n  // Collect now before updating the state, but dispatch after the state has changed.\n  const changes = getVariableChanges(updates);\n  if (!changes?.length) return;\n\n  const timestamp = now();\n  forEach2(changes, ([, current, previous]) => {\n    if (current && !current.cache) {\n      current.cache = previous?.cache ?? [timestamp, VARIABLE_CACHE_DURATION];\n    }\n  });\n  assign2(tabVariables, changes);\n\n  const sharedChanges = filter2(\n    changes,\n    ([, , , key]) => anyVariableScope.compare(key.scope, \"tab\") > 0\n  );\n\n  if (sharedChanges.length) {\n    post({ type: \"patch\", payload: obj2(sharedChanges) });\n  }\n\n  dispatchVariablesChanged(\n    map2(changes, ([, current, previous, key]) => [key, current, previous]),\n    tabVariables,\n    true\n  );\n};\n\naddEncryptionNegotiatedListener((httpEncrypt, httpDecrypt) => {\n  // Keep tab ID and variables between pages in the same tab.\n  addPageLoadedListener((loaded) => {\n    if (loaded) {\n      const localState = httpDecrypt(\n        sessionStorage.getItem(CLIENT_STATE_CHANNEL_ID)\n      ) as [tabId: string, variables: StateVariable[]];\n      sessionStorage.removeItem(CLIENT_STATE_CHANNEL_ID);\n\n      TAB_ID =\n        localState?.[0] ??\n        now(true).toString(36) +\n          Math.trunc(1296 * Math.random())\n            .toString(36)\n            .padStart(2, \"0\");\n\n      tabVariables = new Map(\n        concat2(\n          filter2(tabVariables, ([, variable]) => variable?.scope === \"view\"),\n          map2(localState?.[1], (variable) => [\n            variableKeyToString(variable),\n            variable,\n          ])\n        )\n      );\n    } else {\n      sessionStorage.setItem(\n        CLIENT_STATE_CHANNEL_ID,\n        httpEncrypt([\n          TAB_ID,\n          map2(tabVariables, ([, variable]) =>\n            variable && variable.scope !== \"view\" ? variable : skip2\n          ),\n        ])\n      );\n    }\n  }, true);\n\n  post = (message: StateMessage, target?: string) => {\n    if (!httpEncrypt) return;\n    localStorage.setItem(\n      CLIENT_STATE_CHANNEL_ID,\n      httpEncrypt([TAB_ID, message, target])\n    );\n    localStorage.removeItem(CLIENT_STATE_CHANNEL_ID);\n  };\n\n  listen(window, \"storage\", (ev) => {\n    if (ev.key === CLIENT_STATE_CHANNEL_ID) {\n      const message = httpDecrypt?.(ev.newValue) as [\n        sender: string,\n        message: StateMessage,\n        target?: string\n      ];\n      if (!message || (message[2] && message[2] !== TAB_ID)) return;\n      const [sender, { type, payload }] = message;\n\n      if (type === \"query\") {\n        !initTimeout.active &&\n          post(\n            {\n              type: \"set\",\n              payload: [map2(state.knownTabs), map2(state.variables)],\n            },\n            sender\n          );\n      } else if (type === \"set\" && initTimeout.active) {\n        state.knownTabs = new Map(payload[0]);\n        state.variables = new Map(payload[1]);\n        tabVariables = new Map(payload[1]);\n        initTimeout.trigger();\n      } else if (type === \"patch\") {\n        // Collect now before updating the state, but dispatch after the state has changed.\n        const changedEventData = getVariableChanges(\n          map2(payload, ([key, value]) => [stringToVariableKey(key), value])\n        );\n\n        assign2(state.variables, payload);\n        assign2(tabVariables, payload);\n\n        dispatchVariablesChanged(\n          map2(changedEventData, ([, current, previous, key]) => [\n            key,\n            current,\n            previous,\n          ]),\n          tabVariables,\n          false\n        );\n      } else if (type === \"tab\") {\n        set2(state.knownTabs, sender, payload);\n        payload && dispatchState(\"tab\", payload, false);\n      }\n    }\n  });\n\n  // Add a short delay to allow other tabs to share their information (if any).\n  const initTimeout = clock(() => dispatchState(\"ready\", state, true), -25);\n\n  const heartbeat = clock({\n    callback: () => {\n      const timeout = now() - HEARTBEAT_FREQUENCY * 2;\n      forEach2(\n        state.knownTabs,\n        // Remove tabs that no longer responds (presumably closed but may also have been frozen).\n        ([tabId, tabState]) =>\n          tabState[0] < timeout && set2(state.knownTabs, tabId, undefined)\n      );\n      tabState.heartbeat = now();\n      post({ type: \"tab\", payload: tabState });\n    },\n    frequency: HEARTBEAT_FREQUENCY,\n    paused: true,\n  });\n\n  const toggleTab = (loading: boolean) => {\n    post({ type: \"tab\", payload: loading ? tabState : undefined });\n    if (loading) {\n      initTimeout.restart();\n      post({ type: \"query\" });\n    } else {\n      initTimeout.toggle(false);\n    }\n    heartbeat.toggle(loading);\n  };\n\n  addPageLoadedListener((loaded) => toggleTab(loaded), true);\n}, true);\nexport { addStateListener };\n","import {\n  PrettifyIntersection,\n  createEvent,\n  delay,\n  forEachAsync,\n  isFunction,\n  stop,\n  throwError,\n  undefined,\n} from \"@tailjs/util\";\nimport {\n  REQUEST_LOCK_KEY,\n  USE_ENCRYPTION,\n  httpDecrypt,\n  httpEncrypt,\n  sharedLock,\n} from \".\";\n\nexport type RequestOptions<Beacon extends boolean = false> =\n  PrettifyIntersection<\n    {\n      encrypt?: boolean;\n    } & (Beacon extends true ? { beacon: true } : { beacon?: false })\n  >;\n\nconst [addRequestHandler, dispatchRequest] =\n  createEvent<\n    [url: string, data: any, retry: number, update: (data: any) => void]\n  >();\nconst [addResponseHandler, dispatchResponse] = createEvent<[response: any]>();\nexport { addRequestHandler, addResponseHandler };\n\nconst requestLock = sharedLock(REQUEST_LOCK_KEY);\n\n/**\n * If a function, this is run before a request is made (including retries). It is run within the lock, and allows the requested data to be modified.\n * If it returns false, the request is aborted and if it returns `undefined` or `true` the existing data is used.\n */\ntype RequestData<T> =\n  | T\n  | ((data: T | undefined, retry: number) => T | boolean | undefined);\n\nexport const request: {\n  <Data = any, Response = any>(\n    url: string,\n    data: RequestData<Data>,\n    options?: RequestOptions<false>\n  ): Promise<Response>;\n  <Data = any>(\n    url: string,\n    data: RequestData<Data>,\n    options: RequestOptions<true>\n  ): void;\n} = async (\n  url: string,\n  data: any,\n  { beacon = false, encrypt = true }: RequestOptions<boolean> = {}\n) => {\n  encrypt = encrypt && USE_ENCRYPTION;\n  let cancel = false;\n  let currentData: any;\n  let serialized: any;\n\n  const prepareRequestData = (retry: number) => {\n    const prepareResult = isFunction(data) ? data?.(currentData, retry) : data;\n    if (prepareResult === false) {\n      return false;\n    }\n\n    prepareResult != null &&\n      prepareResult !== true &&\n      (currentData = prepareResult);\n\n    dispatchRequest(\n      url,\n      currentData,\n      retry,\n      (newData) => (\n        (cancel = currentData === undefined), (currentData = newData)\n      )\n    );\n\n    return cancel\n      ? false\n      : (serialized = encrypt\n          ? httpEncrypt(currentData, true)\n          : JSON.stringify(currentData));\n  };\n\n  if (beacon) {\n    if (!prepareRequestData(0)) return;\n    !navigator.sendBeacon(\n      url,\n      new Blob(currentData != null ? [serialized] : [], {\n        // This content type avoids the overhead of the \"preflight\" request that is otherwise made by browsers in cross-domain scenarios.\n        // (application/x-www-form-urlencoded could also work).\n        type: \"text/plain; charset=iso-8859-1\",\n      })\n    ) && throwError(\"Beacon send failed.\");\n  } else {\n    let retries = 1;\n    return await requestLock(() =>\n      forEachAsync(1, async (retry) => {\n        if (!prepareRequestData(retry)) return stop();\n\n        const response = await fetch(url, {\n          method: currentData != null ? \"POST\" : \"GET\",\n          cache: \"no-cache\",\n          credentials: \"include\",\n          mode: \"cors\",\n          headers: {\n            \"Content-Type\": \"text/plain; charset=iso-8859-1\",\n          },\n          body: serialized,\n        });\n\n        if (response.status >= 400) {\n          return retry === retries - 1\n            ? stop(throwError(`Invalid response: ${await response.text()}`))\n            : (console.warn(\n                `Request to ${url} failed on attempt ${retry + 1}/${3}.`\n              ),\n              await delay((1 + retry) * 200));\n        }\n\n        const body = encrypt\n          ? new Uint8Array(await response.arrayBuffer())\n          : await response.text();\n\n        const parsed = body?.length\n          ? (encrypt ? httpDecrypt : JSON.parse)?.(body as any)\n          : undefined;\n\n        if (parsed != null) {\n          dispatchResponse(parsed);\n        }\n        return stop(parsed);\n      })\n    );\n  }\n};\n","import {\n  delay,\n  now,\n  promise,\n  race,\n  throwError,\n  tryCatchAsync,\n} from \"@tailjs/util\";\nimport {\n  TAB_ID,\n  httpDecode,\n  httpDecrypt,\n  httpEncode,\n  httpEncrypt,\n  listen,\n} from \".\";\n\n/**\n *  A lock that is shared between all tabs.\n * It would seem tempting to use the browser's native LockManager, yet that disables bf_cache, so we don't.\n */\nexport const sharedLock = (\n  lockId: string,\n  { timeout = 1000, encrypt = true, retries: defaultRetries = 10 } = {}\n): (<R, TO extends number | undefined = undefined>(\n  action: () => PromiseLike<R>,\n  timeout?: TO,\n  retries?: number\n) => Promise<TO extends number ? undefined | R : R>) => {\n  type LockState = [owner: string, expires: number];\n  const get = () =>\n    (encrypt ? httpDecrypt<LockState> : httpDecode<LockState>)(\n      localStorage.getItem(lockId)\n    );\n\n  let intervalId: any = 0;\n  const renew = () =>\n    localStorage.setItem(\n      lockId,\n      (encrypt ? httpEncrypt : httpEncode)([TAB_ID, now() + timeout])\n    );\n\n  return (async (\n    action: any,\n    localTimeout?: number,\n    retries = localTimeout != null ? 1 : defaultRetries\n  ) => {\n    while (retries--) {\n      let current = get();\n      if (!current || current[1] < now()) {\n        renew();\n        if (get()?.[0] === TAB_ID) {\n          // Keep lock alive while the action executes.\n          timeout > 0 && (intervalId = setInterval(() => renew(), timeout / 2));\n          return await tryCatchAsync(action, true, () => {\n            clearInterval(intervalId);\n            localStorage.removeItem(lockId);\n          });\n        }\n      }\n      let waitHandle = promise();\n      const [unbind] = listen(window, \"storage\", (ev) => {\n        if (ev.key === lockId && !ev.newValue) {\n          waitHandle.resolve();\n        }\n      });\n      await race(delay(localTimeout ?? timeout), waitHandle);\n      unbind();\n    }\n    localTimeout == null && throwError(lockId + \" could not be acquired.\");\n  }) as any;\n};\n","import {\n  extractKey,\n  isSuccessResult,\n  isVariableResult,\n  PostRequest,\n  PostResponse,\n  toVariableResultPromise,\n  VariableGetRequest,\n  VariableGetter,\n  VariableKey,\n  VariableOperationParameter,\n  VariableOperationResult,\n  VariableResultStatus,\n  VariableSetter,\n  VariableValueSetter,\n  WithCallbacks,\n} from \"@tailjs/types\";\nimport {\n  clock,\n  concat2,\n  forEach2,\n  get2,\n  isString,\n  map2,\n  now,\n  Nullish,\n  pick2,\n  push2,\n  remove,\n  required,\n  skip2,\n  some2,\n} from \"@tailjs/util\";\nimport {\n  addPageLoadedListener,\n  addResponseHandler,\n  addVariablesChangedListener,\n  logError,\n  request,\n  StateVariable,\n  StateVariableEntry,\n  TrackerContext,\n  tryGetVariable,\n  updateVariableState,\n  VARIABLE_CACHE_DURATION,\n  VARIABLE_POLL_FREQUENCY,\n} from \".\";\nimport {\n  ClientVariableGetResult,\n  ClientVariableGetter,\n  ClientVariableGetterCallback,\n  ClientVariableKey,\n  ClientVariableSetResult,\n  ClientVariableSetter,\n  isLocalScopeKey,\n  maskEntityId,\n  ReservedTrackerVariables,\n  stringToVariableKey,\n  variableKeyToString,\n} from \"..\";\n\nconst KEY_PROPS: (keyof VariableKey)[] = [\"scope\", \"key\", \"entityId\", \"source\"];\nconst GETTER_REQUEST_PROPS: (keyof ClientVariableGetter)[] = [\n  ...KEY_PROPS,\n  \"purpose\",\n  \"ifModifiedSince\",\n  \"ifNoneMatch\",\n  \"passive\",\n];\nconst SETTER_REQUEST_PROPS: (keyof VariableValueSetter)[] = [\n  ...KEY_PROPS,\n  \"value\",\n  \"force\",\n  \"ttl\",\n  \"version\",\n];\n\nexport interface TrackerVariableStorage {\n  get<\n    Getters extends VariableOperationParameter<\n      \"get\",\n      ClientVariableGetter & { key: Keys; scope: Scopes }\n    >,\n    Keys extends string,\n    Scopes extends string\n  >(\n    getters: WithCallbacks<\"get\", Getters, ReservedTrackerVariables>\n  ): VariableOperationResult<\n    \"get\",\n    Getters,\n    ClientVariableKey,\n    ReservedTrackerVariables\n  >;\n\n  set<\n    Setters extends VariableOperationParameter<\n      \"set\",\n      ClientVariableSetter & { key: Keys; scope: Scopes }\n    >,\n    Keys extends string,\n    Scopes extends string\n  >(\n    setters: WithCallbacks<\"set\", Setters, ReservedTrackerVariables>\n  ): VariableOperationResult<\n    \"set\",\n    Setters,\n    ClientVariableKey,\n    ReservedTrackerVariables\n  >;\n}\nconst callbackSourceSymbol = Symbol();\ntype RegisteredCallback = ClientVariableGetterCallback & {\n  [callbackSourceSymbol]: ClientVariableGetter;\n};\nconst activeCallbacks = new Map<string, Set<RegisteredCallback>>();\n\nexport const createVariableStorage = (\n  endpoint: string,\n  context?: TrackerContext\n): TrackerVariableStorage => {\n  const pollVariables = clock(async () => {\n    const getters: ClientVariableGetter[] = map2(\n      activeCallbacks,\n      ([key, callbacks]) =>\n        // Only request the variable if one or more callbacks originally requested the variable to be refreshed.\n        some2(callbacks, (callback) => callback[callbackSourceSymbol]?.refresh)\n          ? ({\n              ...stringToVariableKey(key),\n              refresh: true,\n            } satisfies ClientVariableGetter)\n          : skip2\n    );\n\n    getters.length && (await vars.get(getters));\n  }, VARIABLE_POLL_FREQUENCY);\n\n  const registerCallback = (\n    mappedKey: string,\n    callback: RegisteredCallback | undefined\n  ) =>\n    callback &&\n    !!get2(activeCallbacks, mappedKey, () => new Set()).add(callback);\n\n  const invokeCallbacks = (result: ClientVariableGetResult) => {\n    if (!result) return;\n\n    const key = variableKeyToString(result);\n    const callbacks = remove(activeCallbacks, key);\n    if (!callbacks?.size) return;\n\n    forEach2(\n      callbacks,\n      (callback) => callback(result) === true && registerCallback(key, callback)\n    );\n  };\n\n  addPageLoadedListener(\n    (loaded, stateDuration) =>\n      pollVariables.toggle(\n        loaded,\n        loaded && stateDuration >= VARIABLE_POLL_FREQUENCY\n      ),\n    true\n  );\n\n  addVariablesChangedListener((changes) =>\n    forEach2(changes, ([key, current]) => {\n      if (current?.passive) {\n        delete current.passive;\n        return;\n      }\n      invokeCallbacks(\n        current\n          ? { status: VariableResultStatus.Success, ...current }\n          : { status: VariableResultStatus.NotFound, ...key }\n      );\n    })\n  );\n\n  const vars: TrackerVariableStorage = {\n    get: ((getters: ClientVariableGetter[]) =>\n      toVariableResultPromise(\n        \"get\",\n        getters,\n        async (getters: ClientVariableGetter[]) => {\n          let key: string | Nullish;\n          if (!getters[0] || isString(getters[0])) {\n            key = getters[0];\n            getters = getters.slice(1) as any;\n          }\n          context?.validateKey(key);\n\n          const results = new Map<\n            ClientVariableGetter,\n            ClientVariableGetResult\n          >();\n\n          const newLocal: StateVariableEntry[] = [];\n\n          const requestGetters: [\n            request: VariableGetRequest,\n            source: ClientVariableGetter\n          ][] = map2(getters, (getter) => {\n            const key = variableKeyToString(getter);\n            const current = tryGetVariable(key);\n            const purpose = getter.purpose;\n            if (purpose && current?.schema?.usage.purposes[purpose] !== true) {\n              results.set(getter, {\n                ...getter,\n                status: VariableResultStatus.Forbidden,\n                error: `No consent for '${purpose}'.`,\n              });\n            } else if (!getter.refresh && current) {\n              results.set(getter, {\n                status: VariableResultStatus.Success,\n                ...current,\n              });\n            } else if (isLocalScopeKey(getter)) {\n              const value = getter.init?.();\n\n              if (value) {\n                const local: StateVariable = {\n                  ...extractKey(getter),\n                  version: \"1\",\n                  created: timestamp,\n                  modified: timestamp,\n                  value: value,\n                  cache: [timestamp, getter.ttl ?? current?.ttl],\n                };\n\n                push2(newLocal, [extractKey(local), local]);\n                results.set(getter, {\n                  status: VariableResultStatus.Success,\n                  ...local,\n                });\n              } else {\n                results.set(getter, {\n                  status: VariableResultStatus.NotFound,\n                  ...extractKey(getter),\n                });\n              }\n            } else {\n              return [\n                pick2(getter, GETTER_REQUEST_PROPS) as VariableGetRequest,\n                getter,\n              ];\n            }\n            return skip2;\n          });\n\n          const timestamp = now();\n          const response =\n            (requestGetters.length &&\n              (\n                await request<PostRequest, PostResponse>(endpoint, {\n                  variables: {\n                    get: map2(requestGetters, ([getter]) => getter),\n                  },\n                  deviceSessionId: context?.deviceSessionId,\n                })\n              )?.variables?.get) ||\n            [];\n\n          const initSetters: [\n            source: ClientVariableGetter,\n            setter: ClientVariableSetter\n          ][] = [];\n          forEach2(response, (result, i) => {\n            if (result?.status === VariableResultStatus.NotFound) {\n              const getter = requestGetters[i][1];\n              const initValue = getter.init?.();\n              if (initValue != null) {\n                initSetters.push([\n                  getter,\n                  { ...extractKey(getter), value: initValue },\n                ]);\n              }\n            } else {\n              results.set(requestGetters[i][1], maskEntityId(result!));\n            }\n          });\n\n          if (initSetters.length) {\n            forEach2(\n              await vars.set(map2(initSetters, ([, setter]) => setter)).all(),\n              (result, i) => {\n                return results.set(\n                  initSetters[i][0],\n                  maskEntityId(\n                    result.status === VariableResultStatus.Conflict\n                      ? {\n                          ...result,\n                          status: VariableResultStatus.Success,\n                        }\n                      : result.status === VariableResultStatus.Success &&\n                        result.value == null\n                      ? { ...result, status: VariableResultStatus.NotFound }\n                      : result\n                  )\n                );\n              }\n            );\n          }\n\n          if (newLocal.length) {\n            // Update state first before invoking getter callbacks,\n            // since polling callbacks only get success or not found results.\n            //\n            // The actual result must be used for the callback first time it is called.\n            updateVariableState(newLocal);\n          }\n\n          return results;\n        },\n        {\n          poll: (source: VariableGetter, callback) => {\n            callback[callbackSourceSymbol] = source;\n            return registerCallback(\n              variableKeyToString(source as any),\n              callback as any\n            );\n          },\n          logCallbackError: (message, operation, error) =>\n            logError(\"Variables.get\", message, { operation, error }),\n        }\n      )) as any,\n\n    set: ((setters: ClientVariableSetter[]) =>\n      toVariableResultPromise(\n        \"set\",\n        setters,\n        async (setters: ClientVariableSetter[]) => {\n          let key: string | Nullish;\n          if (!setters[0] || isString(setters[0])) {\n            key = setters[0];\n            setters = setters.slice(1) as any;\n          }\n          context?.validateKey(key);\n\n          const localResults: StateVariableEntry[] = [];\n          const results = new Map<\n            ClientVariableSetter,\n            ClientVariableSetResult\n          >();\n\n          const timestamp = now();\n\n          let pendingPatches: ClientVariableSetter[] = [];\n\n          // Only request non-null setters, and use the most recent version we have already read, if any.\n          const requestVariables = map2(setters, (setter) => {\n            const key = variableKeyToString(setter);\n            const current = tryGetVariable(key);\n\n            if (isLocalScopeKey(setter)) {\n              const value = setter.patch\n                ? setter.patch(current?.value)\n                : setter.value;\n\n              let local: StateVariable | undefined =\n                value == null\n                  ? undefined\n                  : {\n                      ...extractKey(setter),\n                      created: current?.created ?? timestamp,\n                      modified: timestamp,\n                      version: current?.version\n                        ? \"\" + (parseInt(current.version) + 1)\n                        : \"1\",\n                      scope: setter.scope,\n                      key: setter.key,\n                      value,\n                      cache: [timestamp, setter.ttl],\n                    };\n\n              if (local) {\n                local.cache = [\n                  timestamp,\n                  setter.ttl ?? VARIABLE_CACHE_DURATION,\n                ];\n              }\n\n              results.set(\n                setter,\n                !local\n                  ? {\n                      status: VariableResultStatus.Success,\n                      ...extractKey(setter),\n                    }\n                  : {\n                      status: current\n                        ? VariableResultStatus.Success\n                        : VariableResultStatus.Created,\n                      ...local,\n                    }\n              );\n\n              push2(localResults, [extractKey(setter), local]);\n\n              return skip2;\n            }\n\n            if (setter.patch) {\n              pendingPatches.push(setter);\n              return skip2;\n            }\n\n            if (setter?.version === undefined) {\n              setter.version = current?.version;\n            }\n\n            return [pick2(setter, SETTER_REQUEST_PROPS as any), setter];\n          });\n\n          let attempts = 0;\n          while (!attempts++ || pendingPatches.length) {\n            const current = await vars\n              .get(map2(pendingPatches, (patch) => extractKey(patch)))\n              .all();\n            forEach2(current, (result, i) => {\n              const setter = pendingPatches[i];\n\n              if (isSuccessResult(result, false)) {\n                push2(requestVariables, [\n                  {\n                    ...setter,\n                    patch: undefined,\n                    value: pendingPatches[i].patch!(result?.value),\n                    version: result.version,\n                  },\n                  setter,\n                ]);\n              } else {\n                results.set(setter, result);\n              }\n            });\n            pendingPatches = [];\n\n            const response = !requestVariables.length\n              ? []\n              : required(\n                  (\n                    await request<PostRequest, PostResponse>(endpoint, {\n                      variables: {\n                        set: map2(requestVariables, ([setter]) => setter),\n                      },\n                      deviceSessionId: context?.deviceSessionId,\n                    })\n                  ).variables?.set,\n                  \"No result.\"\n                );\n\n            forEach2(response, (result, index) => {\n              const [, setter] = requestVariables[index];\n              if (\n                attempts <= 3 &&\n                setter.patch &&\n                (result?.status === VariableResultStatus.Conflict ||\n                  result?.status === VariableResultStatus.NotFound)\n              ) {\n                push2(pendingPatches, setter);\n                return;\n              }\n              results.set(setter, maskEntityId(result!));\n            });\n          }\n\n          if (localResults.length) {\n            updateVariableState(localResults);\n          }\n\n          return results;\n        },\n        {\n          logCallbackError: (message, operation, error) =>\n            logError(\"Variables.set\", message, { operation, error }),\n        }\n      )) as any,\n  };\n\n  addResponseHandler(({ variables }: PostResponse) => {\n    if (!variables) return;\n\n    const changed = concat2(\n      map2(variables.get, (result) =>\n        isVariableResult(result) ? result : skip2\n      ),\n      map2(variables.set, (result) =>\n        isSuccessResult(result) ? result : skip2\n      )\n    );\n\n    changed?.length &&\n      updateVariableState(\n        map2(\n          changed,\n          (result) =>\n            [\n              extractKey(result),\n              isSuccessResult(result) ? result : undefined,\n            ] as any\n        )\n      );\n  });\n\n  return vars as any;\n};\n","import {\n  ConfiguredComponent,\n  ImpressionEvent,\n  ImpressionRegionStats,\n  ImpressionTextStats,\n} from \"@tailjs/types\";\nimport {\n  F,\n  Intervals,\n  NoOpFunction,\n  Nullish,\n  T,\n  TextStats,\n  Timer,\n  assign,\n  clock,\n  count,\n  createIntervals,\n  createTimer,\n  filter2,\n  forEach2,\n  getTextStats,\n  map2,\n  restrict,\n  skip2,\n} from \"@tailjs/util\";\nimport {\n  document,\n  getActiveTime,\n  getScreenPos,\n  getViewport,\n  trackerConfig,\n  trackerFlag,\n} from \".\";\nimport {\n  BoundaryData,\n  Tracker,\n  createViewDurationTimer,\n  getComponentContext,\n  getViewTimeOffset,\n} from \"..\";\n\nconst intersectionHandler = Symbol();\n\nconst INTERSECTION_POLL_INTERVAL = 250;\n\ntype ImpressionThreshold = [ownRatio: number, viewportRatio: number];\n\n/** The amount of the component that must be visible for the impression to count. */\nconst IMPRESSION_START = [0.75, 0.33];\n\n/** The impression stops when only this amount of the component is visible. */\nconst IMPRESSION_STOP = [0.25, 0.33];\n\n/** The percentage of the total number of characters contained in the top region. */\nconst TEXT_REGION_TOP = 0.25;\n\n/* The percentage of the total number of characters before the bottom region. */\nconst TEXT_REGION_BOTTOM = 0.75;\n\nexport const createImpressionObserver = (tracker: Tracker) => {\n  const observer = new IntersectionObserver(\n    (els) => forEach2(els, (args) => args.target[intersectionHandler]?.(args))\n    // Low thresholds used to be able to handle components larger than view ports.\n  );\n\n  const currentIntersections = new Set<() => void>();\n\n  const monitor = clock({\n    callback: () => forEach2(currentIntersections, (handler) => handler()),\n    frequency: INTERSECTION_POLL_INTERVAL,\n    raf: true,\n  });\n\n  const constrain = (point: number, max: number, min = 0) =>\n    point < min ? min : point > max ? max : point;\n\n  const probeRange = document.createRange();\n\n  return (el: Element, boundaryData: BoundaryData<true> | undefined) => {\n    if (!boundaryData) return;\n\n    let components: ConfiguredComponent[] | Nullish;\n    if (\n      (components = filter2(\n        boundaryData?.component,\n        (cmp) =>\n          // Impression settings from the DOM/CSS are ignored for secondary and inferred components (performance thing)\n          cmp!.track?.impressions ||\n          (cmp.track?.secondary ?? cmp.inferred) !== T\n      ))\n    ) {\n      if (!count(components)) return;\n\n      let active = F;\n      let pendingActive = F;\n      let impressions = 0;\n      let visiblePercentage = 0;\n      let regions:\n        | [\n            data: ImpressionRegionStats,\n            timer: Timer,\n            pending: boolean,\n            active: boolean,\n            top: number,\n            bottom: number,\n            readTime: number,\n            intervals: Intervals\n          ][]\n        | undefined;\n\n      const updateRegion = (\n        index: number,\n        top: number,\n        bottom: number,\n        readTime: number\n      ) => {\n        const region = ((regions ??= [])[index] ??= [\n          { duration: 0, impressions: 0 },\n          createTimer(false, getActiveTime),\n          false,\n          false,\n          0,\n          0,\n          0,\n          createIntervals(),\n        ]);\n        region[4] = top;\n        region[5] = bottom;\n        region[6] = readTime;\n      };\n\n      const visible = [createIntervals(), createIntervals()];\n\n      const viewDuration = createViewDurationTimer(false);\n      const activeTime = createTimer(false, getActiveTime);\n\n      let impressionEvents: ImpressionEvent[] | undefined;\n      let unbindPassiveEventSources: NoOpFunction[] | undefined;\n      // let overlays = map(2, (i) => {\n      //   const overlay = document.createElement(\"div\");\n      //   overlay.style.cssText = `position:absolute;${i ? \"bottom\" : \"top\"}:0;${\n      //     i ? \"right\" : \"left\"\n      //   }:0;background-color:blue`;\n      //   el.appendChild(overlay);\n      //   return overlay;\n      // });\n\n      // (el as any).style.border = \"1px solid blue\";\n      // (el as any).style.position = \"relative\";\n\n      let prevHeight = -1;\n      let boundaries: TextStats[\"boundaries\"] | undefined;\n      let stats: ImpressionTextStats | undefined;\n\n      const poll = () => {\n        const rect = el.getBoundingClientRect();\n        const viewWidth = window.innerWidth;\n        const viewHeight = window.innerHeight;\n\n        const intersection = [\n          constrain(rect.top, viewHeight),\n          constrain(rect.right, viewWidth),\n          constrain(rect.bottom, viewHeight),\n          constrain(rect.left, viewWidth),\n        ];\n\n        const intersectionHeight = intersection[2] - intersection[0];\n        const intersectionWidth = intersection[1] - intersection[3];\n\n        const verticalIntersection = intersectionHeight / rect.height || 0;\n        const horizontalIntersection = intersectionWidth / rect.width || 0;\n\n        /**\n         * The threshold for when an impression becomes active/inactive.\n         * They depend on whether the impression is currently active.\n         */\n        const thresholds = active ? IMPRESSION_STOP : IMPRESSION_START;\n\n        /**\n         * The smallest of the horizontal and vertical intersection percentage. If this is smaller than the threshold,\n         * the component is intuitively not visible (or \"impressed\", lol).\n         */\n        const qualified =\n          (intersectionHeight > thresholds[0] * viewHeight ||\n            verticalIntersection > thresholds[0]) &&\n          (intersectionWidth > thresholds[0] * viewWidth ||\n            horizontalIntersection > thresholds[0]);\n\n        if (pendingActive !== qualified) {\n          activeTime((pendingActive = qualified), true);\n        }\n        if (\n          active !==\n          (active =\n            pendingActive &&\n            activeTime() >=\n              trackerConfig.impressionThreshold - INTERSECTION_POLL_INTERVAL)\n        ) {\n          ++impressions;\n          viewDuration(active);\n          if (!impressionEvents) {\n            impressionEvents = map2(\n              components!,\n              (cmp) =>\n                ((cmp!.track?.impressions ||\n                  trackerFlag(\n                    el,\n                    \"impressions\",\n                    T,\n                    (data) => data.track?.impressions\n                  )) &&\n                  restrict<ImpressionEvent>({\n                    type: \"impression\",\n                    pos: getScreenPos(el),\n                    viewport: getViewport(),\n                    timeOffset: getViewTimeOffset(),\n                    impressions,\n                    ...getComponentContext(el, T),\n                  })) ||\n                skip2\n            );\n            tracker(impressionEvents);\n          }\n\n          if (impressionEvents?.length) {\n            const duration = viewDuration();\n            unbindPassiveEventSources = map2(impressionEvents, (event) =>\n              tracker.events.registerEventPatchSource(event, () => ({\n                relatedEventId: event.clientId!,\n                duration,\n                impressions: impressions,\n                regions: regions && {\n                  top: regions[0][0],\n                  middle: regions[1][0],\n                  bottom: regions[2][0],\n                },\n                seen: visiblePercentage,\n                text: stats,\n                read:\n                  duration.activeTime &&\n                  stats &&\n                  constrain(\n                    duration.activeTime / stats.readTime,\n                    visiblePercentage\n                  ),\n              }))\n            );\n          }\n        }\n\n        if (rect.height !== prevHeight) {\n          prevHeight = rect.height;\n          const text = (el as HTMLElement).textContent;\n          ({ boundaries, ...stats } = getTextStats(\n            text ?? \"\",\n            [0, 0.25, 0.75, 1]\n          ));\n\n          if (regions || rect.height >= 1.25 * viewHeight) {\n            const nodes = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);\n            let node: Node | null;\n            let length = 0;\n\n            let boundaryIndex = 0;\n            regions ??= [];\n            while (\n              boundaryIndex < boundaries.length &&\n              (node = nodes.nextNode())\n            ) {\n              let nodeLength = node.textContent?.length ?? 0;\n              length += nodeLength;\n              while (length >= boundaries[boundaryIndex]?.offset) {\n                // While loop because two boundaries may have the same offset.\n                probeRange[boundaryIndex % 2 ? \"setEnd\" : \"setStart\"](\n                  node,\n                  boundaries[boundaryIndex].offset - length + nodeLength\n                );\n\n                if (boundaryIndex++ % 2) {\n                  const { top, bottom } = probeRange.getBoundingClientRect();\n                  const offset = rect.top;\n\n                  if (boundaryIndex < 3) {\n                    updateRegion(\n                      0,\n                      top - offset,\n                      bottom - offset,\n                      boundaries[1].readTime\n                    );\n                  } else {\n                    updateRegion(\n                      1,\n                      regions[0][4],\n                      top - offset,\n                      boundaries[2].readTime\n                    );\n                    updateRegion(\n                      2,\n                      top - offset,\n                      bottom - offset,\n                      boundaries[3].readTime\n                    );\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        let horizontalOffset = rect.left < 0 ? -rect.left : 0;\n        let verticalOffset = rect.top < 0 ? -rect.top : 0;\n        const area = rect.width * rect.height;\n\n        if (active) {\n          visiblePercentage =\n            (visible[0].push(\n              verticalOffset,\n              verticalOffset + intersectionHeight\n            ) *\n              visible[1].push(\n                horizontalOffset,\n                horizontalOffset + intersectionWidth\n              )) /\n            area;\n        }\n\n        if (regions) {\n          forEach2(regions, (region) => {\n            const intersectionTop = constrain(\n              rect.top < 0 ? -rect.top : 0,\n              region[5],\n              region[4]\n            );\n            const intersectionBottom = constrain(\n              rect.bottom > viewHeight ? viewHeight : rect.bottom,\n              region[5],\n              region[4]\n            );\n\n            // Zero height, nothing to do.\n            let qualified = active && intersectionBottom - intersectionTop > 0;\n\n            const data = region[0];\n            data.duration = region[1](qualified);\n\n            if (qualified) {\n              region[3] !== (region[3] = qualified) && ++region[0].impressions!;\n\n              data.seen =\n                region[7].push(intersectionTop, intersectionBottom) /\n                (region[5] - region[4]);\n              data.read = constrain(data.duration / region[6], data.seen);\n            }\n          });\n        }\n      };\n\n      el[intersectionHandler] = ({\n        isIntersecting,\n      }: IntersectionObserverEntry) => {\n        assign(currentIntersections, poll, isIntersecting);\n        !isIntersecting &&\n          (forEach2(unbindPassiveEventSources, (unbind) => unbind()), poll());\n      };\n      observer.observe(el);\n    }\n  };\n};\n","import { __DEBUG__ } from \"@constants\";\r\nimport { formatDataUsage, formatVariableKey } from \"@tailjs/types\";\r\nimport { ansi, concat, count, F, map2, skip2, sort2, T } from \"@tailjs/util\";\r\nimport { addVariablesChangedListener, childGroups, debug } from \".\";\r\nimport { ClientVariable, isLocalScopeKey } from \"../interfaces\";\r\n\r\nconst formatVariables = (variables: ClientVariable[]) => {\r\n  return map2(\r\n    sort2(variables, [\r\n      (variable) => variable.scope,\r\n      (variable) => variable.key,\r\n    ]),\r\n    (variable) =>\r\n      variable\r\n        ? [\r\n            variable,\r\n            `${formatVariableKey(variable)}, ${\r\n              isLocalScopeKey(variable)\r\n                ? \"client-side memory only\"\r\n                : formatDataUsage(variable.schema?.usage)\r\n            })`,\r\n            F,\r\n          ]\r\n        : skip2\r\n  );\r\n};\r\n\r\nexport const addDebugListeners = __DEBUG__\r\n  ? () => {\r\n      addVariablesChangedListener((changes, all, local) => {\r\n        const variables = concat(\r\n          formatVariables(\r\n            map2(changes, ([, current]) => (current ? current : skip2))\r\n          ),\r\n          [\r\n            [\r\n              {\r\n                [childGroups]: formatVariables(\r\n                  map2(all, ([, current]) => (current ? current : skip2))\r\n                ),\r\n              },\r\n              \"All variables\",\r\n              T,\r\n            ],\r\n          ]\r\n        )!;\r\n\r\n        debug(\r\n          { [childGroups]: variables },\r\n          ansi(\r\n            `Variables changed${\r\n              !local ? \" - merging changes from another tab\" : \"\"\r\n            } (${changes.length} changed, ${count(all)} in total).`,\r\n            \"2;3\"\r\n          )\r\n        );\r\n      });\r\n    }\r\n  : () => {};\r\n","import { CLIENT_CALLBACK_CHANNEL_ID } from \"@constants\";\n\nimport {\n  AnchorNavigationEvent,\n  CartUpdatedEvent,\n  ComponentClickEvent,\n  ComponentClickIntentEvent,\n  ComponentElementInfo,\n  NavigationEvent,\n  ScreenPosition,\n  UserInteractionEvent,\n} from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  createTimeout,\n  ellipsis,\n  equalsAny,\n  forEach2,\n  isObject,\n  map2,\n  nil,\n  parseUri,\n  push,\n  remove,\n  restrict,\n  some,\n  stop,\n  update,\n  type Nullish,\n} from \"@tailjs/util\";\nimport {\n  TrackerExtensionFactory,\n  getComponentContext,\n  getViewTimeOffset,\n  onFrame,\n  parseActivationTags,\n  pushNavigationSource,\n  tryGetCartEventData,\n} from \"..\";\nimport {\n  MNT_URL,\n  attr,\n  forAncestorsOrSelf,\n  getBoundaryData,\n  getPos,\n  getRect,\n  getScreenPos,\n  getViewport,\n  isInternalUrl,\n  listen,\n  matchExHash,\n  nextId,\n  normalizedAttribute,\n  tagName,\n  trackerConfig,\n  trackerFlag,\n} from \"../lib\";\n\nconst isLinkElement = (\n  el: Element,\n  href: any = tagName(el) === \"A\" && attr(el, \"href\")\n): el is HTMLAnchorElement =>\n  href && href != \"#\" && !href.startsWith(\"javascript:\");\n\nconst isClickable = (\n  el: Element,\n  t = tagName(el),\n  attr = trackerFlag(el, \"button\")\n): el is HTMLElement =>\n  attr !== F &&\n  (equalsAny(t, \"A\", \"BUTTON\") ||\n    (t === \"INPUT\" &&\n      equalsAny(normalizedAttribute(el, \"type\"), \"button\", \"submit\")) ||\n    attr === T);\n\nconst getElementInfo = (el: Element, includeRect = false) => ({\n  tagName: el.tagName,\n  text: ellipsis(\n    attr(el, \"title\")?.trim() ||\n      attr(el, \"alt\")?.trim() ||\n      (el as HTMLElement).innerText?.trim(),\n    100\n  ),\n  href: (el as any).href?.toString(),\n  rect: includeRect ? getRect(el) : undefined,\n});\nconst getElementLabel = (\n  el: Element | EventTarget | null,\n  container: Element,\n  includeRect = false\n) => {\n  let info: Pick<UserInteractionEvent, \"element\"> | undefined;\n  forAncestorsOrSelf(el ?? container, (el) =>\n    tagName(el) === \"IMG\" || el === container\n      ? ((info = {\n          element: getElementInfo(el, includeRect),\n        }),\n        F)\n      : T\n  );\n  return info;\n};\nexport const userInteraction: TrackerExtensionFactory = {\n  id: \"navigation\",\n\n  setup(tracker) {\n    // The tracked click positions for click events that has already been posted once.\n    const activeEventClicks = new WeakMap<Node, ScreenPosition[]>();\n\n    const stripPositions = <T = any>(el: any, hitTest: boolean): T =>\n      hitTest\n        ? el\n        : (map2(el, ([key]) =>\n            key === \"rect\" ||\n            //key === \"pos\"  Changed so pos is always included.\n            key === \"viewport\"\n              ? remove(el, key)\n              : isObject(el[key]) &&\n                map2(el[key], (item) => stripPositions(item, hitTest))\n          ),\n          el);\n    const trackDocument = (document: Document) => {\n      listen(\n        document,\n        [\"click\", \"contextmenu\", \"auxclick\"],\n        (ev: MouseEvent) => {\n          let trackClicks: boolean | Nullish;\n          let trackRegion: boolean | Nullish;\n          let clickableElement: HTMLElement | undefined;\n          let containerElement: Element | undefined;\n\n          let nav = F;\n\n          let clickables: ComponentElementInfo[] | undefined;\n\n          forAncestorsOrSelf<boolean>(ev.target, (el) => {\n            isClickable(el) && (clickableElement ??= el);\n            nav = nav || tagName(el) === \"NAV\";\n\n            const boundary = getBoundaryData(el);\n            const components = boundary?.component;\n            if (!ev.button && components?.length && !clickables) {\n              forEach2(\n                el.querySelectorAll(\"a,button\"),\n                (clickable) =>\n                  isClickable(clickable) &&\n                  ((clickables ??= []).length > 3\n                    ? stop() // If there are more than three clickables, there is presumably not any missed click intent.\n                    : clickables.push({\n                        ...getElementInfo(clickable, true),\n                        component: forAncestorsOrSelf(\n                          clickable,\n                          (\n                            child,\n                            r,\n                            _,\n                            childComponents = getBoundaryData(child)?.component\n                          ) => childComponents && r(childComponents[0]),\n                          (child) => child === el\n                        ),\n                      }))\n              );\n\n              if (clickables) {\n                containerElement ??= el;\n              }\n            }\n\n            trackClicks ??=\n              trackerFlag(el, \"clicks\", T, (data) => data.track?.clicks) ??\n              (components &&\n                some(components, (cmp) => cmp.track?.clicks !== F));\n            trackRegion ??=\n              trackerFlag(el, \"region\", T, (data) => data.track?.region) ??\n              (components && some(components, (cmp) => cmp.track?.region));\n          });\n\n          if (!(containerElement ??= clickableElement)) {\n            return;\n          }\n          const clickIntent = clickables && !clickableElement && trackClicks;\n\n          const componentContext = getComponentContext(\n            clickableElement ?? containerElement,\n            false,\n            clickIntent\n          );\n          const tags = parseActivationTags(\n            clickableElement ?? containerElement\n          );\n          trackClicks ??= !nav;\n          trackRegion ??= T;\n\n          const sharedEventProperties = {\n            ...(trackRegion\n              ? {\n                  pos: getScreenPos(clickableElement, ev),\n                  viewport: getViewport(),\n                }\n              : nil),\n            ...getElementLabel(ev.target, clickableElement ?? containerElement),\n            ...componentContext,\n            timeOffset: getViewTimeOffset(),\n            ...tags,\n          };\n          if (!clickableElement) {\n            clickIntent &&\n              update(activeEventClicks, containerElement, (current) => {\n                const pos = getPos(containerElement!, ev);\n                if (!current) {\n                  // Reuse the same event and only add the new click coordinates\n                  // if the element is clicked again to reduce data.\n                  const intentEvent = restrict<ComponentClickIntentEvent>({\n                    type: \"component_click_intent\",\n                    ...sharedEventProperties,\n                    clicks: (current = [pos]),\n\n                    clickables,\n                  });\n\n                  tracker.events.registerEventPatchSource(\n                    intentEvent,\n                    () => ({\n                      clicks: activeEventClicks.get(containerElement!),\n                    }),\n                    true,\n                    containerElement\n                  );\n                } else {\n                  push(current, pos);\n                }\n\n                return current;\n              });\n            //  ,              overlay(containerElement, \"Click intent\", true)\n\n            return;\n          }\n\n          if (isLinkElement(clickableElement!)) {\n            const link = clickableElement;\n            const external = link.hostname !== location.hostname;\n\n            const {\n              host,\n              scheme,\n              source: href,\n            } = parseUri(link.href, {\n              delimiters: false,\n              requireAuthority: true,\n            });\n            if (\n              link.host === location.host &&\n              link.pathname === location.pathname &&\n              link.search === location.search\n            ) {\n              if (link.hash === \"#\") {\n                // Don't care about that one.\n                return;\n              }\n              if (link.hash !== location.hash) {\n                if (ev.button === 0)\n                  tracker(\n                    restrict<AnchorNavigationEvent>({\n                      type: \"anchor_navigation\",\n                      anchor: link.hash,\n                      ...sharedEventProperties,\n                    })\n                  );\n              }\n              return;\n            }\n\n            const navigationEvent: NavigationEvent = restrict<NavigationEvent>({\n              clientId: nextId(),\n              type: \"navigation\",\n              href: external ? link.href : href,\n              external,\n              domain: { host, scheme },\n              self: T,\n              anchor: link.hash,\n              ...sharedEventProperties,\n            });\n\n            // There does not seem to be any way to detect when the user clicks\n            // \"Open link in new tab/window\", so we need to do a little extra gymnastics to capture it.\n            if (ev.type === \"contextmenu\") {\n              const originalUrl = link.href;\n              const internalUrl = isInternalUrl(originalUrl);\n              if (internalUrl) {\n                // If the page loads in a new tab, it will pick up this value as the referrer,\n                //   and we will know navigation happened.\n                pushNavigationSource(navigationEvent.clientId, () =>\n                  tracker(navigationEvent)\n                );\n                return;\n              }\n\n              // Detecting external navigation is _much_ harder.\n              // Unfortunately we need to rewrite the URL to redirect via the request handler, and poll for a local storage key.\n              // This is only a problem if the user decides to copy the link from the context menu and share it,\n              // since some may argue the link looks \"obscure\".\n              var requestId = (\"\" + Math.random())\n                .replace(\".\", \"\")\n                .substring(1, 8);\n              if (!internalUrl) {\n                if (!trackerConfig.captureContextMenu) return;\n                link.href =\n                  MNT_URL + \"=\" + requestId + encodeURIComponent(originalUrl);\n\n                // Poll for the storage key where the request handler will write the request ID before it redirects\n                // the user if the link is opened.\n                listen(\n                  window,\n                  \"storage\",\n                  (ev, unbind) =>\n                    ev.key === CLIENT_CALLBACK_CHANNEL_ID &&\n                    (ev.newValue &&\n                      JSON.parse(ev.newValue)?.requestId === requestId &&\n                      tracker(navigationEvent),\n                    unbind())\n                );\n\n                createTimeout;\n                // Switch the link back when the context menu closes.\n                listen(\n                  document,\n                  [\"keydown\", \"keyup\", \"visibilitychange\", \"pointermove\"],\n                  (_, unbind) => {\n                    unbind();\n\n                    link.href = originalUrl;\n                  }\n                );\n              }\n              return;\n            }\n\n            if (ev.button <= 1) {\n              if (\n                ev.button === 1 || //Middle-click: new tab.\n                ev.ctrlKey || // New tab\n                ev.shiftKey || // New window\n                ev.altKey || // Download\n                attr(link, \"target\") !== window.name\n              ) {\n                pushNavigationSource(navigationEvent.clientId);\n                navigationEvent.self = F;\n                // Fire immediately, we are staying on the page.\n                tracker(navigationEvent);\n                return;\n              } else if (!matchExHash(location.href, link.href)) {\n                navigationEvent.exit = navigationEvent.external;\n                // No \"real\" navigation will happen if it is only the hash changing.\n                pushNavigationSource(navigationEvent.clientId);\n              }\n\n              // // If it so happened that navigation happened we will send it on VIEW_END.\n              // pendingNavigationEvent = registerViewEndAction(() =>\n              //   tracker(navigationEvent)\n              // );\n            }\n            return;\n          }\n\n          const cart = tryGetCartEventData(ev.target as Element);\n          (cart || trackClicks) &&\n            tracker(\n              cart\n                ? restrict<CartUpdatedEvent>({\n                    type: \"cart_updated\",\n                    ...sharedEventProperties,\n                    ...cart,\n                  })\n                : restrict<ComponentClickEvent>({\n                    type: \"component_click\",\n                    ...sharedEventProperties,\n                  })\n            );\n          return;\n        }\n      );\n    };\n\n    trackDocument(document);\n    onFrame(\n      (frame) => frame.contentDocument && trackDocument(frame.contentDocument)\n    );\n  },\n};\n","import {\n  type CartAction,\n  type CartEventData,\n  type CartUpdatedEvent,\n  type OrderEvent,\n} from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  equalsAny,\n  isObject,\n  isString,\n  last,\n  nil,\n  type Nullish,\n} from \"@tailjs/util\";\nimport { TrackerExtensionFactory, isCartCommand, isOrderCommand } from \"..\";\nimport { forAncestorsOrSelf, getBoundaryData, trackerProperty } from \"../lib\";\n\nexport const parseCartEventData = (\n  data: boolean | string | CartEventData | Nullish\n): CartEventData | undefined => (\n  data == nil ? undefined : (data === T || data === \"\") && (data = \"add\"),\n  isString(data) && equalsAny(data, \"add\", \"remove\", \"update\", \"clear\")\n    ? { action: data as CartAction }\n    : isObject(data)\n    ? data\n    : undefined\n);\n\nfunction normalizeCartEventData(data: CartEventData | Nullish) {\n  if (!data) return undefined;\n\n  if (data.units != nil && equalsAny(data.action, nil, \"add\", \"remove\")) {\n    if (data.units === 0) return undefined;\n    data.action = data.units > 0 ? \"add\" : \"remove\";\n  }\n  return data;\n}\n\nexport function tryGetCartEventData(sourceElement: Element) {\n  // Find cart. Look for cart attributes and/or data until the first content is met.\n  let contextCart: CartEventData | Nullish;\n  forAncestorsOrSelf(\n    sourceElement,\n    (el, r) =>\n      !!(contextCart ??= parseCartEventData(\n        getBoundaryData(el)?.cart ?? trackerProperty(el, \"cart\")\n      )) &&\n      !contextCart.item &&\n      (contextCart.item = last(getBoundaryData(el)?.content)) &&\n      r(contextCart)\n  );\n\n  return normalizeCartEventData(contextCart);\n}\n\nexport const commerce: TrackerExtensionFactory = {\n  id: \"cart\",\n  setup(tracker) {\n    return {\n      processCommand(command) {\n        if (isCartCommand(command)) {\n          let cart = command.cart;\n          cart === \"clear\"\n            ? tracker({\n                type: \"cart_updated\",\n                action: \"clear\",\n              } as CartUpdatedEvent)\n            : (cart = normalizeCartEventData(cart)!) &&\n              tracker({\n                ...cart,\n                type: \"cart_updated\",\n              } as CartUpdatedEvent);\n\n          return T;\n        }\n        if (isOrderCommand(command)) {\n          tracker({\n            type: \"order\",\n            ...command.order,\n          } as OrderEvent);\n\n          return T;\n        }\n        return F;\n      },\n    };\n  },\n};\n","import { FormEvent, FormField, Timestamp } from \"@tailjs/types\";\nimport {\n  T,\n  ansi,\n  createTimeout,\n  ellipsis,\n  forEach2,\n  get2,\n  nil,\n  now,\n  parseBoolean,\n  replace,\n  some2,\n  tryCatch,\n  type Nullish,\n} from \"@tailjs/util\";\nimport {\n  TrackerExtensionFactory,\n  getComponentContext,\n  getViewTimeOffset,\n  getVisibleDuration,\n  onFrame,\n} from \"..\";\nimport {\n  NodeWithParentElement,\n  addPageLoadedListener,\n  attr,\n  debug,\n  getRect,\n  isVisible,\n  listen,\n  scopeAttribute,\n  trackerFlag,\n  trackerPropertyName,\n  uuidv4,\n} from \"../lib\";\n\ntype FormElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\n\nconst enum FormFillState {\n  None = 0,\n  Submitted = 1,\n  Pending = 2,\n  Submitting = 3,\n}\n\ntype FormState = [\n  event: FormEvent,\n  fields: WeakMap<Element, FormFieldState>,\n  element: HTMLFormElement,\n  fillState: FormFillState,\n  started: Timestamp,\n  nextFillOrder: number\n];\n\nconst currentValue = Symbol();\ntype FormFieldState = FormField & {\n  [currentValue]: string;\n};\n\n/** The time waited after a form submit event to test if it still there, which is assumed to indicate that there are validation errors. */\nconst VALIDATION_ERROR_TIMEOUT = 1750;\n\nexport const forms: TrackerExtensionFactory = {\n  id: \"forms\",\n  setup(tracker) {\n    const formEvents = new Map<HTMLFormElement, FormState>();\n\n    const getFormFieldValue = (element: any, tracked = false): string => {\n      let include =\n        !tracked || scopeAttribute(element, trackerPropertyName(\"form-value\"));\n\n      tracked &&\n        (include = include\n          ? parseBoolean(include)\n          : element.type === \"checkbox\");\n\n      let value = element.selectedOptions\n        ? [...element.selectedOptions].map((option) => option.value).join(\",\")\n        : element.type === \"checkbox\"\n        ? element.checked\n          ? \"true\"\n          : \"false\"\n        : element.value;\n\n      if (tracked && value) {\n        value = ellipsis(value, 200);\n      }\n      return include ? value : undefined;\n    };\n\n    const getFormState = (\n      el: FormElement\n    ): [input: FormElement, state: FormState] | undefined => {\n      const formElement = el.form;\n      if (!formElement) return; // Don't care if we started with an element that didn't map to a field.\n\n      const refName =\n        scopeAttribute(formElement, trackerPropertyName(\"ref\")) || \"track_ref\";\n\n      const parseElements = () => {\n        forEach2(\n          formElement.querySelectorAll(\n            \"INPUT,SELECT,TEXTAREA,BUTTON\"\n          ) as any as Iterable<FormElement>,\n          (el, i) => {\n            if (el.tagName === \"BUTTON\" && el.type !== \"submit\") {\n              return;\n            }\n            if (!el.name || el.type === \"hidden\") {\n              if (\n                el.type === \"hidden\" &&\n                (el.name === refName || trackerFlag(el, \"ref\"))\n              ) {\n                !el.value && (el.value = uuidv4());\n                state[0].ref = el.value;\n              }\n              return;\n            }\n            const name = el.name;\n            const field = (state[0].fields![name] ??= {\n              id: el.id || name,\n              name,\n              label: replace(\n                el.labels?.[0]?.innerText ?? el.name,\n                /^\\s*(.*?)\\s*\\*?\\s*$/g,\n                \"$1\"\n              ),\n              activeTime: 0,\n              totalTime: 0,\n              type: el.type ?? \"unknown\",\n              [currentValue as any]: getFormFieldValue(el),\n              value: getFormFieldValue(el, true),\n            }) as FormFieldState;\n\n            state[0].fields![field.name] = field;\n            state[1].set(el, field);\n          }\n        );\n      };\n\n      let capturedContext: ReturnType<typeof getComponentContext>;\n\n      const isFormVisible = () =>\n        formElement.isConnected && getRect(formElement).width;\n\n      const state = get2(formEvents, formElement, () => {\n        const fieldMap = new Map<Element, FormFieldState>();\n        const ev: FormEvent = {\n          type: \"form\",\n          name:\n            scopeAttribute(formElement, trackerPropertyName(\"form-name\")) ||\n            attr(formElement, \"name\") ||\n            formElement.id ||\n            undefined,\n          activeTime: 0,\n          totalTime: 0,\n          fields: {},\n        };\n\n        tracker.events.post(ev);\n\n        tracker.events.registerEventPatchSource(\n          ev,\n          () => ({ ...ev, timeOffset: getViewTimeOffset() } as any)\n        );\n\n        let state: FormState;\n        const commitEvent = () => {\n          if (state[3] === FormFillState.Submitted) {\n            // The final form event has already been submitted.\n            return;\n          }\n          handleLostFocus(); // focusout or change events may not be called when the user leaves the page while a field has focus.\n\n          // If the form has disappeared it is heuristically assumed it was submitted successfully.\n          if (state[3] >= FormFillState.Pending) {\n            ev.completed =\n              state[3] === FormFillState.Submitting || !isFormVisible();\n          }\n\n          tracker.events.postPatch(ev, {\n            ...capturedContext,\n            completed: ev.completed,\n            totalTime: now(T) - state[4],\n          });\n\n          state[3] = FormFillState.Submitted;\n        };\n\n        const commitTimeout = createTimeout();\n\n        const isReCaptchaActive = () => {\n          let probeDoc: Document | undefined = formElement.ownerDocument;\n          while (probeDoc) {\n            if (\n              some2(\n                probeDoc.querySelectorAll(\"iframe\"),\n                (frame) =>\n                  frame.src.match(\n                    // reCAPTCHA challenge URLs are like `https://www.google.com/recaptcha/(something)/bframe?(something)`\n                    // There may be other iframes with `recaptcha` in the URL, but that is typically the \"badge\" shown in some forms.\n                    /https:\\/\\/www.google.com\\/.*(?<=\\/)recaptcha\\/.*(?<=\\/)bframe/gi\n                  ) && isVisible(frame)\n              )\n            ) {\n              return true;\n            }\n\n            // Walk up the frames. The dialog may have been injected into the main window.\n            probeDoc = tryCatch(\n              () => probeDoc!.defaultView?.frameElement?.ownerDocument,\n              () => undefined\n            );\n          }\n          return false;\n        };\n\n        listen(\n          formElement.ownerDocument.body,\n          \"submit\",\n          (submitEvent) => {\n            capturedContext = getComponentContext(formElement);\n            state[3] = FormFillState.Submitting;\n\n            if (submitEvent.defaultPrevented) {\n              // Might be XHR. If so, the default would have been prevented.\n              // However, we must wait and see if the form disappears, otherwise, it could also be validation errors.\n              const [unbindNavigationListener] = addPageLoadedListener(\n                (loaded) => {\n                  if (loaded) return;\n\n                  // If the browser navigates while waiting, this is also considered a submit.\n                  if (recaptcha) {\n                    debug(\n                      `The browser is navigating to another page after submit leaving a reCAPTCHA challenge. ${ansi(\n                        \"Form not submitted\",\n                        1\n                      )}`\n                    );\n                  } else if (state[3] === FormFillState.Submitting) {\n                    debug(\n                      `The browser is navigating to another page after submit. ${ansi(\n                        \"Form submitted\",\n                        1\n                      )}`\n                    );\n                    commitEvent();\n                  } else {\n                    debug(\n                      `The browser is navigating to another page after submit, but submit was earlier cancelled because of validation errors. ${ansi(\n                        \"Form not submitted.\",\n                        1\n                      )}`\n                    );\n                  }\n                  unbindNavigationListener();\n                }\n              );\n              let recaptcha = false;\n              commitTimeout(() => {\n                if (isReCaptchaActive()) {\n                  state[3] = FormFillState.Pending;\n                  debug(\"reCAPTCHA challenge is active.\");\n                  recaptcha = true;\n                  return true;\n                }\n                if (recaptcha) {\n                  recaptcha = false;\n                  debug(\"reCAPTCHA challenge ended (for better or worse).\");\n                  state[3] = FormFillState.Submitting;\n                }\n                if (formElement.isConnected && getRect(formElement).width > 0) {\n                  state[3] = FormFillState.Pending;\n                  debug(\n                    `Form is still visible after ${VALIDATION_ERROR_TIMEOUT} ms, validation errors assumed. ${ansi(\n                      \"Form not submitted\",\n                      1\n                    )}`\n                  );\n                  unbindNavigationListener();\n                } else {\n                  debug(\n                    `Form is no longer visible ${VALIDATION_ERROR_TIMEOUT} ms after submit. ${ansi(\n                      \"Form submitted\",\n                      1\n                    )}`\n                  );\n                  commitEvent();\n                  unbindNavigationListener();\n                }\n              }, VALIDATION_ERROR_TIMEOUT);\n              return;\n            } else {\n              debug(\n                `Submit event triggered and default not prevented. ${ansi(\n                  \"Form submitted\",\n                  1\n                )}`\n              );\n              commitEvent();\n            }\n          },\n          { capture: false }\n        );\n\n        return (state = [\n          ev,\n          fieldMap,\n          formElement,\n          FormFillState.None,\n          now(T),\n          1,\n        ]);\n      });\n      if (!state[1].get(el)) {\n        // This will also be the case if a new field was added to the DOM.\n        parseElements();\n      }\n      return [el!, state];\n    };\n\n    const getFieldInfo = (\n      el: NodeWithParentElement,\n      [formElement, state] = getFormState(el as any) ?? [],\n      field = state?.[1].get(formElement as Element)\n    ) => field && ([state![0], field, formElement!, state!] as const);\n\n    let currentField: ReturnType<typeof getFieldInfo> | null = nil;\n    const handleLostFocus = () => {\n      if (!currentField) return;\n\n      const [form, field, el, state] = currentField;\n      const active = -(tv0 - (tv0 = getVisibleDuration()));\n      const total = -(t0 - (t0 = now(T)));\n\n      const previousValue = field[currentValue];\n      const newValue = (field[currentValue] = getFormFieldValue(el));\n\n      if (newValue !== previousValue) {\n        field.fillOrder ??= state[5]++;\n        if (field.filled) {\n          field.corrections = (field.corrections ?? 0) + 1;\n        }\n        field.filled = T;\n\n        state[3] = FormFillState.Pending;\n        forEach2(\n          form.fields!,\n          ([name, value]) => (value.lastField = name === field.name)\n        );\n      }\n      field.value = getFormFieldValue(el, true);\n\n      field.activeTime! += active;\n      field.totalTime! += total;\n      form.activeTime! += active;\n      form.totalTime! += total;\n      currentField = nil;\n    };\n\n    let tv0 = 0;\n    let t0 = 0;\n    const wireFormFields = (document: Document | Nullish) =>\n      document &&\n      listen(\n        document,\n        [\"focusin\", \"focusout\", \"change\"],\n        (ev, _, current = ev.target && getFieldInfo(ev.target)) =>\n          current &&\n          ((currentField = current),\n          ev.type === \"focusin\"\n            ? ((t0 = now(T)), (tv0 = getVisibleDuration()))\n            : handleLostFocus())\n      );\n\n    wireFormFields(document);\n    onFrame(\n      (frame) => frame.contentDocument && wireFormFields(frame.contentDocument),\n      true\n    );\n  },\n};\n","import {\n  TrackerExtensionFactory,\n  commerce,\n  components,\n  context,\n  forms,\n  scroll,\n  userInteraction,\n  consent,\n} from \"..\";\n\nexport const defaultExtensions: TrackerExtensionFactory[] = [\n  context,\n  components,\n  userInteraction,\n  scroll,\n  commerce,\n  forms,\n  consent,\n];\n","import type { Component, ExternalReference } from \"@tailjs/types\";\nimport { T, add, map2, nil, push, split, toString } from \"@tailjs/util\";\nimport { attr } from \".\";\nimport type { BoundaryCommand } from \"..\";\n\ntype MappedComponent = [\n  command: {\n    component?: Component;\n    content?: ExternalReference;\n    area?: string;\n  },\n  elements: HTMLElement[]\n];\n\nexport function scanAttributes(\n  attributeName: string,\n  references: MappedComponent[0][]\n): BoundaryCommand[] {\n  if (!references) return [];\n  const commands: BoundaryCommand[] = [];\n\n  const seen = new Set<any>();\n  document.querySelectorAll(`[${attributeName}]`).forEach((el) => {\n    if (seen.has(el)) {\n      return;\n    }\n\n    const stack: any[] = [];\n\n    while (attr(el, attributeName) != nil) {\n      add(seen, el);\n      const delta = split(attr(el, attributeName)!, \"|\");\n      attr(el, attributeName, nil);\n      for (let i = 0; i < delta.length; i++) {\n        let item: any = delta[i];\n        if (item === \"\") {\n          continue; // If the attribute starts with \"|\" it means \"keep stack\". Splitting the array on \"|\" will give an empty item.\n        }\n        const number = item === \"-\" ? -1 : parseInt(toString(item) ?? \"\", 36);\n        if (number < 0) {\n          stack.length += number;\n          continue;\n        } else if (i === 0) {\n          stack.length = 0; // The first item has a value to replace the stack since not preceded by neither \"|\" nor a negative number (pop).\n        }\n\n        if (isNaN(number) && /^[\"\\[{]/.test(item)) {\n          // Poor man's parser. If the JSON contains '|'s keep going until it works.\n          let json = \"\";\n          for (; i < delta.length; i++) {\n            try {\n              item = JSON.parse((json += delta[i]));\n              break;\n            } catch (e) {}\n          }\n        }\n\n        if (number >= 0 && references[number]) {\n          item = references[number];\n        }\n        push(stack, item);\n      }\n      push(\n        commands,\n        ...map2(stack, (data) => ({ add: T, ...data, boundary: el }))\n      );\n      const next = el.nextElementSibling!; // Ignore TS null error.\n      if (el.tagName === \"WBR\") {\n        el.parentNode?.removeChild(el);\n      }\n      el = next;\n    }\n  });\n\n  return commands;\n}\n","import { ScrollEvent } from \"@tailjs/types\";\nimport { T, defer, map2, push, restrict } from \"@tailjs/util\";\nimport { addViewChangedListener, type TrackerExtensionFactory } from \"..\";\nimport { listen, relativeScrollPos, scrollPos } from \"../lib\";\n\nexport const scroll: TrackerExtensionFactory = {\n  id: \"scroll\",\n  setup(tracker) {\n    let emitted: Partial<Record<Required<ScrollEvent>[\"scrollType\"], boolean>> =\n      {};\n    let initialScroll = scrollPos(T);\n\n    addViewChangedListener(() =>\n      defer(() => ((emitted = {}), (initialScroll = scrollPos(T))), 250)\n    );\n\n    listen(window, \"scroll\", () => {\n      const scroll = scrollPos();\n      const offset = relativeScrollPos();\n\n      if (scroll.y >= initialScroll.y) {\n        const types: (keyof typeof emitted)[] = [];\n\n        !emitted[\"fold\"] &&\n          scroll.y >= initialScroll.y + 200 &&\n          ((emitted[\"fold\"] = T), push(types, \"fold\"));\n\n        !emitted[\"page-middle\"] &&\n          offset.y >= 0.5 &&\n          ((emitted[\"page-middle\"] = T), push(types, \"page-middle\"));\n\n        !emitted[\"page-end\"] &&\n          offset.y >= 0.99 &&\n          ((emitted[\"page-end\"] = T), push(types, \"page-end\"));\n\n        const mapped = map2(types, (scrollType) =>\n          restrict<ScrollEvent>({\n            type: \"scroll\",\n            scrollType,\n            offset,\n          })\n        );\n\n        mapped.length && tracker(mapped);\n      }\n    });\n  },\n};\n","import { CONSENT_INFO_KEY } from \"@constants\";\r\n\r\nimport {\r\n  ConsentEvent,\r\n  DataPurposeName,\r\n  DataPurposes,\r\n  DataUsage,\r\n  UserConsent,\r\n  VariablePollCallback,\r\n} from \"@tailjs/types\";\r\nimport { Clock, F, Nullish, T, clock, map2, restrict } from \"@tailjs/util\";\r\nimport {\r\n  ConsentCommand,\r\n  TrackerExtensionFactory,\r\n  isUpdateConsentCommand,\r\n} from \"..\";\r\nimport { debug, document, window } from \"../lib\";\r\n\r\nexport const consent: TrackerExtensionFactory = {\r\n  id: \"consent\",\r\n  setup(tracker) {\r\n    const getCurrentConsent = async (\r\n      callback?: VariablePollCallback<UserConsent>\r\n    ) => {\r\n      return (await tracker.variables\r\n        .get({\r\n          scope: \"session\",\r\n          key: CONSENT_INFO_KEY,\r\n          poll: callback,\r\n          refresh: !callback,\r\n          passive: !callback,\r\n        })\r\n        .value()) as UserConsent | undefined;\r\n    };\r\n\r\n    const updateConsent = async <C extends UserConsent | Nullish>(\r\n      consent: C\r\n    ): Promise<\r\n      C extends Nullish\r\n        ? undefined\r\n        : [updated: boolean, current: UserConsent | undefined]\r\n    > => {\r\n      if (!consent) return undefined as any;\r\n\r\n      let current = await getCurrentConsent();\r\n\r\n      if (!current || DataUsage.equals(current, consent)) {\r\n        return [false, current] as any;\r\n      }\r\n\r\n      await tracker.events.post(\r\n        restrict<ConsentEvent>({\r\n          type: \"consent\",\r\n          consent,\r\n        }),\r\n        {\r\n          async: false,\r\n          variables: {\r\n            get: [{ scope: \"session\", key: CONSENT_INFO_KEY }],\r\n          },\r\n        }\r\n      );\r\n      return [true, consent] as any;\r\n    };\r\n\r\n    (() => {\r\n      // TODO: Make injectable to support other than GCMv2 compatible cookie disclaimers.\r\n      // Ideally, it could be injected in the init script from the request handler.\r\n      // However, hooking into the main categories of Google's consent mode v2 should cover most cases.\r\n\r\n      // Since the data layer is a capped buffer that may get rotated\r\n      // we detect changes by keeping track of the last element in the array.\r\n      // This also handles the situation where someone replaces the data layer.\r\n\r\n      const GCMv2Mappings: Record<string, DataPurposeName> = {\r\n        // Performance\r\n        analytics_storage: \"performance\",\r\n\r\n        // Functionality\r\n        functionality_storage: \"functionality\",\r\n\r\n        // This should be covered with normal \"functionality\".\r\n        // No distinction between functionality and personalization in common cookie CMP, e.g. CookieBot.\r\n        // Not sure why Google thinks this is a different, but tail.js can be configured to treat this purpose separately.\r\n        //\r\n        personalization_storage: \"personalization\",\r\n\r\n        ad_storage: \"marketing\", // Targeting\r\n\r\n        security_storage: \"security\", // Security\r\n      };\r\n\r\n      let dataLayerHead: any;\r\n      tracker({\r\n        consent: {\r\n          externalSource: {\r\n            key: \"Google Consent Mode v2\",\r\n            frequency: 250,\r\n            poll: () => {\r\n              const layer = window[\"dataLayer\"];\r\n              const previousHead = dataLayerHead;\r\n              let n: number = layer?.length;\r\n              if (\r\n                !n ||\r\n                (dataLayerHead === (dataLayerHead = layer[n - 1]) &&\r\n                  dataLayerHead) // Also check that the last item has a value, otherwise an empty element could trick us.\r\n              ) {\r\n                return;\r\n              }\r\n\r\n              let item: any;\r\n              while (\r\n                n-- &&\r\n                ((item = layer[n]) !== previousHead || !previousHead) // Check all items if we have not captured the previous head.\r\n              ) {\r\n                const purposes: DataPurposes = {};\r\n                let anonymous = true;\r\n                // Read from the end of the buffer to see if there is any [\"consent\", \"update\", ...] entry\r\n                // since last time we checked.\r\n                if (item?.[0] === \"consent\" && item[1] === \"update\") {\r\n                  map2(\r\n                    GCMv2Mappings,\r\n                    ([key, code]) =>\r\n                      item[2][key] === \"granted\" &&\r\n                      ((purposes[code] = true),\r\n                      (anonymous &&=\r\n                        // Security is considered \"necessary\" for some external purpose by tail.js\r\n                        // and does not deactivate anonymous tracking by itself.\r\n                        code === \"security\" || code === \"necessary\"))\r\n                  );\r\n\r\n                  return {\r\n                    classification: anonymous ? \"anonymous\" : \"direct\",\r\n                    purposes,\r\n                  };\r\n                }\r\n              }\r\n            },\r\n          },\r\n        },\r\n      } as ConsentCommand);\r\n    })();\r\n\r\n    const externalConsentSources: Record<string, Clock> = {};\r\n\r\n    return {\r\n      processCommand(command) {\r\n        if (isUpdateConsentCommand(command)) {\r\n          const getter = command.consent.get;\r\n          if (getter) {\r\n            getCurrentConsent((current, _, previous) => {\r\n              return current ? getter(current, previous) : true;\r\n            });\r\n          }\r\n\r\n          const setter = command.consent.set;\r\n          setter &&\r\n            (async () => {\r\n              if (\"consent\" in setter) {\r\n                const [updated, consent] = await updateConsent(setter.consent);\r\n                setter.callback?.(updated, consent);\r\n              } else {\r\n                updateConsent(setter);\r\n              }\r\n            })();\r\n\r\n          const externalSource = command.consent.externalSource;\r\n\r\n          if (externalSource) {\r\n            const key = externalSource.key;\r\n            const poller = (externalConsentSources[key] ??= clock({\r\n              frequency: externalSource.frequency ?? 1000,\r\n            }));\r\n            let previousConsent: DataUsage | undefined;\r\n\r\n            const pollConsent = async () => {\r\n              if (!document.hasFocus()) return;\r\n\r\n              const newConsent = externalSource.poll(previousConsent);\r\n\r\n              if (!newConsent) return;\r\n\r\n              if (\r\n                newConsent &&\r\n                !DataUsage.equals(previousConsent, newConsent)\r\n              ) {\r\n                const [updated, current] = await updateConsent(newConsent);\r\n                if (updated) {\r\n                  debug(current, \"Consent was updated from \" + key);\r\n                }\r\n                previousConsent = newConsent;\r\n              }\r\n            };\r\n            poller.restart(externalSource.frequency, pollConsent).trigger();\r\n          }\r\n\r\n          return T;\r\n        }\r\n        return F;\r\n      },\r\n    };\r\n  },\r\n};\r\n","export const commandTest =\n  <T = any>(...name: any[]) =>\n  (command: any): command is T =>\n    command === name[0] ||\n    name.some(\n      (name) => typeof name === \"string\" && command?.[name] !== undefined\n    );\n","import { CartEventData } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Triggers events related to a shopping cart.\n */\nexport interface CartCommand {\n  cart: \"clear\" | CartEventData;\n}\n\nexport const isCartCommand = commandTest<CartCommand>(\"cart\");\n","import type { Nullish } from \"@tailjs/util\";\nimport { commandTest } from \"./shared\";\n\nexport interface ChangeUserCommand {\n  username: string | Nullish;\n}\n\nexport const isChangeUserCommand = commandTest<ChangeUserCommand>(\"username\");\n","import type { TagMappings } from \"..\";\nimport { commandTest } from \"./shared\";\n\nexport type TagAttributesCommand = {\n  tagAttributes: TagMappings;\n};\nexport const isTagAttributesCommand =\n  commandTest<TagAttributesCommand>(\"tagAttributes\");\n","import { commandTest } from \"./shared\";\n\n/**\n * Enables or disables tracking.\n */\nexport type ToggleCommand = {\n  disable: boolean;\n};\nexport const isToggleCommand = commandTest<ToggleCommand>(\"disable\");\n","import type {\n  CartAction,\n  CartEventData,\n  ConfiguredComponent,\n  Content,\n  ParsableTags,\n  Tag,\n  TrackingSettings,\n} from \"@tailjs/types\";\n\nimport { commandTest } from \"./shared\";\nimport { MaybeArray, Nullish } from \"@tailjs/util\";\n\nexport interface BoundaryData<RequireArrays = false> {\n  /**\n   * The component definition(s) associated with the boundary element.\n   */\n  component?: MaybeArray<ConfiguredComponent, true, RequireArrays> | null;\n\n  /**\n   * The content definition(s) associated with the boundary element.\n   */\n  content?: MaybeArray<Content, true, RequireArrays> | null;\n\n  /**\n   * The name of the content area associated with the boundary element.\n   *\n   * A content area is used to indicate where activated components are used.\n   */\n  area?: string | null;\n\n  /**\n   *  These tags will be added to the components and content in user activations with the boundary element or any of its descendants.\n   */\n  tags?: RequireArrays extends true ? Tag[] : ParsableTags;\n\n  /**\n   * The element will include cart data when activated.\n   */\n  cart?: CartAction | CartEventData;\n\n  /**\n   * Settings that will apply to components contained by the boundary element including itself, similar to specifying \"track-*\" HMTL attributes on the element.\n   */\n  track?: TrackingSettings;\n}\n\n/**\n * Registers an element as the boundary for a component or similar tracking data. All events triggered from the element or its descendants will have this information attached.\n * In case of nested boundaries the closest one is used.\n */\nexport type BoundaryCommand = {\n  boundary: Element;\n} & (\n  | (BoundaryData & {\n      /**\n       * The content, tags and components will be added to the existing, if any.\n       */\n      add?: boolean;\n    })\n  | { update: (current?: BoundaryData<true>) => BoundaryData | Nullish }\n);\n\n// {\n//   /**\n//    * The component definition(s) associated with the boundary element.\n//    */\n//   component?: ConfiguredComponent | ConfiguredComponent[] | null;\n\n//   /**\n//    * The content definition(s) associated with the boundary element.\n//    */\n//   content?: Content | Content[] | null;\n\n//   /**\n//    * The name of the content area associated with the boundary element.\n//    *\n//    * A content area is used to indicate where activated components are used.\n//    */\n//   area?: string | string[] | null;\n\n//   /**\n//    *  These tags will be added to the components and content in user activations with the boundary element or any of its descendants.\n//    */\n//   tags?: Tag | Tag[] | null;\n\n//   /**\n//    * The element will include cart data when activated.\n//    */\n//   cart?: CartAction | CartEventData;\n\n//   /**\n//    * The element's component will be included in the stack even when the activation tracking level is `direct`.\n//    */\n//   promote?: boolean;\n\n//   /**\n//    * Specifies how the this command modifies the data associated with the boundary element.\n//    *\n//    * Only properties present in this command are affected (e.g. `component` or `content`) unless the action is `clear`.\n//    *\n//    * @default \"add\"\n//    */\n//   action?: \"add\" | \"remove\" | \"clear\";\n\n//   /**\n//    * The DOM element that gets this command's data associated.\n//    */\n//   boundary: Element;\n// }\n\nexport const isDataBoundaryCommand = commandTest<BoundaryCommand>(\"boundary\");\n","import type { TrackerExtensionFactory } from \"..\";\nimport { commandTest } from \"./shared\";\n\nexport interface ExtensionCommand {\n  extension: TrackerExtensionFactory;\n  priority?: number;\n}\nexport const isExtensionCommand = commandTest<ExtensionCommand>(\"extension\");\n","import { T } from \"@tailjs/util\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Causes all queued events to be posted to the server immediately.\n */\nexport type FlushCommand = { flush: boolean; force?: boolean; defer?: boolean };\nexport const isFlushCommand = commandTest<FlushCommand>(T, \"flush\");\n","import { MaybeArray, PickRequired } from \"@tailjs/util\";\nimport { ClientVariableGetter } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Used to get variables (data) from the backend.\n */\nexport interface GetCommand {\n  get: MaybeArray<PickRequired<ClientVariableGetter, \"callback\">>;\n\n  //MaybeArray<PickRequired<ClientVariableGetter, \"result\">, true>;\n}\n\nexport const isGetCommand = commandTest<GetCommand>(\"get\");\n","import type { Listener } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Registers a listener that will be invoked before and after events are flushed.\n * Useful for debugging or client-side integration with other tracker libraries (if one absolutely must).\n */\nexport interface ListenerCommand {\n  listener: Listener;\n}\nexport const isListenerCommand = commandTest<ListenerCommand>(\"listener\");\n","import { Order, OrderEvent } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Shorthand command to trigger an {@link OrderEvent} event.\n */\nexport interface OrderCommand {\n  /**\n   * The order that was completed or cancelled.\n   */\n  order: Order;\n}\n\nexport const isOrderCommand = commandTest<OrderCommand>(\"order\");\n","import type { Component, ExternalReference } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\nexport type ComponentOrContent =\n  | { component: Component }\n  | { content: ExternalReference };\n\n/**\n * Registers an element as the boundary for a component. All events triggered from the element or its descendants will have this information attached.\n * In case of nested boundaries the closest one is used.\n */\nexport interface ScanComponentsCommand {\n  scan: {\n    attribute: string;\n    components: ComponentOrContent[];\n  };\n}\n\nexport const isScanComponentsCommand =\n  commandTest<ScanComponentsCommand>(\"scan\");\n","import { MaybeArray } from \"@tailjs/util\";\nimport { ClientVariableSetter } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Used to set variables (data) in the backend.\n */\nexport interface SetCommand {\n  /** An object where the names of the properties correspond to the variables set in the tracker. */\n  set: MaybeArray<ClientVariableSetter>;\n}\n\nexport const isSetCommand = commandTest<SetCommand>(\"set\");\n","import type { Tracker, TrackerCommand } from \"..\";\n\nexport type UseTrackerCommand = (tracker: Tracker) => void;\nexport const isTrackerAvailableCommand = (\n  command: TrackerCommand\n): command is (tracker: Tracker) => void => typeof command === \"function\";\n","import { DataUsage, UserConsent, VariablePollCallback } from \"@tailjs/types\";\r\nimport { commandTest } from \"./shared\";\r\nimport { MaybePromiseLike } from \"@tailjs/util\";\r\n\r\nexport type ExternalConsentPoller = (\r\n  current: DataUsage | undefined\r\n) => DataUsage | undefined;\r\n\r\n/** Return `true` if you want this callback invoked every time the consent changes, and not just once. */\r\nexport type ConsentCallback = (\r\n  consent: UserConsent,\r\n  previous: UserConsent | undefined\r\n) => MaybePromiseLike<boolean | undefined | void>;\r\n\r\n/** Gets or updates the user's consent. */\r\nexport interface ConsentCommand {\r\n  consent: {\r\n    get?: ConsentCallback;\r\n    set?:\r\n      | DataUsage\r\n      | {\r\n          consent: DataUsage;\r\n          callback?: (\r\n            updated: boolean,\r\n            current: UserConsent | undefined\r\n          ) => void;\r\n        };\r\n    /**\r\n     * This can be used to poll the client's browser environment for something that translates into a tail.js consent.\r\n     * The primary use case is to integrate with a CMP (e.g. Cookiebot).\r\n     *\r\n     * Please provide a unique key for the poll function to avoid unintended double polling if for some reason\r\n     * the command is unintentionally submitted more than once.\r\n     */\r\n    externalSource?: {\r\n      key: string;\r\n      poll: ExternalConsentPoller;\r\n      /** @default 1000 */\r\n      frequency?: number;\r\n    };\r\n  };\r\n}\r\n\r\nexport const isUpdateConsentCommand = commandTest<ConsentCommand>(\"consent\");\r\n","import { TRACKER_CONFIG_PLACEHOLDER } from \"@constants\";\nimport { initializeTracker } from \".\";\ninitializeTracker(TRACKER_CONFIG_PLACEHOLDER);\n","import { UserAgentEvent, UserAgentLanguage } from \"@tailjs/types\";\r\nimport { map2, restrict } from \"@tailjs/util\";\r\nimport { Tracker, currentViewEvent, detectDeviceType } from \"..\";\r\n\r\nexport const postUserAgentEvent = (tracker: Tracker) =>\r\n  tracker(\r\n    restrict<UserAgentEvent>({\r\n      type: \"user_agent\",\r\n      hasTouch: navigator.maxTouchPoints > 0,\r\n      userAgent: navigator.userAgent,\r\n      view: currentViewEvent?.clientId,\r\n      languages: map2(navigator.languages, (id, i) => {\r\n        const [language, region] = id.split(\"-\");\r\n        return restrict<UserAgentLanguage>({\r\n          id,\r\n          language,\r\n          region,\r\n          primary: i === 0,\r\n          preference: i + 1,\r\n        });\r\n      }),\r\n      timezone: {\r\n        iana: Intl.DateTimeFormat().resolvedOptions().timeZone,\r\n        offset: new Date().getTimezoneOffset(),\r\n      },\r\n      ...detectDeviceType(),\r\n    })\r\n  );\r\n","import type { UserAgentEvent } from \"@tailjs/types\";\nimport { window } from \"../lib\";\n\nexport const detectDeviceType = (): Pick<\n  UserAgentEvent,\n  \"deviceType\" | \"screen\"\n> => {\n  // Common thresholds based on https://yesviz.com/viewport/\n  const screen = window?.screen;\n  if (!screen) return {};\n\n  let { width: w, height: h, orientation: o } = screen; // Get's the resolution in logical (CSS) pixels.\n  const landscape = w < h;\n  const angle = o?.angle ?? window[\"orientation\"] ?? 0;\n  (angle === -90 || angle === 90) && ([w, h] = [h, w]);\n\n  return {\n    deviceType: w < 480 ? \"mobile\" : w <= 1024 ? \"tablet\" : \"desktop\",\n    screen: { dpr: window.devicePixelRatio, width: w, height: h, landscape },\n  };\n};\n"],"names":["stringRuleCache","input","matchProjection","collected","metadata","key","current","pos","screenPos","x","y","rect","cached","name","cachedMappings","currentBoundaryData","propertyValue","_defaultTransports","ev","postCallbacks","tracker","currentViewEvent","pushPopNavigation","entry","content","throwError","error","transform","message","Error","isString","unwrap","structuralEquals","value1","value2","depth","isArray","isPlainObject","length","n","Object","keys","equalsAny","target","singleValue","otherValues","some","t","value","tryCatch","expression","errorHandler","always","e","isFunction","isError","isBoolean","console","DeferredPromise","Promise","initialized","this","_result","then","onfulfilled","onrejected","_this__result","_action","catch","finally","onfinally","constructor","action","super","_define_property","deferredPromise","async","tryCatchAsync","await","restrict","item","isTruish","isTrue","T","undefined","MAX_SAFE_INTEGER","Number","F","NOOP","IDENTITY","FILTER_NULLISH","symbolIterator","Symbol","iterator","symbolAsyncIterator","asyncIterator","createTypeConverter","typeTester","parser","parse","ifDefined","resultOrProperty","parseBoolean","isNotFalse","isNumber","toString","Array","array","clone","isIterable","isObject","hasMethod","isSymbol","acceptStrings","isMap","Map","isSet","Set","round","number","decimals","Math","pow","testFirstLast","s","first","last","isJsonString","stopInvoked","stop","yieldValue","wrapProjection","projection","sliceAction","start","end","index","filterArray","filter","createIterator","source","createFilteringIterator","i","createObjectIterator","createNavigatingIterator","step","maxIterations","yield","createRangeIterator","offset","project","flatten","expandObjects","flattenInternal","nested","map","mapped","push","array2","distinct","flatMap","concat","items","merged","forEach","forEachArray","returnValue","forEachIterable","forEachObject","forEachInternal","forEachAsync","fromEntries","result","obj","selector","merge","_","reduce","reducer","seed","seedFactory","_reducer","predicate","count","size","max","args","projected","_ref","_source_some1","_source_some","call","sort","rank","lhs","rhs","set","delete","add","get","init","has","values","assign","setter","update","remove","eu","splice","k","v","unshift","diff","updated","previous","patchedValue","patched","delta","previousValue","now","performance","trunc","timeOrigin","Date","createTimer","started","timeReference","capturedElapsed","t0","elapsed","toggle","reset","clock","callbackOrSettings","frequency","settings","callback","queue","paused","trigger","once","raf","timeoutId","mutex","promise","resolve","timer","outerCallback","skipQueue","pending","instance","busy","updateTimeout","setTimeout","requestAnimationFrame","timeoutCallback","active","resetTimer","clearTimeout","restart","newFrequency","newCallback","ResettablePromise","_promise","ifPending","reject","OpenPromise","signal","captured","inner","TypeError","delay","ms","isFinite","r","resettable","createEventBinders","listener","attach","detach","bound","outerListener","unbind","rebind","createEvent","dispatchedArgs","listeners","handler","binders","payload","pluralize","singular","plural","ansiSupported","ansi","ps","buffer","join","ellipsis","text","maxLength","debug","slice","createEnumParser","levels","ranks","defineProperty","writable","enumerable","configurable","validate","propertySettings","defineProperties","compare","rank1","rank2","parameterListSymbol","parseKeyValue","delimiters","decode","lowerCase","split","parts","decodeURIComponent","trim","replaceAll","toLowerCase","forEach2","delim","stop2","parseUri","uri","requireAuthority","options","match","scheme","slashes","authority","user","password","bracketHost","host","port","path","queryString","fragment","parsed","urn","parseInt","query","parseQueryString","parseParameters","separator","parameters","map2","part","replace","skip2","results","obj2","group2","concat2","testRegex","test","matches","regex","collect","escapeRegEx","REGEX_NEVER","unionOrNever","joined","join2","RegExp","isRegEx","parseRegex","separators","replaceValue","createIntervals","cmp","width","interval","ranges","finalize","sum","changed","getRootPrototype","proto","getPrototypeOf","findPrototypeFrame","frameWindow","matchPrototype","frame","document","getElementsByTagName","contentWindow","findDeclaringScope","globalThis","window","forEachSymbol","asyncIteratorFactorySymbol","ensureForEachImplementations","retry","scope","context","genericForEachIterable","prototype","_this_symbolAsyncIterator","WeakMap","WeakSet","range2","Function","traverse2","next","filter2","invert","prev","flatMap2","groups","kv","get2","some2","arg0","other","arg","sortCompare","descending","localeCompare","setSymbol","getSymbol","pushSymbol","ensureAssignImplementations","initialize","add2","set2","push2","assign2","sources","merge2","deep","overwrite","nulls","pick2","isEmptyString","arg1","arg2","itemize2","rest","conjunction","enumerated","DataClassification","never","anonymous","indirect","direct","sensitive","DATA_PURPOSES","VALID_PURPOSE_NAMES","purpose","mapOptionalPurpose","freeze","optionalPurposes","personalization","security","mapOptionalPurposes","purposes","mappedPurposes","functionality","DataPurposes","names","specificNames","includeDefault","SCHEMA_TYPE_PROPERTY","all","marketing","intersect","targetPurpose","hasAny","DataUsage","public","trusted-write","trusted-only","classification","usage","equals","usage1","usage2","serialize","deserialize","usageString","defaultUsage","clearMetadata","event","client","posted","queued","entries","isEventPatch","patchTargetId","VALIDATION_ERROR_SYMBOL","formatErrorSource","JSON","stringify","REGEX_DATE","REGEX_DATETIME","REGEX_UUID","REGEX_URI","REGEX_EMAIL","addError","errors","type","integer","allowStrings","isNaN","isInteger","parseFloat","primitiveValidators","VariableServerScope","primitive","enum","enumValues","validator","format","iso","allowNumericStrings","toISOString","exec","min","errorMessage","global","session","device","formatVariableKey","entityId","extractKey","VariableResultStatus","isVariableResult","requireFound","status","isSuccessResult","formatVariableResult","VariableStorageError","operations","succeeded","failed","_operations_filter","operation","_operations_filter1","hasCallback","op","hasPollCallback","poll","sourceOperation","toVariableResultPromise","operationType","logCallbackError","ops","callbackErrors","handlerResultPromise","initialResult","callbacks","pollingCallback","mapResults","require","handlerResults","NotFound","as","isTrackedEvent","isViewEvent","types","typeTest","maybeDecode","tag","score","collectTags","tagString","prefix","ns","localName","quoted1","quoted2","unquoted","localVariableScope","view","tab","shared","anyVariableScope","maskEntityId","isLocalScopeKey","variableKeyToString","stringToVariableKey","NOT_INITIALIZED","win","doc","body","matchSelector","node","MAX_ANCESTOR_DISTANCE","chrome","forAncestorsOrSelf","el","stoppingCriterion","distance","nodeType","parentElement","ownerDocument","_prev_ownerDocument_defaultView","defaultView","frameElement","parseAttributeValue","_trim","httpDecode","httpDecrypt","attr","getAttribute","scopeAttribute","normalizedAttribute","attributeNames","getAttributeNames","cssProperty","getComputedStyle","getPropertyValue","tagName","scrollPos","int","scrollX","scrollY","matchExHash","href1","href2","getScreenPos","mouseEvent","includeFold","getPos","xpx","ypx","offsetWidth","offsetHeight","pageFolds","innerHeight","pointerType","pageY","pageX","getRect","includeScroll","getBoundingClientRect","left","top","height","listen","capture","passive","addEventListener","removeEventListener","parseDomain","getViewport","innerWidth","totalWidth","totalHeight","boundaryData","getBoundaryData","trackerPropertyName","css","matchAttributeNames","tags","eligible","l","cachedTagMapper","parseTagAttributes","trackerConfig","rule","cache","cssPropertyWithBase","parsedCssRules","parseCssMappingRules","rulesString","rule1","rule2","trackerProperty","inherit","_ref1","trackerFlag","parseTags","sourceEl","elementTagData","src","disabled","postEvents","postFrequency","requestTimeout","encryptionKey","apiKey","json","impressionThreshold","captureContextMenu","default","codes","chars","charCode","charCodeAt","to64u","p","bytes","chunk","base64","String","fromCharCode","FNVs","32","64","128","entropy","random","msgDeserialize","msgSerialize","data","multiple","floatBuffer","floatView","Uint8Array","append","subarray","isReplacement","appendByte","lo","isSafeInteger","appendBytes","hi","appendInt64","DataView","ArrayBuffer","setFloat64","str","ascii","ci","c","c2","sec","getTime","getMilliseconds","appendArray","Uint8ClampedArray","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","invalidTypeReplacement","byte","newLength","newArray","abs","read","readMap","readArray","readStr","readBin","readExt","readFloat","readUInt","readInt","byteOffset","getFloat32","getFloat64","lengthSize","decodeUtf8","msgpack","encode","exports","REF_PROP","includeValue","includeDefaultValues","defaultValues","prettify","cleaners","refs","refIndex","patchProperty","addCleaner","cleaner","toJSON","matchedRef","stack","createTransport","factory","decodeJson","serializeOptions","encrypt","decrypt","hash","fastStringHash","bitsOrNumeric","jsonDecode","encoded","numericOrBits","j","pad","bits","prime","mixer","mixer255","iw","mixer0","window0","resetMixer","updateMixer","ENTROPY","MAX_PADDING","cipher","BigInt","asUintN","MIN_SAFE_INTEGER","binary","from64u","jsonEncode","currentScript","SCRIPT_SRC","TRACKER_DOMAIN","isInternalUrl","url","endsWith","mapUrl","urlParts","VAR_URL","MNT_URL","groupValue","childGroups","group","collapsed","groupCollapsed","children","log","groupEnd","httpEncode","httpEncrypt","USE_ENCRYPTION","addEncryptionNegotiatedListener","dispatchEncryptionNegotiated","logError","shift","id","addPageLoadedListener","dispatchPageLoaded","addPageVisibleListener","dispatchPageVisible","maybeDispatchPageLoaded","newLoaded","loaded","sleepTimer","maybeDispatchPageVisible","visible","visibilityState","visibleTimer","activated","activeTime","dispatchPageActivated","activationTimeout","setActivated","getActiveTime","localId","TAB_ID","nextId","nextLocalId","randomValues","tabVariables","tabState","heartbeat","state","knownTabs","variables","addStateListener","dispatchState","addVariablesChangedListener","dispatchVariablesChanged","post","tryGetVariable","timestamp","variable","setLocalVariables","updateVariableState","created","modified","version","getVariableChanges","sharedChanges","changes","updates","dispatchRequest","localState","sessionStorage","getItem","CLIENT_STORAGE_PREFIX","CLIENT_STATE_CHANNEL_ID","removeItem","padStart","setItem","localStorage","changedEventData","newValue","sender","initTimeout","timeout","HEARTBEAT_FREQUENCY","tabId","loading","addResponseHandler","dispatchResponse","requestLock","sharedLock","retries","defaultRetries","intervalId","renew","localTimeout","setInterval","clearInterval","waitHandle","race","lockId","request","beacon","currentData","serialized","cancel","prepareRequestData","prepareResult","newData","response","fetch","method","credentials","mode","headers","Content-Type","warn","arrayBuffer","navigator","sendBeacon","Blob","KEY_PROPS","GETTER_REQUEST_PROPS","SETTER_REQUEST_PROPS","callbackSourceSymbol","activeCallbacks","registerPostCallback","intersectionHandler","IMPRESSION_START","IMPRESSION_STOP","formatVariables","formatDataUsage","schema","isLinkElement","href","startsWith","isClickable","getElementInfo","includeRect","_el_href","_el_innerText","innerText","getCurrentViewId","clientId","referrerKey","pushNavigationSource","navigationEventId","consumed","totalDuration","visibleDuration","activations","addViewChangedListener","dispatchViewChanged","createViewDurationTimer","totalTime","visibleTime","activationsCounter","addFrameListenerInternal","callOnFrame","onFrame","triggerCurrent","frames","knownFrames","normalizeCartEventData","units","hasComponentOrContent","boundary","component","parseBoundaryTags","ancestor","stripRects","keep","getComponentContext","directOnly","includeRegion","areaPath","components","collectedContent","includeState","area","track","secondary","promote","region","currentValue","defaultExtensions","setup","definition","pendingViewDefinition","navigation","postView","events","postPatch","viewIndex","tabIndex","currentLocation","tabs","force","qs","referrer","location","pathname","domain","tabNumber","tabViewNumber","viewport","duration","firstTab","landingPage","_utm","utm","navigationType","getEntriesByType","redirects","redirectCount","relatedEventId","externalReferrer","registerEventPatchSource","history","apply","processCommand","isChangeUserCommand","command","username","decorate","impressions","observer","IntersectionObserver","els","currentIntersections","constrain","point","probeRange","createRange","regions","impressionEvents","unbindPassiveEventSources","boundaries","stats","pendingActive","visiblePercentage","updateRegion","viewDuration","prevHeight","inferred","bottom","readTime","viewWidth","viewHeight","intersection","right","intersectionHeight","intersectionWidth","thresholds","qualified","timeOffset","middle","seen","textContent","prevIndex","charMatcher","words","longWords","sentences","hasWord","limits","wordsBefore","inSentence","wasBoundary","MINUTE","SECOND","characters","lix","nodes","createTreeWalker","NodeFilter","SHOW_TEXT","boundaryIndex","nextNode","nodeLength","horizontalOffset","verticalOffset","intersectionTop","intersectionBottom","isIntersecting","observe","registerComponent","cart","eventData","clickables","clickable","cmd","isDataBoundaryCommand","isScanComponentsCommand","attributeName","references","commands","querySelectorAll","nextElementSibling","parentNode","removeChild","scan","attribute","activeEventClicks","trackDocument","trackClicks","trackRegion","clickableElement","containerElement","nav","button","child","childComponents","clicks","contextCart","clickIntent","componentContext","sharedEventProperties","container","info","element","link","external","hostname","search","anchor","originalUrl","requestId","navigationEvent","self","ctrlKey","shiftKey","altKey","exit","internalUrl","substring","encodeURIComponent","intentEvent","contentDocument","emitted","initialScroll","defer","f","scroll","fold","scrollType","isCartCommand","aP","order","getFormState","formEvents","getFormFieldValue","tracked","include","selectedOptions","option","checked","capturedContext","refName","formElement","form","fieldMap","fields","commitEvent","handleLostFocus","completed","isConnected","commitTimeout","defaultTimeout","handle","currentCallback","stickyTimeout","isReCaptchaActive","unbindNavigationListener","recaptcha","submitEvent","defaultPrevented","probeDoc","style","visibility","opacity","VALIDATION_ERROR_TIMEOUT","field","label","labels","crypto","getRandomValues","ref","getFieldInfo","currentField","total","tv0","fillOrder","filled","corrections","lastField","wireFormFields","dataLayerHead","getCurrentConsent","refresh","updateConsent","consent","GCMv2Mappings","analytics_storage","functionality_storage","personalization_storage","ad_storage","security_storage","externalConsentSources","externalSource","layer","dataLayer","previousHead","code","getter","previousConsent","isUpdateConsentCommand","newConsent","hasFocus","commandTest","isTagAttributesCommand","isToggleCommand","isExtensionCommand","isFlushCommand","isGetCommand","isListenerCommand","isOrderCommand","isSetCommand","isTrackerAvailableCommand","initializeTracker","config","clientEncryptionKey","setStorageKey","extensions","callListeners","pendingStateCommands","trackerContext","mainArgs","currentArg","insertArgs","globalStateResolved","ready","apiProtectionKey","queuedCommands","unsubscribe","endpoint","pollVariables","getters","vars","VARIABLE_POLL_FREQUENCY","registerCallback","mappedKey","invokeCallbacks","stateDuration","Success","validateKey","newLocal","requestGetters","Forbidden","local","ttl","_this","deviceSessionId","_variables","initSetters","initValue","Conflict","setters","localResults","pendingPatches","requestVariables","patch","Created","attempts","required","applyEventExtensions","skip","extension","throwIfInvalid","snapshots","mapPatchTarget","sourceEvent","updateSnapshot","abort","flush","newEvents","unloading","updatedEvents","unbinding","initialPost","relatedNode","snapshot","tagAttributes","disable","expanded","priority","success","__isTracker","_1","_2","hasUserAgent","hasTouch","maxTouchPoints","userAgent","languages","language","primary","preference","timezone","iana","Intl","DateTimeFormat","resolvedOptions","timeZone","getTimezoneOffset","screen","w","h","orientation","o","landscape","angle","deviceType","dpr","devicePixelRatio"],"mappings":"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","x_google_ignoreList":[47]}