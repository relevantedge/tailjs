{"version":3,"file":"tail.js","sources":["../../../../../npm/packages/@tailjs/util/src/types/validation.ts","../../../../../npm/packages/@tailjs/util/src/regex.ts","../../../../../npm/packages/@tailjs/types/src/EventMetadata.ts","../../../../../npm/packages/@tailjs/client/src/lib2/dom/dom-util.ts","../../../../../npm/packages/@tailjs/client/src/lib2/dom/dom-data.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/transport.ts","../../../../../npm/packages/@tailjs/client/src/lib2/request.ts","../../../../../npm/packages/@tailjs/client/src/extensions/context.ts","../../../../../npm/packages/@tailjs/client/src/extensions/components.ts","../../../../../npm/packages/@tailjs/client/src/initializeTracker.ts","../../../../../npm/packages/@tailjs/types/src/DataClassification.ts","../../../../../npm/packages/@tailjs/types/src/DataPurposes.ts","../../../../../npm/packages/@tailjs/types/src/protocol/Variable.ts","../../../../../npm/packages/@tailjs/types/src/protocol/VariableSetter.ts","../../../../../npm/packages/@tailjs/client/src/lib2/LocalVariables.ts","../../../../../npm/packages/@tailjs/util/src/types/types.ts","../../../../../npm/packages/@tailjs/util/src/iterators.ts","../../../../../npm/packages/@tailjs/util/src/accessors.ts","../../../../../npm/packages/@tailjs/util/src/time.ts","../../../../../npm/packages/@tailjs/util/src/concurrency.ts","../../../../../npm/packages/@tailjs/util/src/events.ts","../../../../../npm/packages/@tailjs/util/src/strings.ts","../../../../../npm/packages/@tailjs/util/src/types/strings.ts","../../../../../npm/packages/@tailjs/util/src/enums.ts","../../../../../npm/packages/@tailjs/util/src/parsers.ts","../../../../../npm/packages/@tailjs/types/src/protocol/PostResponse.ts","../../../../../npm/packages/@tailjs/types/src/protocol/VariableResult.ts","../../../../../npm/packages/@tailjs/types/src/events/TrackedEvent.ts","../../../../../npm/packages/@tailjs/types/src/events/ViewEvent.ts","../../../../../npm/packages/@tailjs/types/src/util/type-test.ts","../../../../../npm/packages/@tailjs/types/src/util/parseTagString.ts","../../../../../npm/packages/@tailjs/client/src/lib2/consts.ts","../../../../../npm/packages/@tailjs/client/src/lib2/dom/dom-alias.ts","../../../../../npm/packages/@tailjs/client/src/lib2/config.ts","../../../../../npm/packages/@tailjs/client/src/lib2/env.ts","../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/base64.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/lfsr.ts","../../../../../npm/node_modules/.pnpm/github.com+nielskuhnel+msgpack.js@ad309e8a7e5319c2472193e3b28df68124caa590/node_modules/@ygoe/msgpack/msgpack.js","../../../../../npm/packages/@tailjs/client/src/lib2/cipher.ts","../../../../../npm/packages/@tailjs/client/src/lib2/errors.ts","../../../../../npm/packages/@tailjs/client/src/lib2/page-events.ts","../../../../../npm/packages/@tailjs/client/src/lib2/shared-state.ts","../../../../../npm/packages/@tailjs/client/src/lib2/concurrency.ts","../../../../../npm/packages/@tailjs/client/src/lib2/TrackerVariableStorage.ts","../../../../../npm/packages/@tailjs/client/src/lib2/EventQueue.ts","../../../../../npm/packages/@tailjs/client/src/lib2/ImpressionObserver.ts","../../../../../npm/packages/@tailjs/client/src/extensions/deviceDetection.ts","../../../../../npm/packages/@tailjs/client/src/extensions/user-agent.ts","../../../../../npm/packages/@tailjs/client/src/extensions/userInteraction.ts","../../../../../npm/packages/@tailjs/client/src/extensions/commerce.ts","../../../../../npm/packages/@tailjs/client/src/extensions/forms.ts","../../../../../npm/packages/@tailjs/client/src/extensions/defaultExtensions.ts","../../../../../npm/packages/@tailjs/client/src/lib2/scanComponents.ts","../../../../../npm/packages/@tailjs/client/src/extensions/scroll.ts","../../../../../npm/packages/@tailjs/client/src/commands/shared.ts","../../../../../npm/packages/@tailjs/client/src/commands/CartCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ChangeUserCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ConfigCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ToggleCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/BoundaryCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ExtensionCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/FlushCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/GetCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ListenerCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/OrderCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ScanComponentsCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/SetCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/TrackerAvailableCommand.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["import {\n  Defined,\n  Falsish,\n  If,\n  IsAny,\n  MaybePromise,\n  NotFunction,\n  Nullish,\n  OmitNullish,\n  TogglePromise,\n  UnwrapPromiseLike,\n  Wrapped,\n  isObject,\n  isArray,\n  isBoolean,\n  isError,\n  isFunction,\n  isString,\n  unwrap,\n  MaybeUndefined,\n  ToggleReadonly,\n} from \"..\";\n\nexport type ErrorGenerator = string | Error | (() => string | Error);\n\nexport const throwError = (\n  error: ErrorGenerator,\n  transform: (string: string) => Error = (message) => new TypeError(message)\n): never => {\n  throw isString((error = unwrap(error))) ? transform(error) : error;\n};\n\ntype CombineTypeTests<T> = T extends []\n  ? {}\n  : T extends [infer F, ...infer Rest]\n  ? F extends (value: any) => value is infer R\n    ? (IsAny<R> extends true ? T : R) & CombineTypeTests<Rest>\n    : never\n  : never;\n\nexport const validate = <\n  T,\n  Validator extends\n    | ((candidate: T) => candidate is any)\n    | ((candidate: T) => R)\n    | [\n        validate: (candidate: T) => any,\n        ...typeTests: ((candidate: T) => candidate is any)[]\n      ]\n    | (R & NotFunction),\n  R\n>(\n  value: T,\n  validate: Validator | R,\n  validationError?: ErrorGenerator,\n  undefinedError?: ErrorGenerator\n): Defined<\n  If<\n    IsAny<Validator>,\n    T,\n    Validator extends readonly [any, ...infer TypeTests]\n      ? CombineTypeTests<TypeTests>\n      : Validator extends ((value: any) => infer R) | infer R\n      ? R extends Falsish\n        ? never\n        : Validator extends (value: any) => value is infer R\n        ? Defined<R>\n        : T\n      : never\n  >\n> =>\n  (\n    isArray(validate)\n      ? validate.every((test) => test(value))\n      : isFunction(validate)\n      ? validate(value)\n      : validate\n  )\n    ? value\n    : required(value, undefinedError ?? validationError) &&\n      (throwError(validationError ?? \"Validation failed.\") as any);\n\nexport class InvariantViolatedError extends Error {\n  constructor(invariant?: string) {\n    super(invariant ? \"INV: \" + invariant : \"An invariant was violated.\");\n  }\n}\n\nexport const structuralEquals = (\n  value1: any,\n  value2: any,\n  depth = -1\n): boolean => {\n  if (value1 === value2) return true;\n  // interpret `null` and `undefined` as the same.\n  if ((value1 ?? value2) == null) return true;\n\n  if (isObject(value1) && isObject(value2) && value1.length === value2.length) {\n    let n = 0;\n    for (const key in value1) {\n      if (\n        value1[key] !== value2[key] &&\n        !structuralEquals(value1[key], value2[key], depth - 1)\n      ) {\n        return false;\n      }\n      ++n;\n    }\n    return n === Object.keys(value2).length;\n  }\n  return false;\n};\n\n/** Tests whether a value equals at least one of some other values.  */\nexport const equalsAny: <T extends readonly any[]>(\n  target: any,\n  ...values: T\n) => target is T[number] = ((\n  target: any,\n  singleValue: any,\n  ...otherValues: any\n) =>\n  target === singleValue ||\n  (otherValues.length > 0 &&\n    otherValues.some((value: any) => equalsAny(target, value)))) as any;\n\n/**\n * States an invariant.\n */\nexport const invariant = <T>(\n  test: Wrapped<T | false>,\n  description?: string\n): Defined<T> => {\n  const valid = unwrap(test);\n  return valid != null && valid !== false\n    ? (valid as any)\n    : throwError(new InvariantViolatedError(description));\n};\n\nexport const required = <T>(value: T, error?: ErrorGenerator): OmitNullish<T> =>\n  value != null\n    ? (value as any)\n    : throwError(\n        error ?? \"A required value is missing\",\n        (text) => new TypeError(text.replace(\"...\", \" is required.\"))\n      );\n\nexport const tryCatch = <\n  T,\n  E extends boolean | ((error: any) => any) | Nullish\n>(\n  expression: () => T,\n  errorHandler: E = true as any,\n  always?: () => void\n):\n  | T\n  | (E extends Nullish | true\n      ? never\n      : E extends false\n      ? undefined\n      : E extends (error: any) => infer R\n      ? R extends Error\n        ? never\n        : R extends void\n        ? undefined\n        : R\n      : E) => {\n  try {\n    return expression();\n  } catch (e) {\n    return isFunction(errorHandler)\n      ? isError((e = errorHandler(e)))\n        ? throwError(e)\n        : e\n      : isBoolean(errorHandler)\n      ? console.error(errorHandler ? throwError(e) : e)\n      : (errorHandler as any);\n  } finally {\n    always?.();\n  }\n};\n\nexport type ErrorHandler = Nullish | boolean | ((error: any) => any);\ntype ErrorHandlerResult<Handler> = Handler extends true\n  ? never\n  : Handler extends (...args: any) => infer R\n  ? TogglePromise<UnwrapPromiseLike<R> extends Error ? never : R, R>\n  : void;\n\nconst maybeAwait = <T, R>(value: MaybePromise<T>, action: (value: T) => R): R =>\n  (value as any)?.then(action) ?? action(value as any);\n\nconst handleError = <Handler extends ErrorHandler>(\n  errorHandler: Handler,\n  error: any,\n  log = true\n): ErrorHandlerResult<Handler> =>\n  errorHandler === false\n    ? undefined\n    : errorHandler === true ||\n      errorHandler == null ||\n      isError((error = errorHandler(error)))\n    ? maybeAwait(\n        error,\n        (error) => (log && console.error(error), throwError(error))\n      )\n    : error;\n\n/** A value that is initialized lazily on-demand. */\nexport const deferred = <T>(expression: Wrapped<T>): (() => T) => {\n  let result: T | undefined = undefined;\n  return () => (result ??= unwrap(expression));\n};\n\nexport interface DeferredPromise<T> extends PromiseLike<T> {\n  initialized: boolean;\n}\n\nexport type MaybeDeferredPromise<T> =\n  | (T & { initialized?: boolean })\n  | DeferredPromise<T>;\n\n/**\n * A promise that is initialized lazily on-demand.\n * For promises this is more convenient than {@link deferred}, since it just returns a promise instead of a function.\n */\nexport const deferredPromise = <T>(\n  expression: Wrapped<MaybePromise<T>>\n): DeferredPromise<T> => {\n  let promise: DeferredPromise<T> = {\n    initialized: true,\n    then: thenMethod(() => ((promise.initialized = true), unwrap(expression))),\n  };\n  return promise;\n};\n\nexport const thenMethod = <T>(\n  expression: Wrapped<MaybePromise<T>>\n): (<TResult1 = T, TResult2 = never>(\n  onfulfilled?:\n    | ((value: T) => TResult1 | PromiseLike<TResult1>)\n    | undefined\n    | null,\n  onrejected?:\n    | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n    | undefined\n    | null\n) => PromiseLike<TResult1 | TResult2>) => {\n  let result = deferred(expression);\n  return (onfullfilled?, onrejected?) =>\n    tryCatchAsync(result, [onfullfilled, onrejected] as any);\n};\n\nexport const tryCatchAsync = async <\n  T,\n  C = void,\n  E extends boolean | ((error: any) => MaybePromise<C>) = true,\n  T1 = T\n>(\n  expression: Wrapped<MaybePromise<T>>,\n  errorHandler: E = true as any,\n  always?: () => MaybePromise<void>\n): Promise<T1 | C> => {\n  try {\n    const result = (await unwrap(expression)) as any;\n    return isArray(errorHandler) ? errorHandler[0]?.(result) : result;\n  } catch (e) {\n    if (!isBoolean(errorHandler)) {\n      if (isArray(errorHandler)) {\n        if (!errorHandler[1]) throw e;\n        return errorHandler[1](e) as any;\n      }\n\n      const error = (await (errorHandler as any)?.(e)) as any;\n      if (error instanceof Error) throw error;\n      return error;\n    } else if (errorHandler) {\n      throw e;\n    } else {\n      // Boolean  means \"swallow\".\n      console.error(e);\n    }\n  } finally {\n    await always?.();\n  }\n\n  return undefined as any;\n};\n\n/**\n *  No-op function to validate types in TypeScript. Because function parameters are contravariant, passing an event that does not match on all properties will get red wiggly lines)\n *\n */\nexport const restrict: {\n  <T extends any[] | undefined>(\n    item: T extends (infer T)[] ? T : undefined\n  ): T extends (infer T)[] ? T : undefined;\n  <T>(item: T): T;\n} = (item: any) => item as any;\n","import {\n  If,\n  MaybeUndefined,\n  Nullable,\n  distinct,\n  filter,\n  isArray,\n  isBoolean,\n  isString,\n  join,\n  map,\n  nil,\n  undefined,\n  type ConstToNormal,\n  type IterableOrSelf,\n  type Nullish,\n} from \".\";\n\n/**\n * Common definition of expressions that are used for string matching.\n *\n * If not already a regular expression, a string that starts with `/` and optionally ends with `/` is parsed as regular expressions with flags `gu` applied (global and Unicode).\n * This enables defining regular expression in text based configuration files that do not have native regular expressions.\n *\n * For convenience an asterisk (`*`) can be used to match any number of characters in strings, and  `,` and white-space ` ` are interpreted as list separators.\n * `\\` is used as the escape character so the string `\\/escaped\\*,and\\ this` will only match the strings, literally, `\\/escaped\\*` and `and this`.\n * This also means that intentional backslashes, commas and spaces must be escaped as `\\\\`, `\\,` and `\\ ` respectively.\n *\n * Arrays of strings and/or regular expressions are evaluated as unions (_string 1_ \"or\" _string 2_ \"or\" ...).\n *\n * The special values `null`, `undefined`, the empty string,  and `false` are interpreted as \"never\", and `true` is \"always\".\n *\n * Regarding separators, they may be different in specific contexts. If so, it will be mentioned there.\n */\nexport type ParsableRegExp =\n  | IterableOrSelf<null | undefined | boolean | string | RegExp>\n  | Iterable<ParsableRegExp>;\n\nexport const testRegex = <Nulls>(\n  s: Nullable<string, Nulls>,\n  match: Nullable<RegExp, Nulls>\n) => (!match || s == null ? undefined : match.test(s));\n\nexport const matches = <R, Nulls>(\n  s: Nullable<string, Nulls>,\n  regex: RegExp | Nullish,\n  selector: (...args: string[]) => R | Nullish\n): MaybeUndefined<Nulls, ConstToNormal<R>[]> => match(s, regex, selector, true);\n\nlet matchProjection: any;\nlet collected: any[];\n\n/**\n * Matches a regular expression against a string and projects the matched parts, if any.\n */\nexport const match: {\n  <R, Nulls, Collect extends boolean = false>(\n    s: Nullable<string, Nulls>,\n    regex: RegExp | Nullish,\n    selector: (...args: string[]) => R | Nullish,\n    collect?: Collect\n  ): MaybeUndefined<Nulls, If<Collect, ConstToNormal<R>[], R | undefined>>;\n  (s: string | Nullish, match: RegExp | Nullish): RegExpMatchArray | null;\n} = <R>(\n  s: string,\n  regex: RegExp,\n  selector?: (...args: string[]) => R,\n  collect = false\n) =>\n  (s ?? regex) == nil\n    ? undefined\n    : selector\n    ? ((matchProjection = undefined),\n      collect\n        ? ((collected = []),\n          match(\n            s,\n            regex,\n            (...args) =>\n              (matchProjection = selector(...args)) != null &&\n              collected.push(matchProjection)\n          ))\n        : s.replace(\n            // Replace seems to be a compact way to get the details of each match\n            regex,\n            (...args) => (matchProjection = selector(...args)) as any\n          ),\n      matchProjection)\n    : s.match(regex);\n\n/**\n * Replaces reserved characters to get a regular expression that matches the string.\n */\nexport const escapeRegEx = <T extends string | Nullish>(\n  input: T\n): MaybeUndefined<T, string> =>\n  input?.replace(/[\\^$\\\\.*+?()[\\]{}|]/g, \"\\\\$&\") as any;\n\nconst REGEX_NEVER = /\\z./g;\nconst unionOrNever = (parts: (string | Nullish)[], joined?: string) =>\n  (joined = join(distinct(filter(parts, (part) => part?.length)), \"|\"))\n    ? new RegExp(joined, \"gu\")\n    : REGEX_NEVER;\n\nconst stringRuleCache: { [pattern: string]: RegExp } = {};\nexport const isRegEx = (value: any): value is RegExp => value instanceof RegExp;\n\n/**\n * Tests or parses a regular expression accepting the {@link ParsableRegExp} format.\n *\n * Strings are cached, so there is no need to do additional caching outside this function (as far as the caching would only concern strings).\n */\nexport const parseRegex = <T>(\n  input: T,\n  separators: readonly string[] = [\",\", \" \"]\n): T extends ParsableRegExp ? RegExp : undefined =>\n  isRegEx(input)\n    ? input\n    : isArray(input) // Parse individual specifiers, and join them into one long regex. An empty array is interpreted as \"never\".\n    ? unionOrNever(map(input, (part) => parseRegex(part, separators)?.source)!)\n    : isBoolean(input)\n    ? input // `true` is \"always\", `false` is \"never\"\n      ? /./g\n      : REGEX_NEVER // Matches nothing. End of string followed by something is never the case.\n    : isString(input)\n    ? (stringRuleCache[input] ??= match(\n        input || \"\",\n        /^(?:\\/(.+?)\\/?|(.*))$/gu,\n        (_, regex, text) =>\n          regex\n            ? new RegExp(regex, \"gu\")\n            : unionOrNever(\n                map(\n                  split(\n                    text,\n                    new RegExp(\n                      `?<!(?<!\\\\)\\\\)[${join(separators, escapeRegEx, \",\")}]/`\n                    )\n                  ),\n                  (text) =>\n                    text &&\n                    `^${join(\n                      // Split on non-escaped asterisk (Characterized by a leading backslash that is not itself an escaped backslash).\n                      split(text, /(?<!(?<!\\\\)\\\\)\\*/),\n                      (part) =>\n                        escapeRegEx(\n                          // Remove backslashes used for escaping.\n                          replace(part, /\\\\(.)/g, \"$1\")\n                        ),\n                      // Join the parts separated by non-escaped asterisks with the regex wildcard equivalent.\n                      \".*\"\n                    )}$`\n                )\n              )\n      )!)\n    : (undefined as any);\n\n/**\n * Better minifyable version of `String`'s `split` method that allows a null'ish parameter.\n */\nexport const split = <T extends string | Nullish>(\n  s: T,\n  separator: RegExp | string\n): MaybeUndefined<T, string[]> => s?.split(separator) ?? (s as any);\n\n/**\n * Better minifyable version of `String`'s `replace` method that allows a null'ish parameter.\n */\nexport const replace = <T extends string | Nullish>(\n  s: T,\n  match: RegExp,\n  replaceValue: string | ((...args: string[]) => string)\n): T => s?.replace(match, replaceValue as any) ?? (s as any);\n","import { Nullish } from \"@tailjs/util\";\nimport { TrackedEvent } from \".\";\n\n/** These properties are used to track the state of events as they get collected, and not stored. */\nexport interface EventMetadata {\n  /** Hint to the request handler, that new sessions should not be started if all posted events are passive. */\n  passive?: boolean;\n\n  /** Hint that the event has been queued. */\n  queued?: boolean;\n\n  /** Hint to client code, that the event has been posted to the server. */\n  posted?: boolean;\n}\n\nlet metadata: EventMetadata | undefined;\nexport const clearMetadata = <\n  T extends TrackedEvent | Nullish,\n  ClientSide extends boolean\n>(\n  event: T,\n  client: ClientSide\n): T &\n  (ClientSide extends true\n    ? { metadata?: { posted?: undefined } }\n    : { metadata?: undefined }) => (\n  (metadata = event?.metadata) &&\n    (client\n      ? (delete metadata.posted,\n        delete metadata.queued,\n        !Object.entries(metadata).length && delete event.metadata)\n      : delete event.metadata),\n  event as any\n);\n","import {\n  type Domain,\n  type Position,\n  type Rectangle,\n  type ScreenPosition,\n  type Size,\n  type Viewport,\n} from \"@tailjs/types\";\nimport {\n  Binders,\n  F,\n  MAX_SAFE_INTEGER,\n  NOOP,\n  Nullable,\n  T,\n  Unbinder,\n  createEventBinders,\n  entries,\n  filter,\n  isArray,\n  joinEventBinders,\n  map,\n  match,\n  nil,\n  parseBoolean,\n  parseUri,\n  replace,\n  restrict,\n  round,\n  tryCatch,\n  type MaybeUndefined,\n  type Nullish,\n} from \"@tailjs/util\";\nimport { body, httpDecode, httpDecrypt } from \"..\";\n\nexport type NodeWithParentElement = Node | EventTarget;\n\nexport let MAX_ANCESTOR_DISTANCE = MAX_SAFE_INTEGER;\n\nexport const forAncestorsOrSelf = <T = any>(\n  el: NodeWithParentElement | Nullish,\n  action: (\n    el: Element,\n    returnValue: (value: T, replace?: boolean) => void,\n    distance: number\n  ) => any,\n  stoppingCriterion: (el: Element, distance: number) => boolean = (\n    el,\n    distance\n  ) => distance >= MAX_ANCESTOR_DISTANCE\n): T | undefined => {\n  let i = 0;\n  let returnValue: any;\n  let stop = F;\n  while (\n    el?.[\"nodeType\"] === 1 &&\n    !stoppingCriterion(el as Element, i++) &&\n    action(\n      el as Element,\n      (value, replace) => (\n        value != nil &&\n          ((returnValue = value), (stop = replace !== T && returnValue != nil)),\n        T\n      ),\n      i - 1\n    ) !== F &&\n    !stop\n  ) {\n    const prev = el;\n    el = (el as Element).parentElement;\n    if (el === null && (prev as Element)?.ownerDocument !== document) {\n      el = (prev as Element)?.ownerDocument.defaultView?.frameElement;\n    }\n  }\n\n  return returnValue;\n};\n\nexport type AttributeValueType =\n  /**\n   * The normalized attribute value, int the sense it gets trimmed and lowercased.\n   * The empty spring is considered undefined.\n   *\n   * This is the default.\n   */\n  | true\n  | \"z\"\n\n  /**\n   * The attribute value as a boolean or undefined if it does match `0`, `1`, `true`, `false` or \"\".\n   * The empty string matches existence of an attribute `<tag attribute/>`.\n   * If parsing arrays of booleans, the empty string will be considered undefined since that is an empty element in this context.\n   */\n  | \"b\"\n\n  /** The attribute value as a number or undefined if it does not look like a number. */\n  | \"n\"\n\n  /** The raw attribute value. */\n  | false\n  | \"r\"\n\n  /**  The attribute value parsed as JSON. */\n  | \"j\"\n\n  /**  The attribute value parsed as a HTTP encoded string (from @tailjs/util/transport). */\n  | \"h\"\n\n  /**  The attribute value parsed as a client encrypted value (from @tailjs/util/transport). This also supports JSON. */\n  | \"e\"\n\n  /**\n   * This means the attribute value will be parsed as an array with elements separated by `,`.\n   * Whitespace is trimmed, and empty values are considered undefined.\n   *\n   * A type may be included in the tuple to parse the items as this type. In this case unparsable values will be included in the array\n   * as undefined.\n   */\n  | readonly [type?: AttributeValueType & string];\n\ntype ParsedAttributeValue<\n  T extends AttributeValueType | Nullish,\n  EncodedType = any\n> = T extends readonly [infer T extends AttributeValueType]\n  ? ParsedAttributeValue<T>[]\n  : T extends (boolean | \"z\" | Nullish) | \"r\"\n  ? string\n  : T extends \"b\"\n  ? boolean | undefined\n  : T extends \"n\"\n  ? number | undefined\n  : T extends \"j\" | \"h\" | \"e\"\n  ? EncodedType | undefined\n  : never;\n\nexport const parseAttributeValue: <\n  V,\n  Type extends AttributeValueType | Nullish = \"z\"\n>(\n  value: V,\n  type?: Type\n) => MaybeUndefined<\n  V,\n  Type extends \"b\"\n    ? boolean\n    : V extends \"\"\n    ? undefined\n    : ParsedAttributeValue<Type>\n> = (value: any, type) => {\n  if (value == null || value === \"null\" || (value === \"\" && type !== \"b\"))\n    return undefined;\n\n  switch (type) {\n    case true:\n    case \"z\":\n      return (\"\" + value).trim()?.toLowerCase();\n    case false:\n    case \"r\":\n      value;\n    case \"b\":\n      return value === \"\" || parseBoolean(value);\n    case \"n\":\n      return parseFloat(value);\n    case \"j\":\n      return tryCatch(() => JSON.parse(value), NOOP);\n    case \"h\":\n      return tryCatch(() => httpDecode(value), NOOP);\n    case \"e\":\n      return tryCatch(() => httpDecrypt?.(value), NOOP);\n    default:\n      return isArray(type)\n        ? value === \"\"\n          ? undefined\n          : (\"\" + value)\n              .split(\",\")\n              .map(\n                (value) =>\n                  (value =\n                    value.trim() === \"\"\n                      ? undefined\n                      : parseAttributeValue(value, type![0]))\n              )\n        : undefined;\n  }\n};\n\nexport const attr = <\n  Node extends NodeWithParentElement | Nullish,\n  Type extends AttributeValueType | Nullish = \"z\"\n>(\n  node: Node,\n  name: string,\n  type?: Type\n) => parseAttributeValue((node as any)?.getAttribute(name), type);\n\nexport const setAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string,\n  value: any\n) =>\n  value === nil\n    ? (node as any)?.removeAttribute(name)\n    : (node as any)?.setAttribute(name, \"\" + value);\n\nexport const scopeAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string,\n  type?: AttributeValueType\n) => forAncestorsOrSelf(node, (el, value) => value(attr(el, name, type)));\n\nexport const inElementScope = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) =>\n  forAncestorsOrSelf(node, (el, value) =>\n    value(tagName(el) === name || undefined)\n  );\n\nexport const normalizedAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) => attr(node, name)?.trim()?.toLowerCase();\n\nlet value: string | undefined;\n\nexport const booleanAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) => (value = attr(node, name)) === \"\" || parseBoolean(value);\n\nexport const numericAttribute = (\n  node: NodeWithParentElement | Nullish,\n  name: string\n) => parseFloat(\"\" + (value = attr(node, name))) ?? undefined;\n\nexport const attributeNames = <\n  T extends NodeWithParentElement | Nullish | Nullish\n>(\n  node: T\n): MaybeUndefined<T, string[]> => (node as any)?.getAttributeNames();\n\nexport const cssProperty = (el: Element, name: string) =>\n  getComputedStyle(el).getPropertyValue(name) || nil;\n\nlet parameters: {};\nexport const define = <\n  T,\n  P extends Record<keyof any, [any, boolean?] | undefined>\n>(\n  target: T,\n  props: P\n): T & P =>\n  ((parameters = {}),\n  (map(\n    filter(entries(props), ([_, value]) => value != nil),\n    ([name, [value, writable = F] = []]) =>\n      (parameters[name] = {\n        writable,\n        configurable: writable,\n        value,\n      })\n  ),\n  Object.defineProperties(target, parameters))) as any;\n\nexport const tagName = <T extends Element | Nullish>(\n  el: T\n): T extends Nullish ? null : string => (el != nil ? (el.tagName as any) : nil);\n\nlet pos: Position;\nexport const relativeScrollPos = (): Position => (\n  (pos = scrollPos(F)),\n  {\n    x: pos.x / (body.offsetWidth - window.innerWidth) || 0,\n    y: pos.y / (body.offsetHeight - window.innerHeight) || 0,\n  }\n);\n\nexport const scrollPos = (int?: boolean): Position => ({\n  x: round(scrollX, int),\n  y: round(scrollY, int),\n});\n\nexport const matchExHash = (href1: string, href2: string) =>\n  replace(href1, /#.*$/, \"\") === replace(href2, /#.*$/, \"\");\n\nlet screenPos: Position | undefined;\nexport const getScreenPos = <T extends Element | Nullish>(\n  el: T,\n  mouseEvent?: MouseEvent,\n  includeFold = T\n): MaybeUndefined<ScreenPosition> =>\n  (screenPos = getPos(el, mouseEvent)) &&\n  (restrict<ScreenPosition>({\n    xpx: screenPos.x,\n    ypx: screenPos.y,\n    x: round(screenPos.x / body.offsetWidth, 4),\n    y: round(screenPos.y / body.offsetHeight, 4),\n    pageFolds: includeFold ? screenPos.y / window.innerHeight : undefined,\n  }) as any);\n\nlet x: number;\nlet y: number;\nexport const getPos = <Nulls>(\n  el: Nullable<Element, Nulls>,\n  mouseEvent?: MouseEvent\n): MaybeUndefined<Nulls, Position> => {\n  return !!mouseEvent?.[\"pointerType\"] && mouseEvent?.pageY != nil\n    ? { x: mouseEvent.pageX, y: mouseEvent.pageY }\n    : el\n    ? (({ x, y } = getRect(el)!), { x, y })\n    : (undefined as any);\n};\n\nlet rect: DOMRect;\nexport const getRect = <Nulls>(\n  el: Nullable<Element, Nulls>\n): MaybeUndefined<Nulls, Rectangle> =>\n  el\n    ? ((rect = el.getBoundingClientRect()),\n      (pos = scrollPos(F)),\n      {\n        x: round(rect.left + pos.x),\n        y: round(rect.top + pos.y),\n        width: round(rect.width),\n        height: round(rect.height),\n      })\n    : (undefined as any);\n\ntype AllMaps = WindowEventMap &\n  GlobalEventHandlersEventMap &\n  DocumentEventMap &\n  HTMLElementEventMap & {\n    freeze: PageTransitionEvent;\n    resume: PageTransitionEvent;\n  };\n\nexport const listen = <K extends keyof AllMaps>(\n  target: {\n    addEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions\n    ): void;\n    removeEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | EventListenerOptions\n    ): void;\n  },\n  name: K | K[],\n  listener: (\n    ev: AllMaps[K extends any[] ? K[number] : K],\n    unbind?: Unbinder\n  ) => any,\n  options: AddEventListenerOptions = { capture: true, passive: true }\n): Binders => {\n  return isArray(name)\n    ? joinEventBinders(\n        ...map(name, (name) => listen(target, name as any, listener, options))\n      )\n    : createEventBinders(\n        listener,\n        (listener) => target.addEventListener(name, listener, options),\n        (listener) => target.addEventListener(name, listener, options)\n      );\n};\n\nexport const parseDomain = (href: string): Domain => {\n  const { host, scheme, port } = parseUri(href, false, true);\n  return { host: host + (port ? \":\" + port : \"\"), scheme };\n};\n\nexport const getViewportSize = (): Size => ({\n  width: window.innerWidth,\n  height: window.innerHeight,\n});\n\nexport const getViewport = (): Viewport => (\n  (pos = scrollPos(T)),\n  {\n    ...pos,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    totalWidth: body.offsetWidth,\n    totalHeight: body.offsetHeight,\n  }\n);\n","import { parseTagString, type Tag } from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  concat,\n  flatMap,\n  forEach,\n  isFunction,\n  isIterable,\n  isPlainObject,\n  isRegEx,\n  isString,\n  join,\n  map,\n  matches,\n  nil,\n  parseBoolean,\n  parseRegex,\n  replace,\n  stop,\n  testRegex,\n  values,\n  type Nullish,\n} from \"@tailjs/util\";\n\nimport {\n  NodeWithParentElement,\n  attr,\n  attributeNames,\n  createElement,\n  cssProperty,\n  forAncestorsOrSelf,\n  matchSelector,\n  trackerConfig,\n} from \"..\";\nimport type { BoundaryData, TagMappings } from \"../..\";\n\nexport const boundaryData = new WeakMap<Node, BoundaryData<true>>();\nexport const getBoundaryData = (el: Node) => boundaryData.get(el);\n\nexport const trackerPropertyName = (name: string, css = F) =>\n  (css ? \"--track-\" : \"track-\") + name;\n\n// const trackerProperty = (\n//   el: Element,\n//   name: string,\n//   value = attr(el, trackerPropertyName(name)),\n//   css = cssProperty(el as Element, trackerPropertyName(name, T))\n// ) => (value ? (css ? value + \" \" + css : value) : css);\n\ntype MatchAttributeRule = readonly [\n  match: RegExp,\n  selector?: string,\n  baseRank?: string\n];\n\ntype CacheMatchRules = [\n  eligibleCache: { [name: string]: boolean },\n  rules: MatchAttributeRule[] | Nullish\n];\n\n/**\n * Extracts an element's tags given an attribute name, and a list of rules about how to match..\n * Since this function is external, its local variables are added as local parameters. Don't tamper.\n *\n * An optional `eligibleCache` can be passed along to speed up rejecting attribute names that definitely don't match anything.\n */\nconst matchAttributeNames = (\n  el: Element | Nullish,\n  cached: CacheMatchRules | Nullish,\n  tags: Set<string>,\n  prefix?: string | boolean,\n  value?: string,\n  eligible?: boolean\n) =>\n  cached?.[1] &&\n  forEach(\n    attributeNames(el),\n    (name) =>\n      (cached[0][name] ??=\n        ((eligible = F),\n        isString(\n          (prefix =\n            // No cache. Let's loop through them then.\n            forEach(\n              cached[1],\n              ([match, selector, prefix], _) =>\n                testRegex(name, match) &&\n                // Sneakily we \"delete\" the eligible flag, so the skipNameCache's `??=` assignment will always be reevaluated.\n                // If this code branch is never hit, we return the initial value `false`, and this check will never be performed again.\n                // We do this check before the selector check, since this result is not generally cacheable.\n                ((eligible = undefined),\n                !selector || matchSelector(el, selector)) &&\n                stop(prefix ?? name)\n            ))\n        ) && // The empty string is also \"true\" since it means presence of the attribute without a value (as in `<div tag-yes />).\n          (!(value = el!.getAttribute(name)!) || parseBoolean(value)) &&\n          parseTagString(value, replace(prefix, /\\-/g, \":\"), tags),\n        eligible))\n  );\n\n// We cache the tracker configuration's rules for tag mappings.\nlet cachedTagMapper: (el: Element, tags: Set<string>) => void = () => {};\nlet cachedMappings: TagMappings | undefined;\nconst parseTagAttributes = (el: Element, tags: Set<string>) => {\n  if (cachedMappings === (cachedMappings = trackerConfig.tags)) {\n    return cachedTagMapper(el, tags);\n  }\n\n  const parse = (rule: TagMappings[string]): MatchAttributeRule[] =>\n      !rule\n        ? []\n        : isRegEx(rule)\n        ? [[rule]]\n        : isIterable(rule)\n        ? flatMap(rule, parse)\n        : [\n            isPlainObject(rule)\n              ? [parseRegex(rule.match)!, rule.selector, rule.prefix]\n              : [parseRegex(rule)!],\n          ],\n    cache: CacheMatchRules = [\n      {},\n      // Start by checking whether we have any of the good ol', documented, \"tail.js official\" tag attributes.\n      [[/^(?:track\\-)?tags?(?:$|\\-)(.*)/], ...parse(values(cachedMappings))],\n    ];\n\n  (cachedTagMapper = (el: Element, tags: Set<string>) =>\n    matchAttributeNames(el, cache, tags))(el, tags);\n};\n\nconst cssPropertyWithBase = (el: Element, name: string) =>\n  join(\n    concat(\n      cssProperty(el, trackerPropertyName(name, T)),\n      cssProperty(el, trackerPropertyName(\"base-\" + name, T))\n    ),\n    \" \"\n  );\n\n// We cannot cache as broadly for CSS based rules, so we cache per selector instead.\nconst parsedCssRules: {\n  [rule: string]: CacheMatchRules;\n} = {};\n\nconst parseCssMappingRules = (\n  el: Element,\n  tags: Set<string>,\n  rulesString = cssPropertyWithBase(el, \"attributes\")\n) => {\n  rulesString &&\n    matchAttributeNames(\n      el,\n      (parsedCssRules[rulesString] ??= [\n        {},\n        matches(\n          rulesString,\n          /(?:(\\S+)\\:\\s*)?(?:\\((\\S+)\\)|([^\\s,:]+))\\s*(?!\\S*\\:)/g,\n          (_, prefix, rule1, rule2) =>\n            [parseRegex(rule1 || rule2), , prefix] as const\n        ),\n      ]),\n      tags\n    );\n  parseTagString(cssPropertyWithBase(el, \"tags\"), undefined, tags);\n};\n\nlet currentBoundaryData: BoundaryData<true> | Nullish;\nexport const trackerProperty = (\n  el: Element,\n  name: string,\n  inherit:\n    | boolean\n    | ((el: NodeWithParentElement, distance: number) => boolean) = F,\n  boundaryData?: (el: BoundaryData<true>) => string | Nullish\n): string | null =>\n  (inherit\n    ? forAncestorsOrSelf(\n        el,\n        (el, r) => r(trackerProperty(el, name, F)),\n        isFunction(inherit) ? inherit : undefined\n      )\n    : join(\n        concat(\n          attr(el, trackerPropertyName(name)),\n          cssProperty(el, trackerPropertyName(name, T))\n        ),\n        \" \"\n      )) ??\n  (boundaryData &&\n    (currentBoundaryData = getBoundaryData(el)) &&\n    boundaryData(currentBoundaryData)) ??\n  nil;\n\nlet propertyValue: string | Nullish;\nexport const trackerFlag = (\n  el: Element,\n  name: string,\n  inherit:\n    | boolean\n    | ((el: NodeWithParentElement, distance: number) => boolean) = F,\n  boundaryData?: (data: BoundaryData) => boolean | Nullish\n) =>\n  (propertyValue = trackerProperty(el, name, inherit, boundaryData as any)) ===\n    \"\" || (propertyValue == nil ? propertyValue : parseBoolean(propertyValue));\n\nexport type ParsedTags = { tags?: Tag[] };\n\nexport const parseTags = (\n  sourceEl: Element | Nullish,\n  stoppingCriterion?: (el: Element, distance: number) => boolean,\n  elementTagData?: (el: Element) => Iterable<Tag | Nullish> | Nullish,\n  tags?: Set<string>\n): ParsedTags =>\n  !sourceEl\n    ? {}\n    : ((tags ??= new Set<string>()),\n      parseCssMappingRules(sourceEl, tags),\n      forAncestorsOrSelf(\n        sourceEl,\n        (el) => {\n          parseTagAttributes(el, tags!);\n          parseTagString(map(elementTagData?.(el)), undefined, tags!);\n        },\n        stoppingCriterion\n      ),\n      tags.size ? { tags: [...tags] } : {});\n\nlet styleElement: Node;\nexport const injectCssDefaults = (document: Document) => {\n  document.body.appendChild(\n    (((styleElement =\n      // --track-base-attributes and --track-base-tags are not set, since they are supposed to be inherited.\n      createElement(\"style\")).innerText = `* { ${trackerPropertyName(\n      \"tags\",\n      T\n    )}:; ${trackerPropertyName(\"attributes\", T)}:;}`),\n    styleElement)\n  );\n};\n","import msgpack from \"@ygoe/msgpack\";\nconst { deserialize, serialize } = msgpack;\n\nimport {\n  IsNever,\n  Nullish,\n  isObject,\n  isArray,\n  isFunction,\n  isIterable,\n  isNumber,\n  isPlainObject,\n  isString,\n  isSymbol,\n  map,\n  tryCatch,\n  undefined,\n} from \"@tailjs/util\";\nimport { HashFunction, from64u, lfsr, to64u } from \".\";\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\nexport type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the constract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properies that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param validate This property has no effect other than letting TypeScript validate whether the value can be deserialized back to its original form without losing properties.\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  (value: any, validate?: false): string;\n  <T = Encodable>(value: T & EncodableContract<T>, validate: true): string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(encoded: string | Nullish) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\n/**\n * Misc. fixes to the msgpack library. For example, it does not handle exponential numbers well.\n */\nconst patchSerialize = (value: any) => {\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number;\n  const patchProperty = (\n    value: any,\n    key: any,\n    val = value[key],\n    patched = inner(val)\n  ) => (\n    (val !== patched || isSymbol(key)) &&\n      ((value[key] = patched), addCleaner(() => (value[key] = val))),\n    val\n  );\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (value == null || isFunction(value) || isSymbol(value)) {\n      return null;\n    }\n\n    // if (Number.isFinite(value) && !Number.isSafeInteger(value)) {\n    //   // A bug in @ygoe/msgpack means floats do not get encoded. We need to encode them in a different way.\n    //   // This is how it landed, since data structure is highly unlikely to be encountered,\n    //   // yet it is probably not the best way to do this (apart from fixing the bug ofc.)\n    //   floatView.setFloat64(0, value, true);\n    //   return { \"\": [...new Uint32Array(floatBuffer)] };\n    // }\n\n    if (!isObject(value)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if ((refIndex = (refs ??= new Map()).get(value)) != null) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isPlainObject(value)) {\n      refs.set(value, refs.size + 1);\n\n      Object.keys(value).forEach(\n        (k) =>\n          (patchProperty(value, k) === undefined || isSymbol(k)) &&\n          delete (value as any)[k]\n      );\n    } else if (isIterable(value)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  const serialized = serialize(inner(value));\n  cleaners?.forEach((cleaner) => cleaner());\n  return serialized;\n};\n\nconst patchDeserialize = (value: Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value)) return value;\n\n    // if (isArray(value[\"\"]) && (value = value[\"\"]).length === 2) {\n    //   return new DataView(new Uint32Array(value).buffer).getFloat64(0, true);\n    // }\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return value != null ? inner(deserialize(value)) : undefined;\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<any>\n];\n\nlet _defaultTransports: [cipher: Transport, json: Transport] | undefined;\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lfsr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (\n  key?: string | Nullish,\n  json = false,\n  jsonDecodeFallback = true\n): Transport => {\n  const factory = (\n    key?: string | Nullish,\n    json = false,\n    jsonDecodeFallback = true\n  ): Transport => {\n    const fastStringHash = (value: any, bitsOrNumeric: any) => {\n      if (isNumber(value) && bitsOrNumeric === true) return value;\n\n      value = isString(value)\n        ? new Uint8Array(map(value.length, (i) => value.charCodeAt(i) & 255))\n        : json\n        ? JSON.stringify(value)\n        : patchSerialize(value);\n      return hash(value, bitsOrNumeric);\n    };\n    const jsonDecode = (encoded: any) =>\n      encoded == null\n        ? undefined\n        : tryCatch(() => JSON.parse(encoded, undefined));\n    if (json) {\n      return [\n        (data: any) => JSON.stringify(data),\n        jsonDecode,\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ];\n    }\n    const [encrypt, decrypt, hash] = lfsr(key);\n\n    return [\n      (data: any) => to64u(encrypt(patchSerialize(data))),\n      (encoded: any) =>\n        encoded != null\n          ? // JSON fallback.\n            jsonDecodeFallback && (encoded?.[0] === \"{\" || encoded?.[0] === \"[\")\n            ? jsonDecode(encoded)\n            : patchDeserialize(decrypt(from64u(encoded)))\n          : null,\n      (value: any, numericOrBits?: any) =>\n        fastStringHash(value, numericOrBits) as any,\n    ];\n  };\n\n  if (!key) {\n    return (_defaultTransports ??= [factory(null, false), factory(null, true)])[\n      +json\n    ];\n  }\n  return factory(key, json, jsonDecodeFallback);\n};\n\nexport const defaultTransport = createTransport();\nexport const defaultJsonTransport = createTransport(null, true);\n\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\n","import { isPostResponse } from \"@tailjs/types\";\nimport {\n  If,\n  NOOP,\n  Nullish,\n  PrettifyIntersection,\n  clock,\n  createEvent,\n  delay,\n  escapeRegEx,\n  forEachAsync,\n  isFunction,\n  match,\n  throwError,\n  undefined,\n  stop,\n} from \"@tailjs/util\";\nimport {\n  REQUEST_LOCK_KEY,\n  httpDecrypt,\n  httpEncrypt,\n  sharedLock,\n  trackerConfig,\n} from \".\";\n\nexport type RequestOptions<Beacon extends boolean = false> =\n  PrettifyIntersection<\n    {\n      encrypt?: boolean;\n    } & If<Beacon, { beacon: true }, { beacon?: false }>\n  >;\n\nconst [addRequestHandler, dispatchRequest] =\n  createEvent<\n    [url: string, data: any, retry: number, update: (data: any) => void]\n  >();\nconst [addResponseHandler, dispatchResponse] = createEvent<[response: any]>();\nexport { addRequestHandler, addResponseHandler };\n\nconst requestLock = sharedLock(REQUEST_LOCK_KEY);\n\nlet pushCookieMatcher: RegExp | undefined;\nlet pushCookie: string | Nullish;\nconst pollPushCookie = clock(() => {\n  if (pushCookie !== (pushCookie = trackerConfig.pushCookie)) {\n    if (!pushCookie) return;\n    pushCookieMatcher = new RegExp(escapeRegEx(pushCookie) + \"=([^;]*)\");\n  }\n  const value = httpDecrypt?.(match(document.cookie, pushCookieMatcher)?.[1]);\n  if (isPostResponse(value)) {\n    dispatchResponse(value);\n  }\n}, 1000);\n\n/** The number of \"threads\" anticipating a push cookie. When this is zero, the poll frequency goes down. */\nlet pushExpectations = 0;\n/**\n *  Call this before making a request or otherwise doing something where you anticipate the server to set a push cookie.\n *  (Preparing for a redirect that pushes a cookie via context menu navigation is an example that does not make a request per se.)\n *\n *  Call the function returned as soon as possible, and DEFINITELY call the function at some point if a non-positive timeout is used\n *  lest eager polling will get stuck indefinitely.\n * */\nexport const anticipatePushCookie = (timeout = 1000) => {\n  let pushTimeout = 0;\n  let done = () => {\n    done = NOOP; // Prevent further invocations.\n    if (!--pushExpectations) {\n      pollPushCookie.restart(1000);\n      clearTimeout(pushTimeout);\n    }\n  };\n  if (!pushExpectations++) {\n    pollPushCookie.restart(100);\n  }\n  timeout > 0 && setTimeout(done, timeout);\n  return done();\n};\n\n/**\n * If a function, this is run before a request is made (including retries). It is run within the lock, and allows the requested data to be modified.\n * If it returns false, the request is aborted and if it returns `undefined` or `true` the existing data is used.\n */\ntype RequestData<T> =\n  | T\n  | ((data: T | undefined, retry: number) => T | boolean | undefined);\n\nexport const request: {\n  <Data = any, Response = any>(\n    url: string,\n    data: RequestData<Data>,\n    options?: RequestOptions<false>\n  ): Promise<Response>;\n  <Data = any>(\n    url: string,\n    data: RequestData<Data>,\n    options: RequestOptions<true>\n  ): void;\n} = async (\n  url: string,\n  data: any,\n  { beacon = false, encrypt = true }: RequestOptions<boolean> = {}\n) => {\n  let cancel = false;\n  let currentData: any;\n  let serialized: any;\n\n  const prepareRequestData = (retry: number) => {\n    const prepareResult = isFunction(data) ? data?.(currentData, retry) : data;\n    if (prepareResult === false) {\n      return false;\n    }\n\n    prepareResult != null &&\n      prepareResult !== true &&\n      (currentData = prepareResult);\n\n    dispatchRequest(\n      url,\n      currentData,\n      retry,\n      (newData) => (\n        (cancel = currentData === undefined), (currentData = newData)\n      )\n    );\n\n    return cancel\n      ? false\n      : (serialized = (encrypt ? httpEncrypt : (JSON.stringify as any))(\n          currentData\n        ));\n  };\n\n  if (beacon) {\n    if (!prepareRequestData(0)) return;\n    anticipatePushCookie(1000);\n\n    !navigator.sendBeacon(\n      url,\n      new Blob(currentData != null ? [serialized] : [], {\n        // This content type avoids the overhead of the \"preflight\" request that is otherwise made by browsers in cross-domain scenarios.\n        // (application/x-www-form-urlencoded could also work).\n        type: \"text/plain\",\n      })\n    ) && throwError(\"Beacon send failed.\");\n  } else {\n    let retries = 1;\n    return await requestLock(() =>\n      forEachAsync(1, async (retry) => {\n        if (!prepareRequestData(retry)) return stop();\n\n        const response = await fetch(url, {\n          method: currentData != null ? \"POST\" : \"GET\",\n          cache: \"no-cache\",\n          credentials: \"include\",\n          mode: \"cors\",\n          headers: {\n            \"Content-Type\": \"text/plain\",\n          },\n          body: serialized,\n        });\n\n        if (response.status >= 400) {\n          return retry === retries - 1\n            ? stop(throwError(`Invalid response: ${await response.text()}`))\n            : (console.warn(\n                `Request to ${url} failed on attempt ${retry + 1}/${3}.`\n              ),\n              await delay((1 + retry) * 200));\n        }\n\n        const responseText = await response.text();\n\n        const parsed = responseText?.length\n          ? (encrypt ? httpDecrypt : JSON.parse)?.(responseText)\n          : undefined;\n\n        console.log(JSON.stringify(parsed, null, 2));\n\n        if (parsed != null) {\n          dispatchResponse(parsed);\n        }\n        return stop(parsed);\n      })\n    );\n  }\n};\n","import { LocalID, View, ViewEvent, isViewEvent } from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  add,\n  clock,\n  createEvent,\n  createTimer,\n  forEach,\n  map,\n  nil,\n  now,\n  parseQueryString,\n  parseUri,\n  push,\n  replace,\n  structuralEquals,\n} from \"@tailjs/util\";\nimport { TrackerExtensionFactory, isChangeUserCommand } from \"..\";\nimport { tracker } from \"../initializeTracker\";\nimport {\n  LocalVariableScope,\n  TAB_ID,\n  addPageActivatedListener,\n  addPageVisibleListener,\n  deltaDiff,\n  getViewport,\n  isInternalUrl,\n  listen,\n  matchExHash,\n  nextId,\n  parseDomain,\n  setLocalVariables,\n  tryGetVariable,\n} from \"../lib2\";\n\nexport let currentViewEvent: ViewEvent | undefined;\n\nexport const getCurrentViewId = () => currentViewEvent?.clientId;\n\nlet pushPopNavigation: ViewEvent[\"navigationType\"] | undefined;\n\nconst referrerKey = {\n  scope: \"shared\",\n  key: \"referrer\",\n} as const;\n\nexport const pushNavigationSource = (\n  navigationEventId: LocalID,\n  consumed?: () => void\n) => {\n  tracker.variables.set({\n    ...referrerKey,\n    value: [getCurrentViewId()!, navigationEventId],\n  });\n\n  consumed &&\n    tracker.variables.get({\n      // Grr! Intellisense won't use the constant scope and key values if `...referrerKey`.\n      scope: referrerKey.scope,\n      key: referrerKey.key,\n      result: (current: any, previous: any, poll) => {\n        current\n          ? poll()\n          : previous?.value?.[1] === navigationEventId && consumed();\n      },\n    });\n};\n\nconst totalDuration = createTimer();\nconst visibleDuration = createTimer();\nconst interactiveDuration = createTimer();\nlet activations = 1;\n\nexport const getVisibleDuration = () => visibleDuration();\n\nconst [addViewChangedListener, dispatchViewChanged] =\n  createEvent<[viewEvent: ViewEvent]>();\n\nexport { addViewChangedListener };\n\nexport const createViewDurationTimer = (started?: boolean) => {\n  const totalTime = createTimer(started, totalDuration);\n  const visibleTime = createTimer(started, visibleDuration);\n  const interactiveTime = createTimer(started, interactiveDuration);\n  const activationsCounter = createTimer(started, () => activations);\n  return (toggle?: boolean, reset?: boolean) => ({\n    totalTime: totalTime(toggle, reset),\n    visibleTime: visibleTime(toggle, reset),\n    interactiveTime: interactiveTime(toggle, reset),\n    activations: activationsCounter(toggle, reset),\n  });\n};\n\nconst timer = createViewDurationTimer();\nexport const getViewTimeOffset = () => timer();\n\nconst [onFrame, callOnFrame] = createEvent<[frame: HTMLIFrameElement]>();\nexport { onFrame };\n\nconst knownFrames = new WeakSet<any>();\nconst frames = document.getElementsByTagName(\"iframe\");\n\nexport const context: TrackerExtensionFactory = {\n  id: \"context\",\n  setup(tracker) {\n    clock(\n      () =>\n        forEach(\n          frames as any as Iterable<HTMLIFrameElement>,\n          (frame) => add(knownFrames, frame) && callOnFrame(frame)\n        ),\n      -1000\n    ).trigger();\n\n    tracker.push({\n      get: [\n        {\n          scope: \"view\",\n          key: \"view\",\n          result: (value) => {\n            value;\n          },\n        },\n      ],\n    });\n    // Keep track of when new views are set.\n    // A view is considered new if either 1) it is different (duh) or 2) set from a different href.\n    // This is to prevent stray updates from, say, React components that may set the variable every time they rerender.\n\n    // TODO: Move to separate function.\n\n    /** This contains the next view for view events. It is cleared when the view event is posted.  */\n    let nextView: View | undefined;\n    let previousHref: string;\n    let currentView: View | undefined;\n    tracker.variables.get({\n      scope: \"view\",\n      key: \"view\",\n      result: (value, _, poll) => {\n        // Only update the view\n        (!structuralEquals(currentView, value?.value) ||\n          previousHref !== (previousHref = \"\" + location.href)) &&\n          (nextView = currentView = value?.value);\n\n        if (nextView && currentViewEvent && !currentViewEvent.definition) {\n          currentViewEvent.definition = nextView;\n          if (currentViewEvent.metadata?.posted) {\n            // Send the definition as a patch because the view event has already been posted.\n            tracker.events.postPatch(currentViewEvent, {\n              definition: nextView,\n            });\n          }\n          nextView = undefined;\n        }\n\n        return poll();\n      },\n    });\n\n    let localIndex = tryGetVariable({ scope: \"tab\", key: \"index\" })?.value ?? 0;\n    let globalIndex = tryGetVariable({ scope: \"tab\", key: \"index\" })?.value;\n    if (globalIndex == null) {\n      globalIndex =\n        tryGetVariable({ scope: \"shared\", key: \"index\" })?.value ?? 0;\n      setLocalVariables({\n        scope: LocalVariableScope.Shared,\n        key: \"index\",\n        value: globalIndex + 1,\n      });\n    }\n\n    let currentLocation: string | null = nil;\n\n    const postView = (force = F) => {\n      if (\n        matchExHash(\"\" + currentLocation, (currentLocation = location.href)) &&\n        !force\n      ) {\n        return;\n      }\n\n      const {\n        source: href,\n        scheme,\n        host,\n      } = parseUri(location.href + \"\", true, true);\n      currentViewEvent = {\n        type: \"view\",\n        timestamp: now(),\n        clientId: nextId(),\n        tab: TAB_ID,\n        href,\n        path: location.pathname,\n        hash: location.hash || undefined,\n        domain: { scheme, host },\n        tabIndex: globalIndex,\n        viewport: getViewport(),\n        duration: timer(undefined, true),\n      };\n\n      globalIndex === 0 && (currentViewEvent.firstTab = T);\n      globalIndex === 0 &&\n        localIndex === 0 &&\n        (currentViewEvent.landingPage = T);\n\n      const qs = parseQueryString(location.href);\n      map(\n        [\"source\", \"medium\", \"campaign\", \"term\", \"content\"],\n        (p, _) => ((currentViewEvent!.utm ??= {})[p] = qs[`utm_${p}`]?.[0])\n      );\n\n      !(currentViewEvent.navigationType = pushPopNavigation) &&\n        performance &&\n        map(\n          performance.getEntriesByType(\"navigation\"),\n          (entry: PerformanceNavigationTiming) => {\n            currentViewEvent!.redirects = entry.redirectCount;\n            currentViewEvent!.navigationType = replace(\n              entry.type,\n              /\\_/g,\n              \"-\"\n            ) as any;\n          }\n        );\n\n      pushPopNavigation = undefined;\n\n      if ((currentViewEvent.navigationType ??= \"navigate\") === \"navigate\") {\n        // Try find related event and parent tab context if any.\n        // And only if navigating (not back/forward/refresh)\n\n        const referrer = tryGetVariable(referrerKey)?.value;\n\n        if (referrer && isInternalUrl(document.referrer)) {\n          currentViewEvent.view = referrer?.[0];\n          currentViewEvent.relatedEventId = referrer?.[1];\n          tracker.variables.set({ ...referrerKey, value: undefined });\n        }\n      }\n\n      // Referrer\n      const referrer = document.referrer || nil;\n      referrer &&\n        !isInternalUrl(referrer) &&\n        (currentViewEvent!.externalReferrer = {\n          href: referrer,\n          domain: parseDomain(referrer),\n        });\n\n      // If we already have a view ready, set this on the event.\n      currentViewEvent.definition = nextView;\n      nextView = undefined;\n      tracker.events.post(currentViewEvent);\n\n      tracker.events.registerEventPatchSource(currentViewEvent!, (previous) =>\n        deltaDiff(\n          {\n            duration: getViewTimeOffset(),\n          },\n          previous\n        )\n      );\n\n      dispatchViewChanged(currentViewEvent);\n    };\n\n    addPageActivatedListener((activated) => interactiveDuration(activated));\n    addPageVisibleListener((visible) => {\n      if (visible) {\n        visibleDuration(T);\n        ++activations;\n      } else {\n        visibleDuration(F);\n        interactiveDuration(F);\n      }\n    });\n\n    listen(\n      window,\n      \"popstate\",\n      () => ((pushPopNavigation = \"back-forward\"), postView())\n    );\n    map([\"push\", \"replace\"], (name) => {\n      const inner = history[(name += \"State\")];\n      history[name] = (...args: any) => {\n        inner.apply(history, args);\n        pushPopNavigation = \"navigate\";\n        postView();\n      };\n    });\n\n    postView();\n\n    return {\n      processCommand: (command) =>\n        isChangeUserCommand(command) &&\n        (push(\n          tracker,\n          command.username\n            ? { type: \"login\", username: command.username }\n            : { type: \"logout\" }\n        ),\n        T),\n\n      decorate: (event) => {\n        currentViewEvent &&\n          !isViewEvent(event) &&\n          (event.view = currentViewEvent.clientId);\n      },\n    };\n  },\n};\n","import {\n  type ActivatedComponent,\n  type ActivatedContent,\n  type ConfiguredComponent,\n  type Rectangle,\n  type UserInteractionEvent,\n} from \"@tailjs/types\";\nimport {\n  F,\n  MaybeUndefined,\n  Nullish,\n  T,\n  array,\n  concat,\n  filter,\n  flatMap,\n  forEach,\n  get,\n  isString,\n  join,\n  map,\n  max,\n  push,\n  remove,\n  some,\n  unshift,\n  update,\n} from \"@tailjs/util\";\nimport {\n  BoundaryCommand,\n  BoundaryData,\n  TrackerExtensionFactory,\n  isDataBoundaryCommand,\n  isScanComponentsCommand,\n} from \"..\";\nimport {\n  NodeWithParentElement,\n  boundaryData,\n  createImpressionObserver,\n  forAncestorsOrSelf,\n  getRect,\n  parseTags,\n  scanAttributes,\n  trackerProperty,\n} from \"../lib2\";\nexport type ActivatedDomComponent = ConfiguredComponent & ActivatedComponent;\n\nexport const componentDomConfiguration = Symbol(\"DOM configuration\");\n\nexport const parseActivationTags = (el: Element) =>\n  parseTags(el, undefined, (el) => map(array(get(boundaryData, el)?.tags)));\n\nconst hasComponentOrContent = (boundary?: BoundaryData<true> | null) =>\n  boundary?.component || boundary?.content;\n\nlet entry: BoundaryData<true> | undefined;\nexport const parseBoundaryTags = (el: Element) => {\n  return parseTags(\n    el,\n    (ancestor) =>\n      ancestor !== el && !!hasComponentOrContent(get(boundaryData, ancestor)),\n    (el) => {\n      entry = get(boundaryData, el)!;\n      return (\n        (entry = get(boundaryData, el)) &&\n        flatMap(concat(entry.component, entry.content, entry), \"tags\")\n      );\n    }\n  );\n};\n\nlet content: ActivatedContent[] | undefined;\nconst stripRects = (\n  component: ActivatedDomComponent,\n  keep?: boolean\n): ActivatedDomComponent =>\n  keep\n    ? component\n    : {\n        ...component,\n        rect: undefined,\n        content:\n          (content = component.content) &&\n          map(content, (content) => ({ ...content, rect: undefined })),\n      };\n\nconst enum IncludeState {\n  Secondary = 0,\n  Primary = 1,\n  Promoted = 2,\n}\n\nexport const getComponentContext = (\n  el: NodeWithParentElement,\n  directOnly = F\n) => {\n  let collectedContent: ActivatedContent[] = [];\n\n  type Area = {} & string; // For clarity.\n  let collected: (ActivatedDomComponent | Area)[] = [];\n\n  let includeState = IncludeState.Secondary;\n  let rect: Rectangle | undefined;\n  forAncestorsOrSelf(el, (el) => {\n    const entry = get(boundaryData, el);\n    if (!entry) {\n      return;\n    }\n\n    if (hasComponentOrContent(entry)) {\n      const components = filter(\n        array(entry.component),\n        (entry) =>\n          includeState === IncludeState.Secondary ||\n          (!directOnly &&\n            ((includeState === IncludeState.Primary &&\n              entry.track?.secondary !== T) ||\n              entry.track?.promote))\n      );\n\n      rect =\n        (some(components, (item) => item.track?.region) && getRect(el)) ||\n        undefined;\n      const tags = parseBoundaryTags(el);\n      entry.content &&\n        unshift(\n          collectedContent,\n          ...map(entry.content, (item) => ({\n            ...item,\n            rect,\n            ...tags,\n          }))\n        );\n\n      components?.length &&\n        (unshift(\n          collected,\n          ...map(\n            components,\n            (item) => (\n              (includeState = max(\n                includeState,\n                item.track?.secondary // INV: Secondary components are only included here if we did not have any components from a child element.\n                  ? IncludeState.Primary\n                  : IncludeState.Promoted\n              )),\n              stripRects(\n                {\n                  ...item,\n                  content: collectedContent,\n                  rect,\n                  ...tags,\n                },\n                !!rect\n              )\n            )\n          )\n        ),\n        (collectedContent = []));\n    }\n\n    const area = entry.area || trackerProperty(el, \"area\");\n    area && unshift(collected, ...map(area));\n  });\n\n  let areaPath: string[] | undefined;\n  let components: ActivatedComponent[] | undefined;\n\n  if (collectedContent.length) {\n    // Content without a containing component is gathered in an ID-less component.\n    push(collected, stripRects({ id: \"\", rect, content: collectedContent }));\n  }\n\n  forEach(collected, (item) => {\n    if (isString(item)) {\n      push((areaPath ??= []), item);\n    } else {\n      item.area ??= join(areaPath, \"/\");\n      unshift((components ??= []), item);\n    }\n  });\n\n  return components || areaPath\n    ? { components: components, area: join(areaPath, \"/\") }\n    : undefined;\n};\n\nexport const components: TrackerExtensionFactory = {\n  id: \"components\",\n  setup(tracker) {\n    const impressions = createImpressionObserver(tracker);\n\n    const normalizeBoundaryData = <T extends BoundaryData | Nullish>(\n      data: T\n    ): MaybeUndefined<T, BoundaryData<true>> =>\n      data == null\n        ? (undefined as any)\n        : ({\n            ...data,\n            component: array(data.component),\n            content: array(data.content),\n            tags: array(data.tags),\n          } as BoundaryData<true>);\n\n    const registerComponent = ({\n      boundary: el,\n      ...command\n    }: BoundaryCommand) => {\n      update(boundaryData, el, (current) =>\n        normalizeBoundaryData(\n          \"add\" in command\n            ? {\n                ...current,\n                component: concat(current?.component, command.component),\n                content: concat(current?.content, command.content),\n                area: command?.area ?? current?.area,\n                tags: concat(current?.tags, command.tags),\n                cart: command.cart ?? current?.cart,\n                track: command.track ?? current?.track,\n              }\n            : \"update\" in command\n            ? command.update(current)\n            : command\n        )\n      );\n\n      impressions(el, get(boundaryData, el));\n    };\n\n    return {\n      decorate(eventData) {\n        // Strip tracking configuration.\n        forEach((eventData as UserInteractionEvent).components, (component) =>\n          remove(component as any, \"track\")\n        );\n      },\n      processCommand(cmd) {\n        return isDataBoundaryCommand(cmd)\n          ? (registerComponent(cmd), T)\n          : isScanComponentsCommand(cmd)\n          ? (map(\n              scanAttributes(cmd.scan.attribute, cmd.scan.components),\n              registerComponent\n            ),\n            T)\n          : F;\n      },\n    };\n  },\n};\n","import { SCOPE_INFO_KEY } from \"@constants\";\nimport { SessionInfo, TrackedEvent, isTrackedEvent } from \"@tailjs/types\";\nimport {\n  F,\n  MAX_SAFE_INTEGER,\n  T,\n  array,\n  assign,\n  define,\n  filter,\n  flatMap,\n  isArray,\n  isString,\n  map,\n  nil,\n  now,\n  push,\n  remove,\n  required,\n  sort,\n  throwError,\n  tryCatch,\n  type Nullish,\n} from \"@tailjs/util\";\nimport {\n  Listener,\n  Tracker,\n  TrackerCommand,\n  TrackerConfiguration,\n  TrackerExtension,\n  defaultExtensions,\n  isExtensionCommand,\n  isFlushCommand,\n  isGetCommand,\n  isListenerCommand,\n  isSetCommand,\n  isTagAttributesCommand,\n  isToggleCommand,\n  isTrackerAvailableCommand,\n  postUserAgentEvent,\n} from \".\";\nimport {\n  ERR_INTERNAL_ERROR,\n  ERR_INVALID_COMMAND,\n  TrackerContext,\n  VAR_URL,\n  addStateListener,\n  createEventQueue,\n  createVariableStorage,\n  httpDecode,\n  isTracker,\n  nextId,\n  setStorageKey,\n  trackerConfig,\n  window,\n} from \"./lib2\";\nimport { errorLogger, logError } from \"./lib2/errors\";\n\nexport let tracker: Tracker;\nexport const initializeTracker = (config: TrackerConfiguration | string) => {\n  if (tracker) return tracker;\n\n  isString(config) && (config = httpDecode<TrackerConfiguration>(config)!);\n  assign(trackerConfig, config);\n\n  setStorageKey(remove(trackerConfig, \"clientKey\"));\n\n  const apiKey = remove(trackerConfig, \"apiKey\");\n\n  const queuedCommands = window[trackerConfig.name] ?? [];\n  if (!isArray(queuedCommands)) {\n    throwError(\n      `The global variable for the tracker \"${trackerConfig.name}\" is used for something else than an array of queued commands.`\n    );\n    return;\n  }\n\n  // Extensions / listeners\n  const extensions: [number, TrackerExtension][] = [];\n  let listeners: Listener[] = [];\n  // Extensions may post commands when constructed and while the tracker is initializing\n\n  const callListeners = (event: string, ...args: any[]) => {\n    let keep = T;\n    listeners = filter(listeners, (listener) =>\n      tryCatch(\n        () => (\n          listener[event]?.(...args, {\n            tracker: tracker,\n            unsubscribe: () => (keep = F),\n          }),\n          keep // Will be set synchronously in the unsubscribe handler before this value is returned.\n        ),\n        errorLogger(listener)\n      )\n    );\n  };\n\n  const pendingStateCommands: TrackerCommand[] = [];\n\n  const trackerContext: TrackerContext = {\n    applyEventExtensions(event) {\n      event.clientId ??= nextId();\n      event.timestamp ??= now();\n\n      insertArgs = T;\n      let skip = F;\n      map(extensions, ([, extension]) => {\n        if (skip || extension.decorate?.(event) === F) {\n          skip = T;\n        }\n      });\n\n      return skip ? undefined : event;\n    },\n  };\n  // Variables\n  const variables = createVariableStorage(VAR_URL, trackerContext);\n\n  // Main\n  const events = createEventQueue(VAR_URL, trackerContext);\n\n  let mainArgs: TrackerCommand[] | null = nil;\n  let currentArg = 0;\n  let insertArgs = F;\n\n  let globalStateResolved = F;\n\n  define(window, [\n    {\n      [trackerConfig.name]: [\n        (tracker = Object.freeze({\n          id: \"tracker_\" + nextId(),\n          events,\n          variables,\n          push: ((...commands: (TrackerCommand | string)[]) => {\n            if (!mainArgs && apiKey) {\n              if (commands[0] !== apiKey) {\n                throw new Error(\"Invalid API key.\");\n              }\n              commands.splice(0, 1);\n            }\n\n            if (!commands.length) {\n              return;\n            }\n\n            let flush = F; // // Flush after these commands, optionally without waiting for other requests to finish (because the page is unloading and we have no better option even though it may split sessions.)\n\n            commands = filter(\n              flatMap(commands, (command) =>\n                isString(command)\n                  ? httpDecode<TrackerCommand>(command)\n                  : command\n              ),\n              (command) => {\n                if (!command) return F;\n\n                if (isTagAttributesCommand(command)) {\n                  trackerConfig.tags = assign(\n                    {} as any,\n                    trackerConfig.tags,\n                    command.tagAttributes\n                  );\n                } else if (isToggleCommand(command)) {\n                  trackerConfig.disabled = command.disable;\n                  return F;\n                } else if (isFlushCommand(command)) {\n                  flush = T;\n                  return F;\n                } else if (isTrackerAvailableCommand(command)) {\n                  command(tracker);\n                  return F;\n                }\n                if (\n                  !globalStateResolved &&\n                  !isListenerCommand(command) &&\n                  !isExtensionCommand(command)\n                ) {\n                  pendingStateCommands.push(command);\n                  return F;\n                }\n                // #endregion\n                return T;\n              }\n            );\n\n            if (!commands.length && !flush) {\n              return;\n            }\n\n            const getCommandRank = (cmd: TrackerCommand) =>\n              isExtensionCommand(cmd)\n                ? -100\n                : isListenerCommand(cmd)\n                ? -50\n                : isSetCommand(cmd)\n                ? -10\n                : isTrackedEvent(cmd)\n                ? 90\n                : 0;\n\n            // Put events last to allow listeners and interceptors from the same batch to work on them.\n            // Sets come before gets to avoid unnecessary waiting\n            // Extensions then listeners are first so they can evaluate the rest.\n            const expanded: TrackerCommand[] = sort(commands, getCommandRank);\n\n            // Allow nested calls to tracker.push from listeners and interceptors. Insert commands in the currently processed main batch.\n            if (\n              mainArgs &&\n              mainArgs.splice(\n                insertArgs ? currentArg + 1 : mainArgs.length,\n                0,\n                ...expanded\n              )\n            )\n              return;\n\n            mainArgs = expanded;\n\n            for (currentArg = 0; currentArg < mainArgs.length; currentArg++) {\n              if (!mainArgs[currentArg]) continue;\n              tryCatch(\n                () => {\n                  const command = mainArgs![currentArg];\n                  callListeners(\"command\", command);\n                  insertArgs = F;\n                  if (isTrackedEvent(command)) {\n                    events.post(command, false);\n                  } else if (isGetCommand(command)) {\n                    variables.get(...array(command.get));\n                  } else if (isSetCommand(command)) {\n                    variables.set(...array(command.set));\n                  } else if (isListenerCommand(command)) {\n                    push(listeners, command.listener);\n                  } else if (isExtensionCommand(command)) {\n                    let extension: TrackerExtension | Nullish;\n                    if (\n                      (extension = tryCatch(\n                        () => command.extension.setup(tracker),\n                        (e) => logError(command.extension.id, e)\n                      )!)\n                    ) {\n                      push(extensions, [command.priority ?? 100, extension]);\n                      sort(extensions, ([priority]) => priority);\n                    }\n                  } else if (isTrackerAvailableCommand(command)) {\n                    command(tracker); // Variables have already been loaded once.\n                  } else {\n                    let success = F;\n                    for (const [, extension] of extensions) {\n                      if (\n                        (success = extension.processCommand?.(command) ?? F)\n                      ) {\n                        break;\n                      }\n                    }\n                    !success && logError(ERR_INVALID_COMMAND, command);\n                  }\n                },\n                (e) => logError(tracker, ERR_INTERNAL_ERROR, e)\n              );\n            }\n\n            mainArgs = nil;\n            if (flush) {\n              events.post([], true);\n            }\n          }) as any,\n          [isTracker]: T,\n        })),\n      ],\n    },\n  ]);\n\n  addStateListener(async (event, _1, _2, unbind) => {\n    // Make sure we have a session on the server before posting anything.\n    // As part of this, we also get the device session ID.\n    if (event === \"ready\") {\n      const session = required(\n        await variables.get({\n          scope: \"session\",\n          key: SCOPE_INFO_KEY,\n          cache: MAX_SAFE_INTEGER,\n        }).value,\n        \"No session data.\"\n      ) as SessionInfo;\n      trackerContext.deviceSessionId = session.deviceSessionId;\n\n      if (!session.hasUserAgent) {\n        postUserAgentEvent(tracker);\n        session.hasUserAgent = true;\n      }\n      globalStateResolved = true;\n      pendingStateCommands.length && push(tracker, pendingStateCommands);\n\n      unbind();\n\n      push(\n        tracker,\n        ...map(defaultExtensions, (extension) => ({ extension })),\n        ...queuedCommands,\n        { set: { scope: \"local\", key: \"loaded\", value: true } }\n      );\n    }\n  }, true);\n\n  return tracker;\n};\n","import { EnumValue, createEnumAccessor } from \"@tailjs/util\";\n\n/**\n * Defines to which extend a piece of information relates to a natural person (user of your app or website).\n *\n * Tail.js requires all data points (data types and their properties) to be classified to prevent any data from being stored or otherwise used beyond a user's consent.\n *\n * YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with its default settings, intended design or implementation.\n *\n */\nexport enum DataClassification {\n  /**\n   * The data cannot reasonably be linked to a specific user after the user leaves the website or app, and their session ends.\n   *\n   * Tail.js will collect this kind of data in a way that does not use cookies or rely on other information persisted in the user's device.\n   *\n   * Identifying returning visitors will not be possible at this level.\n   * In-session personalization will be possible based on the actions a user has taken such as adding or removing things to a shopping basket, or reading an article.\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with its default settings, intended design or implementation.\n   */\n  Anonymous = 0,\n\n  /**\n   * The data may possibly identify the user if put into context with other data, yet not specifically on its own.\n   *\n   * Examples of data you should classify as at least indirect personal data are IP addresses, detailed location data, and randomly generated device IDs persisted over time to track returning visitors.\n   *\n   * Identifying returning visitors will be possible at this level of consent, but not across devices.\n   * Some level of personalization to returning visitors will be possible without knowing their specific preferences with certainty.\n   *\n   * This level is the default when a user has consented to necessary infomration being collected via a  cookie discalimer or similar.\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with its default settings, intended design or implementation.\n   */\n  Indirect = 1,\n\n  /**\n   * The data directly identifies the user on its own.\n   *\n   * Examples are name, username, street address and email address.\n   *\n   * Identifying returning visitors across devices will be possible at this level of consent.\n   * Personalization based on past actions such as purchases will also be possible.\n   *\n   * This level is the default should be considered the default level if users are offered an option to create a user profile or link an existing user profile from an external identity provider (Google, GitHub, Microsoft etc.).\n   *\n   * Please note it is possible to access user data even when nothing is tracked beyond the bla... level\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with default settings.\n   */\n  Direct = 2,\n\n  /**\n   * Sensitive data about a user.\n   *\n   * Examples are data related to health, financial matters, race, political and religious views, and union membership.\n   * If the user is given the option to consent at this level, it should be very clear, and you must make sure that all levels of your tail.js implementation and connected services meets the necessary levels of compliance for this in your infrastructure.\n   *\n   * Identifying returning visitors across devices will be possible at this level of consent.\n   * and so will advanced personalization.\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with default settings.\n   */\n  Sensitive = 3,\n}\n\nexport const dataClassification = createEnumAccessor(\n  DataClassification,\n  false,\n  \"data classification\"\n);\n\nexport type DataClassificationValue<Numeric = boolean> = EnumValue<\n  typeof DataClassification,\n  DataClassification,\n  false,\n  Numeric\n> extends infer T\n  ? T\n  : never;\n","import { EnumValue, createEnumAccessor } from \"@tailjs/util\";\r\n\r\n/** Data purposes are flags that can be combined, so if multiple are needed you can combine them with bitwise OR (the `|` operator).  */\r\nexport type DataPurposesFlagHint = number & {};\r\n\r\n// Grrr... We need to write out the calculated numbers for each enum value. Otherwise stupid JSON schema generator won't work.\r\n\r\n/** Purposes data can be used for, including combinations of {@link DataPurpose} */\r\nexport enum DataPurposeFlags {\r\n  /** Data without a purpose will not get stored and cannot be used for any reason. This can be used to disable parts of a schema. */\r\n  None = 0,\r\n\r\n  /**\r\n   * Data stored for this purpose is vital for the system, website or app to function.\r\n   */\r\n  Necessary = 1,\r\n\r\n  /**\r\n   * Data stored for this purpose is used for personalization or otherwise adjust the appearance of a website or app\r\n   * according to a user's preferences.\r\n   *\r\n   * DO NOT use this category if the data may be shared with third parties or otherwise used for targeted marketing outside the scope\r\n   * of the website or app. Use {@link DataPurposeFlags.Targeting} instead.\r\n   *\r\n   * It may be okay if the data is only used for different website and apps that relate to the same product or service.\r\n   * This would be the case if a user is able to use an app and website interchangeably for the same service. Different areas of a brand may\r\n   * also be distributed across multiple domain names.\r\n   *\r\n   */\r\n  Functionality = 2,\r\n\r\n  /**\r\n   * Data stored for this purpose is used to gain insights on how users interact with a website or app optionally including\r\n   * demographics and similar traits with the purpose of optimizing the website or app.\r\n   *\r\n   * DO NOT use this category if the data may be shared with third parties or otherwise used for targeted marketing outside the scope\r\n   * of the website or app. Use {@link DataPurposeFlags.Targeting} instead.\r\n   *\r\n   * It may be okay if the data is only used for different website and apps that relate to the same product or service.\r\n   * This would be the case if a user is able to use an app and website interchangeably for the same service. Different areas of a brand may\r\n   * also be distributed across multiple domain names.\r\n   *\r\n   */\r\n  Performance = 4,\r\n\r\n  /**\r\n   * Data stored for this purpose may be similar to both functionality and performance data, however it may be shared with third parties\r\n   * or otherwise used to perform marketing outside the scope of the specific website or app.\r\n   *\r\n   * If the data is only used for different website and apps that relate to the same product or service, it might not be necessary\r\n   * to use this category.\r\n   * This would be the case if a user is able to use an app and website interchangeably for the same service. Different areas of a brand may\r\n   * also be distributed across multiple domain names.\r\n   */\r\n  Targeting = 8,\r\n\r\n  /**\r\n   * Data stored for this purpose is used for security purposes. As examples, this can both be data related to securing an authenticated user's session,\r\n   * or for a website to guard itself against various kinds of attacks.\r\n   *\r\n   * This is implicitly also `Necessary`.\r\n   */\r\n  Security = 16,\r\n\r\n  /**\r\n   * Data stored for this purpose may be similar to the performance category, however it is specifically\r\n   * only used for things such as health monitoring, system performance and error logging and unrelated to user behavior.\r\n   *\r\n   * This is implicitly also `Necessary`.\r\n   */\r\n  Infrastructure = 32,\r\n\r\n  /**\r\n   * All purposes that are permissable for anonymous users.\r\n   */\r\n  Anonymous = 49, //DataPurposes.Necessary | DataPurposes.Infrastructure | DataPurposes.Security,\r\n\r\n  /**\r\n   * Data can be used for any purpose.\r\n   */\r\n  Any = 63,\r\n\r\n  /**\r\n   * The data is not available client-side.\r\n   * Note that this is a special flag that is not included in \"Any\"\r\n   */\r\n  Server = 64,\r\n}\r\n\r\nexport type DataPurpose =\r\n  | DataPurposeFlags.Necessary\r\n  | DataPurposeFlags.Functionality\r\n  | DataPurposeFlags.Performance\r\n  | DataPurposeFlags.Targeting\r\n  | DataPurposeFlags.Security\r\n  | DataPurposeFlags.Infrastructure\r\n  | DataPurposeFlags.Server;\r\n\r\nconst purePurposes: DataPurpose =\r\n  DataPurposeFlags.Necessary |\r\n  DataPurposeFlags.Functionality |\r\n  DataPurposeFlags.Performance |\r\n  DataPurposeFlags.Targeting |\r\n  DataPurposeFlags.Security |\r\n  DataPurposeFlags.Infrastructure |\r\n  DataPurposeFlags.Server;\r\n\r\nexport const dataPurposes = createEnumAccessor(\r\n  DataPurposeFlags as typeof DataPurposeFlags,\r\n  true,\r\n  \"data purpose\",\r\n  purePurposes\r\n);\r\n\r\nexport const singleDataPurpose = createEnumAccessor(\r\n  DataPurposeFlags as typeof DataPurposeFlags,\r\n  false,\r\n  \"data purpose\",\r\n  0\r\n);\r\n\r\nexport type DataPurposeValue<Numeric = boolean> = EnumValue<\r\n  typeof DataPurposeFlags,\r\n  DataPurposeFlags,\r\n  true,\r\n  Numeric\r\n>;\r\n","import {\n  EnumValue,\n  MaybePick,\n  MaybeUndefined,\n  ParsedEnumResult,\n  PartialExcept,\n  PrettifyIntersection,\n  createEnumAccessor,\n  createEnumPropertyParser,\n} from \"@tailjs/util\";\nimport {\n  DataClassification,\n  DataClassificationValue,\n  DataPurposeFlags,\n  DataPurposeValue,\n  Timestamp,\n  dataClassification,\n  dataPurposes,\n  singleDataPurpose,\n} from \"..\";\n\nexport enum VariableScope {\n  /** Global variables. */\n  Global = 0,\n\n  /**\n   * Variables related to an external identity.\n   * One use case could be used to augment data a CMS with real-time data related to personalization or testing.\n   */\n  Entity = 1,\n\n  /** Variables related to sessions. */\n  Session = 2,\n\n  /** Variables related to a device (browser or app). */\n  Device = 3,\n\n  /** Variables related to an identified user. */\n  User = 4,\n}\n\nexport const variableScope = createEnumAccessor(\n  VariableScope as typeof VariableScope,\n  false,\n  \"variable scope\"\n);\n\nexport type VariableScopeValue<Numeric extends boolean | undefined = boolean> =\n  EnumValue<typeof VariableScope, VariableScope, false, Numeric> extends infer T\n    ? T\n    : never;\n\n/** Transforms properties with known enum types to their parsable counterparts. */\nexport type Parsable<T, Numeric extends boolean | undefined = boolean> = {\n  [P in keyof T]: T[P] extends DataClassification | undefined | null\n    ? DataClassificationValue<MaybeUndefined<T[P], Numeric>>\n    : T[P] extends DataPurposeFlags | undefined | null\n    ? DataPurposeValue<MaybeUndefined<T[P], Numeric>>\n    : T[P] extends VariableScope | undefined | null\n    ? VariableScopeValue<MaybeUndefined<T[P], Numeric>>\n    : Parsable<T[P], Numeric>;\n};\n\n/**\n * Uniquely addresses a variable by scope, target and key name.\n */\nexport interface VariableKey<NumericEnums extends boolean = boolean> {\n  /** The scope the variable belongs to. */\n  scope: VariableScopeValue<NumericEnums>;\n\n  /**\n   * The name of the variable.\n   *\n   * A key may have a prefix that decides which variable storage it is routed to.\n   * The prefix and the key are separated by colon (`prefix:key`). Additional colons will be considered part of the variable name.\n   * To address a variable with a colon in its name without prefix use `:key`, for example `:colon:in:my:name`.\n   */\n  key: string;\n\n  /**\n   * The ID of the entity in the scope the variable belongs to.\n   * This is ignored for global variables, and can be set to `\"\"`.\n   */\n  targetId?: string;\n}\n\nexport type RestrictedVariable<\n  T = any,\n  NumericEnums extends boolean = true,\n  LocalScopes extends boolean = true\n> = RestrictVariableTargets<Variable<T, NumericEnums>, LocalScopes>;\n\ntype RestrictVariableItemTargets<\n  T extends readonly any[],\n  LocalScopes extends boolean\n> = T extends readonly []\n  ? []\n  : T extends [infer Item, ...infer Rest]\n  ? [\n      RestrictVariableTargets<Item, LocalScopes>,\n      ...RestrictVariableItemTargets<Rest, LocalScopes>\n    ]\n  : T extends readonly (infer T)[]\n  ? RestrictVariableTargets<T, LocalScopes>[]\n  : never;\n\nexport type RestrictVariableTargets<\n  T,\n  LocalScopes extends boolean = true\n> = boolean extends LocalScopes\n  ? T\n  : T extends readonly any[]\n  ? RestrictVariableItemTargets<T, LocalScopes>\n  : T extends { current: infer C }\n  ? PrettifyIntersection<\n      Omit<T, \"current\"> & { current: RestrictVariableTargets<C, LocalScopes> }\n    >\n  : PrettifyIntersection<\n      T extends { scope: any; targetId?: any }\n        ? Omit<T, \"targetId\"> &\n            (\n              | {\n                  scope:\n                    | VariableScope.Global\n                    | \"global\"\n                    | (LocalScopes extends true\n                        ?\n                            | VariableScope.User\n                            | \"user\"\n                            | VariableScope.Device\n                            | \"device\"\n                            | VariableScope.Session\n                            | \"session\"\n                        : never);\n                  targetId?: undefined;\n                }\n              | {\n                  scope:\n                    | (LocalScopes extends true\n                        ? never\n                        :\n                            | VariableScope.User\n                            | \"user\"\n                            | VariableScope.Device\n                            | \"device\"\n                            | VariableScope.Session\n                            | \"session\")\n                    | VariableScope.Entity\n                    | \"entity\";\n                  targetId: T[\"targetId\"] & string;\n                }\n            )\n        : T\n    >;\n\n/** Dummy function to contain variables and variable results to locally scoped targets. */\nexport const restrictTargets = <T>(value: T): RestrictVariableTargets<T> =>\n  value as any;\n\n/**\n * A {@link VariableKey} that optionally includes the expected version of a variable value.\n * This is used for \"if none match\" queries to invalidate caches efficiently.\n */\nexport interface VersionedVariableKey<NumericEnums extends boolean = boolean>\n  extends VariableKey<NumericEnums> {\n  version?: string;\n}\n\n/**\n * Defines how the value of variable is classified and for which purposes it can be used.\n */\nexport interface VariableClassification<\n  NumericEnums extends boolean = boolean\n> {\n  /**\n   * The legal classification of the kind of data a variable holds.\n   * This limits which data will be stored based on a user's consent.\n   */\n  classification: DataClassificationValue<NumericEnums>;\n\n  /**\n   * Optionally defines the possible uses of the data a variables holds (they are binary flags).\n   * When a variable is requested by some logic, it may be stated what the data is used for.\n   * If the user has not consented to data being used for this purpose the variable will not be avaiable.\n   */\n  purposes: DataPurposeValue<NumericEnums>;\n}\n\nexport const Necessary: VariableClassification<true> = {\n  classification: DataClassification.Anonymous,\n  purposes: DataPurposeFlags.Necessary,\n};\n\nexport interface VariableMetadata {\n  /**\n   * Optionally categorizes variables.\n   *\n   * For example, the tag `address` could be used for all variables related to a user's address,\n   * or `newsletter` for everything related to newsletter subscriptions.\n   */\n  tags?: string[];\n}\n\n/**\n * Information about when a variable's value was modified and a unique version (ETag) used for conflict resolution\n * in case multiple processes try to update it at the same time (optimistic concurrency).\n *\n * Only the version, and not the modified timestamp must be relied on during conflict resolution.\n */\nexport interface VariableVersion {\n  /**\n   * Timestamp for when the variable was created.\n   */\n  created?: Timestamp;\n\n  /**\n   * Timestamp for when the variable was created or modified.\n   */\n  modified?: Timestamp;\n\n  /**\n   * A unique token that changes every time a variable is changed.\n   * It follows the semantics of a \"weak\" ETag in the HTTP protocol.\n   * How the value is generated is an internal implementation detail specific to the storage that manages the variable.\n   *\n   * The value is only undefined if it is not assumed to exist before a set operation.\n   */\n  version?: string | undefined;\n}\n\n/**\n * All data related to a variable except its value.\n */\nexport interface VariableHeader<NumericEnums extends boolean = true>\n  extends VariableKey<NumericEnums>,\n    VariableClassification<NumericEnums>,\n    VariableMetadata,\n    VariableVersion {}\n\n/**\n * A variable is a specific piece of information that can be classified and changed independently.\n * A variable can either be global or related to a specific entity or tracker scope.\n */\nexport interface Variable<T = any, NumericEnums extends boolean = true>\n  extends VariableHeader<NumericEnums> {\n  /**\n   * The value of the variable is read-only. Trying to update its value in its storage will result in an error.\n   */\n  readonly?: boolean;\n\n  /**\n   * The value of the variable. It must only be undefined in a set operation in which case it means \"delete\".\n   */\n  value: T;\n}\n\n/**\n * The information needed about a variable to validate whether it complies with a user's consents,\n * or meets other authorization based requirements.\n */\nexport type VariableValidationBasis<NumericEnums extends boolean = boolean> =\n  VariableKey<NumericEnums> & Partial<VariableClassification<NumericEnums>>;\n\n/** Returns a description of a key that can be used for logging and error messages.  */\nexport const formatKey = (key: VariableKey<true> | VariableKey) =>\n  `'${key.key}' in ${variableScope.format(key.scope)} scope`;\n\n/** The individual parts of a key specifed as string. */\nexport type ParsedKey = {\n  /** The prefix of the key, or the empty string if none. */\n  prefix: string;\n\n  /** The excluding its prefix. */\n  key: string;\n\n  /** The original key string. */\n  sourceKey: string;\n\n  /** For queries. */\n  not?: boolean;\n};\n\nexport const stripPrefix = <T extends VariableKey | undefined>(key: T): T =>\n  key && { ...key, key: parseKey(key.key).key };\n\n/** Returns the individual parts of a key specified as a string.  */\nexport const parseKey = <T extends string | undefined>(\n  sourceKey: T\n): MaybeUndefined<T, ParsedKey> => {\n  if (sourceKey == null) return undefined as any;\n  const not = sourceKey[0] === \"!\";\n  if (not) {\n    sourceKey = (sourceKey.slice(1) as T)!;\n  }\n  const prefixIndex = sourceKey.indexOf(\":\");\n  const prefix = prefixIndex < 0 ? \"\" : sourceKey.substring(0, prefixIndex);\n  const key = prefixIndex > -1 ? sourceKey.slice(prefixIndex + 1) : sourceKey;\n\n  return {\n    prefix,\n    key,\n    sourceKey,\n    not,\n  } as any;\n};\n\nexport const VariableEnumProperties = {\n  scope: variableScope,\n  purpose: singleDataPurpose,\n  purposes: dataPurposes,\n  classification: dataClassification,\n} as const;\n\nexport const toNumericVariableEnums: <T>(\n  value: T\n) => ParsedEnumResult<T, [typeof VariableEnumProperties]> =\n  createEnumPropertyParser(VariableEnumProperties);\n\nexport const extractKey = <\n  T,\n  C extends undefined | Partial<VariableClassification> = undefined\n>(\n  variable: T & PartialExcept<VariableKey, \"key\">,\n  classificationSource?: C\n): T extends undefined\n  ? undefined\n  : T extends VariableKey\n  ? PrettifyIntersection<\n      MaybePick<T, keyof VariableKey> &\n        (\"scope\" extends keyof T\n          ? {\n              scope: VariableScope;\n            }\n          : never) &\n        (C extends undefined\n          ? {}\n          : MaybePick<\n              C & Partial<VariableClassification<true>>,\n              keyof VariableClassification\n            >)\n    >\n  : never =>\n  variable\n    ? ({\n        scope: variableScope(variable.scope),\n        targetId: variable.targetId,\n        key: variable.key,\n        ...(classificationSource && {\n          classification: dataClassification(\n            classificationSource.classification\n          ),\n          purposes: dataPurposes(classificationSource.purposes),\n        }),\n      } as Required<VariableKey> as any)\n    : undefined;\n","import {\r\n  EnumValue,\r\n  If,\r\n  Json,\r\n  MaybeArray,\r\n  MaybePromise,\r\n  Nullish,\r\n  PartialExcept,\r\n  ParsedValue,\r\n  PickPartial,\r\n  PrettifyIntersection,\r\n  ReplaceProperties,\r\n  ToggleReadonly,\r\n  TupleOrArray,\r\n  createEnumAccessor,\r\n  isFunction,\r\n} from \"@tailjs/util\";\r\nimport {\r\n  Variable,\r\n  VariableClassification,\r\n  VariableGetter,\r\n  VariableKey,\r\n  VariableMetadata,\r\n  VariableScope,\r\n  VariableVersion,\r\n  variableScope,\r\n} from \"..\";\r\n\r\nexport type TargetedVariableScope =\r\n  | VariableScope.Session\r\n  | VariableScope.Device\r\n  | VariableScope.User\r\n  | VariableScope.Entity;\r\n\r\nexport enum VariableResultStatus {\r\n  Success = 200,\r\n  Created = 201,\r\n  Unchanged = 304,\r\n  Denied = 403,\r\n  NotFound = 404,\r\n  ReadOnly = 405,\r\n  Conflict = 409,\r\n  Unsupported = 501,\r\n  Invalid = 400,\r\n  Error = 500,\r\n}\r\n\r\nexport const resultStatus = createEnumAccessor(\r\n  VariableResultStatus as typeof VariableResultStatus,\r\n  false,\r\n  \"variable set status\"\r\n);\r\n\r\nexport type ResultStatusValue<Numeric extends boolean | undefined = boolean> =\r\n  EnumValue<\r\n    typeof VariableResultStatus,\r\n    VariableResultStatus,\r\n    false,\r\n    Numeric\r\n  > extends infer T\r\n    ? T\r\n    : never;\r\n\r\ntype PickScopeAndTarget<T> = T extends { scope: infer Scope }\r\n  ? T extends { targetId: infer Target }\r\n    ? { scope: ParsedValue<typeof variableScope, Scope>; targetId: Target }\r\n    : { scope: ParsedValue<typeof variableScope, Scope> }\r\n  : {};\r\n\r\ntype KeepVariableTarget<Source extends VariableSetter, T> = T extends undefined\r\n  ? undefined\r\n  : ReplaceProperties<Variable<T, true>, PickScopeAndTarget<Source>>;\r\n\r\ntype VariableSetResultValue<Source extends VariableSetter> =\r\n  PrettifyIntersection<\r\n    KeepVariableTarget<Source, VariableSetResultValue_<Source>>\r\n  >;\r\n\r\ntype VariableSetResultValue_<Source extends VariableSetter> = Source extends {\r\n  patch: infer R & {};\r\n}\r\n  ? R extends (current: any) => infer R | { value: infer T }\r\n    ?\r\n        | (T extends undefined ? undefined : T)\r\n        | (R extends undefined ? undefined : never)\r\n    : R extends { match: any; value: infer T }\r\n    ? T extends undefined\r\n      ? undefined\r\n      : T\r\n    : R extends { type: VariablePatchTypeValue }\r\n    ? number\r\n    : never\r\n  : Source extends { value: infer T }\r\n  ? T extends undefined\r\n    ? undefined\r\n    : T\r\n  : never;\r\n\r\nexport type VariableSetResult<\r\n  T = any,\r\n  Source extends VariableSetter<T> = VariableSetter<T>\r\n> =\r\n  | VariableSetSuccessResult<T, Source>\r\n  | ({\r\n      source: Source;\r\n    } & (\r\n      | {\r\n          status: VariableResultStatus.Conflict;\r\n          current: VariableSetResultValue<Source>;\r\n        }\r\n      | ((\r\n          | {\r\n              status:\r\n                | VariableResultStatus.ReadOnly\r\n                | VariableResultStatus.Invalid\r\n                | VariableResultStatus.Denied\r\n                | VariableResultStatus.NotFound\r\n                | VariableResultStatus.Unsupported;\r\n\r\n              error?: any;\r\n            }\r\n          | {\r\n              status: VariableResultStatus.Error;\r\n              transient?: boolean;\r\n              error: any;\r\n            }\r\n        ) & { current?: never })\r\n    ));\r\n\r\nexport type VariableSetSuccessResult<\r\n  T = any,\r\n  Source extends VariableSetter<T> = VariableSetter<T>\r\n> = {\r\n  status:\r\n    | VariableResultStatus.Success\r\n    | VariableResultStatus.Unchanged\r\n    | (VariableSetResultValue<Source> extends undefined\r\n        ? never\r\n        : VariableResultStatus.Created);\r\n\r\n  current: VariableSetResultValue<Source>;\r\n\r\n  source: Source;\r\n};\r\n\r\nexport interface VariablePatchSource<\r\n  T = any,\r\n  NumericEnums extends boolean = boolean\r\n> extends VariableVersion,\r\n    VariableClassification<NumericEnums>,\r\n    VariableMetadata {\r\n  value: T;\r\n}\r\n\r\nexport type VariablePatchResult<T = any, Validated = boolean> =\r\n  | (VariableMetadata &\r\n      (Partial<VariableClassification<If<Validated, true, boolean>>> & {\r\n        value: T;\r\n      }))\r\n  | undefined;\r\n\r\nexport type VariablePatchAction<T = any, Validated = boolean> = (\r\n  current: VariablePatchSource<T, If<Validated, true, boolean>> | undefined\r\n) => MaybePromise<VariablePatchResult<T, Validated> | undefined>;\r\n\r\nexport enum VariablePatchType {\r\n  Add = 0,\r\n  Min = 1,\r\n  Max = 2,\r\n  IfMatch = 3,\r\n  IfNoneMatch = 4,\r\n}\r\n\r\nexport type VariablePatchTypeValue<\r\n  Numeric extends boolean | undefined = boolean\r\n> = EnumValue<\r\n  typeof VariablePatchType,\r\n  VariablePatchType,\r\n  false,\r\n  Numeric\r\n> extends infer T\r\n  ? T\r\n  : never;\r\n\r\nexport const patchType = createEnumAccessor(\r\n  VariablePatchType as typeof VariablePatchType,\r\n  false,\r\n  \"variable patch type\"\r\n);\r\n\r\nexport type VariableValuePatch<T = any> = {\r\n  selector?: string;\r\n} & (\r\n  | {\r\n      type: VariablePatchType.Add | \"add\";\r\n      /**\r\n       * The amount to add (subtract if negative).\r\n       */\r\n      by: number;\r\n      /**\r\n       * The initial value if none exists.\r\n       * @default 0\r\n       */\r\n      seed?: number;\r\n    }\r\n  | {\r\n      type: VariablePatchType.Min | VariablePatchType.Max | \"min\" | \"max\";\r\n      value: number;\r\n    }\r\n  | {\r\n      type: VariablePatchType.IfMatch | \"ifMatch\";\r\n      match: T | undefined;\r\n      value: T | undefined;\r\n    }\r\n  | {\r\n      type: VariablePatchType.IfNoneMatch | \"ifNoneMatch\";\r\n      match: T | undefined;\r\n      value: T | undefined;\r\n    }\r\n);\r\nexport type VariablePatchActionSetter<\r\n  T = any,\r\n  Validated = boolean\r\n> = VariableKey<If<Validated, true, boolean>> &\r\n  VariableKey &\r\n  Partial<Variable<T, If<Validated, true, boolean>>> & {\r\n    patch: VariablePatchAction<T, Validated>;\r\n  };\r\n\r\nexport type VariableValuePatchSetter<\r\n  T = any,\r\n  Validated = boolean\r\n> = VariableKey<If<Validated, true, boolean>> &\r\n  Partial<Variable<T, If<Validated, true, boolean>>> &\r\n  (Partial<VariableClassification<If<Validated, true, boolean>>> & {\r\n    patch: VariableValuePatch<T>;\r\n  });\r\n\r\nexport type VariablePatch<T = any, Validated = boolean> =\r\n  | VariablePatchActionSetter<T, Validated>\r\n  | VariableValuePatchSetter<T, Validated>;\r\n\r\nexport type VariableValueSetter<T = any, Validated = false> = (\r\n  | PickPartial<\r\n      Variable<T, If<Validated, true, boolean>>,\r\n      \"classification\" | \"purposes\" | \"version\"\r\n    >\r\n  | (PartialExcept<\r\n      Variable<T, If<Validated, true, boolean>>,\r\n      keyof VariableKey\r\n    > & { value: undefined })\r\n) & {\r\n  /**\r\n   * Ignore versioning (optimistic concurrency), and save the value regardless.\r\n   * Consider your scenario before doing this.\r\n   */\r\n  force?: boolean;\r\n};\r\n\r\n/**\r\n * Any variable setter that only has numeric enum values.\r\n */\r\nexport type ValidatedVariableSetter = VariableSetter<any, string, true>;\r\n\r\n/**\r\n * Defines options for creating, updating or deleting a variable.\r\n */\r\nexport type VariableSetter<\r\n  T = any,\r\n  K extends string = string,\r\n  Validated = boolean\r\n> = { key: K } & (\r\n  | (VariableValueSetter<T, Validated> & { patch?: undefined })\r\n  | (VariablePatch<T, Validated> & { value?: undefined })\r\n);\r\n\r\nexport type VariableSetters<\r\n  SetterType extends Partial<VariableSetter<any>> | boolean,\r\n  Inferred extends VariableSetters<SetterType> = never\r\n> =\r\n  | Inferred\r\n  | TupleOrArray<\r\n      | (SetterType extends boolean\r\n          ? VariableSetter<any, string, SetterType>\r\n          : SetterType)\r\n      | Nullish\r\n    >;\r\n\r\nexport type MapVariableSetResult<Source> = Source extends VariableSetter<\r\n  infer T\r\n>\r\n  ? VariableSetResult<T, Source>\r\n  : never;\r\n\r\nexport type VariableSetResults<K extends readonly any[] = any[]> =\r\n  K extends readonly []\r\n    ? []\r\n    : K extends readonly [infer Item, ...infer Rest]\r\n    ? [MapVariableSetResult<Item>, ...VariableSetResults<Rest>]\r\n    : K extends readonly (infer T)[]\r\n    ? MapVariableSetResult<T>[]\r\n    : never;\r\n\r\ntype StripPatchFunctionItems<\r\n  T extends readonly (VariableGetter | VariableSetter)[]\r\n> = T extends readonly []\r\n  ? []\r\n  : T extends readonly [infer T, ...infer Rest]\r\n  ? [\r\n      StripPatchFunctions<T & (VariableGetter | VariableSetter)>,\r\n      ...StripPatchFunctionItems<\r\n        Rest & readonly (VariableGetter | VariableSetter)[]\r\n      >\r\n    ]\r\n  : T extends readonly any[]\r\n  ? ToggleReadonly<StripPatchFunctions<T[number]>[], T>\r\n  : never;\r\n\r\nexport type StripPatchFunctions<\r\n  T extends MaybeArray<VariableGetter | VariableSetter | Nullish, true>\r\n> = T extends Nullish\r\n  ? T\r\n  : T extends readonly any[]\r\n  ? StripPatchFunctionItems<T>\r\n  : T extends VariableGetter\r\n  ? T & { init?: Json }\r\n  : Exclude<VariableSetter, VariablePatchActionSetter>;\r\n\r\nexport const isVariablePatch = <Validated>(\r\n  setter: VariableSetter<any, string, Validated> | undefined\r\n): setter is VariablePatch<any, Validated> => !!setter?.[\"patch\"];\r\n\r\nexport const isVariablePatchAction = (\r\n  setter: any\r\n): setter is VariablePatchActionSetter => isFunction(setter?.[\"patch\"]);\r\n","import {\n  DataClassification,\n  DataPurposeFlags,\n  MapVariableGetResult,\n  MapVariableSetResult,\n  RestrictVariableTargets,\n  StripPatchFunctions,\n  Variable,\n  VariableEnumProperties,\n  VariableGetResult,\n  VariableGetter,\n  VariableKey,\n  VariableResultStatus,\n  VariableSetResult,\n  VariableSetter,\n  variableScope,\n} from \"@tailjs/types\";\nimport {\n  EnumValue,\n  GeneralizeConstants,\n  If,\n  IfNot,\n  IsAny,\n  MaybeUndefined,\n  Nullish,\n  PrettifyIntersection,\n  ToggleArray,\n  UnknownIsAny,\n  createEnumAccessor,\n  createEnumPropertyParser,\n} from \"@tailjs/util\";\n\nimport type { LocalID, VariableScopeValue, View } from \"@tailjs/types\";\n\nexport type ReferringViewData = [\n  viewId: LocalID,\n  relatedEventId: LocalID | undefined\n];\n\ntype ReservedVariableDefinitions = {\n  view: View;\n  tags: string[];\n  rendered: boolean;\n  consent: boolean;\n  loaded: boolean;\n  index: number;\n  scripts: Record<string, \"pending\" | \"loaded\" | \"failed\">;\n  referrer: ReferringViewData;\n};\n\nexport type ReservedVariableType<\n  K,\n  Default = any\n> = K extends ReservedVariableKey\n  ? ReservedVariableDefinitions[K]\n  : UnknownIsAny<Default>;\n\nexport type ReservedVariableKey = keyof ReservedVariableDefinitions;\n\nexport type LocalVariableKey = ReservedVariableKey | (string & {});\n\nexport enum LocalVariableScope {\n  /** Variables are only available in memory in the current view. */\n  View = -3,\n\n  /** Variables are only available in memory in the current tab, including between views in the same tab as navigation occurs. */\n  Tab = -2,\n\n  /** Variables are only available in memory and shared between all tabs. */\n  Shared = -1,\n}\n\nexport const localVariableScope = createEnumAccessor(\n  LocalVariableScope as typeof LocalVariableScope,\n  false,\n  \"local variable scope\"\n);\n\nexport const anyVariableScope = (scope: string | number) =>\n  localVariableScope.tryParse(scope) ?? variableScope(scope);\n\nexport type LocalVariableScopeValue<\n  Numeric extends boolean | undefined = boolean\n> = EnumValue<\n  typeof LocalVariableScope,\n  LocalVariableScope,\n  false,\n  Numeric\n> extends infer T\n  ? T\n  : never;\n\nexport type LocalVariableHeader<NumericEnums extends boolean = boolean> = {\n  key: LocalVariableKey;\n  scope: LocalVariableScopeValue<NumericEnums>;\n  targetId?: undefined;\n  classification?: DataClassification.Anonymous;\n  purposes?: DataPurposeFlags.Necessary;\n  version?: string;\n};\n\nexport type ReservedVariables<\n  K extends ReservedVariableKey = ReservedVariableKey\n> = K extends infer K\n  ? LocalVariable<\n      ReservedVariableDefinitions[K & ReservedVariableKey],\n      K & string\n    >\n  : never;\n\ntype LocalVariable<\n  T = unknown,\n  K extends string = LocalVariableKey,\n  NumericEnums extends boolean = true\n> = PrettifyIntersection<\n  {\n    key: K;\n    value: T;\n  } & LocalVariableHeader<NumericEnums>\n>;\n\ntype LocalVariableGetResult<\n  T = any,\n  K = LocalVariableKey,\n  Patched = false\n> = PrettifyIntersection<\n  (\n    | ({\n        status:\n          | VariableResultStatus.Success\n          | VariableResultStatus.Unchanged\n          | VariableResultStatus.Created;\n      } & LocalVariable<T, K & string>)\n    | IfNot<\n        Patched,\n        {\n          status: VariableResultStatus.NotFound;\n          value?: undefined;\n        }\n      >\n  ) &\n    LocalVariableHeader<true> & { key: K }\n>;\n\ntype LocalVariableSetResult<T, Source> = PrettifyIntersection<{\n  source: Source;\n  status:\n    | VariableResultStatus.Success\n    | VariableResultStatus.Unchanged\n    | VariableResultStatus.Created;\n  current: Source extends { value: infer Value }\n    ? Value extends undefined\n      ? undefined\n      : LocalVariable<T, Source extends { key: infer K } ? K & string : string>\n    : never;\n}>;\nexport type ClientVariable<\n  T = any,\n  K extends string = string,\n  Local = boolean\n> = Local extends true\n  ? LocalVariable<T, K>\n  : { key: K } & Omit<RestrictVariableTargets<Variable<T>>, \"key\">;\n\nexport type VariableCacheSettings = {\n  /**\n   * The maximum number of milliseconds the value of this variable can be cached.\n   * If omitted or `true` the default value of 3 seconds will be used.\n   * `false` or 0 means the variable will not be cached.\n   */\n  cache?: number | boolean;\n};\n\nexport type ClientVariableCallback<\n  T = any,\n  K extends string = string & {},\n  Local = boolean\n> = (\n  value: ClientVariable<T, K, Local> | undefined,\n  previous: ClientVariable<T, K, Local> | undefined,\n  poll: () => void\n) => void;\n\nexport type ClientVariableGetter<\n  T = any,\n  K extends string = string & {},\n  Local = boolean\n> = PrettifyIntersection<\n  (Local extends true\n    ? { key: K } & LocalVariableHeader & {\n          init?: { value: GeneralizeConstants<T> | undefined };\n        }\n    : StripPatchFunctions<\n        RestrictVariableTargets<VariableGetter<T, K, false>, true>\n      >) & {\n    /**\n     * A callback to do something with the result.\n     * If the second function is invoked the variable will be polled for changes, and the callback will be invoked\n     * next time the value changes. To keep polling, keep calling the poll function every time the callback is invoked.\n     */\n    result?: ToggleArray<ClientVariableCallback<T, K, Local>>;\n\n    /**\n     * If the get requests fails this callback will be called instead of the entire operation throwing an error.\n     * If it returns `false` an error will still be thrown.\n     */\n    error?: (\n      result: ClientVariableGetResult<T, K, boolean, Local>,\n      error: string\n    ) => void | boolean;\n\n    /**\n     * Do not accept a cached version of the variable.\n     */\n    refresh?: boolean;\n  } & VariableCacheSettings\n>;\n\nexport type ClientVariableSetter<\n  T = any,\n  K extends string = string,\n  Local extends boolean = boolean\n> = PrettifyIntersection<\n  (Local extends true\n    ? LocalVariable<GeneralizeConstants<T> | undefined, K, boolean> & {\n        patch?: undefined;\n      }\n    : StripPatchFunctions<\n        RestrictVariableTargets<VariableSetter<T, K, false>, true>\n      >) & {\n    /** A callback that will get invoked when the set operation has completed. */\n    result?: (\n      current: ClientVariable<T, K, Local> | undefined,\n      source: Local extends true\n        ? ClientVariableSetter<any, any, true>\n        : ClientVariableSetter<any, any, false>\n    ) => void;\n\n    /**\n     * If the get requests fails this callback will be called instead of the entire operation throwing an error.\n     * If it returns `false` an error will still be thrown.\n     */\n    error?: (\n      result: ClientVariableSetResult<\n        any,\n        Local extends true\n          ? ClientVariableSetter<any, any, true>\n          : ClientVariableSetter<any, any, false>\n      >,\n      error: string\n    ) => void | boolean;\n  } & VariableCacheSettings\n>;\n\nexport type ClientScopeValue<\n  NumericEnums extends boolean = boolean,\n  Local extends boolean = boolean\n> = Local extends true\n  ? LocalVariableScopeValue<NumericEnums>\n  : VariableScopeValue<NumericEnums>;\n\nexport type ClientVariableKey<\n  NumericEnums extends boolean = boolean,\n  Local extends boolean = boolean\n> = Local extends false\n  ? VariableKey<NumericEnums>\n  : { key: string; scope: LocalVariableScopeValue<NumericEnums> };\n\ntype MapLocalGetResult<Getter> = Getter extends ClientVariableGetter<\n  infer T,\n  infer K & string,\n  true\n>\n  ? LocalVariableGetResult<\n      ReservedVariableType<K, T>,\n      K,\n      Getter extends { init: { value?: infer V } }\n        ? If<IsAny<V>, false, undefined extends V ? false : true>\n        : false\n    >\n  : Getter extends Nullish\n  ? undefined\n  : never;\n\ntype MapLocalSetResult<Setter> = Setter extends ClientVariableSetter<\n  infer T,\n  infer K & string,\n  true\n>\n  ? LocalVariableSetResult<\n      T extends undefined ? undefined : ReservedVariableType<K, T>,\n      Setter\n    >\n  : Setter extends Nullish\n  ? undefined\n  : never;\n\ntype MapClientVariableResult<P, Getter> = P extends {\n  scope: LocalVariableScopeValue;\n}\n  ? If<Getter, MapLocalGetResult<P>, MapLocalSetResult<P>>\n  : RestrictVariableTargets<\n      If<Getter, MapVariableGetResult<P>, MapVariableSetResult<P>>\n    >;\n\nexport type ClientVariableGetResult<\n  T = any,\n  K extends string = string,\n  Patched = boolean,\n  Local = boolean\n> = Local extends true\n  ? LocalVariableGetResult<T, K, Patched>\n  : RestrictVariableTargets<VariableGetResult<T, K, Patched>>;\n\nexport type ClientVariableSetResult<\n  T = any,\n  Source extends ClientVariableSetter = ClientVariableSetter<\n    any,\n    string,\n    boolean\n  >\n> = Source extends ClientVariableSetter<any, any, true>\n  ? LocalVariableSetResult<T, Source>\n  : Source extends ClientVariableSetter<any, any, false>\n  ? RestrictVariableTargets<VariableSetResult<T, Source>>\n  : any;\n\nexport type ClientVariableResults<\n  P extends readonly any[],\n  Getters\n> = P extends readonly []\n  ? []\n  : P extends readonly [infer Result, ...infer Rest]\n  ? readonly [\n      MapClientVariableResult<Result, Getters>,\n      ...ClientVariableResults<Rest, Getters>\n    ]\n  : P extends readonly (infer Result)[]\n  ? readonly MapClientVariableResult<Result, Getters>[]\n  : never;\n\nexport const isLocalScopeKey = (\n  key: any\n): key is {\n  scope: LocalVariableScopeValue;\n} => !!localVariableScope.tryParse(key?.scope);\n\nexport const toNumericVariableEnums = createEnumPropertyParser(\n  { scope: localVariableScope },\n  VariableEnumProperties\n);\n\nexport const variableKeyToString: <\n  S extends ClientVariableKey | { source?: ClientVariableKey }\n>(\n  key: S\n) => MaybeUndefined<S, string> = (key: any): any =>\n  key == null\n    ? undefined\n    : key.source\n    ? variableKeyToString(key.source)!\n    : `${anyVariableScope(key.scope)}\\0${key.key}\\0${key.targetId ?? \"\"}`;\n\nexport const stringToVariableKey = (key: string): ClientVariableKey => {\n  const parts = key.split(\"\\0\");\n  return {\n    scope: +parts[0],\n    key: parts[1],\n    targetId: parts[2],\n  } as any;\n};\n","import { Defined, Extends, MaybeUndefined, ToggleReadonly, tryCatch } from \"..\";\n\n/**\n * The ECMAScript primitive types.\n */\nexport type Primitives =\n  | null\n  | undefined\n  | void\n  | boolean\n  | number\n  | bigint\n  | string\n  | symbol\n  | Date;\n\nexport type NonAsync =\n  | Primitives\n  | Iterable<any>\n  | ((...args: any[]) => any)\n  | RecordType;\n\n/**\n * Common function type used for projection of [key,value] entries.\n */\nexport type KeyValueProjection<K, V, R> = (\n  entry: [key: K, value: V],\n  index: number\n) => R;\n\n/**\n * Anything but a promise.\n */\nexport type NotPromise = { then?: never };\n\n/**\n * Anything but a function.\n */\nexport type NotFunction =\n  | bigint\n  | boolean\n  | null\n  | number\n  | string\n  | symbol\n  | undefined\n  | {\n      [key: string | number | symbol]: any;\n      [Symbol.hasInstance]?: never;\n    };\n\n/** Shorter than writing all this out, and slightly easier to read. */\nexport type Nullish = null | undefined;\n\n/** A record type that is neither iterable or a function. */\nexport type RecordType<K extends keyof any = keyof any, V = any> = object & {\n  readonly [P in K]?: V;\n} & {\n  [Symbol.iterator]?: never;\n  [Symbol.asyncIterator]?: never;\n  [Symbol.hasInstance]?: never;\n\n  then?(\n    onfulfilled?: ((value: any) => any) | undefined | null,\n    onrejected?: ((reason: any) => any) | undefined | null\n  ): never;\n};\n\nexport type UnwrapPromiseLike<T> = T extends PromiseLike<infer T>\n  ? UnwrapPromiseLike<T>\n  : T;\n\nexport type MaybePromise<T> = T | PromiseLike<T>;\n/**\n * Shorthand for a value that is optionally awaitable.\n */\nexport type TogglePromise<T, Toggle = boolean> = Toggle extends\n  | true\n  | PromiseLike<any>\n  ? T extends PromiseLike<any>\n    ? T\n    : PromiseLike<T>\n  : T extends PromiseLike<infer T>\n  ? UnwrapPromiseLike<T>\n  : T;\n\n/**\n * Trick for having a function that returns a non-null value, if a formal parameter always has a non-null value,\n * similar to .NET's [NotNullIfNotNull].\n *\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n *\n * @obsolete\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\n/** All keys of any type in a union */\nexport type AllKeys<Ts> = Ts extends infer T\n  ? unknown extends T\n    ? keyof any\n    : keyof T\n  : never;\n\n/** If any type in a union has a value for the given property that cannot be null'ish.*/\nexport type HasRequiredProperty<T, P> = true extends (\n  T extends infer T\n    ? true extends Extends<\n        Nullish,\n        keyof T extends P ? T[P & keyof T] : P extends keyof T ? T[P] : never\n      >\n      ? false\n      : true\n    : never\n)\n  ? true\n  : false;\n\nexport type IfNever<T, Default> = [T] extends [never] ? Default : T;\n\nexport type Filter<T, FilterTypes, Default = never> = IfNever<\n  T extends infer T ? (T extends FilterTypes ? T : never) : never,\n  Default\n>;\n\n/** Returns the type of a property for each type in a union when the type has the given property. */\nexport type Property<T, P> = T extends infer T\n  ? keyof T extends P\n    ? T[P & keyof T]\n    : P extends keyof T\n    ? T[P]\n    : never\n  : never;\n\n/**\n * Creates a new type where with all the properties from any of the specified types.\n * This can make life easier for code working with polymorphic types.\n */\n\nexport type CommonTypeTemplate<Ts> = {\n  [P in AllKeys<Ts>]?: Ts extends infer T\n    ? P extends keyof T\n      ? T[P]\n      : never\n    : never;\n};\n\n/**\n * Maps all null'ish types to `undefined`.\n */\nexport type Undefined<T> = T extends Nullish | void ? undefined : T;\n\nexport type ExpandTypes<\n  Ts,\n  Common = CommonTypeTemplate<Ts>\n> = Ts extends infer T\n  ? {\n      [P in keyof Common]: P extends keyof T ? T[P] : Common[P];\n    }\n  : never;\n\n/* JSON */\n\nexport type JsonArray = Json[];\n\nexport type JsonTuple = {\n  [TupleIndex in number]?: Json;\n};\n\nexport type JsonObject = {\n  [props: string | number]: Json;\n} & { [symbols: symbol]: never };\n\ntype JsonOnly<T> = T extends Json ? T : never;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Json<T = unknown> = unknown extends T\n  ? Nullish | string | number | boolean | JsonArray | JsonTuple | JsonObject\n  : Omit<\n      {\n        [P in keyof T]: JsonOnly<T[P]>;\n      },\n      symbol\n    >;\n\nexport type ToJsonAble<T> = { toJSON(): T };\n\n/** Minify friendly version of `false`. */\nexport const undefined = void 0;\n\n/** Caching this value potentially speeds up tests rather than using `Number.MAX_SAFE_INTEGER`. */\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/** Caching this value potentially speeds up tests rather than using `Number.MAX_SAFE_INTEGER`. */\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\n\n/** Minify friendly version of `false`. */\nexport const F = false;\n\n/** Minify friendly version of `true`. */\nexport const T = true;\n\n/** Minify friendly version of `null`. */\nexport const nil = null;\n\nexport type NoOpFunction = (...args: any) => void;\n\n/** A function that does nothing. */\nexport const NOOP: NoOpFunction = () => {};\n\nexport type IdentityFunction = <T>(item: T, ...args: any) => T;\n\n/** The identity function (x)=>x. */\nexport const IDENTITY: IdentityFunction = (item: any) => item;\n\nexport type NullFilterFunction = <T>(item: T | Nullish) => boolean;\n\n/** A function that filters out values != null. */\nexport const FILTER_NULLS: NullFilterFunction = (item: any) => item != nil;\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = <V, P extends boolean = true>(\n  value: V,\n  parse?: P\n) => T extends Nullish\n  ? undefined\n  : V extends T\n  ? V\n  : (true extends P ? T : never) | undefined;\n\n/** Using this cached value speeds up testing if an object is iterable seemingly by an order of magnitude. */\nexport const symbolIterator = Symbol.iterator;\n\n/** Using this cached value speeds up testing if an object is iterable seemingly by an order of magnitude. */\nexport const symbolAsyncIterator = Symbol.asyncIterator;\n\nexport const createTypeConverter =\n  <T>(\n    typeTester: TypeTester<T>,\n    parser?: (value: any) => T | undefined\n  ): TypeConverter<T> =>\n  (value: any, parse = true as any) =>\n    typeTester(value)\n      ? value\n      : parser && parse && value != null && (value = parser(value)) != null\n      ? value\n      : (undefined as any);\n\nexport const ifDefined = <T, P, R>(\n  value: T,\n  resultOrProperty: (\n    | (AllKeys<T> & (keyof any & {}))\n    | ((value: Exclude<T, Nullish>) => R)\n  ) &\n    P\n): MaybeUndefined<T, P extends keyof any ? Exclude<T, Nullish> : R> =>\n  isFunction(resultOrProperty)\n    ? value !== undefined\n      ? (resultOrProperty(value as any) as any)\n      : undefined\n    : value?.[resultOrProperty as any] !== undefined\n    ? value\n    : undefined;\n\nexport const isNullish = (value: any): value is undefined | void | null =>\n  value == null;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\n\nexport const parseBoolean = createTypeConverter(isBoolean, (value) =>\n  value == 0 // Both numbers and string with the value 0 or 1\n    ? false\n    : value == 1\n    ? true\n    : value === \"false\"\n    ? false\n    : value === \"true\"\n    ? true\n    : undefined\n);\n\nexport const isTruish = <T>(value: T): value is Exclude<T, Falsish> => !!value;\n\nexport const isTrue = (value: any): value is true => value === T;\nexport const isNotTrue = <T>(value: T): value is Exclude<T, true> =>\n  value !== T;\n\nexport type Falsish = void | null | undefined | 0 | \"\" | false;\n\nexport const isFalsish = (value: any): value is Falsish => !value;\n\nexport const isFalse = (value: any): value is false => value === F;\nexport const isNotFalse = <T>(value: T): value is Exclude<T, false> =>\n  value !== F;\n\n/** An array where it is easy to conditionally leave elements out like `[\"item1\", condition&&\"item2\", undefined]`. */\nexport type MaybeFalsish<T> = T extends readonly (infer Item)[]\n  ? ToggleReadonly<MaybeFalsish<Item>[], T>\n  : T | Falsish;\n\nexport const truish: {\n  <T>(items: Iterable<T | Falsish>, keepUndefined?: false): T[];\n  <T>(items: Iterable<T>, keepUndefined: true): (T extends Falsish\n    ? undefined\n    : T)[];\n  <T extends { [Symbol.iterator]?: never } | string>(\n    value: T | Falsish\n  ): T extends Falsish ? undefined : Exclude<T, Falsish>;\n} = (value: any, keepUndefined?: boolean) =>\n  isArray(value)\n    ? keepUndefined\n      ? value.map((item) => (!!item ? item : undefined))\n      : value.filter((item: any) => !!item)\n    : !!value\n    ? (value as any)\n    : undefined;\n\nexport const isInteger: (value: any) => value is number =\n  Number.isSafeInteger as any;\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\n\nexport const isFinite: (value: any) => value is number = Number.isFinite as any;\n\nexport const parseNumber = createTypeConverter(isNumber, (value) =>\n  isNaN((value = parseFloat(value))) ? undefined : value\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\n\nexport const parseBigInt = createTypeConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createTypeConverter(isString, (value) =>\n  value?.toString()\n);\n\nexport const isArray: (value: any) => value is any[] = Array.isArray;\n\nexport const isError = (value: any): value is Error => value instanceof Error;\n\n/**\n * Returns the value as an array following these rules:\n * - If the value is undefined (this does not include `null`), so is the return value.\n * - If the value is already an array its original value is returned unless `clone` is true. In that case a copy of the value is returned.\n * - If the value is iterable, an array containing its values is returned\n * - Otherwise, an array with the value as its single item is returned.\n */\nexport const array: {\n  // <T>(value: AsyncIterable<T>, clone?: boolean): MaybeUndefined<\n  //   [T][0],\n  //   Promise<T[]>\n  // >;\n  <T, Clone extends boolean = false>(value: T, clone?: Clone): T extends Nullish\n    ? undefined\n    : T extends readonly any[]\n    ? [Clone] extends [false]\n      ? T\n      : [...T]\n    : (T extends Iterable<infer T> ? T : T)[];\n} = (value: any, clone = false as any): any =>\n  value == null\n    ? undefined\n    : !clone && isArray(value)\n    ? value\n    : isIterable(value)\n    ? [...value]\n    : // : isAsyncIterable(value)\n      // ? toArrayAsync(value)\n      ([value] as any);\n\nexport const isObject = (value: any): value is Record<keyof any, any> =>\n  value !== null && typeof value === \"object\";\n\nconst objectPrototype = Object.prototype;\nconst getPrototypeOf = Object.getPrototypeOf;\n\nexport const isPlainObject = (\n  value: any\n): value is RecordType<keyof any, any> =>\n  value != null && getPrototypeOf(value) === objectPrototype;\n\nexport const hasProperty = <P extends keyof any>(\n  value: any,\n  property: P\n): value is { [Prop in P]: any } => isObject(value) && property in value;\n\nexport const hasMethods = <Names extends readonly (keyof any)[]>(\n  value: any,\n  ...names: Names\n): value is {\n  [P in Names[number]]: (...args: any) => any;\n} =>\n  value == null\n    ? false\n    : names.every((name) => typeof value[name] === \"function\");\n\nexport const hasMethod = <Name extends keyof any>(\n  value: any,\n  name: Name\n): value is {\n  [P in Name]: (...args: any) => any;\n} => typeof (value as any)?.[name] === \"function\";\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createTypeConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\n\nexport const isIterable = (\n  value: any,\n  acceptStrings = false\n): value is Iterable<any> =>\n  !!(value?.[symbolIterator] && (typeof value === \"object\" || acceptStrings));\n\nexport const isAsyncIterable = (value: any): value is AsyncIterable<any> =>\n  !!value?.[symbolAsyncIterator];\n\nexport const toIterable = <T>(value: T | Iterable<T>): Iterable<T> =>\n  isIterable(value) ? value : [value];\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\n/**\n * If the value is a promise, it will be awaited.\n */\nexport const awaitIfAwaitable = <T, R>(\n  value: T,\n  action: (value: T extends PromiseLike<infer T> ? T : T) => R\n): TogglePromise<R, T> =>\n  (value as any)?.then?.((value: any) => action(value)) ?? action(value as any);\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == null\n    ? value === null\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\n/**\n * Round a number of to the specified number of decimals.\n */\nexport const round = <T extends number | Nullish>(\n  number: T,\n  decimals?: number | boolean\n): MaybeUndefined<T, number> =>\n  number == null\n    ? (undefined as any)\n    : decimals === false\n    ? number\n    : ((decimals = Math.pow(10, !decimals || decimals === true ? 0 : decimals)),\n      Math.round(number * decimals) / decimals);\n","import {\n  AllKeys,\n  AnyAll,\n  ArraysAsEmpty,\n  Entries,\n  Extends,\n  FILTER_NULLS,\n  GeneralizeConstants,\n  If,\n  IfNot,\n  IsAny,\n  IterableOrArrayLike,\n  KeyValuePairsToObject,\n  KeyValueSource,\n  KeyValueSourcesToObject,\n  MAX_SAFE_INTEGER,\n  MaybeArray,\n  MaybeUndefined,\n  Minus,\n  Nullish,\n  OmitNullish,\n  Property,\n  RecordType,\n  StrictUndefined,\n  UndefinedIfEmpty,\n  add,\n  array,\n  get,\n  ifDefined,\n  isObject,\n  isArray,\n  isBoolean,\n  isFalsish,\n  isFunction,\n  isIterable,\n  isMap,\n  isNumber,\n  isPlainObject,\n  isSet,\n  isString,\n  isTruish,\n  symbolIterator,\n  undefined,\n  separate,\n  EnumerationSeparators,\n} from \".\";\n\nexport const UTF16MAX = 0xffff;\n\nlet stopInvoked = false;\nexport const stop = (yieldValue?: any) => ((stopInvoked = true), yieldValue);\n\nexport const toCharCodes = (s: string) =>\n  [...new Array(s.length)].map((_, i) => s.charCodeAt(i));\nexport const codePoint = (string: string, index: number = 0) =>\n  string.codePointAt(index)!;\n\nexport type IteratorSource =\n  | Nullish\n  | number\n  | Iterable<any>\n  | RecordType\n  | NavigatingIteratorStep;\n\nexport type IteratorSourceOf<T> =\n  | (T extends number ? number : never)\n  | Iterable<T>\n  | (T extends readonly [infer K, infer V]\n      ? K extends keyof any\n        ? RecordType<K, V>\n        : never\n      : never)\n  | NavigatingIteratorStep<T>;\n\nexport type IteratorItem<S extends IteratorSource> = unknown extends S\n  ? any\n  : S extends number\n  ? number\n  : S extends Iterable<infer T>\n  ? T\n  : S extends RecordType<infer K, infer V>\n  ? readonly [K, V]\n  : S extends ArrayLike<infer T>\n  ? T\n  : S extends (...args: any) => infer T | undefined\n  ? T\n  : never;\n\nexport type IteratorItems<S extends readonly IteratorSource[]> =\n  S extends readonly [infer S]\n    ? IteratorItem<S & IteratorSource>\n    : S extends readonly [infer S, ...infer Rest]\n    ? IteratorItem<S & IteratorSource> | IteratorItems<Rest & IteratorSource[]>\n    : S extends readonly (infer S)[]\n    ? IteratorItem<S & IteratorSource>\n    : never;\n\nexport interface IteratorControl<S extends IteratorSource> {\n  source: S;\n  prev: IteratorItem<S> | undefined;\n  skip(): void;\n  end(): void;\n  end<P>(value: P): P;\n}\n\nexport type FunctionalIteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = any,\n  Value = IteratorItem<S>\n> = (\n  value: Value,\n  index: number\n) => Projection | readonly [any, any] | typeof stop | Nullish;\n\nexport type IteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = unknown,\n  Value = IteratorItem<S>\n> = AllKeys<IteratorItem<S>> | FunctionalIteratorAction<S, Projection, Value>;\n\n// We need both the inferred return value from the IteratorAction and the IteratorAction itself used as the parameter\n// in functions like `<S extends IteratorSource, Return, Action>(source: S, action: IteratorAction<S,Return> | P)=>IteratorProjection<S,Return,Action>.\n// It is important to set the generic type for Action's default value to undefined\n// This seems to be the only way we can both automatically infer non-readonly tuples from `()=>[\"test\", 1]` as tuples, and at the same time\n// allow property names from the source's items. If we did not include the parameter itself it would not be possible to differentiate\n// between property names and return values.\ntype IteratorProjection<\n  S extends IteratorSource,\n  Return,\n  Action,\n  Default = IteratorItem<S>\n> = Action extends Nullish\n  ? Default\n  : unknown extends Action\n  ? Default\n  : Action extends keyof any\n  ? Exclude<Property<IteratorItem<S>, Action>, Nullish>\n  : Return;\n\ntype IteratorProjectionWithUndefined<\n  S extends IteratorSource,\n  Return,\n  Action,\n  Default = IteratorItem<S>\n> =\n  | IteratorProjection<S, Return, Action, Default>\n  | (Action extends (...args: any) => infer R\n      ? R extends typeof stop\n        ? undefined\n        : StrictUndefined<R>\n      : Action extends keyof any\n      ? StrictUndefined<Property<IteratorItem<S>, Action>>\n      : never) extends infer T\n  ? T\n  : never;\n\ntype StartEndArgs<S extends IteratorSource> =\n  | []\n  | (S extends number\n      ? [offset?: number | Nullish]\n      : S extends NavigatingIteratorStep<infer T>\n      ? [seed?: T, maxIterations?: number]\n      : [start: number | Nullish, end?: number | Nullish]);\n\nexport type NavigatingIteratorStep<T = any> = (\n  current: T | undefined\n) => T | undefined;\n\ntype FlatIteratorItem<T, D extends number = 1, Object = false> = T extends\n  | undefined\n  | void\n  ? never\n  : D extends 0\n  ? T\n  : T extends\n      | Iterable<any>\n      | (Object extends true ? Record<keyof any, any> : never)\n  ? D extends 1\n    ? IteratorItem<T>\n    : FlatIteratorItem<IteratorItem<T>, Minus<D, 1>, Object>\n  : T;\n\nconst wrapProjection = <P>(\n  projection: P | undefined\n): undefined | ((item: any, index: number) => any) =>\n  projection == null\n    ? undefined\n    : isFunction(projection)\n    ? (projection as any)\n    : (item) => item[projection as any];\n\nfunction* createFilteringIterator<S extends IteratorSource, R, P>(\n  source: S,\n  projection?: IteratorAction<S, R> | P\n): Iterable<IteratorProjection<S, R, P>> {\n  if (source == null) return;\n  if (projection) {\n    projection = wrapProjection(projection)!;\n    let i = 0;\n    for (let item of source as any) {\n      if ((item = projection(item, i++)) != null) {\n        yield item;\n      }\n      if (stopInvoked) {\n        stopInvoked = false;\n        break;\n      }\n    }\n  } else {\n    for (let item of source as any) {\n      if (item != null) yield item;\n    }\n  }\n}\n\nfunction* createObjectIterator<S extends Record<keyof any, any>, R, P>(\n  source: S,\n  action?: IteratorAction<S, R> | P\n): Iterable<IteratorProjection<S, P, R>> {\n  action = wrapProjection(action);\n  let i = 0;\n  for (const key in source) {\n    let value = [key, source[key]] as any;\n    action && (value = action(value, i++));\n\n    if (value != null) {\n      yield value;\n    }\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n}\n\nfunction* createRangeIterator(length = 0, offset?: number): Iterable<number> {\n  if (length < 0) {\n    offset ??= -length - 1;\n    while (length++) yield offset--;\n  } else {\n    offset ??= 0;\n    while (length--) yield offset++;\n  }\n}\n\nexport function* createStringIterator(\n  input: string,\n  start: number,\n  end: number\n): Iterable<[char: string, codePoint: number]> {\n  while (start < end) {\n    const codePoint = input.codePointAt(start)!;\n    let p = input[start++];\n    if (codePoint > UTF16MAX) {\n      start++;\n      p = String.fromCodePoint(codePoint);\n    }\n    yield [p, codePoint];\n  }\n}\n\nexport function* createNavigatingIterator<T>(\n  step: NavigatingIteratorStep<T>,\n  start?: T | undefined,\n  maxIterations = Number.MAX_SAFE_INTEGER\n): Iterator<T> {\n  if (start != null) yield start;\n  while (maxIterations-- && (start = step(start)) != null) {\n    yield start;\n  }\n}\n\nconst sliceAction = <S extends IteratorSource, R, P>(\n  action: IteratorAction<S, R> | P,\n  start: any,\n  end: any\n): P =>\n  (start ?? end) !== undefined\n    ? ((action = wrapProjection(action)!),\n      (start ??= 0),\n      (end ??= MAX_SAFE_INTEGER),\n      (value, index) =>\n        start--\n          ? undefined\n          : end!--\n          ? action\n            ? action(value, index)\n            : value\n          : end)\n    : (action as any);\n\nexport type IteratorFilter<S extends IteratorSource> = (\n  value: IteratorItem<S>,\n  index: number\n) => any;\n\n/** Faster way to exclude null'ish elements from an array than using {@link filter} or {@link map} */\nexport const filterArray = <T extends readonly any[] | undefined>(\n  array: T\n): T extends readonly (infer Item)[] ? OmitNullish<Item>[] : undefined =>\n  array?.filter(FILTER_NULLS) as any;\n\nconst createIterator = <S extends IteratorSource, R, P>(\n  source: S,\n  projection?: IteratorAction<S, R> | P,\n  start?: any,\n  end?: any\n): Iterable<IteratorProjection<S, R, P>> =>\n  source == null\n    ? ([] as any)\n    : !projection && isArray(source)\n    ? filterArray(source)\n    : source[symbolIterator]\n    ? createFilteringIterator(\n        source,\n        start === undefined\n          ? projection\n          : sliceAction(projection, start as any, end)\n      )\n    : isObject(source)\n    ? createObjectIterator(\n        source as any,\n        sliceAction(projection, start as any, end)\n      )\n    : createIterator(\n        isFunction(source)\n          ? createNavigatingIterator(source, start, end)\n          : (createRangeIterator(source as number, start as any) as any),\n        projection\n      );\n\nconst mapToArray = <T, M>(\n  projected: Iterable<T>,\n  map: M\n): true extends M ? T[] : Iterable<T> =>\n  map && !isArray(projected) ? [...projected] : (projected as any);\n\ntype ProjectFunction = {\n  <S extends IteratorSource, R, P>(\n    source: S,\n    projection?: IteratorAction<S, R> | P,\n    ...rest: StartEndArgs<S>\n  ): Iterable<IteratorProjection<S, R, P>>;\n};\n\ntype MapFunction = {\n  <S extends IteratorSource, R, P>(\n    source: S,\n    projection?: IteratorAction<S, R> | P,\n    ...rest: StartEndArgs<S>\n  ): MaybeUndefined<S, Exclude<IteratorProjection<S, R, P>, Nullish>[]>;\n};\n\ntype FlatProjectFunction = <\n  S extends IteratorSource,\n  R,\n  P,\n  D extends number = 1,\n  O extends boolean = false\n>(\n  source: S,\n  projection?: IteratorAction<S, R> | P,\n  depth?: D,\n  expandObjects?: O,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<\n  S,\n  Iterable<FlatIteratorItem<IteratorProjection<S, R, P>, D, O>>\n>;\n\nexport const project: ProjectFunction = ((\n  source: any,\n  projection: any,\n  start: any,\n  end: any\n) => createIterator(source, projection, start, end)) as any;\n\nfunction* flattenInternal(\n  value: any,\n  depth: number,\n  expandObjects: boolean,\n  nested: boolean\n) {\n  if (value != null) {\n    if (value[symbolIterator] || (expandObjects && isObject(value))) {\n      for (const item of nested ? createIterator(value) : value) {\n        if (depth !== 1) {\n          yield* flattenInternal(item, depth - 1, expandObjects, true);\n        } else {\n          yield item;\n        }\n      }\n    } else {\n      yield value;\n    }\n  }\n}\nexport const flatten: FlatProjectFunction = (\n  source,\n  projection?,\n  depth = 1 as any,\n  expandObjects: any = false,\n  start?: any,\n  end?: any\n) =>\n  flattenInternal(\n    createIterator(source, projection as any, start, end),\n    depth + 1,\n    expandObjects,\n    false\n  ) as any;\n\nexport const map: MapFunction = (\n  source: any,\n  projection?: any,\n  start?: any,\n  end?: any\n) => {\n  projection = wrapProjection(projection);\n  if (isArray(source)) {\n    let i = 0;\n    const mapped: any[] = [];\n    start = start! < 0 ? source.length + start! : start ?? 0;\n    end = end! < 0 ? source.length + end! : end ?? source.length;\n    for (; start < end && !stopInvoked; start++) {\n      let value = source[start];\n      if ((projection ? (value = projection(value, i++)) : value) != null) {\n        mapped.push(value);\n      }\n    }\n    stopInvoked = false;\n    return mapped;\n  }\n  return source != null\n    ? array(project(source, projection, start, end))\n    : (undefined as any);\n};\n\nexport const mapAsync: <S extends IteratorSource, R, P>(\n  source: S,\n  projection: IteratorAction<S, R> | P,\n  ...rest: StartEndArgs<S>\n) => Promise<\n  MaybeUndefined<S, Exclude<Awaited<IteratorProjection<S, R, P>>, Nullish>[]>\n> = async (source: any, projection?: any, start?: any, end?: any) => {\n  projection = wrapProjection(projection);\n  const mapped: any = [];\n  await forEachAsync(\n    source,\n    async (item) => (item = await projection(item)) != null && mapped.push(item)\n  );\n  return mapped as any;\n};\n\nexport const zip = <Lhs extends IteratorSource, Rhs extends IteratorSource>(\n  lhs: Lhs,\n  rhs: Rhs\n): Iterable<[IteratorItem<Lhs>, IteratorItem<Rhs> | undefined]> => {\n  const it2 = createIterator(rhs)[Symbol.iterator]();\n  return createIterator(lhs, (lhs) => [lhs, it2.next()?.value] as [any, any]);\n};\n\nexport const distinct: {\n  <S extends IteratorSource, R, P>(\n    source: S,\n    projection?: IteratorAction<S, R>,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorProjection<S, R, P>>;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorItem<S>>;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  source != null\n    ? new Set<any>([...project(source, projection, start, end)])\n    : undefined;\n\nexport const single: {\n  <S extends IteratorSource, R, P>(\n    source: S,\n    projection?: IteratorAction<S, R> | P,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorProjection<S, R, P> | undefined;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorItem<S> | undefined;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  source == null\n    ? undefined\n    : (source = mapDistinct(source, projection, start, end) as any).length > 1\n    ? undefined\n    : source[0];\n\nexport const mapDistinct: MapFunction = (\n  source: any,\n  projection?: any,\n  start?: any,\n  end?: any\n) =>\n  source != null\n    ? [...(distinct as any)(source, projection, start, end)]\n    : source;\n\nexport function* concatIterators<S extends IteratorSource[]>(\n  ...iterators: S\n): Iterable<IteratorItems<S>> {\n  for (const iterator of iterators) {\n    if (!iterator) continue;\n    yield* createIterator(iterator);\n  }\n}\n\nexport const intersection = <\n  T,\n  A extends Iterable<T> | undefined,\n  B extends Iterable<T> | undefined,\n  MapToArray extends boolean = A extends any[]\n    ? true\n    : B extends any[]\n    ? true\n    : false\n>(\n  a: A,\n  b: B,\n  mapToArray?: MapToArray\n): MapToArray extends true ? T[] : Iterable<T> => {\n  if (!a || !b) return [];\n  isSet(b) && ([b, a] = [a, b] as any);\n  const lookup = isSet(a) ? a : new Set(a);\n  return filter(b, (value) => lookup.has(value), mapToArray) as any;\n};\n\nexport const intersects = (\n  a: Iterable<any> | undefined,\n  b: Iterable<any> | undefined\n) => !!count(intersection(a, b));\n\nexport const flatMapKv = <S extends IteratorSource, R, P, D extends number = 1>(\n  source: S,\n  action?: IteratorAction<S, R> | P,\n  depth: D = 1 as any\n): FlatIteratorItem<IteratorProjection<S, R, P>, D, true>[] =>\n  flatMap(source, action, depth, true);\n\nexport const flatMap: <\n  S extends IteratorSource,\n  R,\n  P,\n  D extends number = 1,\n  O extends boolean = false\n>(\n  source: S,\n  action?: IteratorAction<S, R> | P,\n  depth?: D,\n  expandObjects?: O,\n  ...rest: StartEndArgs<S>\n) => FlatIteratorItem<IteratorProjection<S, R, P>, D, O>[] = (\n  source,\n  action,\n  depth = 1 as any,\n  expandObjects = false as any,\n  start?: any,\n  end?: any\n) =>\n  array(\n    (flatten as any)(source, action, depth, expandObjects, start, end) as any\n  ) as any;\n\nconst traverseInternal = <T>(\n  root: T | T[] | undefined,\n  selector: (current: T) => Iterable<T> | undefined,\n  include: boolean,\n  results: T[],\n  seen: Set<T>\n) => {\n  if (isArray(root)) {\n    forEachInternal(root, (item) =>\n      traverseInternal(item, selector, include, results, seen)\n    );\n    return results;\n  }\n  if (!root || !add(seen, root)) {\n    return undefined;\n  }\n  include && results.push(root);\n  forEachInternal(selector(root), (item) =>\n    traverseInternal(item, selector, true, results, seen)\n  );\n\n  return results;\n};\n\ntype ConcatResult_<T> = T extends readonly []\n  ? never\n  : T extends readonly [infer Item, ...infer Rest]\n  ?\n      | Exclude<Item extends Iterable<infer T> ? T : Item, Nullish>\n      | ConcatResult_<Rest>\n  : T extends Iterable<infer Item>\n  ? Exclude<Item extends Iterable<infer T> ? T : Item, Nullish>\n  : never;\n\ntype ConcatResult<T> = ConcatResult_<T> extends never\n  ? undefined\n  : ConcatResult_<T>[];\n\nexport const join: {\n  /**\n   *  Joins the specified items with a separator (default is \"\").\n   *  If the source is a string it will be returned as is.\n   *\n   *  The value `false` will be omitted to help syntax like `[condition && \"yes\"]`.   .\n   */\n  <S extends IteratorSource | string>(\n    source: S,\n    separator?: string | readonly [string, string]\n  ): MaybeUndefined<S, string>;\n\n  /**\n   * Joins the projection of the specified items with a separator (default is \"\").\n   * If the source is a string it will be considered an array with the string as its single element.\n   */\n  <S extends IteratorSource | string>(\n    source: S,\n    projection: IteratorAction<S extends string ? [string] : S>,\n    separator?: EnumerationSeparators\n  ): MaybeUndefined<S, string>;\n} = (source: any, projection: any, sep?: any) =>\n  source == null\n    ? undefined\n    : isFunction(projection)\n    ? separate(map(isString(source) ? [source] : source, projection), sep ?? \"\")\n    : isString(source)\n    ? source\n    : separate(\n        map(source, (item) => (item === false ? undefined : item)),\n        projection ?? \"\"\n      );\n\ntype FinalIteratorItem<\n  T,\n  ArraysOnly = false,\n  MaxDepth extends number = -1\n> = MaxDepth extends 0\n  ? T\n  : T extends string\n  ? string\n  : T extends (\n      [ArraysOnly] extends [true]\n        ? readonly (infer T)[]\n        : IterableOrArrayLike<infer T>\n    )\n  ? FinalIteratorItem<\n      T,\n      ArraysOnly,\n      -1 extends MaxDepth ? -1 : Minus<MaxDepth, 1>\n    >\n  : T;\n\nexport const unnest = <\n  T extends readonly any[],\n  ArraysOnly extends boolean = false,\n  Depth extends number = -1\n>(\n  items: T,\n  arraysOnly: ArraysOnly,\n  depth: Depth = -1 as any\n): FinalIteratorItem<T, ArraysOnly>[] => {\n  if (!depth) return items as any;\n\n  const results: any[] = [];\n  const test = arraysOnly ? isArray : isIterable;\n  forEach(items, (item) =>\n    test(item)\n      ? results.push(...unnest(item, arraysOnly, depth - 1))\n      : item != null && results.push(item)\n  );\n  return results;\n};\n\nexport const unarray: {\n  <T extends readonly any[], Depth extends number = -1>(\n    items: T\n  ): FinalIteratorItem<T, true>[];\n  <T extends readonly any[]>(...items: T): FinalIteratorItem<T, true>[];\n} = (...items: any[]) => unnest(items.length === 1 ? items[0] : items, true);\n\nexport const concat: {\n  <T extends readonly any[]>(items: T):\n    | ConcatResult<T>\n    | IfNot<AnyAll<ArraysAsEmpty<T[number]>, false>>;\n  <T extends readonly any[]>(...items: T):\n    | ConcatResult<T>\n    | IfNot<AnyAll<ArraysAsEmpty<T[number]>, false>>;\n} = (...items: any[]) => {\n  let merged: any[] | undefined;\n  forEach(\n    items.length === 1 ? items[0] : items,\n    (item) => item != null && (merged ??= []).push(...(array(item) as any))\n  );\n  return merged as any;\n};\n\nexport const expand = <T>(\n  root: T | T[],\n  selector: (\n    current: Exclude<T, Nullish>\n  ) => Iterable<T | undefined> | undefined,\n  includeSelf = true\n): T extends undefined ? undefined : Exclude<T, Nullish>[] =>\n  traverseInternal(root, selector, includeSelf, [], new Set()) as any;\n\nconst forEachArray = (\n  source: readonly any[],\n  action: any,\n  start: any,\n  end: any\n) => {\n  let returnValue: any;\n  let i = 0;\n  start = start! < 0 ? source.length + start! : start ?? 0;\n  end = end! < 0 ? source.length + end! : end ?? source.length;\n  for (; start < end; start++) {\n    if (\n      source[start] != null &&\n      ((returnValue = action(source[start], i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachIterable = (source: Iterable<any>, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let value of source as any) {\n    if (\n      value != null &&\n      ((returnValue = action(value, i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachObject = (source: any, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let key in source) {\n    if (\n      ((returnValue = action([key, source[key]], i++) ?? returnValue),\n      stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nexport const apply: <S, R, Args extends readonly any[]>(\n  source: S,\n  action: (\n    item: S extends IteratorSource ? IteratorItem<S> : OmitNullish<S>,\n    ...args: Args\n  ) => R,\n  ...args: Args\n) => S extends undefined ? undefined : Exclude<R, Nullish>[] = (\n  source,\n  action,\n  ...args\n) =>\n  source == null\n    ? undefined\n    : isIterable(source)\n    ? map(source, (item) => action(item as any, ...args))\n    : (action(source as any, ...args) as any);\n\nexport const applyAsync: <\n  S extends IteratorSource,\n  R extends PromiseLike<any>,\n  Args extends readonly any[]\n>(\n  source: S,\n  action: (item: IteratorItem<S>, ...args: Args) => R,\n  ...args: Args\n) => Promise<S extends undefined ? undefined : Exclude<R, Nullish>[]> = (\n  source,\n  action,\n  ...args\n) => mapAsync(source, (item) => action(item, ...args)) as any;\n\nconst forEachInternal: <S extends IteratorSource, R>(\n  source: S,\n  action?: IteratorAction<S, R>,\n  start?: any,\n  end?: any\n) => R | undefined = (source, action, start?: any, end?: any) => {\n  if (source == null) return;\n\n  if (isArray(source)) return forEachArray(source, action, start, end);\n  if (start === undefined) {\n    if (source[symbolIterator]) return forEachIterable(source as any, action);\n    if (typeof source === \"object\") return forEachObject(source, action);\n  }\n  let returnValue: any;\n  for (const value of createIterator(source, action, start, end)) {\n    value != null && (returnValue = value);\n  }\n\n  return returnValue;\n};\n\nexport const forEach = forEachInternal as {\n  <S extends IteratorSource, R>(\n    source: S,\n    action: FunctionalIteratorAction<S, R>,\n    ...rest: StartEndArgs<S>\n  ): R | undefined;\n};\n\nexport const forEachAsync: <\n  S extends IteratorSource,\n  R extends PromiseLike<any>\n>(\n  source: S,\n  action: IteratorAction<S, R>,\n  ...rest: StartEndArgs<S>\n) => Promise<R | undefined> = async (\n  source: any,\n  action: any,\n  start?: any,\n  end?: any\n) => {\n  if (source == null) return undefined;\n  let returnValue: any;\n  for (let item of project(source, action, start, end)) {\n    (item = (await item) as any) != null && (returnValue = item);\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nexport const flatForEach = <\n  S extends IteratorSource,\n  R,\n  P,\n  Depth extends number,\n  O extends boolean = false\n>(\n  source: S,\n  action: IteratorAction<S, R> | P,\n  depth: Depth = 1 as any,\n  expandObjects: O = false as any,\n  ...rest: StartEndArgs<S>\n): FlatIteratorItem<IteratorProjection<S, R, P>, Depth, O> | undefined =>\n  forEachInternal(\n    flatten(source, undefined, depth, expandObjects, ...(rest as any)),\n    action as any\n  ) as any;\n\ntype KeyValueParts<T> = T extends readonly [infer Key, infer Value]\n  ? [Key, Value]\n  : [undefined, undefined];\n\nconst fromEntries = Object.fromEntries;\n\n/**\n * Like Object.fromEntries, but accepts any iterable source and a projection instead of just key/value pairs.\n * Properties with undefined values are not included in the resulting object.\n */\nexport const obj: {\n  <S extends KeyValueSource | Nullish>(source: S): MaybeUndefined<\n    S,\n    KeyValuePairsToObject<IteratorItem<S>>\n  >;\n  <S extends Iterable<KeyValueSource> | Nullish, G extends boolean>(\n    source: S,\n    group: G\n  ): S extends Nullish\n    ? undefined\n    : KeyValueSourcesToObject<IteratorItem<S>, G>;\n\n  <S extends IteratorSource | Nullish, R extends readonly [any, any], P>(\n    source: S,\n    selector: IteratorAction<S, R> | P,\n    merge?: (\n      current: KeyValueParts<IteratorProjection<S, R, P>>[1] | undefined,\n      value: KeyValueParts<IteratorProjection<S, R, P>>[1]\n    ) => KeyValueParts<IteratorProjection<S, R, P>>[1] | Nullish\n  ): KeyValuePairsToObject<IteratorProjection<S, R, P>>;\n} = ((source: any, selector?: any, merge?: any) => {\n  if (source == null) return undefined;\n\n  if (isBoolean(selector) || merge) {\n    let result = {} as any;\n    forEach(\n      source,\n      merge\n        ? (item, i) =>\n            (item = selector(item, i)) != null &&\n            (item[1] = merge(result[item[0]], item[1])) != null &&\n            (result[item[0]] = item[1])\n        : (source) =>\n            forEach(\n              source,\n              selector\n                ? (item) =>\n                    item?.[1] != null &&\n                    ((result[item[0]] ??= []).push(item[1]), result)\n                : (item) =>\n                    item?.[1] != null && ((result[item[0]] = item[1]), result)\n            )\n    );\n    return result;\n  }\n  return fromEntries(\n    map(\n      source,\n      selector\n        ? (item, index) => ifDefined(selector(item, index), 1)\n        : (item) => ifDefined(item, 1)\n    )!\n  );\n}) as any;\n\nexport const groupReduce: <\n  S extends IteratorSource,\n  Key,\n  Accumulator = unknown\n>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  reducer: (\n    accumulator: GeneralizeConstants<Accumulator>,\n    item: IteratorItem<S>,\n    index: number\n  ) => Accumulator,\n  seed?: Accumulator | (() => Accumulator),\n  ...reset: StartEndArgs<S>\n) => Map<Key, Accumulator> = (\n  source,\n  keySelector,\n  reducer,\n  seed,\n  start?: any,\n  end?: any\n) => {\n  const groups = new Map<any, any>();\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  const action: IteratorAction<any, any> = (item, index) => {\n    const key = keySelector(item, index);\n    let acc = groups.get(key) ?? seedFactory();\n    const value = reducer(acc, item, index);\n    if (value != null) {\n      groups.set(key, value);\n    }\n  };\n  forEachInternal(source, action, start, end);\n  return groups as any;\n};\n\nexport const group: <S extends IteratorSource, Key, R = IteratorItem<S>>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  valueSelector?: (item: IteratorItem<S>, index: number) => R,\n  ...rest: StartEndArgs<S>\n) => S extends undefined ? undefined : Map<Key, R[]> = (\n  source,\n  keySelector,\n  valueSelector = (item: any) => item,\n  start?: any,\n  end?: any\n) => {\n  if (source == null) return undefined as any;\n  const groups = new Map<any, any[]>();\n  (forEachInternal as any)(\n    source,\n    (item: any, index: number) => {\n      const key = keySelector(item, index);\n      const value = valueSelector(item, index);\n      get(groups, key as any, () => []).push(value);\n    },\n    start,\n    end\n  );\n  return groups as any;\n};\n\nexport const reduce: <\n  S extends IteratorSource,\n  Reducer extends (\n    ...args: [\n      accumulator: unknown extends Accumulator\n        ? any\n        : GeneralizeConstants<Accumulator>,\n      item: IteratorItem<S>,\n      index: number\n    ]\n  ) => GeneralizeConstants<Accumulator>,\n  Accumulator\n>(\n  source: S,\n  reducer: Reducer,\n  seed?: Accumulator | (() => Accumulator),\n  ...rest: StartEndArgs<S>\n) => Reducer extends (...args: any) => infer R\n  ? R | (unknown extends Accumulator ? undefined : never)\n  : never = (source, reducer, seed, start?: any, end?: any) => {\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  return (\n    forEachInternal(\n      source,\n      (value, index) =>\n        (seed =\n          ((reducer as any)(seed as any, value, index) as any) ??\n          seedFactory()),\n      start,\n      end\n    ) ?? (seedFactory() as any)\n  );\n};\n\ntype FilterItem<S extends IteratorSource, F> = F extends (\n  value: any,\n  ...args: any\n) => value is infer T\n  ? T\n  : IteratorItem<S>;\n\nexport const filter: {\n  <\n    S extends IteratorSource,\n    MapToArray extends boolean = S extends Nullish | readonly any[]\n      ? true\n      : false,\n    P extends IteratorFilter<S> = IteratorFilter<S>\n  >(\n    source: S,\n    predicate?: P,\n    map?: MapToArray,\n    ...rest: StartEndArgs<S>\n  ): MapToArray extends true\n    ? MaybeUndefined<S, FilterItem<S, P>[]>\n    : Iterable<FilterItem<S, P>>;\n} = (\n  source: IteratorSource,\n  predicate: IteratorFilter<any> = (item: any) => item != null,\n  map = isArray(source) as any,\n  start?: any,\n  end?: any\n) =>\n  mapToArray(\n    createIterator(\n      source,\n      (item, index) => (predicate(item, index) ? item : undefined),\n      start,\n      end\n    ),\n    map\n  ) as any;\n\nlet filterInternal = filter;\n\nexport const count: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, number> = (\n  source: IteratorSource,\n  filter?: IteratorFilter<IteratorSource>,\n  start?: any,\n  end?: any\n) => {\n  if (source == null) return undefined as any;\n\n  let n: number;\n  if (filter) {\n    source = filterInternal(source, filter, false, start, end) as any;\n  } else {\n    if ((n = source![\"length\"] ?? source![\"size\"]) != null) {\n      return n;\n    }\n    if (!source[symbolIterator]) {\n      return Object.keys(source).length;\n    }\n  }\n  n = 0;\n  return forEachInternal(source, () => ++n) as any;\n};\n\nexport const sum: {\n  <S extends IteratorSourceOf<number>>(\n    source: S,\n    selector?: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n  <S extends IteratorSource>(\n    source: S,\n    selector: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n} = (\n  source: any,\n  selector: any = (item: any) => item,\n  start?: any,\n  end?: any\n) =>\n  reduce(\n    source,\n    (sum, value, index) => sum + (selector(value, index) ?? 0),\n    0,\n    start,\n    end\n  );\n\ntype CanBeEmptySource<S extends IteratorSource> = any[] extends S\n  ? true\n  : S extends { length: 0 } | 0 // Zero length range.\n  ? true\n  : S extends readonly any[] | number\n  ? false\n  : true;\n\ntype MinMaxFunction = {\n  <S extends readonly number[]>(...numbers: S | readonly [number]):\n    | (S extends readonly [] ? undefined : number)\n    | UndefinedIfEmpty<S>;\n  <S extends IteratorSource, R, P>(\n    source: S | readonly [number],\n    selector?: IteratorAction<S, R> | P,\n    ...rest: StartEndArgs<S>\n  ): true extends CanBeEmptySource<S>\n    ? number | undefined\n    : If<\n        Extends<IteratorProjectionWithUndefined<S, R, P>, number>,\n        number,\n        undefined\n      >;\n};\n\nexport const min: MinMaxFunction = (source: any, ...args: any[]) =>\n  source == null\n    ? undefined\n    : isNumber(source)\n    ? Math.min(source, ...args)\n    : reduce(\n        source,\n        (\n          min,\n          value,\n          index,\n          projected = args[1] ? args[1](value, index) : value\n        ) =>\n          min == null || (isNumber(project) && projected < min)\n            ? projected\n            : max,\n        undefined,\n        args[2],\n        args[3]\n      );\n\nexport const max: MinMaxFunction = (source: any, ...args: any[]) =>\n  source == null\n    ? undefined\n    : isNumber(source)\n    ? Math.max(source, ...args)\n    : reduce(\n        source,\n        (\n          max,\n          value,\n          index,\n          projected = args[1] ? args[1](value, index) : value\n        ) =>\n          max == null || (isNumber(projected) && projected > max)\n            ? projected\n            : max,\n        undefined,\n        args[2],\n        args[3]\n      );\n\nexport const values: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<\n  S,\n  IteratorItem<S> extends readonly [any, infer Item] ? Item : IteratorItem<S>\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isPlainObject(source) ? (item: any) => item[1] : (item: any) => item,\n    start,\n    end\n  );\n\nexport const entries: <S extends Iterable<any> | RecordType>(\n  target: S\n) => Entries<S> = (target) =>\n  !isArray(target) && isIterable(target)\n    ? map(\n        target,\n        isMap(target)\n          ? (value) => value\n          : isSet(target)\n          ? (value) => [value, true]\n          : (value, index) => [index, value]\n      )\n    : isObject(target)\n    ? (Object.entries(target) as any)\n    : undefined;\n\nexport const keys: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<\n  S,\n  IteratorItem<S> extends readonly [infer Key, any] ? Key : number\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isPlainObject(source)\n      ? (item: any) => item[0]\n      : (_item: any, i: number) => i,\n    start,\n    end\n  );\n\nexport const mapFirst: <S extends IteratorSource, R, P>(\n  source: S,\n  projection: IteratorAction<S, R> | P,\n  ...rest: StartEndArgs<S>\n) => IteratorProjection<S, R, P> | undefined = (\n  source,\n  projection,\n  start?: any,\n  end?: any\n) =>\n  source == null\n    ? undefined\n    : ((projection = wrapProjection(projection)!),\n      forEachInternal(\n        source,\n        (value, i) =>\n          !projection || (value = projection(value, i) as any)\n            ? stop(value)\n            : undefined,\n        start,\n        end\n      ));\n\nexport const first: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: IteratorFilter<any>,\n  start?: any,\n  end?: any\n) =>\n  source == null\n    ? undefined\n    : forEachInternal(\n        source,\n        (value, i) =>\n          !predicate || predicate(value, i) ? stop(value) : undefined,\n        start,\n        end\n      );\n\nexport const last: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: any,\n  start?: any,\n  end?: any\n) =>\n  source == null\n    ? undefined\n    : isArray(source)\n    ? source[source.length - 1]\n    : forEachInternal(\n        source,\n        (item, i) => (!predicate || predicate(item, i) ? item : undefined),\n        start,\n        end\n      );\n\nexport const find: <S extends IteratorSource>(\n  source: S,\n  predicate: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, IteratorItem<S>> = (\n  source,\n  predicate,\n  start?: any,\n  end?: any\n) =>\n  source == null\n    ? undefined\n    : (source as any).find\n    ? (source as any).find(predicate)\n    : first(filterInternal(source as any, predicate, false, start, end));\n\nexport const rank = <S extends IteratorSource>(source: S) =>\n  createIterator(source, (item, i) => [item, i] as const);\n\nexport const some: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, boolean> = (source, predicate, start?: any, end?: any) =>\n  source == null\n    ? undefined\n    : isPlainObject(source) && !predicate\n    ? Object.keys(source).length > 0\n    : (source as any).some?.(predicate ?? isTruish) ??\n      forEachInternal<any, boolean>(\n        source,\n        predicate\n          ? (item, index) => (predicate(item, index) ? stop(true) : false)\n          : () => stop(true),\n        start,\n        end\n      ) ??\n      false;\n\nexport const every: <S extends IteratorSource>(\n  source: S,\n  predicate?: IteratorFilter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, boolean> = (source, predicate, start?: any, end?: any) =>\n  source == null\n    ? undefined\n    : (!(some as any)(\n        source,\n        predicate\n          ? (item: any, index: number) => !predicate(item, index)\n          : isFalsish,\n        start,\n        end\n      ) as any);\n\n/**\n * Array's `sort` function that offers a single function that is applied on each element instead of having to do it twice (`[...].sort(x,y)=>f(x)-f(y)`).\n * Default is to use the value directly.\n */\nexport const sort = <T extends any[] | Nullish, Item extends IteratorItem<T>>(\n  items: T,\n  rank: (item: Item) => number = (item) => item as any\n): MaybeUndefined<T, Item[]> =>\n  (items?.sort((lhs, rhs) => rank(lhs) - rank(rhs)), items) as any;\n\nexport const binarySearch: {\n  (arr: Array<number>, find: number): number;\n  <T = number>(arr: Array<T>, find: T, compare: (x: T, y: T) => number): number;\n} = <T = number>(\n  arr: Array<T>,\n  find: T,\n  compare: (x: T, y: T) => number = ((x: any, y: any) => x - y) as any\n) => {\n  let m = 0;\n  let n = arr.length - 1;\n  let cmp: number;\n  let k: number;\n  while (m <= n) {\n    k = (n + m) >> 1;\n    cmp = compare(find, arr[k]);\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return k;\n    }\n  }\n  return ~m;\n};\n","import {\n  And,\n  Extends,\n  GeneralizeConstants,\n  If,\n  IsAny,\n  IteratorItem,\n  IteratorSourceOf,\n  KeyValuePairsToObject,\n  MaybeUndefined,\n  MethodOverloads,\n  Minus,\n  NotFunction,\n  Nullish,\n  PrettifyIntersection,\n  Primitives,\n  RecordType,\n  UnionToIntersection,\n  count,\n  forEach,\n  hasMethod,\n  isObject,\n  isArray,\n  isFunction,\n  isMap,\n  isPlainObject,\n  isSet,\n  map,\n  obj,\n  throwError,\n} from \".\";\n\ntype ReadonlyMapLike<K = any, V = any> = {\n  has?(key: K): boolean;\n  get(key: K): V | undefined;\n};\n\n// #region Shared types\ntype MapLike<K = any, V = any> = ReadonlyMapLike<K, V> & {\n  set(key: K, value: V): any;\n  delete(key: K): any;\n  clear(): any;\n};\n\ntype ReadonlySetLike<K = any> = {\n  has(key: K): boolean;\n};\ntype SetLike<K = any> = ReadonlySetLike<K> & {\n  add(key: K): any;\n  delete(key: K): any;\n  clear(): any;\n};\n\ntype ReadonlyPropertyContainer<K extends any = any, V extends any = any> =\n  | RecordType\n  | readonly any[]\n  | ReadonlyMapLike<K, V>\n  | ReadonlySetLike<K>;\n\ntype PropertyContainer<K extends any = any, V extends any = any> =\n  | ReadonlyPropertyContainer<K, V>\n  | MapLike<K, V>\n  | SetLike<K>;\n\nexport type TupleIndices<T extends readonly any[]> = T extends readonly []\n  ? never\n  : number extends T[\"length\"]\n  ? number\n  : T extends readonly [any, ...infer Rest]\n  ? TupleIndices<Rest> | Rest[\"length\"]\n  : never;\n\nexport type KeyType<T extends ReadonlyPropertyContainer | Nullish> =\n  T extends Primitives\n    ? never\n    : T extends ReadonlyMapLike<infer K, any> | ReadonlySetLike<infer K>\n    ? K\n    : T extends readonly any[]\n    ? TupleIndices<T>\n    : keyof T;\n\nexport type ValueType<\n  T extends ReadonlyPropertyContainer | Nullish,\n  K = KeyType<T>,\n  Context extends undefined | \"get\" | \"set\" = undefined\n> = IsAny<T> extends true\n  ? any\n  : T extends Nullish\n  ? never\n  : K extends KeyType<T>\n  ? T extends ReadonlyMapLike<K, infer V>\n    ? V | If<Extends<Context, \"get\" | \"set\">, undefined>\n    : T extends ReadonlySetLike<K>\n    ? boolean\n    : T[K] | If<And<Extends<T, RecordType>, Extends<Context, \"set\">>, undefined>\n  : never;\n\n// #endregion\n\n// #region get\n\nconst updateSingle = (target: any, key: any, value: any) =>\n  setSingle(target, key, isFunction(value) ? value(get(target, key)) : value);\n\nconst setSingle = (target: any, key: any, value: any) => {\n  if (target.constructor === Object) {\n    value === undefined ? delete target[key] : (target[key] = value);\n    return value;\n  }\n\n  value === undefined\n    ? target.delete\n      ? target.delete(key)\n      : delete target[key]\n    : target.set\n    ? target.set(key, value)\n    : target.add\n    ? value\n      ? target.add(key)\n      : target.delete(key)\n    : (target[key] = value);\n\n  return value;\n};\n\nexport const setSingleIfNotDefined = (\n  target: any,\n  key: any,\n  value: any,\n  error: (\n    key: string,\n    currentValue: any,\n    newValue: any,\n    target: any\n  ) => string | Error\n) => {\n  const currentValue = get(target, key);\n  if (currentValue != null) {\n    throwError(error(key, currentValue, value, target));\n  }\n  return setSingle(target, key, value);\n};\n\nexport const get: {\n  <T extends ReadonlyPropertyContainer | Nullish, K extends KeyType<T>>(\n    target: T,\n    key: K\n  ): ValueType<T, K, \"get\">;\n  <\n    T extends ReadonlyPropertyContainer | Nullish,\n    K extends KeyType<T>,\n    R extends\n      | ValueType<T, K>\n      | (() => ValueType<T, K>)\n      | undefined\n      | (() => ValueType<T, K> | undefined)\n  >(\n    target: T,\n    key: K,\n    init: R\n  ): ValueType<\n    T,\n    K,\n    R extends ValueType<T, K> | (() => ValueType<T, K>) ? undefined : \"get\"\n  >;\n} = <\n  T extends ReadonlyPropertyContainer | Nullish,\n  K extends KeyType<T>,\n  R extends ValueType<T, K> | undefined = undefined\n>(\n  target: T,\n  key: K | undefined,\n  init?: Wrapped<R>\n) => {\n  if (!target) return undefined as any;\n  if (target.constructor === Object && init == null) return target[key as any];\n\n  let value = (target as any).get\n    ? (target as any).get(key)\n    : (target as any).has\n    ? (target as any).has(key)\n    : target[key as any];\n\n  if (value === undefined && init != null) {\n    (value = isFunction(init) ? (init as any)() : init) != null &&\n      setSingle(target, key, value);\n  }\n  return value;\n};\n\n// #endregion\n\n// #region set and update\n\ntype UpdateFunction<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current,\n  Factory\n> = Factory extends false\n  ? (\n      current: Current,\n      key: Key,\n      target: T\n    ) => GeneralizeConstants<ValueType<T, Key>> | undefined\n  : (key: Key, target: T) => GeneralizeConstants<ValueType<T, Key>>;\n\ntype Updater<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current = ValueType<T, Key>,\n  SettersOnly = false,\n  Factory = false\n> = SettersOnly extends true\n  ? ValueType<T, Key> | (Factory extends true ? never : undefined)\n  : IsAny<T> extends true\n  ? NotFunction | UpdateFunction<any, any, any, Factory>\n  :\n      | (ValueType<T, Key> extends Function\n          ? never\n          : ValueType<T, Key> | (Factory extends true ? never : undefined))\n      | UpdateFunction<T, Key, Current, Factory>;\n\ntype UpdaterType<T, SettersOnly = false> = SettersOnly extends true\n  ? T\n  : T extends (...args: any) => infer T\n  ? T\n  : T;\n\ntype BulkUpdateObject<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> = T extends MapLike | SetLike | any[]\n  ? {\n      [P in KeyType<T>]: Updater<T, P, ValueType<T, P>, SettersOnly, Factory>;\n    }\n  : { [P in keyof T & KeyType<T>]?: Updater<T, P, T[P], SettersOnly, Factory> };\n\ntype BulkUpdateKeyValue<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false,\n  K extends keyof T = keyof T\n> = IsAny<T> extends true\n  ? readonly [any, Updater<T, any, any, SettersOnly, Factory>]\n  : T extends MapLike | SetLike | any[]\n  ? readonly [\n      KeyType<T>,\n      Updater<T, KeyType<T>, ValueType<T, KeyType<T>>, SettersOnly, Factory>\n    ]\n  : K extends any\n  ? readonly [K, Updater<T, KeyType<T>, any, SettersOnly, Factory>]\n  : never;\n\ntype BulkUpdates<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> =\n  | BulkUpdateObject<T, SettersOnly, Factory>\n  | Iterable<\n      | BulkUpdateKeyValue<T, SettersOnly, Factory>\n      | BulkUpdateObject<T, SettersOnly, Factory>\n    >\n  | readonly (readonly BulkUpdateKeyValue<T, SettersOnly, Factory>[])[];\n\ntype MergeResult_<Updates> = Updates extends Iterable<\n  infer Item extends readonly [keyof any, any]\n>\n  ? KeyValuePairsToObject<Item>\n  : Updates;\n\ntype MergeResult<T, Updates> = T extends RecordType\n  ? PrettifyIntersection<\n      T &\n        UnionToIntersection<\n          MergeResult_<\n            Updates extends Iterable<infer Updates> ? Updates : Updates\n          >\n        >\n    >\n  : T &\n      UnionToIntersection<\n        MergeResult_<\n          Updates extends Iterable<infer Updates> ? Updates : Updates\n        >\n      >;\n\ntype SetErrorHandler<T extends ReadonlyPropertyContainer | Nullish> = (\n  key: KeyType<T>,\n  currentValue: ValueType<T>,\n  newValue: ValueType<T>,\n  target: T\n) => string | Error;\n\ntype SettableKeyType<T extends PropertyContainer> = T extends readonly any[]\n  ? // `KeyType<T>` won't do.\n    // If this `keyof` constraint is not set TypeScript will only constrain values for readonly tuple items to T[number] and not T[K].\n    keyof T\n  : T extends RecordType\n  ? keyof any\n  : KeyType<T>;\n\ntype SettableValueType<T extends PropertyContainer, K> = K extends KeyType<T>\n  ?\n      | ValueType<T, K>\n      // `undefined` removes elements from maps and sets so also allowed.\n      | (T extends MapLike | SetLike ? undefined : never)\n  : T extends RecordType\n  ? any\n  : never;\n\ntype IsGeneralKey<T, S = keyof any> = S extends T ? true : false;\n\n/** List of keys in T that has undefined values. If Template does not allow undefined values for a key it is excluded from the results. */\ntype UndefinedKeys<\n  T,\n  Template = {},\n  K extends keyof T = keyof T\n> = K extends keyof T\n  ? T[K] extends undefined\n    ? K extends keyof Template\n      ? undefined extends Template[K]\n        ? K\n        : never\n      : K\n    : never\n  : never;\n\ntype AllKeys<T> = T extends infer T ? keyof T : never;\n\ntype AnyValue<T, K> = T extends infer T\n  ? K extends keyof T\n    ? T[K]\n    : never\n  : never;\n\ntype MergeObjects<T> = {\n  [P in AllKeys<T>]: AnyValue<T, P>;\n};\n\ntype KeyValueTupleToRecord<Item> = Item extends readonly [infer K, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : Item extends readonly (infer KV)[]\n  ? { [P in KV & keyof any]: KV }\n  : Item extends RecordType\n  ? Item\n  : never;\n\ntype AssignRecord<T, S> = {\n  [P in Exclude<\n    keyof T | keyof S,\n    IsGeneralKey<keyof T | keyof S> extends true ? never : UndefinedKeys<S, T>\n  >]: P extends keyof S\n    ? IsGeneralKey<P> extends true\n      ? AnyValue<S | T, P>\n      : P extends keyof T\n      ? S[P] extends T[P]\n        ? GeneralizeConstants<S[P]> extends T[P]\n          ? GeneralizeConstants<S[P]>\n          : S[P]\n        : never\n      : GeneralizeConstants<S[P]>\n    : P extends keyof T\n    ? T[P]\n    : never;\n};\n\ntype SetOrUpdateFunction<\n  SettersOnly,\n  ErrorHandler = false,\n  Readonly = false\n> = {\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined,\n    U extends Updater<\n      T extends Nullish ? never : T,\n      K,\n      ValueType<T, K>,\n      SettersOnly\n    >,\n    K extends KeyType<T>\n  >(\n    target: T,\n    key: K,\n    value: U,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): UpdaterType<U>;\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined,\n    U\n  >(\n    target: T,\n    values: BulkUpdates<T extends Nullish ? never : T, SettersOnly> & U,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): T;\n};\n\nexport const merge = <\n  Target,\n  Values extends readonly IteratorSourceOf<readonly [keyof any, any]>[]\n>(\n  target: Target,\n  ...values: Values\n): MaybeUndefined<Target, MergeResult<Target, Values>> => (\n  forEach(values, (values) =>\n    forEach(values, ([key, value]) => {\n      if (value != null) {\n        if (isPlainObject(target[key]) && isPlainObject(value)) {\n          merge(target[key], value);\n        } else {\n          target[key] = value;\n        }\n      }\n    })\n  ),\n  target as any\n);\n\nconst createSetOrUpdateFunction =\n  <SettersOnly, Error>(\n    setter: (target: any, key: any, value: any, error?: any) => any\n  ): SetOrUpdateFunction<SettersOnly, Error> =>\n  (target: PropertyContainer, key: any, value?: any, error?: any) => {\n    if (!target) return undefined;\n    if (value != undefined) {\n      return setter(target, key, value, error);\n    }\n\n    forEach(key, (item) =>\n      isArray(item)\n        ? setter(target, item[0], item[1])\n        : forEach(item, ([key, value]) => setter(target, key, value))\n    );\n\n    return target;\n  };\n\nexport const assign = createSetOrUpdateFunction<true, false>(setSingle);\nexport const update = createSetOrUpdateFunction<false, false>(updateSingle);\nexport const assignIfUndefined = createSetOrUpdateFunction<false, true>(\n  setSingleIfNotDefined\n);\n\nexport const swap = <T extends PropertyContainer, K extends KeyType<T>>(\n  target: T,\n  key: K,\n  value: ValueType<T, K>\n): ValueType<T, K, \"get\"> => {\n  const current = get(target, key) as any;\n  if (value !== current) setSingle(target, key, value);\n  return current as any;\n};\n\n// #endregion\n\nexport const add = <T extends PropertyContainer<any, boolean>>(\n  target: T,\n  key: KeyType<T>\n) =>\n  target instanceof Set\n    ? target.has(key)\n      ? false\n      : (target.add(key), true)\n    : get(target, key) !== assign(target, key, true as any);\n\nexport const has = <T extends ReadonlyPropertyContainer>(\n  target: T,\n  key: KeyType<T>\n) =>\n  hasMethod(target, \"has\")\n    ? target.has(key)\n    : ((target as any).get?.(key) ?? (target as any)[key]) != null;\n\ntype RemoveDeepArgs<\n  T,\n  Current extends any[] = [],\n  Depth extends number = 20\n> = T extends PropertyContainer\n  ? Depth extends 0\n    ? Current\n    :\n        | (Depth extends 20 ? never : Current)\n        | RemoveDeepArgs<\n            ValueType<T>,\n            [...Current, KeyType<T>[] | KeyType<T>],\n            Minus<Depth, 1>\n          >\n  : Current;\n\ntype RemoveDeepValue<\n  T,\n  Args extends any[],\n  ArrayIt = false\n> = T extends PropertyContainer\n  ? ArrayIt extends true\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>[]]\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>]\n    ? ValueType<T> | undefined\n    : Args extends [infer R, ...infer Rest]\n    ? RemoveDeepValue<ValueType<T>, Rest, R extends any[] ? true : ArrayIt>\n    : never\n  : never;\n\ntype KeysArg<T extends PropertyContainer | Nullish> = T extends RecordType\n  ? readonly (keyof T | undefined)[]\n  : readonly (KeyType<T> | undefined)[];\n\nconst clearSingle = (target: any, key: any) => {\n  if ((target ?? key) == null) return undefined;\n\n  let current = get(target, key);\n\n  if (hasMethod(target, \"delete\")) {\n    target.delete(key);\n  } else {\n    delete target[key];\n  }\n  return current;\n};\n\n/**\n * Deletes the specified keys from the target and returns the target.\n */\nexport const del: {\n  <T extends PropertyContainer | undefined, K extends KeysArg<T>>(\n    target: T,\n    ...keys: K\n  ): T extends RecordType ? { [P in Exclude<keyof T, K[number]>]: T[P] } : T;\n} = (target: any, ...keys: any) =>\n  target &&\n  (assign(target, map(keys, (key) => [key, undefined]) as any) as any);\n\n/**\n * Removes one or more values from a property container specified by the provided key or array of keys.\n *\n * If more than one level of key arguments are specified, values will be removed from the property container at the deepest level.\n * If a property container becomes empty along the path of keys, it will be removed from its parent.\n *\n */\nexport const clear = <\n  T extends PropertyContainer | Nullish,\n  Args extends RemoveDeepArgs<T>\n>(\n  target: T,\n  ...keys: Args\n): RemoveDeepValue<T, Args> => {\n  const removed: any[] = [];\n  let array = false;\n\n  const clearStep = (\n    target: any,\n    index: number,\n    parent?: any,\n    parentKey?: any\n  ) => {\n    if (!target) return;\n    const targetKeys = keys[index];\n    if (index === keys.length - 1) {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) => removed.push(clearSingle(target, key)));\n      } else {\n        removed.push(clearSingle(target, targetKeys));\n      }\n    } else {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) =>\n          clearStep(get(target, key), index + 1, target, key)\n        );\n      } else {\n        clearStep(get(target, targetKeys), index + 1, target, targetKeys);\n      }\n      if (!count(target) && parent) {\n        remove(parent, parentKey);\n      }\n    }\n  };\n  clearStep(target, 0);\n  return array ? removed : removed[0];\n};\n\n/** Removes all entries from a set or map, and returns them. */\nexport const empty = <S extends SetLike | MapLike | undefined>(\n  target: S\n): MaybeUndefined<S, IteratorItem<S>[]> => {\n  if (!target) return undefined as any;\n\n  const entries = map(target);\n  target.clear();\n  return entries as any;\n};\n\n/**\n * Removes the specified key(s) from a property container and returns their value, or undefined if the container did not have the specified key.\n *\n * The difference between {@link clear} and this function is that it does not consider nested property containers and that arrays will be spliced (as opposed to `clear` where the index will be set to `undefined`).\n */\nexport const remove: {\n  <T extends PropertyContainer | Nullish, K extends KeyType<T> | undefined>(\n    target: T,\n    key: K\n  ): T extends Nullish ? T : ValueType<T, K, \"get\">;\n  <T extends PropertyContainer | Nullish, K extends KeysArg<T>>(\n    target: T,\n    keys: K\n  ): (T extends Nullish ? T : ValueType<T, K[number], \"get\">)[];\n} = (target: PropertyContainer, keys: any) => {\n  if (!target) return undefined;\n\n  if (isArray(keys)) {\n    // Sort array keys descending as they would otherwise not match their offset as the array is spliced along the way.\n    return (\n      isArray(target) && target.length > 1 ? keys.sort((x, y) => y - x) : keys\n    ).map((key) => remove(target, key));\n  }\n\n  return isArray(target)\n    ? keys < target.length\n      ? (target as any[]).splice(keys, 1)[0]\n      : undefined\n    : clearSingle(target, keys);\n};\n\ntype EntryToObject<Item> = Item extends readonly [infer K & keyof any, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : never;\n\ntype EntriesToObject<Entries> = UnionToIntersection<\n  InlinePropertyDescriptors<\n    Entries extends Nullish | boolean\n      ? {}\n      : Entries extends readonly [\n          Partial<Readonly<PropertyDescriptor>>,\n          ...infer Rest\n        ]\n      ? EntriesToObject<Rest[number]>\n      : Entries extends readonly [infer Item, ...infer Rest]\n      ? EntryToObject<Item> & EntriesToObject<Rest>\n      : Entries extends readonly (infer Items)[]\n      ? EntryToObject<Items>\n      : Entries\n  >\n>;\n\ntype InlinePropertyDescriptors<T> = {\n  [P in keyof T]: T[P] extends () => infer V | { value: infer V }\n    ? V\n    : T[P] extends { get(): infer V }\n    ? V\n    : T[P];\n};\n\ntype PropertyList =\n  | boolean\n  | null\n  | undefined\n  | readonly [defaults: Partial<PropertyDescriptor>, ...items: PropertyList[]]\n  | readonly (readonly [key: keyof any, value: any])[]\n  | RecordType;\n\nexport const define: {\n  <T, P extends readonly PropertyList[]>(\n    target: T,\n    ...properties: P\n  ): (T extends Function ? T : {}) &\n    PrettifyIntersection<T & EntriesToObject<P[number]>>;\n} = (target: any, ...args: readonly any[]) => {\n  const add = (arg: any, defaults?: any) => {\n    if (!arg) return;\n    let properties: readonly any[];\n    if (isArray(arg)) {\n      if (isPlainObject(arg[0])) {\n        // Tuple with the first item the defaults and the next the definitions with those defaults,\n        // ([{enumerable: false, ...}, ...])\n        (arg as any[]).splice(1).forEach((items) => add(items, arg[0]));\n        return;\n      }\n      // ([[key1, value1], [key2, value2], ...])\n      properties = arg;\n    } else {\n      // An object.\n      properties = map(arg)!;\n    }\n\n    properties.forEach(([key, value]) =>\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        writable: false,\n        ...defaults,\n        ...(isPlainObject(value) && (\"get\" in value || \"value\" in value)\n          ? value\n          : isFunction(value) && !value.length\n          ? { get: value }\n          : { value }),\n      })\n    );\n  };\n\n  args.forEach((arg) => add(arg));\n  return target as any;\n};\n\ntype PropertySelector<T> =\n  | keyof T\n  | {\n      [P in keyof T]?: PropertySelector<T[P]>;\n    }\n  | readonly (keyof T)[];\n\ntype SinglePickResult<T, Selected> = Selected extends\n  | (string & infer K)\n  | (infer K)[]\n  ? unknown extends K\n    ? T\n    : { [P in keyof T & K]: T[P] }\n  : keyof Selected extends infer Keys\n  ? {\n      [P in Keys & keyof any & keyof Selected]: P extends keyof T\n        ? Selected[P] extends true\n          ? T[P]\n          : SinglePickResult<T[P], Selected[P]>\n        : never;\n    }\n  : never;\n\ntype PickResults<T, Selectors> = PrettifyIntersection<\n  Selectors extends [infer Item, ...infer Rest]\n    ? unknown extends Item\n      ? T\n      : SinglePickResult<T, Item> & SinglePickResult<T, Rest>\n    : never\n>;\n\nexport const pick = <T, Selectors extends PropertySelector<T>[], U>(\n  source: T | (null | (undefined & U)),\n  ...args: Selectors\n): U extends undefined ? undefined : PickResults<T, Selectors> => {\n  if (source === undefined) return undefined as any;\n\n  return Object.fromEntries(\n    args\n      .flatMap((arg) =>\n        isObject(arg)\n          ? isArray(arg)\n            ? arg.map((args) =>\n                isArray(args)\n                  ? args.length === 1\n                    ? [args[0], source![args[0]]]\n                    : pick(source![args[0]], ...(args[1] as any[]))\n                  : [args, source![args]]\n              )\n            : Object.entries(args).map(([key, value]) => [\n                key,\n                value === true ? source![key] : pick(source![key], value),\n              ])\n          : ([[arg, source![arg]]] as any)\n      )\n      .filter((arg) => arg[1] != null)\n  ) as any;\n};\n\nexport type Wrapped<T> = T | (() => T);\n\nexport type Unwrap<T> = T extends () => infer R ? R : T;\n\nexport const unwrap: {\n  <T>(value: Wrapped<T>): T;\n} = (value: Wrapped<any>): any => (isFunction(value) ? value() : value);\n\nexport const unlock = <T extends ReadonlyPropertyContainer>(\n  readonly: T\n): T extends ReadonlyMapLike<infer K, infer V>\n  ? MapLike<K, V>\n  : T extends ReadonlySetLike<infer T>\n  ? SetLike<T>\n  : T => readonly as any;\n\nexport const wrap = <T>(\n  original: T,\n  wrap: (\n    original: T extends (...args: any) => any ? T : () => T,\n    ...args: T extends (...args: infer Args) => any ? Args : []\n  ) => T extends (...args: any) => infer R ? R : T\n): T =>\n  original == null\n    ? original\n    : isFunction(original)\n    ? (...args: any) => wrap(original as any, ...args)\n    : (wrap as any)(() => original as any);\n\nexport const clone = <T>(value: T, depth = -1): T =>\n  isObject(value)\n    ? isArray(value)\n      ? depth\n        ? value.map((value) => clone(value, depth - 1))\n        : [...value]\n      : isSet(value)\n      ? new Set<any>(\n          depth\n            ? (map as any)(value, (value: any) => clone(value, depth - 1))\n            : value\n        )\n      : isMap(value)\n      ? new Map<any, any>(\n          depth\n            ? (map as any)(value, (value: any) =>\n                // Does not clone keys.\n                [value[0], clone(value[1], depth - 1)]\n              )\n            : value\n        )\n      : depth\n      ? obj(value as any, ([k, v]) => [k, clone(v, depth - 1)])\n      : { ...value }\n    : (value as any);\n\n/**\n * Very much like `Array.push` except it accepts anything with a `push ` method  (including non-generic overloads),\n * and returns the target so chaining is easier. Suitable for tight minification.\n */\nexport const push = <T extends { push: (...args: any) => any } | Nullish>(\n  target: T,\n  ...items: MethodOverloads<T, \"push\">[0]\n): T => target?.push(...(items as any))!;\n\n/**\n * Very much like `Array.pop` except it accepts anything with a `pop` method.\n * (Included or the sake of generality since we have {@link push}). Suitable for tight minification.\n */\nexport const pop = <T extends { pop(): R } | undefined, R>(\n  target: T\n): MaybeUndefined<T, R> => target?.pop() as any;\n\n/**\n * Very much like `Array.unshift` except it accepts anything with a `push ` method  (including non-generic overloads),\n * and returns the target so chaining is easier. Suitable for tight minification\n */\nexport const unshift = <T extends { unshift: (...args: any) => any } | Nullish>(\n  target: T,\n  ...items: MethodOverloads<T, \"unshift\">[0]\n): T => target?.unshift(...(items as any))!;\n\n/**\n * Very much like `Array.shift` except it accepts anything with a `shift` method.\n * (Included or the sake of generality since we have {@link unshift}). Suitable for tight minification. */\nexport const shift = <T extends { shift(): R } | undefined, R>(\n  target: T\n): MaybeUndefined<T, R> => target?.shift() as any;\n","import {\n  F,\n  MaybePromise,\n  T,\n  isBoolean,\n  isFunction,\n  isNotFalse,\n  isTrue,\n  promise,\n  tryCatchAsync,\n} from \".\";\n\nexport let now: (round?: boolean) => number =\n  typeof performance !== \"undefined\"\n    ? (round = T) =>\n        round ? Math.trunc(now(F)) : performance.timeOrigin + performance.now()\n    : Date.now;\n\nexport type Timer = {\n  (toggle?: boolean, reset?: boolean): number;\n};\n\nexport const reset = Symbol();\n\nexport const createTimer = (\n  started = true,\n  timeReference = () => now()\n): Timer => {\n  let t0: number = +started * timeReference();\n  let elapsed = 0;\n  let capturedElapsed: number;\n  return (toggle = started, reset?: boolean) => {\n    capturedElapsed = started\n      ? (elapsed += -t0 + (t0 = timeReference()))\n      : elapsed;\n    reset && (elapsed = 0);\n    (started = toggle) && (t0 = timeReference());\n    return capturedElapsed;\n  };\n};\n\n/**\n * The callback invoked when a {@link Clock} ticks.\n * If it returns `false` the clock will stop. Any other return value has no effect.\n */\nexport type ClockCallback = (\n  elapsed: number,\n  delta: number\n) => MaybePromise<any>;\n\nexport interface Clock {\n  readonly active: boolean;\n  readonly busy: boolean;\n  restart(frequency?: number, callback?: ClockCallback): Clock;\n  toggle(start: boolean, trigger?: boolean): Clock;\n  trigger(skipQueue?: boolean): Promise<boolean>;\n}\n\nexport interface ClockSettings {\n  frequency?: number;\n  queue?: boolean;\n  paused?: boolean;\n  trigger?: boolean;\n  once?: boolean;\n  callback?: ClockCallback;\n}\n\n/** Light-weight version of {@link clock}. The trigger and cancel overloads returns true to enable chaining like `timeout(false)&&...` */\nexport const stickyTimeout = (\n  defaultTimeout = 0\n): {\n  (callback: () => void, timeout?: number): void;\n  (cancel: false): true;\n  (trigger: true): true;\n  (): boolean;\n} => {\n  let handle: number;\n  let currentCallback: (() => void) | undefined;\n\n  const stickyTimeout = (arg?: any, timeout = defaultTimeout) => {\n    if (arg === undefined) {\n      return !!currentCallback;\n    }\n    clearTimeout(handle);\n    if (isBoolean(arg)) {\n      arg && (timeout < 0 ? isNotFalse : isTrue)(currentCallback?.())\n        ? stickyTimeout(currentCallback)\n        : (currentCallback = undefined);\n    } else {\n      currentCallback = arg;\n      handle = setTimeout(\n        () => stickyTimeout(true, timeout),\n        timeout < 0 ? -timeout : timeout\n      );\n    }\n  };\n  return stickyTimeout as any;\n};\n\nexport const clock: {\n  (callback: ClockCallback, frequency: number): Clock;\n  (settings: ClockSettings): Clock;\n} = (\n  callbackOrSettings: ClockCallback | ClockSettings,\n  frequency = 0\n): Clock => {\n  const settings = isFunction(callbackOrSettings)\n    ? {\n        frequency,\n        callback: callbackOrSettings,\n      }\n    : callbackOrSettings;\n\n  let {\n    queue = true,\n    paused = false,\n    trigger = false,\n    once = false,\n    callback = () => {},\n  } = settings;\n  frequency = settings.frequency ?? 0;\n\n  let timeoutId = 0;\n  const mutex = promise(true).resolve();\n  const timer = createTimer(!paused);\n  let delta = timer();\n\n  const outerCallback = async (skipQueue?: boolean) => {\n    if (!timeoutId || (!queue && mutex.pending && skipQueue !== true)) {\n      return false;\n    }\n    (instance as any).busy = true;\n    if (skipQueue !== true) {\n      await mutex;\n    }\n\n    mutex.reset();\n\n    if (\n      (await tryCatchAsync(\n        () => callback!(timer(), -delta + (delta = timer())),\n        false,\n        () => mutex.resolve()\n      )) === false ||\n      frequency <= 0 ||\n      once\n    ) {\n      reset(false);\n    }\n\n    return !((instance as any).busy = false);\n  };\n\n  const reset = (start: boolean, resetTimer = !start) => {\n    timer(start, resetTimer);\n    clearInterval(timeoutId);\n    (instance as any).active = !!(timeoutId = start\n      ? (setInterval(\n          outerCallback,\n          frequency < 0 ? -frequency : frequency\n        ) as any)\n      : 0);\n    return instance;\n  };\n\n  const instance: Clock = {\n    active: false,\n    busy: false,\n    restart: (newFrequency, newCallback) => {\n      frequency = newFrequency ?? frequency;\n      callback = newCallback ?? callback;\n      return reset(true, true);\n    },\n    toggle: (start, trigger) =>\n      start !== instance.active\n        ? start\n          ? trigger\n            ? (reset(true), instance.trigger(), instance)\n            : reset(true)\n          : reset(false)\n        : instance,\n    trigger: async (skipQueue) =>\n      (await outerCallback(skipQueue)) && (reset(instance.active), true),\n  };\n\n  return instance.toggle(!paused, trigger);\n};\n","import {\n  If,\n  MaybePromise,\n  MaybeUndefined,\n  Nullish,\n  TogglePromise,\n  Unwrap,\n  Wrapped,\n  createTimer,\n  isFunction,\n  now,\n  throwError,\n  tryCatchAsync,\n  undefined,\n  unwrap,\n} from \".\";\n\nexport class ResettablePromise<T = void, E = any> implements PromiseLike<T> {\n  private _promise: OpenPromise<T>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public get value() {\n    return this._promise.value;\n  }\n  public get error() {\n    return this._promise.error;\n  }\n  public get pending() {\n    return this._promise.pending;\n  }\n\n  public resolve(value: T, ifPending = false) {\n    this._promise.resolve(value, ifPending);\n    return this;\n  }\n\n  public reject(value?: E, ifPending = false) {\n    this._promise.reject(value, ifPending);\n    return this;\n  }\n\n  public reset() {\n    this._promise = new OpenPromise<T>();\n    return this;\n  }\n\n  public signal(value: T) {\n    this.resolve(value);\n    this.reset();\n    return this;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): PromiseLike<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport class OpenPromise<T = void, E = any> implements PromiseLike<T> {\n  private readonly _promise: Promise<T>;\n\n  public readonly resolve: (value: T, ifPending?: boolean) => this;\n  public readonly reject: (reason: E | undefined, ifPending?: boolean) => this;\n  public readonly value: (T extends void ? true : T) | undefined;\n  public readonly error: E | true;\n  public pending = true;\n\n  constructor() {\n    let captured: any[];\n    this._promise = new Promise((...args: any[]) => {\n      captured = args.map((inner, i) => (value: any, ifPending: boolean) => {\n        if (!this.pending) {\n          if (ifPending) return this;\n          throw new TypeError(\"Promise already resolved/rejected.\");\n        }\n\n        (this as any).pending = false;\n        (this as any)[i ? \"error\" : \"value\"] = value === undefined || value;\n        inner(value);\n        return this;\n      });\n    });\n\n    [this.resolve, this.reject] = captured!;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | null\n      | undefined,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | null\n      | undefined\n  ): Promise<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport interface Lock {\n  /**\n   * Wait until the lock is available. If a timeout is not specified or negative, the calling thread will wait indefinitely.\n   * If a owner ID is specified the lock will be reentrant for that ID.\n   */\n  <Ms extends number | undefined = undefined>(\n    timeout?: Ms,\n    ownerId?: string\n  ): Promise<(() => void) | If<Ms, undefined>>;\n\n  /**\n   * Performs the specified action when the lock becomes available.\n   * If a timeout is not specified or negative, the calling thread will wait indefinitely.\n   * If a owner ID is specified the lock will be reentrant for that ID.\n   */\n  <T, Ms extends number | undefined = undefined>(\n    action: () => MaybePromise<T>,\n    timeout?: Ms,\n    ownerId?: string\n  ): Promise<T | If<Ms, undefined>>;\n}\n\nexport type LockState = [owner: string | boolean, expires?: number];\n\nexport const createLock = (timeout?: number): Lock => {\n  const semaphore = promise<LockState | boolean>(true);\n  let state: LockState | undefined;\n\n  const wait = async (\n    arg1?: (() => any) | number,\n    arg2?: number | string,\n    arg3?: string\n  ) => {\n    if (isFunction(arg1)) {\n      const release = await wait(arg2 as number, arg3);\n      return release ? await tryCatchAsync(arg1, true, release) : undefined;\n    }\n    const ownerId = arg2 as string;\n\n    let ms = arg1 as number;\n    let renewInterval = 0;\n    while (state && ownerId !== state[0] && (state[1] ?? 0)! < now()) {\n      if (\n        (await (ms >= 0 ? race(delay(ms), semaphore) : semaphore)) === undefined\n      ) {\n        return undefined;\n      }\n      // If the above did not return undefined we got the semaphore.\n    }\n\n    const release = () => {\n      clearTimeout(renewInterval);\n      state = undefined;\n      semaphore.signal(false);\n    };\n\n    const renew = () => {\n      state = [ownerId ?? true, timeout ? now() - timeout : undefined];\n      timeout &&\n        (renewInterval = setTimeout(() => state && renew(), timeout / 2));\n    };\n    renew();\n\n    return release;\n  };\n  return wait;\n};\n\nexport const defer = (f: VoidFunction, ms = 0) =>\n  ms > 0 ? setTimeout(f, ms) : window.queueMicrotask(f);\n\nexport const delay = <\n  Delay extends number | Nullish,\n  T extends Wrapped<any> = void\n>(\n  ms: Delay,\n  value?: T\n): MaybeUndefined<Delay, TogglePromise<Unwrap<T>, true>> =>\n  ms == null || isFinite(ms)\n    ? !ms || ms <= 0\n      ? unwrap(value)!\n      : new Promise<any>((resolve) =>\n          setTimeout(async () => resolve(await unwrap(value)), ms)\n        )\n    : (throwError(`Invalid delay ${ms}.`) as any);\n\nexport const promise: {\n  <T = void>(resettable?: false): OpenPromise<T>;\n  <T = void>(resettable: true): ResettablePromise<T>;\n} = (resettable?: boolean) =>\n  resettable ? new ResettablePromise() : (new OpenPromise() as any);\n\ntype UnwrapPromiseArg<T> = T extends () => infer T ? Awaited<T> : Awaited<T>;\ntype UnwrapPromiseArgs<T extends any[]> = T extends readonly [infer Arg]\n  ? [UnwrapPromiseArg<Arg>]\n  : T extends readonly [infer Arg, ...infer Rest]\n  ? [UnwrapPromiseArg<Arg>, ...UnwrapPromiseArgs<Rest>]\n  : [];\n\nexport type AsyncValue<T> =\n  | undefined\n  | T\n  | PromiseLike<T>\n  | (() => T)\n  | (() => PromiseLike<T>);\n\nexport const waitAll = <Args extends AsyncValue<any>[]>(\n  ...args: Args\n): Promise<UnwrapPromiseArgs<Args>> =>\n  Promise.all(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n\nexport const race = <Args extends AsyncValue<any>[]>(\n  ...args: Args\n): Promise<UnwrapPromiseArgs<Args>[number]> =>\n  Promise.race(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n","import { filter, reduce } from \".\";\n\nexport type Rebinder = () => boolean;\nexport type Unbinder = () => boolean;\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\n\nexport type SourceListener<Args extends readonly any[]> = (\n  ...args: Args\n) => void;\nexport type Listener<Args extends readonly any[]> = (\n  ...args: [...args: Args, unbind: Unbinder]\n) => void;\n\nexport const createEventBinders = <Args extends any[]>(\n  listener: Listener<Args>,\n  attach: (listener: SourceListener<Args>) => void,\n  detach: (listener: SourceListener<Args>) => void\n): Binders => {\n  let bound = false;\n\n  const outerListener = (...args: Args) => listener(...args, unbind);\n\n  const unbind = () =>\n    bound !== (bound = false) && (detach(outerListener), true);\n\n  const rebind = () =>\n    bound !== (bound = true) && (attach(outerListener), true);\n\n  rebind();\n  return [unbind, rebind];\n};\n\nexport const joinEventBinders = (\n  ...binders: (Binders | undefined)[]\n): Binders => (\n  (binders = filter(binders)),\n  [\n    () => reduce(binders, (changed, binder) => binder![0]() || changed, false),\n    () => reduce(binders, (changed, binder) => binder![1]() || changed, false),\n  ]\n);\n\nexport type EventHandler<Args extends readonly any[]> = (\n  ...payload: Args\n) => void;\n\nexport const createEvent = <Args extends readonly any[]>(): [\n  listen: (listener: Listener<Args>, triggerCurrent?: boolean) => Binders,\n  dispatch: (...payload: Args) => void\n] => {\n  const listeners = new Set<SourceListener<Args>>();\n  let dispatchedArgs: Args | undefined;\n  return [\n    (handler, trigger) => {\n      const binders = createEventBinders(\n        handler as any,\n        (handler) => listeners.add(handler),\n        (handler) => listeners.delete(handler)\n      );\n      trigger &&\n        dispatchedArgs &&\n        (handler as any)(...dispatchedArgs, binders[0]);\n      return binders;\n    },\n    (...payload) => (\n      (dispatchedArgs = payload),\n      listeners.forEach((handler) => handler(...payload))\n    ),\n  ];\n};\n\nexport type ChainedEventHandler<Args extends any[], T> = (\n  ...args: [\n    ...args: Args,\n    next: {\n      (): T;\n      (...args: Args): T;\n    },\n    unbind: Unbinder\n  ]\n) => T;\n\ntype LinkedNode<T> = [\n  prev: LinkedNode<T> | undefined,\n  item: T,\n  next: LinkedNode<T> | undefined\n];\n\nexport const createChainedEvent = <T = void, Args extends any[] = []>(): [\n  register: (\n    handler: ChainedEventHandler<Args, T>,\n    priority?: number\n  ) => Binders,\n  invoke: (...args: Args) => T | undefined\n] => {\n  type Item = [\n    handler: ChainedEventHandler<Args, T>,\n    priority: number,\n    binders: Binders\n  ];\n  type Node = LinkedNode<Item>;\n  let head: Node | undefined;\n  let tail: Node | undefined;\n  let next: Node | undefined;\n\n  const register = (\n    handler: ChainedEventHandler<Args, T>,\n    // Make sure that handler gets rebound at their previous priority without jumping discrete increments.\n    // (It is deseriable to be able to specfiy priority 0 or  10 without having to think about how many 0s there are)\n    priority = (tail?.[1][1] ?? 0) + 0.000001\n  ) => {\n    const registerNode = (node?: Node) => {\n      let bound = true;\n      node ??= [\n        undefined,\n        [\n          handler,\n          priority,\n          [\n            () => {\n              if (!bound) return false;\n              node![0] ? (node![0][2] = node![2]) : (head = node![2]);\n              node![2] ? (node![2][0] = node![0]) : (tail = node![0]);\n              node![0] = node![2] = undefined;\n              return !(bound = false);\n            },\n            () => (bound ? false : (registerNode(node), (bound = true))),\n          ],\n        ],\n        undefined,\n      ];\n      next = head;\n      if (!next) {\n        head = tail = node;\n      } else if (priority >= tail![1][1]) {\n        node[0] = tail;\n        tail = tail![2] = node;\n      } else {\n        // INV: priority < tail.priority, so next will be non-null after loop;\n        while (next![1][1]! <= priority) {\n          next = next[2]!;\n        }\n\n        (node[0] = (node[2] = next)[0]) ? (node[0][2] = node) : (head = node);\n        next[0] = node;\n      }\n\n      return node[1][2];\n    };\n    return registerNode();\n  };\n\n  const invoke = (node: Node | undefined, args: Args) => (\n    (next = node?.[2]),\n    node\n      ? node[1][0](\n          ...args,\n          (...nextArgs: Args) =>\n            invoke(next!, nextArgs.length ? nextArgs : args),\n          node[1][2][0]\n        )\n      : undefined\n  );\n\n  return [register, (...args) => invoke(head, args)];\n};\n","import {\r\n  MaybeUndefined,\r\n  array,\r\n  forEach,\r\n  isArray,\r\n  isBoolean,\r\n  isIterable,\r\n  isNumber,\r\n  isObject,\r\n  isString,\r\n  push,\r\n} from \".\";\r\n\r\nexport const changeCase = <S extends string | null | undefined>(\r\n  s: S,\r\n  upper: boolean\r\n): S => (s == null ? s : upper ? s.toUpperCase() : s.toLowerCase()) as S;\r\n\r\nexport const changeIdentifierCaseStyle = (\r\n  identifier: string,\r\n  type: \"camel\" | \"pascal\" | \"kebab\" | \"snake\"\r\n) =>\r\n  identifier.replace(\r\n    /([_-]*)(\\$*(?:[A-Z]+|[a-z]))([a-z0-9]*)/g,\r\n    (_, underscores, initial, rest, index) =>\r\n      (underscores && (!index || type === \"kebab\" || type === \"snake\")\r\n        ? underscores.replace(/./g, type === \"snake\" ? \"-\" : \"_\")\r\n        : \"\") +\r\n      ((index && (type === \"kebab\" || type === \"snake\") && !underscores\r\n        ? type === \"snake\"\r\n          ? \"-\"\r\n          : \"_\"\r\n        : \"\") +\r\n        changeCase(initial, type === \"pascal\" || (type === \"camel\" && index)) +\r\n        changeCase(\r\n          type === \"kebab\" || type === \"snake\"\r\n            ? rest.replace(\r\n                /(?<=\\D)\\d|(?<=\\d)\\D/g,\r\n                type === \"kebab\" ? \"_$&\" : \"-$&\"\r\n              )\r\n            : rest,\r\n          false\r\n        ))\r\n  );\r\n\r\nexport type EnumerationSeparators = string | [last: string, other?: string];\r\n\r\n/**\r\n * Creates a string enumerating a list of value given a separator, optionally using a different separator between the last two items.\r\n *\r\n * @param values - The list of items to enumerator.\r\n * @param separator - The separator to use (defaults to \", \"). If given a tuple, the first item is the last separator without spaces.\r\n * The second item may optionally specify another separator than the default (\", \").\r\n *\r\n *\r\n * Useful for enumerations like \"item1, item2 and item 3\" (`separate([\"item1\", \"item2\", \"item3\"], [\"and\"])`).\r\n */\r\nexport const separate = (\r\n  values: any[] | undefined,\r\n  separator: EnumerationSeparators = [\"and\", \", \"]\r\n) =>\r\n  !values\r\n    ? undefined\r\n    : values.length === 1\r\n    ? values[0]\r\n    : isArray(separator)\r\n    ? [\r\n        values.slice(-1).join(separator[1] ?? \", \"),\r\n        \" \",\r\n        separator[0],\r\n        \" \",\r\n        values[values.length - 1],\r\n      ].join(\"\")\r\n    : values.join(separator ?? \", \");\r\n\r\n/**\r\n * Pluralizes a noun using standard English rules.\r\n * It is not very smart, so if the plural form is not just adding an \"s\" in the end, it must be specified manually.\r\n *\r\n * @param singular - The singular form of the noun\r\n * @param n - The number of items that decides if the noun should be pluralized. If given an array the number will be postfixed.\r\n * @param plural - The plural form if it is different from adding an \"s\" to the singular form.\r\n * @returns The noun, pluralized if needed.\r\n */\r\nexport const pluralize = <\r\n  T extends string | undefined,\r\n  Plural extends string = string\r\n>(\r\n  singular: T,\r\n  n: number | [number],\r\n  plural?: Plural\r\n): MaybeUndefined<T, string> =>\r\n  singular == null\r\n    ? (undefined as any)\r\n    : (isArray(n) ? (n = n[0]) + \" \" : \"\") +\r\n      (n === 1 ? singular : plural ?? singular + \"s\");\r\n\r\n/**\r\n * Can colorize text using ANSI escape sequences.\r\n * See e.g. https://developer.chrome.com/docs/devtools/console/format-style for options.\r\n */\r\nexport const ansi = <Buffer extends string[] | undefined = undefined>(\r\n  value: string | string[],\r\n  ps: string | number,\r\n  buffer?: Buffer\r\n): Buffer extends undefined ? string : string[] =>\r\n  buffer\r\n    ? (push(buffer, \"\\x1B[\", ps, \"m\"),\r\n      isArray(value) ? push(buffer, ...value) : push(buffer, value),\r\n      push(buffer, \"\\x1B[m\"),\r\n      buffer)\r\n    : (ansi(value, ps, []).join(\"\") as any);\r\n\r\nconst indent = (buffer: string[], n: number, ...values: string[]) => (\r\n  push(buffer, \"  \".repeat(n), ...values), buffer\r\n);\r\nconst br = (buffer: string[], indents = 0) => (\r\n  indents > 0 && indent(buffer, indents), push(buffer, \"\\n\"), buffer\r\n);\r\n\r\nconst prettyPrint = (\r\n  value: any,\r\n  buffer: string[] = [],\r\n  indents = 0,\r\n  terminator = \"\"\r\n) => {\r\n  const wrap = (\r\n    start: string,\r\n    end: string,\r\n    content: (buffer: string[]) => void\r\n  ) => {\r\n    ansi(start, 90, buffer);\r\n    const subBuffer: string[] = [];\r\n    content(subBuffer);\r\n    subBuffer.length &&\r\n      (br(buffer, indents), push(buffer, ...subBuffer)) &&\r\n      indent(buffer, indents);\r\n\r\n    ansi(end, 90, buffer);\r\n  };\r\n\r\n  if (value == null) {\r\n    ansi(value === undefined ? \"(undefined)\" : \"(null)\", \"37;2\", buffer);\r\n  } else if (isIterable(value)) {\r\n    wrap(\"[\", \"]\", (buffer) =>\r\n      forEach(\r\n        value,\r\n        (value) => (\r\n          indent(buffer, indents),\r\n          prettyPrint(value, buffer, indents + 1, \",\\n\")\r\n        )\r\n      )\r\n    );\r\n  } else if (isObject(value)) {\r\n    wrap(\"{\", \"}\", (buffer) =>\r\n      forEach(\r\n        value,\r\n        ([key, value]) => (\r\n          indent(buffer, indents + 1),\r\n          ansi([\"\" + (key as any), \":\"], \"90;3\", buffer),\r\n          push(buffer, \" \"),\r\n          prettyPrint(value, buffer, indents + 1, \",\\n\")\r\n        )\r\n      )\r\n    );\r\n  } else if (isString(value)) {\r\n    ansi(value, 36, buffer);\r\n  } else if (isNumber(value) || isBoolean(value)) {\r\n    ansi(\"\" + value, 33, buffer);\r\n  } else {\r\n    push(buffer, value);\r\n  }\r\n  terminator && push(buffer, terminator);\r\n  return buffer;\r\n};\r\n","import {\r\n  IterableOrArrayLike,\r\n  MaybeArray,\r\n  MaybeUndefined,\r\n  ifDefined,\r\n  isArray,\r\n  isIterable,\r\n  last,\r\n  map,\r\n} from \"..\";\r\n\r\nexport const pluralize = <T>(\r\n  noun: T,\r\n  count: number\r\n): MaybeUndefined<T, string> =>\r\n  ifDefined(noun, () => noun + (count !== 1 ? \"s\" : \"\"));\r\n\r\nexport const conjunct = <T>(\r\n  values: T,\r\n  conjunction = \"and\"\r\n): MaybeUndefined<T, string> =>\r\n  ifDefined(\r\n    values,\r\n    (values: any) => (\r\n      (values = isIterable(values)\r\n        ? map(values, (value) => value + \"\")\r\n        : [values + \"\"]),\r\n      values.length === 0\r\n        ? \"\"\r\n        : values.length === 1\r\n        ? values[0]\r\n        : `${values.slice(0, -1).join(\", \")} ${conjunction} ${last(values)}`\r\n    )\r\n  );\r\n\r\nexport const quote = <T>(\r\n  item: T\r\n): MaybeUndefined<\r\n  T,\r\n  T extends string\r\n    ? string\r\n    : T extends IterableOrArrayLike<any>\r\n    ? string[]\r\n    : string\r\n> =>\r\n  ifDefined(item, (item) =>\r\n    isIterable(item) ? map(item, (item) => \"'\" + item + \"'\") : \"'\" + item + \"'\"\r\n  ) as any;\r\n\r\nexport const capitalize = <T extends string | undefined>(\r\n  sentence: T\r\n): MaybeUndefined<T, string> =>\r\n  ifDefined(sentence, (sentence) =>\r\n    sentence.length > 0\r\n      ? sentence.slice(0, 1).toUpperCase() + sentence.slice(1)\r\n      : \"\"\r\n  );\r\n","import {\n  AllKeys,\n  Entries,\n  Extends,\n  Nullish,\n  Property,\n  define,\n  entries,\n  isArray,\n  isNumber,\n  isObject,\n  isString,\n  obj,\n  throwError,\n  undefined,\n} from \".\";\nimport { conjunct, quote } from \"./types/strings\";\n\nexport type ParsedValue<\n  T extends EnumHelper<any, any, any>,\n  V\n> = V extends Nullish\n  ? V\n  : T extends EnumHelper<infer T, infer Flags & boolean, any>\n  ? V extends keyof T\n    ? T[V]\n    : V extends T[keyof T]\n    ? V\n    : Flags extends true\n    ? number\n    : never\n  : never;\n\ntype EnumValue_<\n  Names extends string,\n  Enum,\n  Flags extends boolean,\n  Numeric\n> = boolean extends Numeric\n  ? Names | Enum | (Flags extends true ? (Names | Enum)[] : never)\n  : Numeric extends true\n  ? Enum\n  : Names | (Flags extends true ? Names[] : never);\n\nexport type EnumValueOf<\n  Helper extends EnumHelper<any, any, any>,\n  Numeric = boolean\n> = Helper extends EnumHelper<infer T, infer Flags & boolean, any>\n  ? EnumValue_<keyof T & string, T[keyof T], Flags & boolean, Numeric>\n  : never;\n\nexport type EnumValue<\n  Names extends Record<string, any>,\n  Enum,\n  Flags extends boolean,\n  Numeric\n> = EnumValue_<\n  Lowercase<keyof Names extends string ? keyof Names : never>,\n  Flags extends true ? Enum | (number & {}) : Enum,\n  Flags,\n  Numeric\n>;\n\nexport type EnumHelper<\n  T extends EnumSource,\n  Flags extends boolean,\n  PureFlags extends number\n> = ParseFunction<T, Flags, \"numeric\", never, true> &\n  Readonly<\n    {\n      /**\n       * The number of possible unique values in the enumeration.\n       */\n      length: number;\n      /**\n       * Converts the provided value to its numeric value or throws an exception if it does not match a value in the enumeration.\n       */\n      parse: ParseFunction<T, Flags, \"numeric\">;\n\n      /**\n       * Converts the provided value to its numeric value or returns `undefined` if it does not match a value in the enumeration.\n       */\n      tryParse: ParseFunction<T, Flags, \"numeric\", undefined>;\n\n      /**\n       * All values of the enumeration.\n       */\n      values: T[keyof T][];\n\n      /**\n       * All names and values of the enumeration.\n       */\n      entries: string extends keyof T\n        ? readonly [string, T[keyof T]][]\n        : Entries<T>;\n\n      /**\n       * Looks up a value and returns its name or array of names if the enumeration represents flags.\n       */\n      lookup: ParseFunction<T, Flags, \"lookup\">;\n\n      /**\n       * Looks up a value and returns its name if it matches a single value in the enumeration ,\n       * or an array of names if the enumeration represents flags and the value matches more than one.\n       */\n      format: ParseFunction<T, Flags, \"format\">;\n\n      /**\n       * Pretty prints an enumeration value with its name and values suitable for logging and error messages.\n       * For example \"The values 'test 1' or 'test 2'\".\n       */\n      logFormat(value: ParsableArg<T, Flags>, conjunction?: string): string;\n    } & (Flags extends true\n      ? {\n          /** Flag values that are not a combination of other flags (that is, a single bit). */\n          pure: readonly EntriesByValue<T, PureFlags>[];\n          map<R = T[keyof T]>(\n            flags: ParsableEnumTypeValue<T, boolean | undefined, Flags>,\n            map?: (entry: EntriesByValue<T, PureFlags>, index: number) => R\n          ): R[];\n        }\n      : {})\n  >;\n\ntype EnumSource = Record<string, string | number>;\n\ntype MaybeArray<T, Flags, ArrayIfArray = false> = Flags extends true\n  ? (ArrayIfArray extends true ? never : T) | T[]\n  : T;\n\ntype Lowercased<T extends EnumSource> = {\n  [P in keyof T & string as Lowercase<P>]: T[P];\n};\n\ntype Lookup<T extends EnumSource, V, Name extends boolean> = V extends never\n  ? never\n  : {\n      [P in keyof T]: V extends T[P] ? (Name extends true ? P : T[P]) : never;\n    } extends infer T\n  ? T[keyof T]\n  : never;\n\ntype ParsedValueInternal<T extends EnumSource, V, Flags> = V extends keyof T\n  ? T[V]\n  : V extends T[keyof T]\n  ? Lookup<T, V, false>\n  : [Flags, V] extends [true, number]\n  ? T[keyof T]\n  : never;\n\nexport type ParsableEnumTypeValue<\n  T extends EnumSource,\n  Numeric,\n  Flags extends boolean,\n  Enum extends number = T[keyof T] & number\n> =\n  | (boolean extends Numeric\n      ? MaybeArray<\n          | (Flags extends true ? number | Enum : Enum)\n          | keyof T\n          | (Flags extends true ? \"any\" | \"none\" : never),\n          Flags\n        >\n      : Numeric extends true\n      ? Flags extends true\n        ? Enum | (number & {})\n        : Enum\n      : Flags extends true\n      ? keyof T | readonly (keyof T)[]\n      : keyof T)\n  | (undefined extends Numeric ? undefined : never);\n\ntype ParsableArg<\n  T extends EnumSource,\n  Flags extends boolean\n> = ParsableEnumTypeValue<T, boolean | undefined, Flags>;\n\ntype ParseFunction<\n  T extends EnumSource,\n  Flags extends boolean,\n  Type extends \"numeric\" | \"lookup\" | \"format\",\n  InvalidValue extends undefined | never = never,\n  MainFunction = false\n> = {\n  <V extends string | number | symbol | null | undefined>(\n    value:\n      | V\n      | ParsableArg<T, Flags>\n      | (Flags extends true ? V[] | ParsableArg<T, Flags>[] : never),\n    ...args: MainFunction extends true ? [] : [validateNumbers?: boolean]\n  ): V extends null | undefined\n    ? undefined\n    : Type extends \"lookup\" | \"format\"\n    ? MaybeArray<\n        | (ParsedValueInternal<T, V, Flags> extends never\n            ? V extends string | number\n              ? keyof T | \"any\" | \"none\" | InvalidValue\n              : InvalidValue\n            : Lookup<T, ParsedValueInternal<T, V, Flags>, true>)\n        | (Type extends \"format\"\n            ? V extends keyof T | T[keyof T]\n              ? never\n              : \"any\" | \"none\"\n            : never),\n        Flags,\n        Type extends \"lookup\" ? true : false\n      >\n    : ParsedValueInternal<T, V, Flags> extends never\n    ? keyof any extends infer K\n      ? K extends V\n        ? T[keyof T] | InvalidValue\n        : never\n      : InvalidValue\n    : ParsedValueInternal<T, V, Flags>;\n};\n\ntype EntriesByValue<T extends Record<keyof any, any>, V extends keyof any> = {\n  [P in keyof T as T[P]]: readonly [P, T[P]];\n}[V] extends infer T // Use the infer trick to make vscode intellisense expand the values.\n  ? T\n  : never;\n\nconst isBit = (n: number) => ((n = Math.log2(n)), n === (n | 0));\n\nexport const createEnumAccessor = <\n  T extends EnumSource,\n  Flags extends boolean,\n  PureFlags extends number = 0\n>(\n  sourceEnum: T,\n  flags: Flags,\n  enumName: string,\n  pureFlags?: PureFlags\n): EnumHelper<Lowercased<T>, Flags, PureFlags> => {\n  const names: Record<string, number> = Object.fromEntries(\n    Object.entries(sourceEnum as any)\n      .filter(([key, value]) => isString(key) && isNumber(value))\n      .map(([key, value]) => [key.toLowerCase(), value])\n  ) as any;\n\n  const entries = Object.entries(names);\n  const values = Object.values(names);\n\n  const any = names[\"any\"] ?? values.reduce((any, flag) => any | flag, 0);\n\n  const nameLookup: Record<string, number> = flags\n    ? { ...names, any, none: 0 }\n    : names;\n\n  const valueLookup = Object.fromEntries(\n    Object.entries(nameLookup).map(([key, value]) => [value, key])\n  );\n\n  const parseValue = (value: any, validateNumbers?: boolean) =>\n    isNumber(value)\n      ? !flags && validateNumbers\n        ? valueLookup[value] != null\n          ? value\n          : undefined\n        : value\n      : isString(value)\n      ? nameLookup[value] ?? nameLookup[value.toLowerCase()]\n      : undefined;\n\n  let invalid = false;\n  let carry: any;\n  let carry2: any;\n\n  const [tryParse, lookup] = flags\n    ? [\n        (value: any, validateNumbers?: boolean) =>\n          Array.isArray(value)\n            ? value.reduce(\n                (flags, flag) =>\n                  flag == null || invalid\n                    ? flags\n                    : (flag = parseValue(flag, validateNumbers)) == null\n                    ? ((invalid = true), undefined)\n                    : (flags ?? 0) | flag,\n                ((invalid = false), undefined as number | undefined)\n              )\n            : parseValue(value),\n        (value: any, format: boolean) =>\n          (value = tryParse(value, false)) == null\n            ? undefined\n            : format && (carry2 = valueLookup[value & any])\n            ? (carry = lookup(value & ~(value & any), false)).length\n              ? [carry2, ...carry]\n              : carry2\n            : ((value = entries\n                .filter(([, flag]) => flag && value & flag && isBit(flag))\n                .map(([name]) => name)),\n              format\n                ? value.length\n                  ? value.length === 1\n                    ? value[0]\n                    : value\n                  : \"none\"\n                : value),\n      ]\n    : [\n        parseValue,\n        (value: any) =>\n          (value = parseValue(value)) != null ? valueLookup[value] : undefined,\n      ];\n\n  let originalValue: any;\n  const parse = (value: any, validateNumbers?: boolean) =>\n    value == null\n      ? undefined\n      : (value = tryParse((originalValue = value), validateNumbers)) == null\n      ? throwError(\n          new TypeError(\n            `${JSON.stringify(originalValue)} is not a valid ${enumName} value.`\n          )\n        )\n      : value;\n\n  const pure = entries.filter(\n    ([, value]) => !pureFlags || ((pureFlags & value) === value && isBit(value))\n  );\n\n  return define(\n    (value: any) => parse(value),\n    [\n      { configurable: false, enumerable: false },\n      {\n        parse,\n        tryParse,\n        entries,\n        values,\n        lookup,\n        length: entries.length,\n        format: (value: any) => lookup(value, true),\n        logFormat: (value: any, c = \"or\") => (\n          (value = lookup(value, true)),\n          value === \"any\"\n            ? \"any \" + enumName\n            : `the ${enumName} ${conjunct(quote(value), c)}`\n        ),\n      } as const,\n      flags &&\n        ({\n          pure,\n          map: (flags: any, map?: (flag: any, index: number) => any) => (\n            (flags = parse(flags)),\n            pure\n              .filter(([, flag]) => flag & flags)\n              .map(map ?? (([, flag]) => flag))\n          ),\n        } as const),\n    ]\n  ) as any;\n};\n\ntype NumericValues<T, Flags> = Flags extends true ? number : T[keyof T];\n\ntype EnumPropertyType<Helper, Value> = Helper extends EnumHelper<\n  infer T,\n  infer Flags extends boolean,\n  any\n>\n  ? Extends<number | string, Value> extends true\n    ? NumericValues<T, Flags>\n    : Value extends infer Keys extends keyof T\n    ? T[Keys]\n    : Value extends NumericValues<T, Flags>\n    ? Value\n    : never\n  : never;\n\nexport type ParsedEnumResult<\n  T,\n  EnumProps extends readonly Record<string, EnumHelper<any, any, any>>[]\n> = T extends Nullish\n  ? T\n  : T extends readonly []\n  ? []\n  : T extends readonly [infer Item, ...infer Rest]\n  ? [\n      ParsedEnumResult<Item, EnumProps>,\n      ...(Rest extends readonly any[] ? ParsedEnumResult<Rest, EnumProps> : [])\n    ]\n  : T extends readonly (infer Item)[]\n  ? ParsedEnumResult<Item, EnumProps>[]\n  : T extends infer T\n  ? {\n      [P in keyof T]: P extends AllKeys<EnumProps[number]>\n        ? EnumPropertyType<Property<EnumProps[number], P>, T[P]>\n        : T[P];\n    }\n  : never;\n\n/**\n * Creates a function that parses the specified enum properties to their numeric values on the object provided.\n * Note that it does the parsing directly on the provided object and does not create a copy.\n */\nexport const createEnumPropertyParser: <\n  EnumProps extends readonly Record<string, EnumHelper<any, any, any>>[]\n>(\n  ...props: EnumProps\n) => <T>(value: T) => ParsedEnumResult<T, EnumProps> = ((\n  ...props: Record<string, EnumHelper<any, any, any>>[]\n) => {\n  const parsers = entries(obj(props, true));\n\n  const parse = (source: any) => (\n    isObject(source) &&\n      (isArray(source)\n        ? source.forEach((sourceItem, i) => (source[i] = parse(sourceItem)))\n        : parsers.forEach(([prop, parsers]) => {\n            let parsed = undefined;\n            let value: any;\n            if ((value = source[prop]) == null) return;\n            parsers.length === 1\n              ? (source[prop] = parsers[0].parse(value))\n              : parsers.forEach(\n                  (parser, i) =>\n                    !parsed &&\n                    (parsed =\n                      i === parsers.length - 1\n                        ? parser.parse(value)\n                        : parser.tryParse(value)) != null &&\n                    (source[prop] = parsed)\n                );\n          })),\n    source\n  );\n\n  return parse;\n}) as any;\n","import {\n  IterableOrArrayLike,\n  IteratorItem,\n  MaybeUndefined,\n  Nullish,\n  PickRequired,\n  PrettifyIntersection,\n  RecordType,\n  concat,\n  forEach,\n  isArray,\n  isString,\n  join,\n  map,\n  mapFirst,\n  match,\n  nil,\n  obj,\n  undefined,\n} from \".\";\n\ntype QueryStringDelimiterValue = boolean | readonly string[] | readonly [];\n\nexport type ParsedUri<\n  QueryStringDelimiters extends QueryStringDelimiterValue = QueryStringDelimiterValue\n> = {\n  /** The original URI that was parsed. */\n  source: string;\n  /** The name of the scheme excluding colon and slashes. */\n  scheme?: string;\n\n  /**\n   * Whether the scheme includes two slashes or not (in which case it is a urn).\n   * Slashes are only included when formatting the URI if this value is explicity `false`,\n   * or {@link scheme} has a value and it is not explicitly `true`.\n   *\n   * @default false\n   */\n  urn?: boolean;\n\n  /**\n   * User name, password, host and port as much as any of these are part of the URI.\n   * When formatting a parsed URI, this is not used, but rather the individual parts.\n   */\n  authority?: string;\n\n  user?: string;\n  password?: string;\n  host?: string;\n  port?: number;\n  path?: string;\n  query?: QueryStringDelimiters extends false\n    ? string\n    : ParsedQueryString<Exclude<QueryStringDelimiters, null>>;\n  fragment?: string;\n};\n\nexport type ParsedQueryString<Delimiters extends QueryStringDelimiterValue> =\n  Record<\n    string,\n    Delimiters extends null | readonly [] | false ? string : string | string[]\n  >;\n\nexport const uriEncode = (value: any) =>\n  value != nil ? encodeURIComponent(value) : undefined;\n\nconst parseKeyValue = (\n  value: string | Nullish,\n  arrayDelimiters: readonly string[] | readonly [] = [\"|\", \";\", \",\"],\n  decode = true\n):\n  | readonly [key: string, value: string | undefined, values: string[]]\n  | undefined => {\n  if (!value) return undefined;\n  const parts: [string, string, string[]] = value\n    .split(\"=\")\n    .map((v) =>\n      decode ? decodeURIComponent(v.trim()).replaceAll(\"+\", \" \") : v.trim()\n    ) as any;\n  parts[1] ??= \"\";\n  parts[2] =\n    (parts[1] &&\n      arrayDelimiters?.length &&\n      mapFirst(arrayDelimiters, (delim, _, split = parts[1]!.split(delim)) =>\n        split.length > 1 ? split : undefined\n      )) ||\n    (parts[1] ? [parts[1]] : []);\n  return parts;\n};\n\n// // Browsers accepts `//` as \"whatever the protocol is\" is links.\n// // A scheme can only be letters, digits, `+`, `-` and `.`.\n// // The slashes are captured so we can put the parsed URI correctly back together.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1\n// Scheme (group 1 and 2) = `//` or `name:` or `name://` = (?:(?:([\\w+.-]+):)?(\\/\\/)?)\n\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.1\n// User Information (groups 4 and 5) = `user@` or `user:password@` = (?:([^:@]+)(?:\\:([^@]*))?@)\n\n// // If an IPv6 address is used with a port it is wrapped in square brackets.\n// // Otherwise a host is anything until port, path or query string.\n// // Se also https://serverfault.com/questions/205793/how-can-one-distinguish-the-host-and-the-port-in-an-ipv6-url about the brackets.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2\n// Host (group 6 or 7) = `[ IPv6 or IPvFuture ]:port` or IPv6 or `IPv4:port` or `domain:port`  = (?:\\[([^\\]]+)\\]|([0-9:]+|[^/+]+?))\n\n// //Port is included in the optional host group to separate `about:blank` like schemes from `localhost:1337` like hosts\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.3\n// Port (group 8) = (?::(\\d*))?\n\n// Authority (group 3) = User Information + Host + Port\n\n// // Anything until an optional query or fragment\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3\n// Path and  (group 9) = (\\/[^#?]*)\n\n// // Anything following a `?` until an optional fragment.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.4\n// Query (group 10) = (?:\\?([^#]*))\n\n// // Anything following a pound sign until end.\n// // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\n// Fragment (group 11) = (?:#.*)\n\n// Everything put together\n// ^(?:(?:([\\w+.-]+):)?(?:\\/\\/)?)?((?:([^:@]+)(?:\\:([^@]*))?@)?(?:\\[([^\\]]+)\\]|([0-9:]+|[^/+]+?))?(?::(\\d*))?)?(\\/[^#?]*)?(?:\\?([^#]*))?(?:#(.*))?$\n\n/**\n * Parses an URI according to https://www.rfc-editor.org/rfc/rfc3986#section-2.1.\n * The parser is not pedantic about the allowed characters in each group\n *\n * @param uri The URI to parse\n * @param query Whether to parse the query into a record with each parameter and its value(s) or just the string.\n *  If an array is provided these are the characters that are used to split query string values. If this is empty, arrays are not parsed.\n * @returns A record with the different parts of the URI.\n */\nexport const parseUri = <\n  Uri extends string | Nullish,\n  QueryString extends QueryStringDelimiterValue = true,\n  RequireAuthority extends boolean = false\n>(\n  uri: Uri,\n  query: QueryString = true as any,\n  requireAuthority?: RequireAuthority\n): PrettifyIntersection<\n  RequireAuthority extends true\n    ? PickRequired<ParsedUri<QueryString>, \"scheme\" | \"host\" | \"urn\" | \"path\">\n    : ParsedUri<QueryString>,\n  true\n> =>\n  uri == nil\n    ? undefined\n    : (match(\n        uri,\n        /^(?:(?:([\\w+.-]+):)?(\\/\\/)?)?((?:([^:@]+)(?:\\:([^@]*))?@)?(?:\\[([^\\]]+)\\]|([0-9:]+|[^/+]+?))?(?::(\\d*))?)?(\\/[^#?]*)?(?:\\?([^#]*))?(?:#(.*))?$/g,\n        (\n          source,\n          scheme,\n          slashes,\n          authority,\n          user,\n          password,\n          bracketHost,\n          host,\n          port,\n          path,\n          queryString,\n          fragment\n        ) => {\n          const parsed: ParsedUri = {\n            source,\n            scheme,\n            urn: scheme ? !slashes : slashes ? false : undefined,\n            authority,\n            user,\n            password,\n            host: bracketHost ?? host,\n            port: port != null ? parseInt(port) : undefined,\n            path,\n            query:\n              query === false\n                ? queryString\n                : parseQueryString(queryString, query),\n            fragment,\n          };\n          parsed.path =\n            parsed.path ||\n            (parsed.authority ? (parsed.urn ? \"\" : \"/\") : undefined);\n          return parsed;\n        }\n      ) as any);\n\nexport const parseQueryString = <\n  V extends string | Nullish,\n  Delimiters extends QueryStringDelimiterValue = true\n>(\n  query: V,\n  arrayDelimiters?: Delimiters,\n  decode = true\n): PrettifyIntersection<ParsedQueryString<Delimiters>> =>\n  query == nil\n    ? undefined\n    : (obj(\n        query?.match(/(?:^.*?\\?|^)(.*)$/)?.[1]?.split(\"&\"),\n        (\n          part,\n          _,\n          [key, value, values] = parseKeyValue(\n            part,\n            arrayDelimiters === false\n              ? []\n              : arrayDelimiters === true\n              ? undefined\n              : arrayDelimiters,\n            decode\n          ) ?? []\n        ) =>\n          (key = key?.replace(/\\[\\]$/, \"\")) != null\n            ? arrayDelimiters !== false\n              ? [key, values!.length > 1 ? values! : value!]\n              : [key, value!]\n            : undefined,\n        (current, value) =>\n          current\n            ? arrayDelimiters !== false\n              ? concat(current, value)\n              : (current ? current + \",\" : \"\") + value\n            : value\n      ) as any);\n\nexport const toQueryString = <\n  P extends\n    | Iterable<readonly [string, any]>\n    | RecordType<string, any>\n    | undefined\n>(\n  parameters: P,\n  delimiter = \",\"\n): MaybeUndefined<P, string> =>\n  parameters == nil\n    ? undefined\n    : (map(parameters, ([key, value]) =>\n        isString(key)\n          ? key +\n              \"=\" +\n              (isArray(value)\n                ? map(value, uriEncode).join(delimiter)\n                : uriEncode(value)) ?? \"\"\n          : undefined\n      )?.join(\"&\") as any);\n\nexport const appendQueryString = <Uri extends string | undefined>(\n  baseUri: Uri,\n  parameters:\n    | Record<string, any>\n    | Iterable<readonly [key: string, value: any]>\n    | undefined\n): MaybeUndefined<Uri, string> => {\n  if (!baseUri) return undefined!;\n  const qs = toQueryString(parameters);\n  return (baseUri.match(/^[^?]*/)![0] + (qs ? \"?\" + qs : \"\")) as any;\n};\n\nexport const mergeQueryString = <Uri extends string | undefined>(\n  currentUri: Uri,\n  parameters:\n    | Record<string, any>\n    | Iterable<readonly [key: string, value: any]>\n    | undefined\n): MaybeUndefined<Uri, string> => {\n  if (!currentUri) return undefined!;\n  const current = parseQueryString(currentUri);\n  forEach(parameters, ([key, value]) => (current[key] = current[key] ?? value));\n  return appendQueryString(currentUri, current) as any;\n};\n\nexport const formatUri = <Uri extends Omit<ParsedUri, \"source\">>(\n  uri: Uri\n): MaybeUndefined<Uri, string> =>\n  uri == nil\n    ? (undefined as any)\n    : join([\n        uri.scheme || uri.urn === false\n          ? (uri.scheme ? uri.scheme + \":\" : \"\") + (!uri.urn ? \"//\" : \"\")\n          : \"\",\n        uri.user,\n        uri.password ? \":\" + uri.password : undefined,\n        uri.user && \"@\",\n        uri.host,\n        uri.port ? \":\" + uri.port : undefined,\n        uri.path === \"/\" ? \"\" : uri.path,\n        uri.query &&\n          \"?\" + (isString(uri.query) ? uri.query : toQueryString(uri.query)),\n        uri.fragment && \"#\" + uri.fragment,\n      ]) || undefined!;\n","import { Nullish } from \"@tailjs/util\";\nimport {\n  RestrictVariableTargets,\n  TrackedEvent,\n  VariableGetResult,\n  VariableSetResult,\n} from \"..\";\n\nexport type PostVariableGetResult = RestrictVariableTargets<\n  VariableGetResult,\n  true\n>;\n\nexport type PostVariableSetResult = Omit<\n  RestrictVariableTargets<VariableSetResult, true>,\n  \"source\"\n>;\n\nexport interface PostResponse {\n  /**\n   * Results from variable operations.\n   * The server may push variables to the client by including get results that the client has not requested.\n   */\n  variables?: {\n    /** Results from get operations made via a {@link PostRequest} or variables the server wants to push. */\n    get?: (PostVariableGetResult | undefined)[];\n\n    /** Result from set operations made via a {@link PostRequest}. */\n    set?: (\n      | Omit<RestrictVariableTargets<VariableSetResult, true>, \"source\">\n      | undefined\n    )[];\n  };\n\n  /** Events to be routed to an external client-side tracker. */\n  clientEvents?: TrackedEvent[];\n}\n\nexport const isPostResponse = (response: any): response is PostResponse =>\n  !!response?.variables;\n","import {\n  AllKeys,\n  Extends,\n  If,\n  IfNot,\n  IsAny,\n  MaybeArray,\n  MaybePick,\n  MaybeUndefined,\n  Nullish,\n  PrettifyIntersection,\n  array,\n  deferredPromise,\n  filter,\n  isArray,\n  map,\n  throwError,\n  undefined,\n} from \"@tailjs/util\";\nimport {\n  Variable,\n  VariableGetResult,\n  VariableResultStatus,\n  VariableSetResult,\n  VariableSetter,\n  formatKey,\n} from \"..\";\n\ntype SuccessStatus<ChangedOnly = false> =\n  | VariableResultStatus.Success\n  | VariableResultStatus.Created\n  | IfNot<ChangedOnly, VariableResultStatus.Unchanged>;\n\ntype VariableSuccessResult<\n  R,\n  Filter extends VariableSuccessResultFilter = \"all\",\n  Return extends VariableResultType = \"result\"\n> = R extends {\n  current: infer V;\n  status: SuccessStatus<Extends<\"changed\", Filter>>;\n} // Set result\n  ? Return extends \"result\"\n    ? R\n    : Return extends \"variable\"\n    ? V\n    : V extends { value: infer V }\n    ? V\n    : never\n  : R extends {\n      value?: infer V;\n      status:\n        | SuccessStatus<Extends<\"changed\", Filter>>\n        | IfNot<Extends<\"value\", Filter>, VariableResultStatus.NotFound>;\n    } // Get result\n  ? Return extends \"result\"\n    ? R\n    : Return extends \"variable\"\n    ? MaybePick<R, keyof Variable>\n    : V\n  : never;\n\nexport type VariableSuccessResultFilter = \"value\" | \"changed\" | \"all\";\nexport type VariableResultType = \"value\" | \"variable\" | \"result\";\nexport type VariableSuccessResults<\n  Results,\n  Filter extends VariableSuccessResultFilter = \"all\",\n  Return extends VariableResultType = \"result\"\n> = Results extends undefined\n  ? undefined\n  : Results extends readonly []\n  ? []\n  : Results extends readonly [infer Item, ...infer Rest]\n  ? [\n      VariableSuccessResult<Item, Filter, Return>,\n      ...VariableSuccessResults<Rest, Filter, Return>\n    ]\n  : Results extends readonly (infer Item)[]\n  ? VariableSuccessResult<Item, Filter, Return>[]\n  : VariableSuccessResult<Results, Filter, Return>;\n\nexport type FilterVariableResults<\n  Results,\n  SuccessOnly extends boolean = false,\n  Filter extends VariableSuccessResultFilter = \"all\"\n> = If<SuccessOnly, Results, VariableSuccessResults<Results, Filter>>;\n\nexport type VariableResultPromise<\n  T extends readonly any[] = readonly any[],\n  Push = undefined\n> = T[number] extends never\n  ? never\n  : PromiseLike<VariableSuccessResults<T>> &\n      PrettifyIntersection<\n        {\n          all: PromiseLike<T>;\n          changed: PromiseLike<VariableSuccessResults<T, \"changed\">>;\n          values: PromiseLike<VariableSuccessResults<T, \"all\", \"value\">>;\n          variables: PromiseLike<VariableSuccessResults<T, \"all\", \"variable\">>;\n        } & (Push extends true | ((arg: any) => void)\n          ? { push(): VariableResultPromise<T, false> }\n          : {}) &\n          (T[\"length\"] extends 1\n            ? {\n                value: PromiseLike<\n                  VariableSuccessResults<T, \"all\", \"value\">[0]\n                >;\n                result: PromiseLike<\n                  Exclude<VariableSuccessResults<T>[0], undefined>\n                >;\n                variable: PromiseLike<\n                  VariableSuccessResults<T, \"all\", \"variable\">[0]\n                >;\n              }\n            : {})\n      >;\n\nexport const toVariableResultPromise = <T extends readonly any[], Push>(\n  results: () => PromiseLike<T>,\n  errorHandlers?: ErrorHandlerParameter<T>,\n  push?: Push &\n    ((results: Exclude<VariableSuccessResult<T[number]>, undefined>[]) => void)\n): VariableResultPromise<T, Push> => {\n  let mapResults = (results: any): any[] => results;\n  let unwrappedResults: any;\n  const property = (\n    map: (\n      results: VariableSuccessResult<VariableGetResult | VariableSetResult>[]\n    ) => any,\n    errorHandler = handleResultErrors\n  ) =>\n    deferredPromise(\n      async () =>\n        (unwrappedResults = mapResults(\n          errorHandler(await results(), errorHandlers)\n        )) && map(unwrappedResults)\n    );\n\n  const promise: Record<AllKeys<VariableResultPromise<any, true>>, any> = {\n    then: property((items) => items).then,\n    all: property(\n      (items) => items,\n      (items) => items\n    ),\n    changed: property((items) => filter(items, (item) => item.status < 300)),\n    variables: property((items) => map(items, getResultVariable)),\n    values: property((items) =>\n      map(items, (item) => getResultVariable(item)?.value)\n    ),\n    push: () => (\n      (mapResults = (results) => (\n        push?.(map(getSuccessResults(results) as any[])), results\n      )),\n      promise as any\n    ),\n\n    value: property((items) => getResultVariable(items[0])?.value),\n    variable: property((items) => getResultVariable(items[0])),\n    result: property((items) => items[0]),\n  };\n\n  return promise as any;\n};\n\ntype ValidatableResult<V = {}> =\n  | (V & {\n      status: VariableResultStatus;\n      error?: any;\n    } & (\n        | {\n            current?: V & { version?: string };\n            source?: KeyLike;\n          }\n        | KeyLike\n      ))\n  | Nullish;\n\nexport const getSuccessResults = <\n  R extends readonly ValidatableResult[] | undefined\n>(\n  results: R\n): VariableSuccessResults<R> =>\n  results?.map((result) => (result?.status! < 400 ? result : undefined)) as any;\n\ntype KeyLike = { scope: any; key: any; targetId?: any };\n\nexport const getResultKey = <R extends ValidatableResult>(\n  result: R\n): MaybeUndefined<\n  R,\n  R extends { source: KeyLike }\n    ? R[\"source\"]\n    : R extends KeyLike\n    ? R\n    : undefined\n> =>\n  (result as VariableSetResult)?.source?.key != null\n    ? (result as VariableSetResult).source\n    : (result as any)?.key != null\n    ? result\n    : (undefined as any);\n\nexport const getResultVariable = <R extends ValidatableResult>(\n  result: R\n): If<\n  IsAny<R>,\n  Variable<any, true>,\n  R extends undefined\n    ? undefined\n    : R extends { current: infer V }\n    ? V\n    : R extends { value: any }\n    ? R\n    : undefined\n> =>\n  result?.status! < 400\n    ? (result as VariableSetResult)?.current ?? (result as any)\n    : undefined; // This included 404 for getters.\n\nexport const isSuccessResult = (\n  result: any\n): result is {\n  status:\n    | VariableResultStatus.Success\n    | VariableResultStatus.Created\n    | VariableResultStatus.Unchanged\n    | VariableResultStatus.NotFound;\n} => result?.status! < 400 || result?.status === 404;\n\ntype ErrorHandler<Result = any> = Result extends undefined\n  ? undefined\n  : undefined | ((result: Result, errorMessage: string) => void | boolean);\n\ntype ErrorHandlerParameter<Results> = Results extends readonly []\n  ? readonly []\n  : Results extends readonly [infer Item, ...infer Rest]\n  ? readonly [ErrorHandler<Item>, ...ErrorHandlerParameter<Rest>]\n  : Results extends readonly (infer Item)[]\n  ? readonly ErrorHandler<Item>[]\n  : ErrorHandler<Results>;\n\nexport const handleResultErrors = <\n  Results extends MaybeArray<ValidatableResult, true>,\n  ErrorHandlers extends ErrorHandlerParameter<Results>,\n  RequireValue = false\n>(\n  results: Results,\n  errorHandlers?: ErrorHandlers,\n  requireValue?: RequireValue\n): FilterVariableResults<Results, true, If<RequireValue, \"value\", \"all\">> => {\n  const errors: string[] = [];\n  let errorHandler: ErrorHandler;\n  let errorMessage: string;\n  const successResults = map(\n    array(results),\n    (result, i) =>\n      result &&\n      (result.status < 400 || (!requireValue && result.status === 404) // Not found can only occur for get requests, and those are all right.\n        ? (result as any)\n        : ((errorMessage = `${formatKey(\n            (result as VariableSetResult).source ?? result\n          )} could not be ${\n            (result as VariableSetResult).status === 404\n              ? \"found.\"\n              : `${\n                  (result as VariableSetResult).source ||\n                  result.status !== VariableResultStatus.Error\n                    ? \"set\"\n                    : \"read\"\n                } because ${\n                  result.status === VariableResultStatus.Conflict\n                    ? `of a conflict. The expected version '${\n                        (result as VariableSetResult).source?.version\n                      }' did not match the current version '${\n                        (result as VariableSetResult).current?.version\n                      }'.`\n                    : result.status === VariableResultStatus.Denied\n                    ? result.error ?? \"the operation was denied.\"\n                    : result.status === VariableResultStatus.Invalid\n                    ? result.error ?? \"the value does not conform to the schema\"\n                    : result.status === VariableResultStatus.ReadOnly\n                    ? \"it is read only.\"\n                    : result.status === VariableResultStatus.Error\n                    ? `of an unexpected error: ${result.error}`\n                    : \"of an unknown reason.\"\n                }`\n          }`),\n          ((errorHandler = errorHandlers?.[i]) == null ||\n            errorHandler(result, errorMessage) !== false) &&\n            errors.push(errorMessage),\n          undefined))\n  );\n\n  if (errors.length) return throwError(errors.join(\"\\n\"));\n  return isArray(results) ? successResults : (successResults?.[0] as any);\n};\n\nexport const requireFound = <\n  T extends MaybeArray<VariableGetResult | undefined> | undefined\n>(\n  variable: T\n): VariableSuccessResult<T, \"value\"> =>\n  handleResultErrors(variable, undefined, true) as any;\n","import type {\n  CartUpdatedEvent,\n  ComponentClickEvent,\n  Integer,\n  LocalID,\n  Session,\n  Tagged,\n  Timestamp,\n  ViewEvent,\n  ImpressionEvent,\n  EventMetadata,\n} from \"..\";\n\n/**\n * The base type for all events that are tracked.\n *\n * The naming convention is:\n * - If the event represents something that can also be considered an entity like \"a page view\", \"a user location\" etc. the name should be a (deverbal) noun.\n * - If the event only indicates something that happened, like \"session started\", \"view ended\" etc. the name should be a verb in the past tense.\n *\n * @id urn:tailjs:core:event\n * @privacy censor-ignore anonymous necessary\n */\nexport interface TrackedEvent extends Tagged {\n  /**\n   * The type name of the event.\n   *\n   * This MUST be set to a constant value in extending interfaces and implementing classes for the event to be registered.\n   * */\n  type: string;\n\n  /**\n   * The ID of the schema the event comes from. It is suggested that the schema ID ends with a hash followed by a SemVer version number. (e.g. urn:tailjs#0.9.0)\n   */\n  schema?: string;\n\n  /**\n   * This is assigned by the server. Only use {@link clientId} client-side.\n   *\n   */\n  id?: LocalID;\n\n  /**\n   * This is set by the client and used to when events reference each other.\n   */\n  clientId?: LocalID;\n\n  /** These properties are used to track the state of the event as it gets collected, and is not persisted. */\n  metadata?: EventMetadata;\n\n  /**\n   * If set, it means this event contains updates to an existing event with this {@link clientId}, and should not be considered a separate event.\n   * It must have the target event's {@link TrackedEvent.type} postfixed with \"_patch\" (for example \"view_patch\").\n   *\n   * The specific logic for how to combine patches is specific to the event type, but numbers should generally be additive,\n   * that is, patches contains the changes i numeric values, and not new values. In this way aggregations work in queries for\n   * analytics.\n   *\n   * Please pay attention to this property when doing analytics so you don't over count.\n   *\n   * Patches are always considered passive, cf. {@link EventMetadata.passive}.\n   */\n  patchTargetId?: LocalID;\n\n  /**\n   * The client ID of the event that caused this event to be triggered or got triggered in the same context.\n   * For example, a {@link NavigationEvent} may trigger a {@link ViewEvent},\n   * or a {@link CartUpdatedEvent} may be triggered with a {@link ComponentClickEvent}.\n   */\n  relatedEventId?: LocalID;\n\n  /**\n   * The session associated with the event.\n   */\n  session?: Session;\n\n  /**\n   * When applicable, the view where the event happened (related by {@link ViewEvent}).\n   */\n  view?: LocalID;\n\n  /**\n   * This timestamp will always have a value before it reaches a backend.\n   * If specified, it must be a negative number when sent from the client (difference between when the event was generated and when is was posted in milliseconds).\n   *\n   * @default now\n   */\n  timestamp?: Timestamp;\n}\n\nexport const isTrackedEvent = (ev: any): ev is TrackedEvent =>\n  ev && typeof ev.type === \"string\";\n","import type {\n  Domain,\n  Integer,\n  LocalID,\n  Size,\n  TrackedEvent,\n  View,\n  ViewTimingData,\n  Viewport,\n} from \"..\";\nimport { typeTest } from \"../util/type-test\";\n\nexport interface ClickIds {\n  google?: string;\n  googleDoubleClick?: string;\n  facebook?: string;\n  microsoft?: string;\n  googleAnalytics?: string;\n}\n\n/**\n * This event is sent a user navigates between views. (page, screen or similar).\n *\n * This event does not\n *\n */\nexport interface ViewEvent extends TrackedEvent {\n  type: \"view\";\n\n  /**\n   * @inheritdoc\n   */\n  clientId: LocalID;\n\n  /**\n   * The primary content used to generate the view including the personalization that led to the decision, if any.\n   * If views are loaded asynchronously in a way where they are not available immediately after a user navigates to a URL\n   * on the website, the view definition may follow from a separate patch event.\n   */\n  definition?: View;\n\n  /**\n   * The tab where the view was shown.\n   */\n  tab?: LocalID;\n\n  /**\n   * The fully qualified URL as shown in the address line of the browser excluding the domain.\n   */\n  href: string;\n\n  /**\n   * The hash part of the URL (/about-us#address).\n   */\n  hash?: string;\n\n  /**\n   * The path portion of the URL.\n   */\n  path?: string;\n\n  /** For how long the view was active. This is set via patches */\n  duration?: ViewTimingData;\n\n  /**\n   * Urchin Tracking Module (UTM) parameters as defined by (Wikipedia)[https://en.wikipedia.org/wiki/UTM_parameters].\n   */\n  utm?: {\n    source?: string;\n    medium?: string;\n    campaign?: string;\n    term?: string;\n    content?: string;\n  };\n  /**\n   * The query string parameters in the URL, e.g. utm_campaign.\n   * Each parameter can have multiple values, for example If the parameter is specified more than once.\n   * If the parameter is only specified once pipes, semicolons and commas are assumed to separate values (in that order).\n   * A parameter without a value will get recorded as an empty string.\n   * @example The URL https://www.foo.com/?utm_source=bar&utm_campaign=campaign1,campaign2&flag&gclid=123xyz&p1=a&p1=b&p2=a;b,c;d has these parameters:\n   *  utm_source = [\"bar\"] \\\n   *  utm_campaign = [\"campaign1\", \"campaign2\"] \\\n   *  gclid = [\"123xyz\"] \\\n   *  flag = [\"\"] \\\n   *  gclid=[\"123xyz\"] \\\n   *  p1=[\"a\", \"b\"] \\\n   *  p2=[\"a\", \"b,c\", \"d\"]\n   */\n  queryString?: Record<string, string[]>;\n\n  // queryString?: {\n  //   source: Record<string, string>;\n  //   parsed: Record<string, string[]>;\n  // };\n\n  /**\n   * The domain part of the href, if any.\n   */\n  domain?: Domain;\n\n  /**\n   * Indicates that this was the first view in the first tab the user opened.\n   * Note that this is NOT tied to the session. If a user closes all tabs and windows for the site and then later navigates back to the site in the same session this flag will be set again.\n   * @default false\n   */\n  landingPage?: boolean;\n\n  /**\n   * Indicates that no other tabs were open when the view happened.\n   * This flag allows a backend to extend the definition of a session that can last indefinitely but still restart after inactivity.\n   * By measuring the time between a view with this flag and the previous event from the same device, it is possible to see for how long the device has been away from the site.\n   * @default false\n   */\n  firstTab?: boolean;\n\n  /**\n   * The 1-indexed view number in the current tab.\n   * This is kept as a convenience, yet technically redundant since it follows from timestamps and context.\n   * @default 1\n   */\n  tabIndex?: Integer;\n\n  /**\n   * Number of redirects that happened during navigation to this view.*/\n  redirects?: Integer;\n\n  /**\n   * Navigation type.\n   */\n  navigationType?: \"navigate\" | \"back-forward\" | \"prerender\" | \"reload\";\n\n  /**\n   * Indicates whether the event was manually triggered through a tracker command, or happened automatically by the tracker's ability to infer navigation.\n   *\n   * @default \"automatic\"\n   */\n  mode?: \"manual\" | \"automatic\";\n\n  /**\n   * External referrer. Internal referrers follows from the event's {@link TrackedEvent[\"relatedView\"]} field.\n   */\n  externalReferrer?: {\n    href?: string;\n    domain?: Domain;\n  };\n\n  /**\n   * The size of the user's viewport (e.g. browser window) and how much it was scrolled when the page was opened.\n   */\n  viewport?: Viewport;\n\n  /**\n   * The type of view, e.g. \"page\" or \"screen\".\n   *\n   * @default \"page\"\n   */\n  viewType?: string;\n}\n\nexport const isViewEvent = typeTest<ViewEvent>(\"view\");\n","import { TrackedEvent } from \"../events\";\n\nexport const typeTest =\n  <T extends TrackedEvent>(...types: string[]) =>\n  (ev: any): ev is T =>\n    ev?.type && types.some((type) => type === ev?.type);\n","import { join } from \"@tailjs/util\";\n\nexport type ParsedTag = { ranks: string[]; value?: string };\n\nconst splitRanks = (ranks?: string) =>\n  ranks\n    ?.toLowerCase()\n    .replace(/[^a-zA-Z0-9:.-]/g, \"_\")\n    .split(\":\")\n    .filter((rank) => rank) ?? [];\n\n/**\n * Parses the tags out of a string\n */\nexport const parseTagString = (\n  input: string | (string | null)[] | null | undefined,\n  baseRank?: string,\n  target?: Set<string>\n) => {\n  if (!input) return [];\n  if (Array.isArray(input)) input = join(input, \",\");\n  // We have an unescaped percentage sign followed by an uppercase two-digit hexadecimal number. Smells like URI encoding!\n  if (/(?<!(?<!\\\\)\\\\)%[A-Z0-9]{2}/.test(input)) {\n    try {\n      input = decodeURIComponent(\n        input.replace(\n          // Change ampersands to commas (as they are value separators), and quote all values just to be sure nothing gets out of control.\n          // That is, `tag=test&tag2&tag3=Encoded%3A%20%22%F0%9F%A5%B3%22` becomes `tag=\"test\",tag2,tag3=\"Encoded: \\\"🥳\\\"\"\n          /([^=&]+)(?:\\=([^&]+))?(&|$)/g,\n          (_, name, value, sep) =>\n            [\n              name,\n              value && `=\"${value.replace(/(?<!(?<!\\\\)\\\\)(\"|%22)/g, '\\\\\"')}\"`, // Escape double quotes (both encoded `%22` and non-encoded `\"`\"), but ignore quotes that are already escaped (yes, why not?).\n              sep && \",\",\n            ].join(\"\")\n        )\n      );\n      // Need to catch exceptions. `decodeURIComponent` will fail on invalid surrogate code points. `%80` is one of those.\n    } catch {}\n  }\n\n  let tags: ParsedTag[] = [],\n    parsedTag: ParsedTag,\n    baseRanks = splitRanks(baseRank);\n\n  input.replace(\n    // Explained:\n    // 1. Tag (group 1): (\\s*(?=\\=)|(?:\\\\.|[^,=\\r\\n])+). It means \"skip leading white-space\", then either\"\n    //   1.1. \\s*(?=\\=) is \"nothing but a `=`\": a blank tag name causing the expression to skip to the actual value. (\"=80,=43\" are techincally supported but will get omitted unless the are base ranks (*))\n    //   2.1. (?:\\\\.|[^,=\\r\\n])+ is \"something not a linebreak including escaped characters such as \\=\":\n    // 2. Value: (?:\\=\\s*(?:\"((?:\\\\.|[^\"])*)\"|'((?:\\\\.|[^'])*)'|((?:\\\\.|\\s*[^,\\s])*)))?. Anything that starts with a `=` until we find a (non-escaped) comma\n    //  2.1: (group 2) \"((?:\\\\.|[^\"])*)\" is any double-quoted ()`\"`) value, can contain commas, anything escaped, or whatever. Goes well with JSON.\n    //  2.2: (group 3) is same as 2.1 just with a single quote (`'`).\n    //  2.3: (group 4) is anything but a non-escaped comma (`,`)\n    // 3. The end. (?:[,\\s]+|$). This is the tag separator or end of string.\n    //        Since tags cannot have line-breaks in them, this technically allows tags to be separated by line-breaks instead of comma.\n    //        This should not be documented as values can very much have line-breaks, and that syntax will then bite you in the money-maker at some point.\n    //        In the scary example below we get \"tag1\", \"tag21:tag22\" and then \"tag3\" with the value \"value\\tag4=value\"(!).\n    //        `tag1\n    //        tag21:tag22\n    //        tag3=value\n    //        tag4=value`\n    /\\s*(\\s*(?=\\=)|(?:\\\\.|[^,=\\r\\n])+)\\s*(?:\\=\\s*(?:\"((?:\\\\.|[^\"])*)\"|'((?:\\\\.|[^'])*)'|((?:\\\\.|[^,])*)))?\\s*(?:[,\\s]+|$)/g,\n    (_0, tag, quote1, quote2, unquoted) => {\n      let value = quote1 || quote2 || unquoted;\n      let ranks = splitRanks(tag);\n\n      baseRanks.length &&\n        // If we have base ranks (that, is a \"prefix\"), a single tag value is interpreted as a value. E.g. `<a data-name=\"foo\"...` becomes `data:name=foo`.\n        // We have this situation if there is exactly one rank, and no value.\n        // Other examples: `<a data-employee=\"foo:test\" ...` gives `data:employee:foo:test`. `data-employee=\"=test\"` gives us `data:employee=test`, and\n        //    `data-employee=\"id=80\"` gives us `data:employee:id=80`.\n        (ranks.length === 1 && !value && (value = ranks.pop()),\n        (ranks = baseRanks.concat(ranks))),\n        // If we don't have any ranks (only a value), we don't have a tag.\n        ranks.length && // * cf. expression explanition 1.1\n          (tags.push(\n            (parsedTag = {\n              ranks,\n              value: value || undefined,\n            })\n          ),\n          target?.add(encodeTag(parsedTag)));\n      return \"\"; // This is a trick. We are not really replacing anything, we are instead using replace as a for loop.\n    }\n  );\n  return tags;\n};\n\nexport const encodeTag = <T extends ParsedTag | null | undefined>(\n  tag: T\n): T extends ParsedTag ? string : null | undefined =>\n  tag == null\n    ? (tag as any)\n    : `${tag.ranks.join(\":\")}${\n        tag.value ? `=${tag.value.replace(/,/g, \"\\\\,\")}` : \"\"\n      }`;\n","import { TrackedEvent } from \"@tailjs/types\";\nimport { throwError } from \"@tailjs/util\";\n\nexport const DEBUG = true;\nexport const HEARTBEAT_FREQUENCY = 5_000;\nexport const STORAGE_PREFIX = \"_t:\";\nexport const REQUEST_LOCK_KEY = STORAGE_PREFIX + \"rq\";\nexport const VARIABLE_POLL_FREQUENCY = 3_000;\nexport const VARIABLE_CACHE_DURATION = 3_000;\nexport const EVENT_POST_FREQUENCY = 2000;\nexport const STATE_KEY = STORAGE_PREFIX + \"data\";\n\nexport const NOT_INITIALIZED = () => () => throwError(\"Not initialized.\");\n\nexport type TrackerContext = {\n  deviceSessionId?: string;\n\n  applyEventExtensions(event: TrackedEvent): TrackedEvent | undefined;\n};\n","import type { Nullish } from \"@tailjs/util\";\n\nexport const SSR = typeof window === \"undefined\";\n\nconst win = window;\nconst doc = document;\nconst nav = navigator;\nconst body = doc.body;\nconst loc = location;\nconst perf = performance;\nconst hist = win.history;\nexport {\n  body,\n  doc as document,\n  hist as history,\n  loc as location,\n  nav as navigator,\n  perf as performance,\n  win as window,\n};\n\nexport const createElement = (tagName: string) => doc.createElement(tagName);\n\nexport const matchSelector = (node: Element | Nullish, selector: string) =>\n  !!node?.matches(selector);\n","import type { TrackerConfiguration } from \"..\";\n\nexport const isTracker = \"__isTracker\";\n\nexport const trackerConfig: Required<TrackerConfiguration> = {\n  name: \"tail\",\n  src: \"/_t.js\",\n  disabled: false,\n  postEvents: true,\n  postFrequency: 2000,\n  requestTimeout: 5000,\n  clientKey: null,\n  apiKey: null,\n\n  pushCookie: null,\n\n  /**\n   * Log events to the browser's developer console.\n   */\n  debug: false,\n  impressionThreshold: 1000,\n  captureContextMenu: true,\n  defaultActivationTracking: \"auto\",\n  tags: { default: [\"data-id\", \"data-name\"] },\n};\n","import {\n  CONTEXT_NAV_QUERY,\n  EVENT_HUB_QUERY,\n  VARIABLES_QUERY,\n} from \"@constants\";\nimport {\n  T,\n  ansi,\n  isObject,\n  join,\n  parseUri,\n  replace,\n  split,\n  type Nullish,\n} from \"@tailjs/util\";\nimport { document } from \".\";\n\nexport const ERR_BUFFER_OVERFLOW = \"buffer-overflow\";\nexport const ERR_POST_FAILED = \"post-failed\";\nexport const ERR_INVALID_COMMAND = \"invalid-command\";\nexport const ERR_INTERNAL_ERROR = \"internal-error\";\nexport const ERR_ARGUMENT_ERROR = \"invalid-argument\";\nexport const ERR_RESERVED = \"reserved\";\nexport const ERR_CONFIG_LOCKED = \"config-locked\";\nexport const ERR_DUPLICATE_KEY = \"key\";\n\nconst src = split(\"\" + document.currentScript![\"src\"], \"#\");\nconst args = split(\"\" + (src[1] || \"\"), \";\");\n\nexport const SCRIPT_SRC = src[0];\nexport const TRACKER_DOMAIN = args[1] || parseUri(SCRIPT_SRC, false)?.host!;\n\nexport const isInternalUrl = (url: string | Nullish) =>\n  !!(\n    TRACKER_DOMAIN && parseUri(url, false)?.host?.endsWith(TRACKER_DOMAIN) === T\n  );\n\nexport const mapUrl = (...urlParts: string[]) =>\n  replace(join(urlParts), /(^(?=\\?))|(^\\.(?=\\/))/, SCRIPT_SRC.split(\"?\")[0]);\n\nexport const VAR_URL = mapUrl(\"?\", EVENT_HUB_QUERY);\nexport const MNT_URL = mapUrl(\"?\", CONTEXT_NAV_QUERY);\nexport const USR_URL = mapUrl(\"?\", VARIABLES_QUERY);\n\nexport const debug = (value: any, group?: string, collapsed = T) => {\n  group &&\n    (collapsed ? console.groupCollapsed : console.group)(\"tail.js: \" + group);\n  value != null &&\n    console.log(\n      isObject(value)\n        ? ansi(JSON.stringify(value, null, 2), \"94\")\n        : // ? window[\"chrome\"]\n          //   ? prettyPrint(value).join(\"\")\n          //   : JSON.stringify(value, null, 2)\n          value\n    );\n  group && console.groupEnd();\n};\n","export const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const INIT_SCRIPT_QUERY = \"init\";\nexport const CLIENT_SCRIPT_QUERY = \"opt\";\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_NAV_QUERY = \"mnt\";\nexport const SCHEMA_QUERY = \"$types\";\n\nexport const CONTEXT_NAV_REQUEST_ID = \"ctx.rid\";\n\n// Must match the key in @tailjs/types/ScopeVariables.ts.\nexport const SCOPE_INFO_KEY = \"info\";\n\nexport const PATCH_EVENT_POSTFIX = \"_patch\";\n","const codes: number[] = [];\nconst chars: number[] = [];\nexport const charCode = (s: string, index = 0) => s.charCodeAt(index);\nexport const fromCharCodes = (chars: number[]) => String.fromCharCode(...chars);\n\n[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"].forEach(\n  (p, i) => (codes[(chars[i] = p.charCodeAt(0))] = i)\n);\n\n/**\n * Encodes an array of bytes to Base64URL without padding (URL safe Base64 using `-` and `_` instead of `+` and `/`).\n *\n * (thanks to Jon Leighton at https://gist.github.com/jonleighton/958841).\n */\nexport const to64u = (bytes: Uint8Array) => {\n  let i = 0;\n  let chunk: number;\n  const n = bytes.length;\n\n  const base64: number[] = [];\n  while (i < n) {\n    chunk = (bytes[i++] << 16) | (bytes[i++] << 8) | bytes[i++];\n    base64.push(\n      chars[(chunk & 16515072) >> 18],\n      chars[(chunk & 258048) >> 12],\n      chars[(chunk & 4032) >> 6],\n      chars[chunk & 63]\n    );\n  }\n  base64.length += n - i;\n\n  return fromCharCodes(base64);\n};\n\n/**\n * Decodes a BaseURL encoded string (without padding).\n */\nexport const from64u = (encoded: string) => {\n  let i = 0;\n  let j = 0;\n  let p: number;\n  const n = encoded.length;\n  const bytes = new Uint8Array(3 * ((n / 4) | 0) + (((n + 3) & 3) % 3));\n  while (i < n) {\n    bytes[j++] =\n      (codes[charCode(encoded, i++)] << 2) |\n      ((p = codes[charCode(encoded, i++)]) >> 4);\n    if (i < n) {\n      bytes[j++] = ((p & 15) << 4) | ((p = codes[charCode(encoded, i++)]) >> 2);\n      if (i < n) {\n        bytes[j++] = ((p & 3) << 6) | codes[charCode(encoded, i++)];\n      }\n    }\n  }\n  return bytes;\n};\n","import { Nullish, isBoolean } from \"..\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  (value: T, bits?: 32 | 64 | 128): string;\n  <B extends boolean>(value: T, numeric: B): B extends true ? number : string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key?: string | Nullish): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (\n    iw = 0;\n    iw < key?.length!;\n    mixer0 += window0[iw] = key!.charCodeAt(iw++)\n  );\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero it all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: Uint8Array, numericOrBits: any = 64) => {\n      if (source == null) return null;\n      bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n","﻿(function () {\r\n\t\"use strict\";\r\n\r\n\t// Serializes a value to a MessagePack byte array.\r\n\t//\r\n\t// data: The value to serialize. This can be a scalar, array or object.\r\n\t// options: An object that defines additional options.\r\n\t// - multiple: (boolean) Indicates whether multiple values in data are concatenated to multiple MessagePack arrays. Default: false.\r\n\t// - invalidTypeReplacement:\r\n\t//   (any) The value that is used to replace values of unsupported types.\r\n\t//   (function) A function that returns such a value, given the original value as parameter.\r\n\tfunction serialize(data, options) {\r\n\t\tif (options && options.multiple && !Array.isArray(data)) {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\r\n\t\t}\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet floatBuffer, floatView;\r\n\t\tlet array = new Uint8Array(128);\r\n\t\tlet length = 0;\r\n\t\tif (options && options.multiple) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tappend(data[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tappend(data);\r\n\t\t}\r\n\t\treturn array.subarray(0, length);\r\n\r\n\t\tfunction append(data, isReplacement) {\r\n\t\t\tswitch (typeof data) {\r\n\t\t\t\tcase \"undefined\":\r\n\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\tappendBoolean(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tappendNumber(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tappendString(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif (data === null)\r\n\t\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\telse if (data instanceof Date)\r\n\t\t\t\t\t\tappendDate(data);\r\n\t\t\t\t\telse if (Array.isArray(data))\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\r\n\t\t\t\t\t\tappendBinArray(data);\r\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\r\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\r\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tappendObject(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\r\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendNull(data) {\r\n\t\t\tappendByte(0xc0);\r\n\t\t}\r\n\r\n\t\tfunction appendBoolean(data) {\r\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\r\n\t\t}\r\n\r\n\t\tfunction appendNumber(data) {\r\n\t\t\tif (isFinite(data) && Number.isSafeInteger(data)) {\r\n\t\t\t\t// Integer\r\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0 && data >= -0x20) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\r\n\t\t\t\t\tappendBytes([0xcc, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\r\n\t\t\t\t\tappendBytes([0xd0, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\r\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\r\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\r\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\r\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\r\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\r\n\t\t\t\t\t// 32 bits for bitwise operations.\r\n\t\t\t\t\tlet hi = data / pow32;\r\n\t\t\t\t\tlet lo = data % pow32;\r\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\r\n\t\t\t\t\tappendByte(0xd3);\r\n\t\t\t\t\tappendInt64(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0) {   // below int64\r\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t\telse {   // above uint64\r\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Float\r\n\t\t\t\tif (!floatView) {\r\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\r\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\r\n\t\t\t\t}\r\n\t\t\t\tfloatView.setFloat64(0, data);\r\n\t\t\t\tappendByte(0xcb);\r\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendString(data) {\r\n\t\t\tlet bytes = encodeUtf8(data);\r\n\t\t\tlet length = bytes.length;\r\n\r\n\t\t\tif (length <= 0x1f)\r\n\t\t\t\tappendByte(0xa0 + length);\r\n\t\t\telse if (length <= 0xff)\r\n\t\t\t\tappendBytes([0xd9, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(bytes);\r\n\t\t}\r\n\r\n\t\tfunction appendArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x90 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let index = 0; index < length; index++) {\r\n\t\t\t\tappend(data[index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendBinArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xff)\r\n\t\t\t\tappendBytes([0xc4, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(data);\r\n\t\t}\r\n\r\n\t\tfunction appendObject(data) {\r\n\t\t\tlet length = 0;\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tif (data[key] !== undefined) {\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x80 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tlet value = data[key];\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tappend(key);\r\n\t\t\t\t\tappend(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendDate(data) {\r\n\t\t\tlet sec = data.getTime() / 1000;\r\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\r\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\r\n\t\t\t\tappendInt64(sec);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendByte(byte) {\r\n\t\t\tif (array.length < length + 1) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + 1)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray[length] = byte;\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\tfunction appendBytes(bytes) {\r\n\t\t\tif (array.length < length + bytes.length) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + bytes.length)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray.set(bytes, length);\r\n\t\t\tlength += bytes.length;\r\n\t\t}\r\n\r\n\t\tfunction appendInt64(value) {\r\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\r\n\t\t\t// bitwise operations.\r\n\t\t\tlet hi, lo;\r\n\t\t\tif (value >= 0) {\r\n\t\t\t\t// Same as uint64\r\n\t\t\t\thi = value / pow32;\r\n\t\t\t\tlo = value % pow32;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\r\n\t\t\t\tvalue++;\r\n\t\t\t\thi = Math.abs(value) / pow32;\r\n\t\t\t\tlo = Math.abs(value) % pow32;\r\n\t\t\t\thi = ~hi;\r\n\t\t\t\tlo = ~lo;\r\n\t\t\t}\r\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deserializes a MessagePack byte array to a value.\r\n\t//\r\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\r\n\t// options: An object that defines additional options.\r\n\t// - multiple: (boolean) Indicates whether multiple concatenated MessagePack arrays are returned as an array. Default: false.\r\n\tfunction deserialize(array, options) {\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet pos = 0;\r\n\t\tif (array instanceof ArrayBuffer) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\r\n\t\t}\r\n\t\tif (!array.length) {\r\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\r\n\t\t}\r\n\t\tif (!(array instanceof Uint8Array)) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tlet data;\r\n\t\tif (options && options.multiple) {\r\n\t\t\t// Read as many messages as are available\r\n\t\t\tdata = [];\r\n\t\t\twhile (pos < array.length) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Read only one message and ignore additional data\r\n\t\t\tdata = read();\r\n\t\t}\r\n\t\treturn data;\r\n\r\n\t\tfunction read() {\r\n\t\t\tconst byte = array[pos++];\r\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\r\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\r\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\r\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\r\n\t\t\tif (byte === 0xc0) return null;   // nil\r\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\r\n\t\t\tif (byte === 0xc2) return false;   // false\r\n\t\t\tif (byte === 0xc3) return true;   // true\r\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\r\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\r\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\r\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\r\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\r\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\r\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\r\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\r\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\r\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\r\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\r\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\r\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\r\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\r\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\r\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\r\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\r\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\r\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\r\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\r\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\r\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\r\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\r\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\r\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\r\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\r\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\r\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\r\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\r\n\t\t\tconsole.debug(\"msgpack array:\", array);\r\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\r\n\t\t}\r\n\r\n\t\tfunction readInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\tlet first = true;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tlet byte = array[pos++];\r\n\t\t\t\t\tvalue += byte & 0x7f;\r\n\t\t\t\t\tif (byte & 0x80) {\r\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvalue *= 256;\r\n\t\t\t\t\tvalue += array[pos++];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readUInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tvalue *= 256;\r\n\t\t\t\tvalue += array[pos++];\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readFloat(size) {\r\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\r\n\t\t\tpos += size;\r\n\t\t\tif (size === 4)\r\n\t\t\t\treturn view.getFloat32(0, false);\r\n\t\t\tif (size === 8)\r\n\t\t\t\treturn view.getFloat64(0, false);\r\n\t\t}\r\n\r\n\t\tfunction readBin(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = array.subarray(pos, pos + size);\r\n\t\t\tpos += size;\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readMap(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = {};\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tlet key = read();\r\n\t\t\t\tdata[key] = read();\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readArray(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = [];\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readStr(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet start = pos;\r\n\t\t\tpos += size;\r\n\t\t\treturn decodeUtf8(array, start, size);\r\n\t\t}\r\n\r\n\t\tfunction readExt(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet type = readUInt(1);\r\n\t\t\tlet data = readBin(size);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 255:\r\n\t\t\t\t\treturn readExtDate(data);\r\n\t\t\t}\r\n\t\t\treturn { type: type, data: data };\r\n\t\t}\r\n\r\n\t\tfunction readExtDate(data) {\r\n\t\t\tif (data.length === 4) {\r\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\treturn new Date(sec * 1000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 8) {\r\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\r\n\t\t\t\t\t((data[1] << 14) >>> 0) +\r\n\t\t\t\t\t((data[2] << 6) >>> 0) +\r\n\t\t\t\t\t(data[3] >>> 2);\r\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\r\n\t\t\t\t\t((data[4] << 24) >>> 0) +\r\n\t\t\t\t\t((data[5] << 16) >>> 0) +\r\n\t\t\t\t\t((data[6] << 8) >>> 0) +\r\n\t\t\t\t\tdata[7];\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 12) {\r\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\tpos -= 8;\r\n\t\t\t\tlet sec = readInt(8);\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Encodes a string to UTF-8 bytes.\r\n\tfunction encodeUtf8(str) {\r\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\r\n\t\tlet ascii = true, length = str.length;\r\n\t\tfor (let x = 0; x < length; x++) {\r\n\t\t\tif (str.charCodeAt(x) > 127) {\r\n\t\t\t\tascii = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\r\n\t\tfor (let ci = 0; ci !== length; ci++) {\r\n\t\t\tlet c = str.charCodeAt(ci);\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tbytes[i++] = c;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c < 2048) {\r\n\t\t\t\tbytes[i++] = c >> 6 | 192;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\r\n\t\t\t\t\tif (++ci >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\r\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\r\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\r\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\r\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\r\n\t\t\t\t}\r\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\r\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\r\n\t\t\t}\r\n\t\t\tbytes[i++] = c & 63 | 128;\r\n\t\t}\r\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\r\n\t}\r\n\r\n\t// Decodes a string from UTF-8 bytes.\r\n\tfunction decodeUtf8(bytes, start, length) {\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = start, str = \"\";\r\n\t\tlength += start;\r\n\t\twhile (i < length) {\r\n\t\t\tlet c = bytes[i++];\r\n\t\t\tif (c > 127) {\r\n\t\t\t\tif (c > 191 && c < 224) {\r\n\t\t\t\t\tif (i >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\r\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 223 && c < 240) {\r\n\t\t\t\t\tif (i + 1 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\r\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 239 && c < 248) {\r\n\t\t\t\t\tif (i + 2 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\r\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\r\n\t\t\t}\r\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\r\n\t\t\telse if (c <= 0x10ffff) {\r\n\t\t\t\tc -= 0x10000;\r\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\r\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\r\n\t\t\t}\r\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\r\n\t// The exported functions\r\n\tlet msgpack = {\r\n\t\tserialize: serialize,\r\n\t\tdeserialize: deserialize,\r\n\r\n\t\t// Compatibility with other libraries\r\n\t\tencode: serialize,\r\n\t\tdecode: deserialize\r\n\t};\r\n\r\n\t// Environment detection\r\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\r\n\t\t// Node.js\r\n\t\tmodule.exports = msgpack;\r\n\t}\r\n\telse {\r\n\t\t// Global object\r\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\r\n\t}\r\n\r\n})();\r\n","import { createEvent, type Nullish } from \"@tailjs/util\";\nimport { Decoder, Encoder, createTransport } from \"@tailjs/util/transport\";\nimport { DEBUG, NOT_INITIALIZED } from \".\";\n\nexport const [httpEncode, httpDecode] = createTransport();\n\nexport let [httpEncrypt, httpDecrypt] = [\n  NOT_INITIALIZED,\n  NOT_INITIALIZED,\n] as any as [Encoder, Decoder];\n\nexport const [addEncryptionNegotiatedListener, dispatchEncryptionNegotiated] =\n  createEvent<[httpEncrypt: Encoder, httpDecrypt: Decoder]>();\n\nexport const setStorageKey = (key: string | Nullish) => {\n  if (httpDecrypt !== NOT_INITIALIZED) return;\n\n  [httpEncrypt, httpDecrypt] = createTransport(key);\n  DEBUG && (httpEncrypt = createTransport(null, true)[0]);\n  dispatchEncryptionNegotiated(httpEncrypt, httpDecrypt);\n};\n","import { NonAsync, isString } from \"@tailjs/util\";\r\n\r\nexport const errorLogger = (source: any) => (error: any) =>\r\n  logError(source, error);\r\n\r\nexport const logError: {\r\n  (source: any, message: string | undefined, ...args: any[]): void;\r\n  (source: any, arg1: Exclude<NonAsync, string>, ...args: any[]): void;\r\n} = (...args: any[]) => {\r\n  let source = args.shift();\r\n  let message = isString(args[1])\r\n    ? args.shift()\r\n    : args[1]?.message ?? \"An error occurred\";\r\n  console.error(message, source.id ?? source, ...args);\r\n};\r\n","import { clock, createEvent, createTimer } from \"@tailjs/util\";\nimport { listen } from \".\";\n\ntype PageLoadListenerArgs = [loaded: boolean, stateDuration: number];\nconst [addPageLoadedListener, dispatchPageLoaded] =\n  createEvent<PageLoadListenerArgs>();\n\nconst [addPageVisibleListener, dispatchPageVisible] =\n  createEvent<[visible: boolean, unloading: boolean, delta: number]>();\n\nconst maybeDispatchPageLoaded = (newLoaded: boolean) =>\n  loaded !== (loaded = newLoaded) &&\n  dispatchPageLoaded((loaded = false), sleepTimer(true, true));\n\nconst maybeDispatchPageVisible = (loaded: boolean) =>\n  visible !==\n    (visible = loaded ? document.visibilityState === \"visible\" : false) &&\n  dispatchPageVisible(visible, !loaded, visibleTimer(true, true));\n\n// A visibilitychange event may not be triggered if the page BF cache loads/unloads.\naddPageLoadedListener(maybeDispatchPageVisible);\n\nlet loaded = true;\nlet visible = false;\nlet visibleTimer = createTimer(false);\nlet sleepTimer = createTimer(false);\nlisten(window, [\"pagehide\", \"freeze\"], () => maybeDispatchPageLoaded(false));\nlisten(window, [\"pageshow\", \"resume\"], () => maybeDispatchPageLoaded(true));\nlisten(\n  document,\n  \"visibilitychange\",\n  () => (\n    maybeDispatchPageVisible(true), visible && maybeDispatchPageLoaded(true)\n  )\n);\n\ndispatchPageLoaded(loaded, sleepTimer(true, true));\n\ntype PageActivatedListenerArgs = [activated: boolean, totalDuration: number];\nlet activated = false;\nlet activeTime = createTimer(false);\n\nconst [addPageActivatedListener, dispatchPageActivated] =\n  createEvent<PageActivatedListenerArgs>();\n\nconst activationTimeout = clock({\n  callback: () =>\n    activated && dispatchPageActivated((activated = false), activeTime(false)),\n  frequency: 20000,\n  once: true,\n  paused: true,\n});\nconst setActivated = () =>\n  !activated &&\n  (dispatchPageActivated((activated = true), activeTime(true)),\n  activationTimeout.restart());\n\nlisten(window, \"focus\", setActivated);\nlisten(window, \"blur\", () => activationTimeout.trigger());\n\nlisten(\n  document.body,\n  [\"keydown\", \"pointerdown\", \"pointermove\", \"scroll\"],\n  setActivated\n);\n\nsetActivated();\n\nexport const getActiveTime = () => activeTime();\nexport {\n  addPageActivatedListener,\n  addPageLoadedListener,\n  addPageVisibleListener,\n};\n","import { UUID } from \"@tailjs/types\";\nimport {\n  MaybeUndefined,\n  Nullish,\n  assign,\n  clear,\n  clock,\n  concat,\n  createEvent,\n  filter,\n  forEach,\n  map,\n  now,\n  obj,\n  replace,\n} from \"@tailjs/util\";\nimport {\n  ClientVariable,\n  ClientVariableGetter,\n  ClientVariableResults,\n  GetterIntellisense,\n  HEARTBEAT_FREQUENCY,\n  LocalVariableScope,\n  NOT_INITIALIZED,\n  STATE_KEY,\n  VARIABLE_CACHE_DURATION,\n  addEncryptionNegotiatedListener,\n  addPageLoadedListener,\n  listen,\n  variableKeyToString,\n} from \".\";\n\nexport interface TabState {\n  id: string;\n  heartbeat: number;\n  viewId?: string;\n}\n\ninterface StateVariableMetadata {\n  timestamp: number;\n  expires: number;\n}\n\nexport type StateVariable = ClientVariable & StateVariableMetadata;\n\nexport interface State {\n  knownTabs: Record<string, TabState>;\n  /** All variables except local. */\n  variables: Map<string, StateVariable>;\n}\n\nlet localId = 0;\n\nexport let TAB_ID: string = undefined as any;\nexport const nextId = () => (TAB_ID ?? NOT_INITIALIZED()) + \"_\" + nextLocalId();\nexport const nextLocalId = () => ++localId;\n\nconst randomValues = (arg: any) => crypto.getRandomValues(arg);\nexport const uuidv4 = (): UUID =>\n  replace(\n    ([1e7] as any) + -1e3 + -4e3 + -8e3 + -1e11,\n    /[018]/g,\n    (c: any) => (\n      (c *= 1),\n      (c ^ (randomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)\n    )\n  );\n\n/** All variables, both local and others. */\nlet tabVariables: Map<string, StateVariable> = undefined as any;\n\nconst tabState: TabState = {\n  id: TAB_ID,\n  heartbeat: now(),\n};\n\nconst state: State = {\n  knownTabs: {\n    [TAB_ID]: tabState,\n  },\n  variables: new Map(),\n};\n\ntype StateMessage =\n  | { type: \"query\"; payload?: undefined }\n  | {\n      type: \"set\";\n      payload: State;\n    }\n  | {\n      type: \"patch\";\n      payload: Record<string, StateVariable | undefined>;\n    }\n  | {\n      type: \"tab\";\n      payload: TabState | undefined;\n    };\n\nconst [addStateListener, dispatchState] = createEvent<\n  | [event: \"ready\", state: State, self: boolean]\n  | [event: \"tab\", tab: TabState, self: boolean]\n  | [\n      event: \"variables\",\n      updates: Record<string, StateVariable | undefined>,\n      self: boolean\n    ]\n>();\n\nlet post: (message: StateMessage, target?: string) => void = NOT_INITIALIZED;\n\nexport const tryGetVariable: {\n  <K extends ClientVariableGetter>(key: K | GetterIntellisense[0]):\n    | (ClientVariableResults<[K], true>[0] & StateVariableMetadata)\n    | undefined;\n  <K extends string | Nullish>(key: K): MaybeUndefined<K, StateVariable>;\n} = (key: any) => tabVariables.get(variableKeyToString(key)!) as any;\n\nexport const setLocalVariables = (\n  ...variables: ClientVariable<any, string, true>[]\n) =>\n  updateVariableState(\n    (variables as StateVariable[]).map(\n      (variable: StateVariable) => (\n        (variable.timestamp = now()),\n        (variable.expires = VARIABLE_CACHE_DURATION),\n        variable\n      )\n    )\n  );\n\n// export const getStateVariables = (): Readonly<State[\"variables\"]> =>\n//   tabVariables;\n\nexport const updateVariableState = (\n  updates: (StateVariable | undefined)[] | undefined\n) => {\n  const changes = map(\n    updates,\n    (variable) => variable && [variableKeyToString(variable), variable]\n  );\n  if (!changes?.length) return;\n\n  assign(tabVariables, changes);\n  const sharedChanges = filter(\n    changes,\n    (variable) => variable[1].scope > LocalVariableScope.Tab\n  );\n  if (sharedChanges.length) {\n    assign(state.variables, changes);\n    post({ type: \"patch\", payload: obj(sharedChanges) });\n  }\n  dispatchState(\"variables\", obj(changes), true);\n};\n\naddEncryptionNegotiatedListener((httpEncrypt, httpDecrypt) => {\n  // Keep tab ID and variables between pages in the same tab.\n  addPageLoadedListener((loaded) => {\n    if (loaded) {\n      const localState = httpDecrypt(sessionStorage.getItem(STATE_KEY)) as [\n        tabId: string,\n        variables: StateVariable[]\n      ];\n      sessionStorage.removeItem(STATE_KEY);\n\n      TAB_ID =\n        localState?.[0] ??\n        now().toString(36) +\n          Math.trunc(1296 * Math.random())\n            .toString(36)\n            .padStart(2, \"0\");\n\n      tabVariables = new Map(\n        concat(\n          // Whatever view variables we already had in case of bf navigation.\n          filter(\n            tabVariables,\n            ([, variable]) => variable.scope === LocalVariableScope.View\n          ),\n          map(localState?.[1], (variable) => [\n            variableKeyToString(variable),\n            variable,\n          ])\n        )\n      );\n    } else {\n      console.log(JSON.stringify(state, null, 2));\n      sessionStorage.setItem(\n        STATE_KEY,\n        httpEncrypt([\n          TAB_ID,\n          filter(\n            tabVariables,\n            ([, variable]) => variable.scope !== LocalVariableScope.View\n          ),\n        ])\n      );\n    }\n  }, true);\n\n  post = (message: StateMessage, target?: string) => {\n    if (!httpEncrypt) return;\n    localStorage.setItem(STATE_KEY, httpEncrypt([TAB_ID, message, target]));\n    localStorage.removeItem(STATE_KEY);\n  };\n\n  listen(window, \"storage\", (ev) => {\n    if (ev.key === STATE_KEY) {\n      const message = httpDecrypt?.(ev.newValue) as [\n        sender: string,\n        message: StateMessage,\n        target?: string\n      ];\n      if (!message || (message[2] && message[2] !== TAB_ID)) return;\n      const [sender, { type, payload }] = message;\n\n      if (type === \"query\") {\n        !initTimeout.active && post({ type: \"set\", payload: state }, sender);\n      } else if (type === \"set\" && initTimeout.active) {\n        assign(state, payload);\n        initTimeout.trigger();\n      } else if (type === \"patch\") {\n        assign(state.variables, payload);\n        assign(tabVariables, payload);\n        dispatchState(\"variables\", payload, false);\n      } else if (type === \"tab\") {\n        assign(state.knownTabs, sender, payload);\n        payload && dispatchState(\"tab\", payload, false);\n      }\n    }\n  });\n\n  const initTimeout = clock(() => dispatchState(\"ready\", state, true), -25);\n\n  const heartbeat = clock({\n    callback: () => {\n      const timeout = now() - HEARTBEAT_FREQUENCY * 2;\n      forEach(\n        state?.knownTabs,\n        // Remove tabs that no longer responds (presumably closed but may also have been frozen).\n        ([tabId, tabState]) =>\n          tabState[0] < timeout && clear(state!.knownTabs, tabId)\n      );\n      tabState.heartbeat = now();\n      post({ type: \"tab\", payload: tabState });\n    },\n    frequency: HEARTBEAT_FREQUENCY,\n    paused: true,\n  });\n\n  const toggleTab = (loading: boolean) => {\n    post({ type: \"tab\", payload: loading ? tabState : undefined });\n    if (loading) {\n      initTimeout.restart();\n      post({ type: \"query\" });\n    } else {\n      initTimeout.toggle(false);\n    }\n    heartbeat.toggle(loading);\n  };\n\n  addPageLoadedListener((loaded) => toggleTab(loaded), true);\n}, true);\nexport { addStateListener };\n","import {\n  delay,\n  now,\n  promise,\n  race,\n  stickyTimeout,\n  throwError,\n  tryCatchAsync,\n} from \"@tailjs/util\";\nimport {\n  TAB_ID,\n  httpDecode,\n  httpDecrypt,\n  httpEncode,\n  httpEncrypt,\n  listen,\n} from \".\";\n\n/**\n *  A lock that is shared between all tabs.\n * It would seem tempting to use the browser's native LockManager, yet that disables bf_cache, so we don't.\n */\nexport const sharedLock = (\n  lockId: string,\n  { timeout = 1000, encrypt = true, retries: defaultRetries = 10 } = {}\n): (<R, TO extends number | undefined = undefined>(\n  action: () => PromiseLike<R>,\n  timeout?: TO,\n  retries?: number\n) => Promise<TO extends number ? undefined | R : R>) => {\n  type LockState = [owner: string, expires: number];\n  const get = () =>\n    (encrypt ? httpDecrypt<LockState> : httpDecode<LockState>)(\n      localStorage.getItem(lockId)\n    );\n  const renew = () =>\n    localStorage.setItem(\n      lockId,\n      (encrypt ? httpEncrypt : httpEncode)([TAB_ID, now() + timeout])\n    );\n  let renewTimer = stickyTimeout(timeout / 2);\n\n  return (async (\n    action: any,\n    localTimeout?: number,\n    retries = localTimeout != null ? 1 : defaultRetries\n  ) => {\n    while (retries--) {\n      let current = get();\n      if (!current || current[1] < now()) {\n        renew();\n        if (get()?.[0] === TAB_ID) {\n          // Keep lock alive while the action executes.\n          renewTimer(renew);\n          return await tryCatchAsync(\n            action,\n            true,\n            () => renewTimer(false) && localStorage.removeItem(lockId)\n          );\n        }\n      }\n      let waitHandle = promise();\n      const [unbind] = listen(window, \"storage\", (ev) => {\n        if (ev.key === lockId && !ev.newValue) {\n          waitHandle.resolve();\n        }\n      });\n      await race(delay(localTimeout ?? timeout), waitHandle);\n      unbind();\n    }\n    localTimeout == null && throwError(lockId + \" could not be acquired.\");\n  }) as any;\n};\n","import {\n  DataClassification,\n  DataPurposeFlags,\n  PostRequest,\n  PostResponse,\n  VariableResultPromise,\n  VariableResultStatus,\n  getResultVariable,\n  isSuccessResult,\n  isVariablePatch,\n  toVariableResultPromise,\n} from \"@tailjs/types\";\nimport {\n  If,\n  IsAny,\n  MaybeArray,\n  apply,\n  assign,\n  clock,\n  concat,\n  filter,\n  forEach,\n  get,\n  isBoolean,\n  isPlainObject,\n  map,\n  now,\n  pick,\n  push,\n  remove,\n  required,\n  throwError,\n} from \"@tailjs/util\";\nimport {\n  ClientVariable,\n  ClientVariableCallback,\n  ClientVariableGetResult,\n  ClientVariableGetter,\n  ClientVariableResults,\n  ClientVariableSetResult,\n  ClientVariableSetter,\n  LocalVariableScopeValue,\n  ReservedVariableKey,\n  ReservedVariableType,\n  StateVariable,\n  TrackerContext,\n  VARIABLE_CACHE_DURATION,\n  VARIABLE_POLL_FREQUENCY,\n  addPageLoadedListener,\n  addResponseHandler,\n  isLocalScopeKey,\n  localVariableScope,\n  request,\n  stringToVariableKey,\n  toNumericVariableEnums,\n  tryGetVariable,\n  updateVariableState,\n  variableKeyToString,\n} from \".\";\n\nconst KEY_PROPS: any[] = [\"scope\", \"key\", \"targetId\", \"version\"];\nconst VARIABLE_PROPS: any[] = [\n  ...KEY_PROPS,\n  \"created\",\n  \"modified\",\n  \"classification\",\n  \"purposes\",\n  \"tags\",\n  \"readonly\",\n  \"value\",\n];\nconst GETTER_PROPS: any[] = [...KEY_PROPS, \"init\", \"purpose\", \"refresh\"];\nconst SETTER_PROPS: any[] = [...VARIABLE_PROPS, \"value\", \"force\", \"patch\"];\n\nexport interface TrackerVariableStorage {\n  // Omit `init` to allow intellisense to suggest the actual type for reserved keys.\n  get<K extends readonly Omit<ClientVariableGetter, \"init\">[]>(\n    ...getters: (K & ValidateParameters<K, true>) | GetterIntellisense\n  ): VariableResultPromise<ClientVariableResults<K, true>>;\n  // Omit `value` to allow intellisense to suggest the actual type for reserved keys.\n  set<V extends readonly Omit<ClientVariableSetter, \"value\">[]>(\n    ...setters: (V & ValidateParameters<V, false>) | SetterIntellisense\n  ): VariableResultPromise<ClientVariableResults<V, false>>;\n}\nconst activeCallbacks = new Map<string, Set<ClientVariableCallback>>();\n\nexport const createVariableStorage = (\n  endpoint: string,\n  context?: TrackerContext\n): TrackerVariableStorage => {\n  const pollVariables = clock(async () => {\n    const getters: ClientVariableGetter[] = map(\n      activeCallbacks,\n      ([key, callbacks]) => ({\n        ...stringToVariableKey(key),\n        result: [...callbacks],\n      })\n    ) as any;\n\n    getters.length && (await vars.get(...(getters as any)));\n  }, VARIABLE_POLL_FREQUENCY);\n\n  const registerCallbacks = (\n    mappedKey: string,\n    callbacks?: MaybeArray<ClientVariableCallback>\n  ) =>\n    apply(callbacks, (callback) =>\n      get(activeCallbacks, mappedKey, () => new Set()).add(callback)\n    );\n\n  const invokeCallbacks = (\n    result: ClientVariableGetResult | ClientVariableSetResult | undefined\n  ) => {\n    if (!isSuccessResult(result)) return;\n    const key = variableKeyToString(result);\n    const variable = getResultVariable(result);\n    let poll: boolean;\n    forEach(remove(activeCallbacks, key), (callback) => {\n      poll = false;\n      callback?.(\n        variable,\n        tryGetVariable(variable as any) as any,\n        (toggle = true) => (poll = toggle)\n      );\n      poll && registerCallbacks(key, callback);\n    });\n  };\n\n  addPageLoadedListener(\n    (loaded, stateDuration) =>\n      pollVariables.toggle(\n        loaded,\n        loaded && stateDuration >= VARIABLE_POLL_FREQUENCY\n      ),\n    true\n  );\n\n  const cacheDurations = new Map<string, number>();\n  const updateCacheDuration = (\n    key: string,\n    duration: undefined | number | boolean\n  ) =>\n    assign(\n      cacheDurations,\n      key,\n      isBoolean(duration) ? (duration ? undefined : 0) : duration\n    );\n\n  const vars = {\n    get: (\n      ...getters: ClientVariableGetter[]\n    ): VariableResultPromise<ClientVariableResults<any, true>> =>\n      toVariableResultPromise(async () => {\n        const results: [ClientVariableGetResult, number][] = [];\n\n        let requestGetters = map(getters, (getter, sourceIndex) => [\n          getter,\n          sourceIndex,\n        ]);\n\n        const newLocal: StateVariable[] = [];\n        const response =\n          (\n            await request<PostRequest, PostResponse>(endpoint, () => {\n              requestGetters = map(requestGetters, ([getter, sourceIndex]) => {\n                if (!getter) return undefined;\n\n                const key = variableKeyToString(getter);\n                registerCallbacks(key, getter.result);\n\n                const current = tryGetVariable(key);\n                getter.init && updateCacheDuration(key, getter.cache);\n                if (!getter.refresh && current?.expires! < now()) {\n                  push(results, [\n                    {\n                      ...current,\n                      status: VariableResultStatus.Success,\n                    } as any,\n                    sourceIndex,\n                  ]);\n                } else if (isLocalScopeKey(getter)) {\n                  if (isPlainObject(getter.init)) {\n                    const local: ClientVariableGetResult<any, any, any, true> =\n                      {\n                        ...toNumericVariableEnums(getter),\n                        status: VariableResultStatus.Created,\n                        ...getter.init,\n                      };\n                    if (local.value != null) {\n                      push(newLocal, setResultExpiration(local));\n                      push(results, [local, sourceIndex]);\n                    }\n                  }\n                } else {\n                  return [pick(getter, GETTER_PROPS), sourceIndex];\n                }\n              });\n\n              return requestGetters.length\n                ? {\n                    variables: { get: map(requestGetters, 0) as any },\n                    deviceSessionId: context?.deviceSessionId,\n                  }\n                : false;\n            })\n          ).variables?.get ?? [];\n\n        push(\n          results,\n          ...map(\n            response,\n            (response, i) => response && [response, requestGetters[i][1]]\n          )\n        );\n\n        if (newLocal.length) {\n          updateVariableState(newLocal);\n        }\n\n        return results.map(([result]) => (invokeCallbacks(result), result));\n      }, map(getters, (getter) => getter?.error) as any) as any,\n\n    set: (\n      ...setters: ClientVariableSetter[]\n    ): ClientVariableResults<any, false> =>\n      toVariableResultPromise(async () => {\n        const newLocal: StateVariable[] = [];\n\n        const results: ClientVariableSetResult[] = [];\n\n        // Only request non-null setters, and use the most recent version we have already read, if any.\n        const requestVariables = map(setters, (setter, sourceIndex) => {\n          if (!setter) return undefined;\n          const key = variableKeyToString(setter);\n          const current = tryGetVariable(key);\n          updateCacheDuration(key, setter.cache);\n          if (isLocalScopeKey(setter)) {\n            if (setter.patch != null)\n              return throwError(\"Local patching is not supported.\");\n            const local: ClientVariable<any, any, true> = {\n              value: setter.value,\n              classification: DataClassification.Anonymous,\n              purposes: DataPurposeFlags.Necessary,\n              scope: localVariableScope(setter.scope),\n              key: setter.key,\n            };\n\n            results[sourceIndex] = {\n              status: current\n                ? VariableResultStatus.Success\n                : VariableResultStatus.Created,\n              source: setter as any,\n              current: local,\n            };\n            push(newLocal, setResultExpiration(local));\n            return undefined;\n          }\n          if (!isVariablePatch(setter) && setter?.version === undefined) {\n            setter.version = current?.version;\n            // Force the first set, we do not have any cached version to validate against.\n            setter.force ??= !!setter.version;\n          }\n          return [setter as ClientVariableSetter, sourceIndex];\n        });\n\n        const response =\n          requestVariables.length > 0\n            ? []\n            : required(\n                (\n                  await request<PostRequest, PostResponse>(endpoint, {\n                    variables: {\n                      set: requestVariables.map(\n                        (variable) => variable[0] as any\n                      ),\n                    },\n                    deviceSessionId: context?.deviceSessionId,\n                  })\n                ).variables?.set,\n                \"No result.\"\n              );\n\n        if (newLocal.length) {\n          updateVariableState(newLocal);\n        }\n\n        forEach(response, (result, index) => {\n          const [setter, sourceIndex] = requestVariables[index];\n          (result as any).source = setter;\n          invokeCallbacks((results[sourceIndex] = result as any));\n        });\n\n        return results as any;\n      }, map(setters, (setter) => setter?.error) as any) as any,\n  };\n\n  const setResultExpiration = (\n    variable: ClientVariable,\n    timestamp = now()\n  ): StateVariable => ({\n    ...pick(variable, VARIABLE_PROPS),\n    timestamp,\n    expires:\n      timestamp +\n      (get(cacheDurations, variableKeyToString(variable)) ??\n        VARIABLE_CACHE_DURATION),\n  });\n  addResponseHandler(({ variables }) => {\n    if (!variables) return;\n    const timestamp = now();\n    const changed = concat(\n      map(variables.get, (result) => getResultVariable(result)),\n      map(variables.set, (result) => getResultVariable(result))\n    );\n\n    changed?.length &&\n      updateVariableState(apply(changed, setResultExpiration, timestamp));\n  });\n\n  return vars as any;\n};\n\n/** Suggests the reserved names and their corresponding values for local variables, and helps autocomplete string enums (purpose etc.). */\nexport type GetterIntellisense<\n  K extends string = ReservedVariableKey | \"(any)\"\n> = readonly (\n  | ClientVariableGetter<any, \"(any)\" | (string & {}), false>\n  | (K extends infer K\n      ? ClientVariableGetter<ReservedVariableType<K>, K & string, true>\n      : // Only suggest reserved local names when local is true. This does that trick.\n\n        never)\n)[];\n\n/** Suggests the reserved names and their corresponding values for local variables, and helps autocomplete string enums (purpose etc.). */\ntype SetterIntellisense<K extends string = ReservedVariableKey | \"(any)\"> =\n  readonly (\n    | ClientVariableSetter<any, \"(any)\" | (string & {}), false>\n    | (K extends infer K\n        ? ClientVariableSetter<ReservedVariableType<K>, K & string, true>\n        : // Only suggest reserved local names when local is true. This does that trick.\n\n          never)\n  )[];\n\ntype ValidateParameter<P, Getters> = P extends {\n  key: infer K & string;\n  scope: LocalVariableScopeValue;\n}\n  ? If<\n      Getters,\n      ClientVariableGetter<ReservedVariableType<K>, K & string, true>,\n      ClientVariableSetter<ReservedVariableType<K>, K & string, true>\n    >\n  : P extends { key: infer K & string }\n  ? If<\n      Getters,\n      ClientVariableGetter<any, K & string, false>,\n      ClientVariableSetter<any, K & string, false>\n    >\n  : never;\n\ntype ValidateParameters<P, Getters> = P extends readonly []\n  ? []\n  : P extends readonly [infer Item, ...infer Rest]\n  ? readonly [\n      ValidateParameter<Item, Getters>,\n      ...ValidateParameters<Rest, Getters>\n    ]\n  : P extends readonly (infer Item)[]\n  ? readonly ValidateParameter<Item, Getters>[]\n  : never;\n","import {\n  EventPatch,\n  PassiveEvent,\n  PostRequest,\n  TrackedEvent,\n  clearMetadata,\n} from \"@tailjs/types\";\nimport {\n  ToggleArray,\n  array,\n  clock,\n  clone,\n  concat,\n  forEach,\n  isNumber,\n  isObject,\n  isPlainObject,\n  join,\n  map,\n  merge,\n  now,\n  pluralize,\n  push,\n  structuralEquals,\n  throwError,\n  unshift,\n} from \"@tailjs/util\";\nimport {\n  EVENT_POST_FREQUENCY,\n  TrackerContext,\n  addPageVisibleListener,\n  debug,\n  request,\n} from \".\";\nimport { PATCH_EVENT_POSTFIX } from \"@constants\";\n\nexport type EventQueue = {\n  /**\n   * Posts events to the server. Do not post event patches using this method. Use {@link postPatch} instead.\n   * If flush is not explicitly requested, the event will eventually get posted, either by the configured post frequency, or when the user leaves the tab.\n   */\n  post<T extends ToggleArray<readonly TrackedEvent[]>>(\n    events: T,\n    flush?: boolean\n  ): Promise<void>;\n\n  /**\n   *  Posts a patch to an existing event.\n   */\n  postPatch<T extends TrackedEvent>(\n    target: T,\n    patch: EventPatchData<T>,\n    flush?: boolean\n  ): Promise<void>;\n\n  /**\n   * Registers a passive event.\n   *\n   * The source will get invoked whenever the tab becomes deactivated. If the source returns undefined or false, the source is unregistered.\n   * The return value is a function to manually unregister the source.\n   */\n  registerEventPatchSource<T extends TrackedEvent>(\n    sourceEvent: T,\n    source: EventPatchSource<T>\n  ): () => void;\n};\n\ntype EventPatchData<T extends TrackedEvent> = Omit<\n  EventPatch<T>,\n  \"patchTargetId\" | \"metadata\" | \"type\"\n> & { type?: undefined };\n\nexport const deltaDiff = <T>(\n  current: T,\n  previous: T | undefined\n): [delta: T, current: T] | undefined => {\n  if (!isPlainObject(previous)) return [current, current];\n\n  const delta: any = {};\n  let any = false;\n  let deltaValue: any;\n  let previousValue: number | undefined;\n  if (isPlainObject(current)) {\n    forEach(\n      current,\n      ([key, value]) =>\n        // No change here.\n        delta[key] !== previous[key] &&\n        (deltaValue = isPlainObject(value)\n          ? deltaDiff(value, previous[key])?.[0]\n          : isNumber(value) && isNumber((previousValue = previous[key]))\n          ? value - previousValue\n          : value) !== previous[key] &&\n        ((delta[key] = deltaValue), (any = true))\n    );\n  }\n  return any ? [delta, current] : undefined;\n};\n\nexport type EventPatchSource<T extends TrackedEvent = TrackedEvent> = (\n  previous: EventPatchData<T>,\n  unbind: () => void\n) => [delta: EventPatchData<T>, current: EventPatchData<T>] | undefined;\n\nexport const createEventQueue = (\n  url: string,\n  context: TrackerContext,\n  postFrequency = EVENT_POST_FREQUENCY\n): EventQueue => {\n  type Factory = () => [event: EventPatch | undefined, unbinding: boolean];\n  const queue: TrackedEvent[] = [];\n\n  const snapshots = new WeakMap<TrackedEvent, any>();\n  const sources = new Map<TrackedEvent, Factory>();\n\n  const mapPatchTarget = <T extends TrackedEvent>(\n    sourceEvent: T,\n    patch: EventPatchData<T> | undefined\n  ): EventPatch<T> =>\n    !sourceEvent.metadata?.queued\n      ? throwError(\"Source event not queued.\")\n      : (merge(patch, {\n          type: sourceEvent.type + PATCH_EVENT_POSTFIX,\n          patchTargetId: sourceEvent.clientId,\n        }) as any);\n\n  const registerEventPatchSource = <T extends TrackedEvent>(\n    sourceEvent: TrackedEvent,\n    source: EventPatchSource<T>\n  ) => {\n    let unbinding = false;\n    const unbind = () => (unbinding = true);\n    snapshots.set(sourceEvent, clone(sourceEvent));\n    const factory: Factory = () => {\n      const snapshot = snapshots.get(sourceEvent);\n      let [delta, current] = source(snapshot, unbind) ?? [];\n\n      if (delta && (!snapshot || !structuralEquals(current, snapshot))) {\n        // The new \"current\" differs from the previous.\n        snapshots.set(sourceEvent, clone(current));\n        // Add patch target ID and the correct event type to the delta data before we return it.\n        return [mapPatchTarget(sourceEvent, delta) as any, unbinding];\n      } else {\n        return [undefined, unbinding];\n      }\n    };\n    sources.set(sourceEvent, factory);\n    return unbind;\n  };\n\n  const post = async (\n    events: ToggleArray<readonly TrackedEvent[]>,\n    flush = false\n  ) => {\n    events = map(array(events), (event) =>\n      merge(context.applyEventExtensions(event), { metadata: { queued: true } })\n    );\n\n    if (events.length) {\n      forEach(events, (event) => debug(event, event.type));\n    }\n    if (!flush) {\n      events.length && push(queue, ...events);\n      return;\n    }\n\n    if (queue.length) {\n      unshift(events as any, ...queue.splice(0));\n    }\n\n    if (!events.length) return;\n\n    debug(\n      join(events, (ev) => ev.type, [\"and\"]),\n      \"Posting \" + pluralize(\"events\", [events.length])\n    );\n\n    await request<PostRequest>(url, {\n      events: events.map(\n        (ev) => (\n          // Update metadata in the source event,\n          // and send a clone of the event without client metadata, and its timestamp in relative time\n          // (the server expects this, and will adjust accordingly to its own time).\n          merge(ev, { metadata: { posted: true } }),\n          merge(clearMetadata(clone(ev), true), {\n            timestamp: ev.timestamp! - now(),\n          })\n        )\n      ),\n      deviceSessionId: context?.deviceSessionId,\n    });\n  };\n\n  postFrequency > 0 && clock(() => post([], true), postFrequency);\n\n  addPageVisibleListener((visible, unloading, delta) => {\n    // Don't do anything if the tab has only been visible for less than a second and a half.\n    // More than that the user is probably just switching between tabs moving past this one.\n    // NOTE: (This number should preferably be better qualified. We could also look into user activation events).\n    if (!visible && (queue.length || unloading || delta > 1500)) {\n      const updatedEvents = map(sources, ([sourceEvent, source]) => {\n        const [event, unbinding] = source();\n        unbinding && sources.delete(sourceEvent);\n        return event;\n      });\n\n      if (queue.length || updatedEvents.length) {\n        post(concat(queue.splice(0), updatedEvents)!, true);\n      }\n    }\n  });\n\n  return {\n    post,\n    postPatch: (target, patch, flush) =>\n      post(mapPatchTarget(target, patch), flush),\n    registerEventPatchSource: registerEventPatchSource,\n  };\n};\n","import { ConfiguredComponent, ImpressionEvent } from \"@tailjs/types\";\nimport {\n  F,\n  NoOpFunction,\n  T,\n  count,\n  filter,\n  forEach,\n  map,\n  nil,\n  push,\n  restrict,\n  stickyTimeout,\n} from \"@tailjs/util\";\nimport {\n  deltaDiff,\n  getScreenPos,\n  getViewport,\n  trackerConfig,\n  trackerFlag,\n} from \".\";\nimport {\n  BoundaryData,\n  Tracker,\n  createViewDurationTimer,\n  getComponentContext,\n  getViewTimeOffset,\n} from \"..\";\n\nconst intersectionHandler = Symbol();\n\nexport const createImpressionObserver = (tracker: Tracker) => {\n  const observer = new IntersectionObserver(\n    (els) =>\n      forEach(\n        els,\n        ({ target, isIntersecting, boundingClientRect, intersectionRatio }) =>\n          target[intersectionHandler]?.(\n            isIntersecting,\n            boundingClientRect,\n            intersectionRatio\n          )\n      ),\n    // Low thresholds used to be able to handle components larger than view ports.\n    { threshold: [0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.75] }\n  );\n\n  return (el: Element, boundaryData: BoundaryData<true> | undefined) => {\n    if (!boundaryData) return;\n\n    let components: ConfiguredComponent[] | undefined;\n    if (\n      (components = filter(\n        boundaryData?.component,\n        (cmp) =>\n          // Impression settings from the DOM/CSS are ignored for secondary and inferred components (performance thing)\n          cmp!.track?.impressions ||\n          (cmp.track?.secondary ?? cmp.inferred) !== T\n      ))\n    ) {\n      if (!count(components)) {\n        return;\n      }\n\n      let visible = F;\n      let impressions = 0;\n      let fold: number;\n      const trackImpression = stickyTimeout(trackerConfig.impressionThreshold);\n      const timer = createViewDurationTimer();\n      let impressionEvents: ImpressionEvent[] | undefined;\n      let unbindPassiveEventSources: NoOpFunction[] | undefined;\n      el[intersectionHandler] = (\n        intersecting: boolean,\n        rect: DOMRectReadOnly,\n        ratio: number\n      ) => {\n        intersecting =\n          ratio >= 0.75 ||\n          (rect.top < (fold = window.innerHeight / 2) && rect.bottom > fold);\n\n        timer(intersecting);\n        if (visible !== (visible = intersecting)) {\n          //el[\"style\"].border = visible ? \"2px solid blue\" : \"\";\n          if (visible) {\n            trackImpression(() => {\n              ++impressions;\n              if (!impressionEvents) {\n                impressionEvents = filter(\n                  map(\n                    components,\n                    (cmp) =>\n                      ((cmp!.track?.impressions ||\n                        trackerFlag(\n                          el,\n                          \"impressions\",\n                          T,\n                          (data) => data.track?.impressions\n                        )) &&\n                        restrict<ImpressionEvent>({\n                          type: \"impression\",\n                          pos: getScreenPos(el),\n                          viewport: getViewport(),\n                          timeOffset: getViewTimeOffset(),\n                          impressions,\n                          ...getComponentContext(el, T),\n                        })) ||\n                      nil\n                  )\n                );\n                push(tracker, impressionEvents);\n              }\n\n              if (impressionEvents?.length) {\n                unbindPassiveEventSources = map(impressionEvents, (event) =>\n                  tracker.events.registerEventPatchSource(event, (previous) =>\n                    deltaDiff(\n                      {\n                        relatedEventId: event.clientId!,\n                        duration: timer(),\n                        impressions: impressions,\n                      },\n                      previous\n                    )\n                  )\n                );\n              }\n            });\n          } else {\n            // Stop timing event updates.\n            forEach(unbindPassiveEventSources, (unbind) => unbind());\n\n            // Not visible, clear timeout (if any, maybe the component disappeared to fast again for it to count as an impression).\n            trackImpression(false);\n          }\n        }\n      };\n      observer.observe(el);\n    }\n  };\n};\n","import type { UserAgentEvent } from \"@tailjs/types\";\nimport { window } from \"../lib2\";\n\nexport const detectDeviceType = (): Pick<\n  UserAgentEvent,\n  \"deviceType\" | \"screen\"\n> => {\n  // Common thresholds based on https://yesviz.com/viewport/\n  const screen = window?.screen;\n  if (!screen) return {};\n\n  let { width: w, height: h, orientation: o } = screen; // Get's the resolution in logical (CSS) pixels.\n  const landscape = w < h;\n  const angle = o?.angle ?? window[\"orientation\"] ?? 0;\n  (angle === -90 || angle === 90) && ([w, h] = [h, w]);\n\n  return {\n    deviceType: w < 480 ? \"mobile\" : w <= 1024 ? \"tablet\" : \"desktop\",\n    screen: { dpr: window.devicePixelRatio, width: w, height: h, landscape },\n  };\n};\n","import { map, push, restrict } from \"@tailjs/util\";\r\nimport { Tracker, currentViewEvent, detectDeviceType } from \"..\";\r\nimport { UserAgentEvent } from \"@tailjs/types\";\r\n\r\nexport const postUserAgentEvent = (tracker: Tracker) =>\r\n  push(\r\n    tracker,\r\n    restrict<UserAgentEvent>({\r\n      type: \"user_agent\",\r\n      hasTouch: navigator.maxTouchPoints > 0,\r\n      userAgent: navigator.userAgent,\r\n      view: currentViewEvent?.clientId,\r\n      languages: map(navigator.languages, (id, i, parts = id.split(\"-\")) =>\r\n        restrict<UserAgentEvent[\"languages\"]>({\r\n          id,\r\n          language: parts[0],\r\n          region: parts[1],\r\n          primary: i === 0,\r\n          preference: i + 1,\r\n        })\r\n      ),\r\n      timezone: {\r\n        iana: Intl.DateTimeFormat().resolvedOptions().timeZone,\r\n        offset: new Date().getTimezoneOffset(),\r\n      },\r\n      ...detectDeviceType(),\r\n    })\r\n  );\r\n","import {\n  AnchorNavigationEvent,\n  CartUpdatedEvent,\n  ComponentClickEvent,\n  ConfiguredComponent,\n  NavigationEvent,\n  UserInteractionEvent,\n} from \"@tailjs/types\";\nimport {\n  TrackerExtensionFactory,\n  getComponentContext,\n  getViewTimeOffset,\n  onFrame,\n  pushNavigationSource,\n  tryGetCartEventData,\n} from \"..\";\n\nimport {\n  F,\n  NOOP,\n  T,\n  array,\n  uriEncode,\n  equalsAny,\n  isObject,\n  map,\n  nil,\n  parseUri,\n  push,\n  remove,\n  restrict,\n  some,\n  stickyTimeout,\n  tryCatch,\n  type Nullish,\n} from \"@tailjs/util\";\nimport { parseActivationTags } from \"..\";\nimport {\n  MNT_URL,\n  attr,\n  forAncestorsOrSelf,\n  getBoundaryData,\n  getScreenPos,\n  getViewport,\n  isInternalUrl,\n  listen,\n  mapUrl,\n  matchExHash,\n  nextId,\n  normalizedAttribute,\n  tagName,\n  trackerConfig,\n  trackerFlag,\n} from \"../lib2\";\n\nconst isLinkElement = (\n  el: Element,\n  href: any = tagName(el) === \"A\" && attr(el, \"href\")\n): el is HTMLAnchorElement =>\n  href && href != \"#\" && !href.startsWith(\"javascript:\");\n\nconst isClickable = (\n  el: Element,\n  t = tagName(el),\n  attr = trackerFlag(el, \"button\")\n): el is HTMLElement =>\n  attr !== F &&\n  (equalsAny(t, \"A\", \"BUTTON\") ||\n    (t === \"INPUT\" &&\n      equalsAny(normalizedAttribute(el, \"type\"), \"button\", \"submit\")) ||\n    attr === T);\n\nfunction getElementLabel(el: Element | EventTarget | null, container: Element) {\n  let info: Pick<UserInteractionEvent, \"element\"> | undefined;\n  forAncestorsOrSelf(el ?? container, (el) =>\n    tagName(el) === \"IMG\" || el === container\n      ? ((info = {\n          element: {\n            tagName: el.tagName,\n            text:\n              attr(el, \"title\") ||\n              attr(el, \"alt\") ||\n              (el as HTMLElement).innerText?.trim().substring(0, 100) ||\n              undefined,\n          },\n        }),\n        F)\n      : T\n  );\n  return info;\n}\nexport const userInteraction: TrackerExtensionFactory = {\n  id: \"navigation\",\n\n  setup(tracker) {\n    const pollContextCookie = stickyTimeout();\n\n    // There can be all kinds of fishy navigation logic happening, so it is not enough just to look at link (<A>) clicks.\n    // Hence, when navigation occurs (in the current tab), we do not send the event before we have an VIEW_END.\n    // We rely on that the logic for VIEW_END takes care all the different ways to navigate (history.push etc.) so this is where we know that navigation happened for sure.\n\n    const stripPositions = <T = any>(el: any, hitTest: boolean): T =>\n      hitTest\n        ? el\n        : (map(el, ([key]) =>\n            key === \"rect\" ||\n            //key === \"pos\"  Changed so pos is always included.\n            key === \"viewport\"\n              ? remove(el, key)\n              : isObject(el[key]) &&\n                map(el[key], (item) => stripPositions(item, hitTest))\n          ),\n          el);\n    const trackDocument = (document: Document) => {\n      listen(\n        document,\n        [\"click\", \"contextmenu\", \"auxclick\"],\n        (ev: MouseEvent) => {\n          let trackClicks: boolean | Nullish;\n          let trackRegion: boolean | Nullish;\n          let clickableElement: HTMLElement | null = nil! as HTMLElement; // Typescript insists this is never?\n\n          let nav = F;\n\n          forAncestorsOrSelf<boolean>(ev.target, (el) => {\n            clickableElement ??= isClickable(el) ? el : nil;\n            nav = nav || tagName(el) === \"NAV\";\n\n            let cmp: readonly ConfiguredComponent[] | Nullish;\n\n            trackClicks ??=\n              trackerFlag(el, \"clicks\", T, (data) => data.track?.clicks) ??\n              ((cmp = array(getBoundaryData(el)?.component)) &&\n                some(cmp, (cmp) => cmp.track?.clicks !== F));\n            trackRegion ??=\n              trackerFlag(el, \"region\", T, (data) => data.track?.region) ??\n              ((cmp = getBoundaryData(el)?.component) &&\n                some(cmp, (cmp) => cmp.track?.region));\n          });\n\n          if (!clickableElement) {\n            return;\n          }\n          const componentContext = getComponentContext(clickableElement);\n          const tags = parseActivationTags(clickableElement);\n          trackClicks ??= !nav;\n          trackRegion ??= T;\n\n          const sharedEventProperties = {\n            ...(trackRegion\n              ? {\n                  pos: getScreenPos(clickableElement, ev),\n                  viewport: getViewport(),\n                }\n              : nil),\n            ...getElementLabel(ev.target, clickableElement),\n            ...componentContext,\n            ...tags,\n            timing: getViewTimeOffset(),\n          };\n\n          if (isLinkElement(clickableElement!)) {\n            const external = clickableElement.hostname !== location.hostname;\n\n            const {\n              host,\n              scheme,\n              source: href,\n            } = parseUri(clickableElement.href, false, true);\n            if (\n              clickableElement.host === location.host &&\n              clickableElement.pathname === location.pathname &&\n              clickableElement.search === location.search\n            ) {\n              if (clickableElement.hash === \"#\") {\n                // Don't care about that one.\n                return;\n              }\n              if (clickableElement.hash !== location.hash) {\n                push(\n                  tracker,\n                  restrict<AnchorNavigationEvent>({\n                    type: \"anchor_navigation\",\n                    anchor: clickableElement.hash,\n                    ...sharedEventProperties,\n                  })\n                );\n              }\n              return;\n            }\n\n            const navigationEvent: NavigationEvent = restrict<NavigationEvent>({\n              clientId: nextId(),\n              type: \"navigation\",\n              href: external ? clickableElement.href : href,\n              external,\n              domain: { host, scheme },\n              self: T,\n              anchor: clickableElement.hash,\n              ...sharedEventProperties,\n            });\n\n            // TODO: Reimplement with push variables\n            // Read the variable CONTEXT_NAV_REQUEST_ID that is set by the request handler when doing CONTEXT_NAV_QUERY redirects.\n            // if (ev.type === \"contextmenu\") {\n            //   const referrerConsumed = pushNavigationSource(\n            //     navigationEvent.clientId\n            //   );\n\n            //   const currentUrl = clickableElement.href;\n            //   const internalUrl = isInternalUrl(currentUrl);\n\n            //   if (!internalUrl) {\n            //     if (!trackerConfig.captureContextMenu) return;\n            //     clickableElement.href = mapUrl(\n            //       MNT_URL,\n            //       \"=\",\n            //       encodeURIComponent(currentUrl)\n            //     );\n            //     tryCatch(\n            //       () =>\n            //         navigator.userActivation?.isActive &&\n            //         navigator.clipboard.writeText(currentUrl)\n            //     );\n            //   }\n\n            //     const flag = Date.now();\n            //     //cookies(CONTEXT_MENU_COOKIE, flag, 11000);\n            //     pollContextCookie(() => {\n            //       (clickableElement as HTMLAnchorElement).href = currentUrl;\n            //       if (\n            //         !referrerConsumed() ||\n            //         +cookies(CONTEXT_MENU_COOKIE)! === flag + 1\n            //       ) {\n            //         cookies(CONTEXT_MENU_COOKIE, nil);\n            //         navigationEvent.self = F;\n            //         push(tracker, navigationEvent);\n            //         clear(pollContextCookie);\n            //       }\n            //     }, -100);\n\n            //     let unbindAll = listen(\n            //       document,\n            //       [\"keydown\", \"keyup\", \"visibilitychange\", \"pointermove\"],\n            //       () =>\n            //         unbindAll() &&\n            //         clear(pollContextCookie, 10000, () =>\n            //           cookies(CONTEXT_MENU_COOKIE, \"\")\n            //         )\n            //     );\n            //   }\n            if (ev.button <= 1) {\n              if (\n                ev.button === 1 || //Middle-click: new tab.\n                ev.ctrlKey || // New tab\n                ev.shiftKey || // New window\n                ev.altKey || // Download\n                attr(clickableElement, \"target\") !== window.name\n              ) {\n                pushNavigationSource(navigationEvent.clientId);\n                navigationEvent.self = F;\n                // Fire immediately, we are staying on the page.\n                push(tracker, navigationEvent);\n                return;\n              } else if (!matchExHash(location.href, clickableElement.href)) {\n                navigationEvent.exit = navigationEvent.external;\n                // No \"real\" navigation will happen if it is only the hash changing.\n                pushNavigationSource(navigationEvent.clientId);\n              }\n\n              // // If it so happened that navigation happened we will send it on VIEW_END.\n              // pendingNavigationEvent = registerViewEndAction(() =>\n              //   push(tracker, navigationEvent)\n              // );\n            }\n            return;\n          }\n\n          const cart = tryGetCartEventData(ev.target as Element);\n          (cart || trackClicks) &&\n            push(\n              tracker,\n              cart\n                ? restrict<CartUpdatedEvent>({\n                    type: \"cart_updated\",\n                    ...sharedEventProperties,\n                    ...cart,\n                  })\n                : restrict<ComponentClickEvent>({\n                    type: \"component_click\",\n                    ...sharedEventProperties,\n                  })\n            );\n          return;\n        }\n      );\n    };\n\n    trackDocument(document);\n    onFrame(\n      (frame) => frame.contentDocument && trackDocument(frame.contentDocument)\n    );\n  },\n};\n","import {\n  type CartAction,\n  type CartEventData,\n  type CartUpdatedEvent,\n  type OrderEvent,\n} from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  equalsAny,\n  isObject,\n  isString,\n  last,\n  nil,\n  push,\n  type Nullish,\n} from \"@tailjs/util\";\nimport { TrackerExtensionFactory, isCartCommand, isOrderCommand } from \"..\";\nimport { forAncestorsOrSelf, getBoundaryData, trackerProperty } from \"../lib2\";\n\nexport const parseCartEventData = (\n  data: boolean | string | CartEventData | Nullish\n): CartEventData | undefined => (\n  data == nil ? undefined : (data === T || data === \"\") && (data = \"add\"),\n  isString(data) && equalsAny(data, \"add\", \"remove\", \"update\", \"clear\")\n    ? { action: data as CartAction }\n    : isObject(data)\n    ? data\n    : undefined\n);\n\nfunction normalizeCartEventData(data: CartEventData | Nullish) {\n  if (!data) return undefined;\n\n  if (data.units != nil && equalsAny(data.action, nil, \"add\", \"remove\")) {\n    if (data.units === 0) return undefined;\n    data.action = data.units > 0 ? \"add\" : \"remove\";\n  }\n  return data;\n}\n\nexport function tryGetCartEventData(sourceElement: Element) {\n  // Find cart. Look for cart attributes and/or data until the first content is met.\n  let contextCart: CartEventData | Nullish;\n  forAncestorsOrSelf(\n    sourceElement,\n    (el, r) =>\n      !!(contextCart ??= parseCartEventData(\n        getBoundaryData(el)?.cart ?? trackerProperty(el, \"cart\")\n      )) &&\n      !contextCart.item &&\n      (contextCart.item = last(getBoundaryData(el)?.content)) &&\n      r(contextCart)\n  );\n\n  return normalizeCartEventData(contextCart);\n}\n\nexport const commerce: TrackerExtensionFactory = {\n  id: \"cart\",\n  setup(tracker) {\n    return {\n      processCommand(command) {\n        if (isCartCommand(command)) {\n          let cart = command.cart;\n          cart === \"clear\"\n            ? push(tracker, {\n                type: \"cart_updated\",\n                action: \"clear\",\n              } as CartUpdatedEvent)\n            : (cart = normalizeCartEventData(cart)!) &&\n              push(tracker, {\n                ...cart,\n                type: \"cart_updated\",\n              } as CartUpdatedEvent);\n\n          return T;\n        }\n        if (isOrderCommand(command)) {\n          push(tracker, {\n            type: \"order\",\n            ...command.order,\n          } as OrderEvent);\n\n          return T;\n        }\n        return F;\n      },\n    };\n  },\n};\n","import { FormEvent, FormField, Timestamp } from \"@tailjs/types\";\nimport {\n  T,\n  forEach,\n  get,\n  map,\n  nil,\n  now,\n  push,\n  replace,\n  restrict,\n  stickyTimeout,\n  type Nullish,\n} from \"@tailjs/util\";\nimport {\n  TrackerExtensionFactory,\n  getComponentContext,\n  getVisibleDuration,\n  onFrame,\n} from \"..\";\nimport {\n  NodeWithParentElement,\n  attr,\n  deltaDiff,\n  getRect,\n  listen,\n  scopeAttribute,\n  trackerFlag,\n  trackerPropertyName,\n  uuidv4,\n} from \"../lib2\";\n\ntype FormElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\n\nconst enum FormFillState {\n  None = 0,\n  Submitted = 1,\n  Pending = 2,\n  Submitting = 3,\n}\n\ntype FormState = [\n  event: FormEvent,\n  fields: WeakMap<Element, FormFieldState>,\n  element: HTMLFormElement,\n  fillState: FormFillState,\n  started: Timestamp,\n  nextFillOrder: number\n];\n\nconst currentValue = Symbol();\ntype FormFieldState = FormField & {\n  [currentValue]: string;\n};\n\nexport const forms: TrackerExtensionFactory = {\n  id: \"forms\",\n  setup(tracker) {\n    const formEvents = new Map<HTMLFormElement, FormState>();\n\n    const getFormFieldValue = (element: any): string =>\n      element.selectedOptions\n        ? [...element.selectedOptions].map((option) => option.value).join(\",\")\n        : element.type === \"checkbox\"\n        ? element.checked\n          ? \"yes\"\n          : \"no\"\n        : element.value;\n\n    const getFormState = (\n      el: FormElement\n    ): [input: FormElement, state: FormState] | undefined => {\n      const formElement = el.form;\n      if (!formElement) return; // Don't care if we started with an element that didn't map to a field.\n\n      const refName =\n        scopeAttribute(formElement, trackerPropertyName(\"ref\")) || \"track_ref\";\n\n      const parseElements = () => {\n        map(\n          formElement.querySelectorAll(\n            \"INPUT,SELECT,TEXTAREA\"\n          ) as any as Iterable<FormElement>,\n          (el, i) => {\n            if (!el.name || el.type === \"hidden\") {\n              if (\n                el.type === \"hidden\" &&\n                (el.name === refName || trackerFlag(el, \"ref\"))\n              ) {\n                !el.value && (el.value = uuidv4());\n                state[0].ref = el.value;\n              }\n              return;\n            }\n\n            const name = el.name;\n            const field = (state[0].fields![name] ??= {\n              id: el.id || name,\n              name,\n              label: replace(\n                el.labels?.[0]?.innerText ?? el.name,\n                /^\\s*(.*?)\\s*\\*?\\s*$/g,\n                \"$1\"\n              ),\n              activeTime: 0,\n              type: el.type ?? \"unknown\",\n              [currentValue as any]: getFormFieldValue(el),\n            }) as FormFieldState;\n\n            state[0].fields![field.name] = field;\n            state[1].set(el, field);\n          }\n        );\n      };\n\n      let capturedContext: ReturnType<typeof getComponentContext>;\n\n      const isFormVisible = () =>\n        formElement.isConnected && getRect(formElement).width;\n\n      const state = get(formEvents, formElement, () => {\n        const fieldMap = new Map<Element, FormFieldState>();\n        const ev: FormEvent = {\n          type: \"form\",\n          name:\n            scopeAttribute(formElement, trackerPropertyName(\"form-name\")) ||\n            attr(formElement, \"name\") ||\n            formElement.id ||\n            undefined,\n          activeTime: 0,\n          totalTime: 0,\n          fields: {},\n        };\n\n        tracker.events.post(ev);\n\n        tracker.events.registerEventPatchSource(ev, (previous) =>\n          deltaDiff(ev as any, previous)\n        );\n\n        let state: FormState;\n        const commitEvent = () => {\n          handleLostFocus(); // focusout or change events may not be called when the user leaves the page while a field has focus.\n\n          // If the form has disappeared it is heuristically assumed it was submitted successfully.\n          state[3] >= FormFillState.Pending &&\n            (ev.completed =\n              state[3] === FormFillState.Submitting || !isFormVisible());\n          tracker.events.postPatch(ev, {\n            ...capturedContext,\n            totalTime: now(T) - state[4],\n          });\n\n          state[3] = FormFillState.Submitted;\n        };\n\n        const commitTimeout = stickyTimeout();\n\n        listen(formElement, \"submit\", () => {\n          capturedContext = getComponentContext(formElement);\n          state[3] = FormFillState.Submitting;\n\n          commitTimeout(() => {\n            // If the form disappears within 750 ms but no navigation happens it is assumed that it was \"submitted\" somehow, e.g. via AJAX.\n            // This heuristic may result in false positives if the user clicks submit, gets validation errors and then leaves the site instantly.\n            //\n            // If the server is aggressively slow to respond to a post and the for goes back into pending state,\n            // it is undefined whether the submit happened or not, if the user leaves the site before the server responds.\n            // In this case it will count as abandonment.\n\n            if (formElement.isConnected && getRect(formElement).width > 0) {\n              state[3] = FormFillState.Pending;\n              commitTimeout();\n            } else {\n              commitEvent();\n            }\n          }, 750);\n        });\n\n        return (state = [\n          ev,\n          fieldMap,\n          formElement,\n          FormFillState.None,\n          now(T),\n          1,\n        ]);\n      });\n      if (!get(state[1], el)) {\n        // This will also be the case if a new field was added to the DOM.\n        parseElements();\n      }\n      return [el!, state];\n    };\n\n    const getFieldInfo = (\n      el: NodeWithParentElement,\n      [formElement, state] = getFormState(el as any) ?? [],\n      field = state?.[1].get(formElement as Element)\n    ) => field && ([state![0], field, formElement!, state!] as const);\n\n    let currentField: ReturnType<typeof getFieldInfo> | null = nil;\n    const handleLostFocus = () => {\n      if (!currentField) return;\n\n      const [form, field, el, state] = currentField;\n      const active = -(tv0 - (tv0 = getVisibleDuration()));\n      const total = -(t0 - (t0 = now(T)));\n\n      const previousValue = field[currentValue];\n      const newValue = (field[currentValue] = getFormFieldValue(el));\n\n      if (newValue !== previousValue) {\n        field.fillOrder ??= state[5]++;\n        if (field.filled) {\n          field.corrections = (field.corrections ?? 0) + 1;\n        }\n        field.filled = T;\n\n        state[3] = FormFillState.Pending;\n        forEach(\n          form.fields!,\n          ([name, value]) =>\n            (value.lastField = name === field.name || undefined)\n        );\n      }\n\n      field.activeTime! += active;\n      field.totalTime! += total;\n      form.activeTime! += active;\n      currentField = nil;\n    };\n\n    let tv0 = 0;\n    let t0 = 0;\n    const wireFormFields = (document: Document | Nullish) => {\n      document &&\n        listen(\n          document,\n          [\"focusin\", \"focusout\", \"change\"],\n          (ev, _, current = ev.target && getFieldInfo(ev.target)) => {\n            current &&\n              ((currentField = current),\n              ev.type === \"focusin\"\n                ? ((t0 = now(T)), (tv0 = getVisibleDuration()))\n                : handleLostFocus());\n          }\n        );\n    };\n\n    wireFormFields(document);\n    onFrame((frame) => frame.contentDocument && wireFormFields);\n  },\n};\n","import {\n  TrackerExtensionFactory,\n  commerce,\n  components,\n  context,\n  forms,\n  scroll,\n  userInteraction,\n} from \"..\";\n\nexport const defaultExtensions: TrackerExtensionFactory[] = [\n  context,\n  components,\n  userInteraction,\n  scroll,\n  commerce,\n  forms,\n];\n","import type { Component, ExternalReference } from \"@tailjs/types\";\nimport type { BoundaryCommand } from \"..\";\nimport { T, add, get, map, nil, push, split, toString } from \"@tailjs/util\";\nimport { attr } from \".\";\n\ntype MappedComponent = [\n  command: {\n    component?: Component;\n    content?: ExternalReference;\n    area?: string;\n  },\n  elements: HTMLElement[]\n];\nexport function scanAttributes(\n  attributeName: string,\n  references: MappedComponent[0][]\n): BoundaryCommand[] {\n  if (!references) return [];\n  const commands: BoundaryCommand[] = [];\n\n  const seen = new Set<any>();\n  document.querySelectorAll(`[${attributeName}]`).forEach((el) => {\n    if (get(seen, el)) {\n      return;\n    }\n\n    const stack: any[] = [];\n\n    while (attr(el, attributeName) != nil) {\n      add(seen, el);\n      const delta = split(attr(el, attributeName)!, \"|\");\n      attr(el, attributeName, nil);\n      for (let i = 0; i < delta.length; i++) {\n        let item: any = delta[i];\n        if (item === \"\") {\n          continue; // If the attribute starts with \"|\" it means \"keep stack\". Splitting the array on \"|\" will give an empty item.\n        }\n        const number = item === \"-\" ? -1 : parseInt(toString(item) ?? \"\", 36);\n        if (number < 0) {\n          stack.length += number;\n          continue;\n        } else if (i === 0) {\n          stack.length = 0; // The first item has an value to replace the stack since not preceded by neither \"|\" nor an negative number (pop).\n        }\n\n        if (isNaN(number) && /^[\"\\[{]/.test(item)) {\n          // Poor man's parser. If the JSON contains '|'s keep going until it works.\n          let json = \"\";\n          for (; i < delta.length; i++) {\n            try {\n              item = JSON.parse((json += delta[i]));\n              break;\n            } catch (e) {}\n          }\n        }\n\n        if (number >= 0 && references[number]) {\n          item = references[number];\n        }\n        push(stack, item);\n      }\n      push(\n        commands,\n        ...map(stack, (data) => ({ add: T, ...data, boundary: el }))\n      );\n      const next = el.nextElementSibling!; // Ignore TS null error.\n      if (el.tagName === \"WBR\") {\n        el.parentNode?.removeChild(el);\n      }\n      el = next;\n    }\n  });\n\n  return commands;\n}\n","import { ScrollEvent } from \"@tailjs/types\";\nimport { T, defer, map, push, restrict } from \"@tailjs/util\";\nimport { addViewChangedListener, type TrackerExtensionFactory } from \"..\";\nimport { listen, relativeScrollPos, scrollPos } from \"../lib2\";\n\nexport const scroll: TrackerExtensionFactory = {\n  id: \"scroll\",\n  setup(tracker) {\n    let emitted: Partial<Record<Required<ScrollEvent>[\"scrollType\"], boolean>> =\n      {};\n    let initialScroll = scrollPos(T);\n\n    addViewChangedListener(() =>\n      defer(() => ((emitted = {}), (initialScroll = scrollPos(T))), 250)\n    );\n\n    listen(window, \"scroll\", () => {\n      const scroll = scrollPos();\n      const offset = relativeScrollPos();\n\n      if (scroll.y >= initialScroll.y) {\n        const types: (keyof typeof emitted)[] = [];\n\n        !emitted[\"fold\"] &&\n          scroll.y >= initialScroll.y + 200 &&\n          ((emitted[\"fold\"] = T), push(types, \"fold\"));\n\n        !emitted[\"page-middle\"] &&\n          offset.y >= 0.5 &&\n          ((emitted[\"page-middle\"] = T), push(types, \"page-middle\"));\n\n        !emitted[\"page-end\"] &&\n          offset.y >= 0.99 &&\n          ((emitted[\"page-end\"] = T), push(types, \"page-end\"));\n\n        const mapped = map(types, (scrollType) =>\n          restrict<ScrollEvent>({\n            type: \"scroll\",\n            scrollType,\n            offset,\n          })\n        );\n\n        mapped.length && push(tracker, mapped);\n      }\n    });\n  },\n};\n","export const commandTest =\n  <T = any>(...name: any[]) =>\n  (command: any): command is T =>\n    command === name[0] ||\n    name.some(\n      (name) => typeof name === \"string\" && command?.[name] !== undefined\n    );\n","import { CartEventData } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Triggers events related to a shopping cart.\n */\nexport interface CartCommand {\n  cart: \"clear\" | CartEventData;\n}\n\nexport const isCartCommand = commandTest<CartCommand>(\"cart\");\n","import type { Nullish } from \"@tailjs/util\";\nimport { commandTest } from \"./shared\";\n\nexport interface ChangeUserCommand {\n  username: string | Nullish;\n}\n\nexport const isChangeUserCommand = commandTest<ChangeUserCommand>(\"username\");\n","import type { TagMappings } from \"..\";\nimport { commandTest } from \"./shared\";\n\nexport type TagAttributesCommand = {\n  tagAttributes: TagMappings;\n};\nexport const isTagAttributesCommand =\n  commandTest<TagAttributesCommand>(\"tagAttributes\");\n","import { commandTest } from \"./shared\";\n\n/**\n * Enables or disables tracking.\n */\nexport type ToggleCommand = {\n  disable: boolean;\n};\nexport const isToggleCommand = commandTest<ToggleCommand>(\"disable\");\n","import type {\n  CartAction,\n  CartEventData,\n  ConfiguredComponent,\n  Content,\n  Tag,\n  TrackingSettings,\n} from \"@tailjs/types\";\n\nimport { commandTest } from \"./shared\";\nimport { MaybeArray, Nullish } from \"@tailjs/util\";\n\nexport interface BoundaryData<RequireArrays = false> {\n  /**\n   * The component definition(s) associated with the boundary element.\n   */\n  component?: MaybeArray<ConfiguredComponent, true, RequireArrays> | null;\n\n  /**\n   * The content definition(s) associated with the boundary element.\n   */\n  content?: MaybeArray<Content, true, RequireArrays> | null;\n\n  /**\n   * The name of the content area associated with the boundary element.\n   *\n   * A content area is used to indicate where activated components are used.\n   */\n  area?: string | null;\n\n  /**\n   *  These tags will be added to the components and content in user activations with the boundary element or any of its descendants.\n   */\n  tags?: MaybeArray<Tag, true, RequireArrays> | null;\n\n  /**\n   * The element will include cart data when activated.\n   */\n  cart?: CartAction | CartEventData;\n\n  /**\n   * Settings that will apply to components contained by the boundary element including itself, similar to specifying \"track-*\" HMTL attributes on the element.\n   */\n  track?: TrackingSettings;\n}\n\n/**\n * Registers an element as the boundary for a component or similar tracking data. All events triggered from the element or its descendants will have this information attached.\n * In case of nested boundaries the closest one is used.\n */\nexport type BoundaryCommand = {\n  boundary: Element;\n} & (\n  | (BoundaryData & {\n      /**\n       * The content, tags and components will be added to the existing, if any.\n       */\n      add?: boolean;\n    })\n  | { update: (current?: BoundaryData<true>) => BoundaryData | Nullish }\n);\n\n// {\n//   /**\n//    * The component definition(s) associated with the boundary element.\n//    */\n//   component?: ConfiguredComponent | ConfiguredComponent[] | null;\n\n//   /**\n//    * The content definition(s) associated with the boundary element.\n//    */\n//   content?: Content | Content[] | null;\n\n//   /**\n//    * The name of the content area associated with the boundary element.\n//    *\n//    * A content area is used to indicate where activated components are used.\n//    */\n//   area?: string | string[] | null;\n\n//   /**\n//    *  These tags will be added to the components and content in user activations with the boundary element or any of its descendants.\n//    */\n//   tags?: Tag | Tag[] | null;\n\n//   /**\n//    * The element will include cart data when activated.\n//    */\n//   cart?: CartAction | CartEventData;\n\n//   /**\n//    * The element's component will be included in the stack even when the activation tracking level is `direct`.\n//    */\n//   promote?: boolean;\n\n//   /**\n//    * Specifies how the this command modifies the data associated with the boundary element.\n//    *\n//    * Only properties present in this command are affected (e.g. `component` or `content`) unless the action is `clear`.\n//    *\n//    * @default \"add\"\n//    */\n//   action?: \"add\" | \"remove\" | \"clear\";\n\n//   /**\n//    * The DOM element that gets this command's data associated.\n//    */\n//   boundary: Element;\n// }\n\nexport const isDataBoundaryCommand = commandTest<BoundaryCommand>(\"boundary\");\n","import type { TrackerExtensionFactory } from \"..\";\nimport { commandTest } from \"./shared\";\n\nexport interface ExtensionCommand {\n  extension: TrackerExtensionFactory;\n  priority?: number;\n}\nexport const isExtensionCommand = commandTest<ExtensionCommand>(\"extension\");\n","import { T } from \"@tailjs/util\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Causes all queued events to be posted to the server immediately.\n */\nexport type FlushCommand = { flush: boolean; force?: boolean; defer?: boolean };\nexport const isFlushCommand = commandTest<FlushCommand>(T, \"flush\");\n","import { MaybeArray, PickRequired } from \"@tailjs/util\";\nimport { ClientVariableGetter } from \"../lib2\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Used to get variables (data) from the backend.\n */\nexport interface GetCommand {\n  get: MaybeArray<PickRequired<ClientVariableGetter, \"result\">, true>;\n}\n\nexport const isGetCommand = commandTest<GetCommand>(\"get\");\n","import type { Listener } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Registers a listener that will be invoked before and after events are flushed.\n * Useful for debugging or client-side integration with other tracker libraries (if one absolutely must).\n */\nexport interface ListenerCommand {\n  listener: Listener;\n}\nexport const isListenerCommand = commandTest<ListenerCommand>(\"listener\");\n","import { Order, OrderEvent } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Shorthand command to trigger an {@link OrderEvent} event.\n */\nexport interface OrderCommand {\n  /**\n   * The order that was completed or cancelled.\n   */\n  order: Order;\n}\n\nexport const isOrderCommand = commandTest<OrderCommand>(\"order\");\n","import type { Component, ExternalReference } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\nexport type ComponentOrContent =\n  | { component: Component }\n  | { content: ExternalReference };\n\n/**\n * Registers an element as the boundary for a component. All events triggered from the element or its descendants will have this information attached.\n * In case of nested boundaries the closest one is used.\n */\nexport interface ScanComponentsCommand {\n  scan: {\n    attribute: string;\n    components: ComponentOrContent[];\n  };\n}\n\nexport const isScanComponentsCommand =\n  commandTest<ScanComponentsCommand>(\"scan\");\n","import { MaybeArray } from \"@tailjs/util\";\nimport { ClientVariableSetter } from \"../lib2\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Used to set variables (data) in the backend.\n */\nexport interface SetCommand {\n  /** An object where the names of the properties correspond to the variables set in the tracker. */\n  set: MaybeArray<ClientVariableSetter<any, string>>;\n}\n\nexport const isSetCommand = commandTest<SetCommand>(\"set\");\n","import type { Tracker, TrackerCommand } from \"..\";\n\nexport type TrackerAvailableCommand = (tracker: Tracker) => void;\nexport const isTrackerAvailableCommand = (\n  command: TrackerCommand\n): command is (tracker: Tracker) => void => typeof command === \"function\";\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\nimport { initializeTracker } from \"./initializeTracker\";\nimport { define, window } from \"./lib2\";\nimport { attach } from \"./pusher\";\n\n// This assumes the script is loaded from the RequestHandler's ?cfg route.\n\n// To prevent external scripts from eaves-dropping and get a hold of the storage key, this is how initialization works:\n// 1: The configuration scripts appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overridden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nwindow[INITIALIZE_TRACKER_FUNCTION] = (callback: any) => {\n  callback(initializeTracker);\n};\n"],"names":["matchProjection","collected","metadata","pos","screenPos","x","y","rect","cachedMappings","currentBoundaryData","propertyValue","_defaultTransports","pushCookieMatcher","pushCookie","currentViewEvent","pushPopNavigation","entry","content","tracker","DataClassification","DataPurposeFlags","VariableScope","VariableResultStatus","VariablePatchType","LocalVariableScope","throwError","error","transform","message","TypeError","isString","unwrap","structuralEquals","value1","value2","depth","isObject","length","n","key","Object","keys","equalsAny","target","singleValue","otherValues","some","value","required","text","replace","tryCatch","expression","errorHandler","always","e","isFunction","isError","isBoolean","console","deferred","result","undefined","deferredPromise","promise","initialized","then","thenMethod","onfullfilled","onrejected","tryCatchAsync","isArray","Error","restrict","item","MAX_SAFE_INTEGER","Number","F","T","NOOP","FILTER_NULLS","symbolIterator","Symbol","iterator","createTypeConverter","typeTester","parser","parse","ifDefined","resultOrProperty","parseBoolean","isTruish","isTrue","isNotFalse","isNumber","toString","Array","array","clone","isIterable","objectPrototype","prototype","getPrototypeOf","isPlainObject","hasMethod","name","isSymbol","acceptStrings","isMap","Map","isSet","Set","round","number","decimals","Math","pow","stopInvoked","stop","yieldValue","wrapProjection","projection","sliceAction","action","start","end","index","filterArray","filter","createIterator","source","createFilteringIterator","i","createObjectIterator","createNavigatingIterator","step","maxIterations","createRangeIterator","offset","mapToArray","projected","map","project","flatten","expandObjects","flattenInternal","nested","mapped","push","distinct","flatMap","join","sep","separate","concat","items","merged","forEach","forEachArray","returnValue","forEachIterable","forEachObject","apply","args","forEachInternal","forEachAsync","fromEntries","obj","selector","merge","reduce","reducer","seed","seedFactory","predicate","count","filterInternal","max","values","entries","mapFirst","last","sort","rank","lhs","rhs","setSingle","constructor","delete","set","add","get","init","has","createSetOrUpdateFunction","setter","assign","update","clearSingle","current","clear","removed","clearStep","parent","parentKey","targetKeys","remove","splice","define","arg","defaults","properties","defineProperty","configurable","enumerable","writable","pick","k","v","unshift","now","performance","trunc","timeOrigin","Date","createTimer","started","timeReference","capturedElapsed","t0","elapsed","toggle","reset","stickyTimeout","defaultTimeout","handle","currentCallback","timeout","clearTimeout","setTimeout","clock","callbackOrSettings","frequency","settings","callback","queue","paused","trigger","once","timeoutId","mutex","resolve","timer","delta","outerCallback","skipQueue","pending","instance","busy","resetTimer","clearInterval","active","setInterval","restart","newFrequency","newCallback","ResettablePromise","_promise","ifPending","reject","OpenPromise","signal","onfulfilled","captured","Promise","inner","defer","f","ms","window","queueMicrotask","delay","isFinite","resettable","race","createEventBinders","listener","attach","detach","bound","outerListener","unbind","rebind","joinEventBinders","binders","changed","binder","createEvent","dispatchedArgs","listeners","handler","payload","separator","slice","conjunct","conjunction","quote","isBit","log2","createEnumAccessor","sourceEnum","flags","enumName","pureFlags","carry","carry2","originalValue","names","toLowerCase","any","flag","nameLookup","none","valueLookup","parseValue","validateNumbers","invalid","tryParse","lookup","format","JSON","stringify","pure","logFormat","c","createEnumPropertyParser","props","parsers","sourceItem","prop","parsed","parseKeyValue","arrayDelimiters","decode","parts","split","decodeURIComponent","trim","replaceAll","delim","_","parseUri","uri","query","requireAuthority","match","scheme","slashes","authority","user","password","bracketHost","host","port","path","queryString","fragment","urn","parseInt","parseQueryString","part","testRegex","s","test","matches","regex","collect","escapeRegEx","input","REGEX_NEVER","unionOrNever","joined","RegExp","stringRuleCache","isRegEx","parseRegex","separators","replaceValue","dataClassification","dataPurposes","singleDataPurpose","clearMetadata","event","client","posted","queued","variableScope","Anonymous","Necessary","formatKey","scope","VariableEnumProperties","purpose","purposes","classification","isVariablePatch","isPostResponse","response","variables","toVariableResultPromise","results","errorHandlers","unwrappedResults","mapResults","property","handleResultErrors","all","status","getResultVariable","getSuccessResults","variable","isSuccessResult","requireValue","errorMessage","errors","successResults","Conflict","version","Denied","Invalid","ReadOnly","isTrackedEvent","ev","type","isViewEvent","typeTest","types","splitRanks","ranks","parseTagString","baseRank","parsedTag","tags","baseRanks","_0","tag","quote1","quote2","unquoted","pop","encodeTag","EVENT_POST_FREQUENCY","STATE_KEY","STORAGE_PREFIX","NOT_INITIALIZED","win","doc","document","body","matchSelector","node","MAX_ANCESTOR_DISTANCE","forAncestorsOrSelf","el","stoppingCriterion","distance","nil","prev","parentElement","ownerDocument","defaultView","frameElement","parseAttributeValue","parseFloat","httpDecode","httpDecrypt","attr","getAttribute","scopeAttribute","normalizedAttribute","attributeNames","getAttributeNames","cssProperty","getComputedStyle","getPropertyValue","tagName","relativeScrollPos","scrollPos","offsetWidth","innerWidth","offsetHeight","innerHeight","int","scrollX","scrollY","matchExHash","href1","href2","getScreenPos","mouseEvent","includeFold","getPos","xpx","ypx","pageFolds","pageY","pageX","getRect","getBoundingClientRect","left","top","width","height","listen","options","capture","passive","addEventListener","parseDomain","href","getViewport","totalWidth","totalHeight","boundaryData","WeakMap","getBoundaryData","trackerPropertyName","css","matchAttributeNames","cached","prefix","eligible","cachedTagMapper","parseTagAttributes","trackerConfig","rule","cache","cssPropertyWithBase","parsedCssRules","parseCssMappingRules","rulesString","rule1","rule2","trackerProperty","inherit","r","trackerFlag","parseTags","sourceEl","elementTagData","size","src","disabled","postEvents","postFrequency","requestTimeout","clientKey","apiKey","debug","impressionThreshold","captureContextMenu","defaultActivationTracking","default","currentScript","SCRIPT_SRC","TRACKER_DOMAIN","isInternalUrl","url","endsWith","mapUrl","urlParts","VAR_URL","codes","chars","charCode","charCodeAt","fromCharCodes","String","fromCharCode","p","to64u","bytes","chunk","base64","from64u","encoded","j","Uint8Array","FNVs","entropy","random","lfsr","pad","hash","bits","prime","mixer","mixer255","iw","mixer0","window0","resetMixer","updateMixer","MAX_PADDING","ENTROPY","cipher","numericOrBits","BigInt","asUintN","MIN_SAFE_INTEGER","serialize","data","multiple","floatBuffer","floatView","append","subarray","isReplacement","appendByte","appendNumber","isSafeInteger","appendBytes","hi","lo","appendInt64","DataView","ArrayBuffer","setFloat64","encodeUtf8","str","ascii","ci","c2","appendDate","sec","getTime","getMilliseconds","ns","appendArray","Uint8ClampedArray","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","appendObject","invalidTypeReplacement","byte","newLength","newArray","abs","deserialize","read","readMap","readArray","readStr","readBin","readExt","readFloat","readUInt","readInt","first","view","buffer","byteOffset","getFloat32","getFloat64","lengthSize","decodeUtf8","readExtDate","msgpack","encode","module","exports","msgpackJsName","REF_PROP","patchSerialize","cleaners","refs","refIndex","patchProperty","val","patched","addCleaner","cleaner","toJSON","serialized","patchDeserialize","matchedRef","createTransport","json","jsonDecodeFallback","factory","fastStringHash","bitsOrNumeric","jsonDecode","encrypt","decrypt","httpEncode","httpEncrypt","addEncryptionNegotiatedListener","dispatchEncryptionNegotiated","setStorageKey","errorLogger","logError","shift","id","addPageLoadedListener","dispatchPageLoaded","addPageVisibleListener","dispatchPageVisible","maybeDispatchPageLoaded","newLoaded","loaded","sleepTimer","maybeDispatchPageVisible","visible","visibilityState","visibleTimer","activated","activeTime","addPageActivatedListener","dispatchPageActivated","activationTimeout","setActivated","localVariableScope","anyVariableScope","isLocalScopeKey","toNumericVariableEnums","variableKeyToString","targetId","stringToVariableKey","localId","TAB_ID","nextId","nextLocalId","randomValues","crypto","getRandomValues","uuidv4","tabVariables","tabState","heartbeat","state","knownTabs","addStateListener","dispatchState","post","tryGetVariable","setLocalVariables","updateVariableState","timestamp","expires","updates","changes","sharedChanges","Tab","localState","sessionStorage","getItem","removeItem","padStart","View","log","setItem","localStorage","newValue","sender","initTimeout","HEARTBEAT_FREQUENCY","tabId","toggleTab","loading","addRequestHandler","dispatchRequest","addResponseHandler","dispatchResponse","requestLock","sharedLock","lockId","retries","defaultRetries","renew","renewTimer","localTimeout","waitHandle","pollPushCookie","cookie","pushExpectations","anticipatePushCookie","done","request","beacon","currentData","cancel","prepareRequestData","retry","prepareResult","newData","fetch","method","credentials","mode","headers","warn","responseText","navigator","sendBeacon","Blob","KEY_PROPS","VARIABLE_PROPS","GETTER_PROPS","activeCallbacks","createVariableStorage","endpoint","context","pollVariables","getters","callbacks","vars","VARIABLE_POLL_FREQUENCY","registerCallbacks","mappedKey","invokeCallbacks","poll","stateDuration","cacheDurations","updateCacheDuration","duration","requestGetters","getter","sourceIndex","newLocal","refresh","Success","local","Created","setResultExpiration","deviceSessionId","setters","requestVariables","patch","force","deltaDiff","previous","deltaValue","previousValue","createEventQueue","snapshots","sources","mapPatchTarget","sourceEvent","patchTargetId","clientId","events","flush","applyEventExtensions","unloading","updatedEvents","unbinding","postPatch","registerEventPatchSource","snapshot","intersectionHandler","createImpressionObserver","observer","IntersectionObserver","els","isIntersecting","boundingClientRect","intersectionRatio","threshold","components","component","cmp","track","impressions","secondary","inferred","fold","impressionEvents","unbindPassiveEventSources","trackImpression","createViewDurationTimer","intersecting","ratio","bottom","viewport","timeOffset","getViewTimeOffset","getComponentContext","relatedEventId","observe","detectDeviceType","screen","w","h","orientation","o","landscape","angle","deviceType","dpr","devicePixelRatio","postUserAgentEvent","hasTouch","maxTouchPoints","userAgent","languages","language","region","primary","preference","timezone","iana","Intl","DateTimeFormat","resolvedOptions","timeZone","getTimezoneOffset","isLinkElement","startsWith","isClickable","t","getCurrentViewId","referrerKey","pushNavigationSource","navigationEventId","consumed","totalDuration","visibleDuration","interactiveDuration","activations","getVisibleDuration","addViewChangedListener","dispatchViewChanged","totalTime","visibleTime","interactiveTime","activationsCounter","onFrame","callOnFrame","knownFrames","WeakSet","frames","getElementsByTagName","parseCartEventData","normalizeCartEventData","units","parseActivationTags","hasComponentOrContent","boundary","parseBoundaryTags","ancestor","stripRects","keep","directOnly","areaPath","collectedContent","includeState","promote","area","currentValue","defaultExtensions","setup","frame","currentView","previousHref","location","nextView","definition","localIndex","globalIndex","Shared","currentLocation","postView","tab","pathname","domain","tabIndex","firstTab","landingPage","qs","utm","navigationType","getEntriesByType","redirects","redirectCount","referrer","externalReferrer","history","processCommand","command","isChangeUserCommand","username","decorate","normalizeBoundaryData","registerComponent","cart","eventData","cmd","isDataBoundaryCommand","isScanComponentsCommand","scanAttributes","attributeName","references","commands","seen","querySelectorAll","stack","isNaN","next","nextElementSibling","parentNode","removeChild","scan","attribute","trackDocument","container","info","trackClicks","trackRegion","clickableElement","nav","clicks","contextCart","componentContext","sharedEventProperties","element","innerText","substring","timing","external","hostname","search","anchor","navigationEvent","self","button","ctrlKey","shiftKey","altKey","exit","contentDocument","emitted","initialScroll","scroll","scrollType","isCartCommand","isOrderCommand","order","formEvents","getFormFieldValue","selectedOptions","option","checked","getFormState","capturedContext","formElement","form","refName","isFormVisible","isConnected","fieldMap","fields","commitEvent","handleLostFocus","completed","commitTimeout","ref","field","label","labels","getFieldInfo","currentField","tv0","total","fillOrder","filled","corrections","lastField","wireFormFields","commandTest","isTagAttributesCommand","isToggleCommand","isExtensionCommand","isFlushCommand","isGetCommand","isListenerCommand","isSetCommand","isTrackerAvailableCommand","initializeTracker","config","queuedCommands","extensions","callListeners","unsubscribe","pendingStateCommands","trackerContext","insertArgs","skip","extension","mainArgs","currentArg","globalStateResolved","freeze","tagAttributes","disable","expanded","priority","success","_1","_2","session","hasUserAgent"],"mappings":"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","x_google_ignoreList":[38]}