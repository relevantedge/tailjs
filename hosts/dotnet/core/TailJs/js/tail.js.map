{"version":3,"file":"tail.js","sources":["../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/util/src/types.ts","../../../../../npm/packages/@tailjs/util/src/iterators.ts","../../../../../npm/packages/@tailjs/client/src/lib2/dom.ts","../../../../../npm/packages/@tailjs/util/src/accessors.ts","../../../../../npm/packages/@tailjs/client/src/lib2/time.ts","../../../../../npm/packages/@tailjs/client/src/lib2/concurrency.ts","../../../../../npm/packages/@tailjs/client/src/lib2/ids.ts","../../../../../npm/packages/@tailjs/client/src/lib2/events.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/base64.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/lfsr.ts","../../../../../npm/node_modules/.pnpm/@ygoe+msgpack@1.0.3/node_modules/@ygoe/msgpack/msgpack.js","../../../../../npm/packages/@tailjs/util/src/transport.pkg/transport.ts","../../../../../npm/packages/@tailjs/client/src/lib2/storage.ts","../../../../../npm/packages/@tailjs/client/src/lib2/consts.ts","../../../../../npm/packages/@tailjs/client/src/lib2/channel.ts","../../../../../npm/packages/@tailjs/client/src/lib2/shared-state.ts","../../../../../npm/packages/@tailjs/client/src/pusher.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["// MUST MATCH packages\\@tailjs\\engine\\src\\RequestHandler.ts\nexport const MUTEX_REQUEST_COOKIE = \".tail.rq\";\nexport const MUTEX_RESPONSE_COOKIE = \".tail.rs\";\nexport const CONTEXT_MENU_COOKIE = \".tail.cm\";\n\nexport const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_MENU_QUERY = \"mnt\";\n","import { toObject, type reduce, forEach, update, map } from \".\";\n\nexport type IsNever<T> = [T] extends [never] ? true : false;\n\n/**\n * Shorthand for a value that is optionally awaitable.\n */\nexport type MaybePromise<T> = PromiseLike<T> | T;\n\nexport type ValueOrDefault<T, R, D = undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? D\n  : R;\n\n/** Shorter than writing all this out, and slightly easier to read. */\nexport type Nullish = null | undefined;\n\n/**\n * Removes null'ish values from a union.\n */\nexport type OmitNullish<T> = T extends Nullish ? never : T;\n\n/**\n * Common function type used for projection of [key,value] entries.\n */\nexport type KeyValueProjection<K, V, R> = (\n  entry: [key: K, value: V],\n  index: number\n) => R;\n\n/**\n * Shorthand for a type that is inferred from a parameter and can either be the item in an iterable, or just the type itself.\n */\nexport type IterableOrSelf<T> = IterableOrArrayLike<T> | T;\n\ntype FunctionComparisonEqualsWrapped<T> = T extends (\n  T extends {} ? infer R & {} : infer R\n)\n  ? { [P in keyof R]: R[P] }\n  : never;\n\ntype FunctionComparisonEquals<A, B> = (<\n  T\n>() => T extends FunctionComparisonEqualsWrapped<A> ? 1 : 2) extends <\n  T\n>() => T extends FunctionComparisonEqualsWrapped<B> ? 1 : 2\n  ? true\n  : false;\n\n/**\n * Tests if a type is `any`. The test used is technically impossable to succeed unless the type is in fact `any`.\n */\nexport type IsAny<T> = FunctionComparisonEquals<T, any>;\n\n/**\n * Utility type to allow `as const` to be used on tuples returned from functions without actually making them `readonly` (which is annoying).\n * Normally TypeScript considers the return value of a function like `x=>[10,\"four\"]` to be `(string|number)[]` (which is also annoying).\n */\nexport type ConstToTuples<T> = T extends readonly any[]\n  ? { -readonly [P in keyof T]: ConstToTuples<T[P]> }\n  : Voidefined<T>;\n\n/**\n * Goes with {@link Nulls} to simplify the expression.\n */\nexport type ArgNulls<T, Arg> = (T | Nullish) & Arg;\n\n/**\n *  TypeScript may be very literal when it infers types. The type fo a function parameter with the value `10` may be inferred as `10` and not `number`.\n *  This is an issue in e.g. {@link reduce}.\n */\nexport type GeneralizeContstants<T> = T extends number\n  ? number\n  : T extends string\n  ? string\n  : T extends boolean\n  ? boolean\n  : unknown extends T\n  ? unknown\n  : {\n      [P in keyof T]: GeneralizeContstants<T[P]>;\n    };\n\n/**\n * The eclectic type found everywhere on the Internet.\n * It convers a union like `{a:1}|{b:2}` to the intersection `{a:1, b:2}`\n */\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never;\n\n/**\n * Makes a union of objects like `{a:1}&{b:2}` appear as `{a:1,b:2}` in intellisense.\n */\nexport type PrettifyIntersection<T> = T extends { [P in infer K]: any }\n  ? { [P in K]: T[P] }\n  : never;\n\n/**\n * Makes an array of key/value pairs to an object with the corresponding properties.\n */\nexport type KeyValuePairsToObject<T> = UnionToIntersection<\n  T extends readonly [infer K & keyof any, infer V]\n    ? { [P in K & keyof any]: V }\n    : ((value: T) => never) extends (\n        value: [infer K & keyof any, infer V]\n      ) => never\n    ? { [P in K & keyof any]: ConstToTuples<V> }\n    : unknown\n>;\n\n/**\n * Anything but a function.\n */\nexport type NotFunction =\n  | bigint\n  | boolean\n  | null\n  | number\n  | string\n  | symbol\n  | undefined\n  | {\n      [key: string | number | symbol]: any;\n      [Symbol.hasInstance]?: never;\n    };\n\n/**\n * Trick for having a function that returns a non-null value, if a formal paramter always has a non-null value,\n * simliar to .NET's [NotNullIfNotNull].\n *\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\n/**\n * Typescript has the distinction between `void` and `undefined`.\n * I'm sure there is a theorically sound explanation. Both that and the distinction are annoying so this little utility type maps `void` to `undefined`.\n *\n * The ampersand union trick makes TypeScript relax instead of the \"The type T could be instantiated etc...\" error.\n */\nexport type Voidefined<T> = T extends void ? T & undefined : T;\n\n/**\n * An extension to T[] and Iterable<T> that also correctly captures weird things like NodeListOf<T>\n */\nexport type IterableOrArrayLike<T> =\n  | Iterable<T>\n  | { [item: number]: T; length: number };\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = (value: any, parse?: boolean) => T | undefined;\n\nexport const undefined = void 0;\nexport const nil = null;\n\nconst createConverter =\n  <T>(typeTester: TypeTester<T>, parser?: (value: any) => T | undefined) =>\n  (value: any, parse = true) =>\n    typeTester(value)\n      ? value\n      : parser && parse && isDefined((value = parser(value)))\n      ? value\n      : undefined;\n\nexport const tryCatch = <T, C = undefined>(\n  expression: () => T,\n  errorHandler: boolean | ((error: any) => C) = true as any,\n  clean?: () => void\n): T | C => {\n  try {\n    return expression();\n  } catch (e) {\n    if (!isBoolean(errorHandler)) {\n      return errorHandler?.(e) as any;\n    }\n    if (errorHandler) {\n      throw e;\n    }\n    console.error(e);\n    return undefined as any;\n  } finally {\n    clean?.();\n  }\n};\n\nexport const tryCatchAsync = async <T, C = undefined>(\n  expression: () => PromiseLike<T> | T,\n  errorHandler: boolean | ((error: any) => Promise<C> | C) = true as any,\n  clean?: () => void\n): Promise<T | C> => {\n  try {\n    return await expression();\n  } catch (e) {\n    if (!isBoolean(errorHandler)) {\n      return (await errorHandler(e)) as any;\n    }\n    if (errorHandler) {\n      throw e;\n    }\n    console.error(e);\n    return undefined as any;\n  } finally {\n    clean?.();\n  }\n};\n\nexport const as = <T, D = undefined, Args extends any[] = []>(\n  value: any,\n  converter: (value: any, ...rest: Args) => T | undefined,\n  defaultValue?: D,\n  ...args: Args\n): T | D => ((value = converter(value, ...args)) ?? defaultValue) as any;\n\nexport const cast = <T, V, Args extends any[] = []>(\n  value: V,\n  typeTest: (value: any, ...args: Args) => value is T,\n  ...args: Args\n): V extends T ? V : undefined =>\n  typeTest(value, ...args) ? (value as any) : undefined;\n\nexport const isNull = (value: any): value is null => value === nil;\n\nexport const isUndefined = (value: any): value is undefined | void =>\n  value === undefined;\n\nexport const isDefined = <T>(value: T): value is Exclude<T, undefined | void> =>\n  value !== undefined;\n\nexport const isNullish = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value == nil;\n\nexport const hasValue = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value != nil;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\n\nexport const parseBoolean = createConverter(isBoolean, (value) => !!value);\nexport const isTruish = (value: any) => !!value;\nexport const isFalsish = (value: any) => !value;\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\nexport const parseNumber = createConverter(isNumber, (value) =>\n  parseFloat(value)\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\nexport const parseBigInt = createConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createConverter(isString, (value) =>\n  hasValue(value) ? \"\" + value : value\n);\n\nconst capturedIsArray = Array.isArray;\nexport const isArray = (value: any): value is any[] => capturedIsArray(value);\n\nexport const toArray = <T>(value: T | Iterable<T>, clone = false): T[] =>\n  value == null\n    ? []\n    : !clone && isArray(value)\n    ? value\n    : isIterable(value, true)\n    ? [...value]\n    : ([value] as any);\n\nexport const isObject = (\n  value: any,\n  acceptIterables = false\n): value is { [P in keyof any]: any } =>\n  value && typeof value === \"object\" && (acceptIterables || !isIterable(value));\n\nexport const hasMethod = <T, Name extends keyof any>(\n  value: T,\n  name: Name | keyof T\n): value is T &\n  Record<\n    Name,\n    T extends { [P in Name]?: (...args: infer Args) => infer R }\n      ? (...args: Args) => R\n      : (...args: any) => any\n  > => typeof (value as any)?.[name] === \"function\";\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\n\nexport const isIterable = (\n  value: any,\n  acceptStrings = false\n): value is Iterable<any> =>\n  !!value?.[Symbol.iterator] && (acceptStrings || !isString(value));\n\nexport const toIterable = <T>(value: T | Iterable<T>): Iterable<T> =>\n  isIterable(value) ? value : [value];\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == nil\n    ? value === nil\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\nexport const identity = <T = any>(value: T) => value;\n\nexport const clone = <T>(value: T, deep = true): T =>\n  isArray(value)\n    ? deep\n      ? (map as any)(value, (value: any) => clone(value, true))\n      : [...value]\n    : isObject(value)\n    ? deep\n      ? toObject(map(value as any, ([k, v]) => [k, clone(v, true)]))\n      : { ...value }\n    : isSet(value)\n    ? new Set<any>(\n        (map as any)(value, (value: any) => (deep ? clone(value, true) : value))\n      )\n    : isMap(value)\n    ? new Map<any, any>(\n        (map as any)(value, (value: any) =>\n          // Does not clone keys.\n          deep ? [value[0], clone(value[1], true)] : value\n        )\n      )\n    : (value as any);\n\ntype CaptureCallback<Args extends any[], R> = (\n  ...args: [...args: Args, self: CaptureCallback<Args, R>]\n) => R;\n\n/**\n * Evaluates a function that can be used to capture values using parameter default values.\n *\n * For example `(previous=current)=>(current+=2, previous)\n */\nexport const capture = <R>(capture: (...args: any[]) => R) => capture();\n","import {\n  ConstToTuples,\n  GeneralizeContstants,\n  IsAny,\n  KeyValuePairsToObject,\n  hasMethod,\n  hasValue,\n  isArray,\n  isDefined,\n  isFalsish,\n  isFunction,\n  isIterable,\n  isObject,\n  isTruish,\n  toArray,\n} from \".\";\n\nexport const UTF16MAX = 0xffff;\n\nexport const toCharCodes = (s: string) =>\n  [...new Array(s.length)].map((_, i) => s.charCodeAt(i));\nexport const codePoint = (string: string, index: number = 0) =>\n  string.codePointAt(index)!;\n\nexport type IteratorSource =\n  | any\n  | null\n  | undefined\n  | number\n  | Iterable<any>\n  | { [P in keyof any]: any }\n  | NavigatingIteratorStep;\n\nexport type IteratorSourceOf<T> =\n  | (T extends number ? number : never)\n  | Iterable<T>\n  | (T extends [infer K, infer V]\n      ? K extends keyof any\n        ? { [P in K]: V }\n        : never\n      : never)\n  | NavigatingIteratorStep<T>;\n\ntype IteratorItem<S extends IteratorSource> = IsAny<S> extends true\n  ? any\n  : S extends number\n  ? number\n  : S extends Record<any, any> & { [Symbol.iterator]?: never }\n  ? S extends (...args: any) => infer T | undefined\n    ? T\n    : [keyof S, S[keyof S]]\n  : S extends Iterable<infer T>\n  ? T extends string\n    ? string\n    : T\n  : never;\n\nexport interface IteratorControl<S extends IteratorSource> {\n  source: S;\n  prev: IteratorItem<S> | undefined;\n  skip(): void;\n  end(): void;\n  end<P>(value: P): P;\n}\n\nexport type IteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = IteratorItem<S>\n> = (\n  value: IteratorItem<S>,\n  index: number,\n  control: IteratorControl<S>\n) => Projection | undefined | void;\n\ntype AnyTuple = [any, ...any[]];\n\ntype IteratorProjection<\n  S extends IteratorSource,\n  Projection,\n  TupleProjection extends AnyTuple\n> = unknown extends Projection\n  ? IteratorItem<S>\n  : TupleProjection extends Projection\n  ? ConstToTuples<TupleProjection>\n  : ConstToTuples<Projection>;\n\ntype StartEndArgs<S extends IteratorSource> = S extends number\n  ? [offset?: number]\n  : S extends NavigatingIteratorStep<infer T>\n  ? [offset?: T, maxIterations?: number]\n  : [start?: number, end?: number];\n\nexport type NavigatingIteratorStep<T = any> = (\n  current: T | undefined\n) => T | undefined;\n\nfunction* createRangeIterator(length = 0, offset = 0): Iterable<number> {\n  while (length--) yield offset++;\n}\n\nexport function* createStringIterator(\n  input: string,\n  start: number,\n  end: number\n): Iterable<[char: string, codePoint: number]> {\n  while (start < end) {\n    const codePoint = input.codePointAt(start)!;\n    let p = input[start++];\n    if (codePoint > UTF16MAX) {\n      start++;\n      p = String.fromCodePoint(codePoint);\n    }\n    yield [p, codePoint];\n  }\n}\n\nexport function* createNavigatingIterator<T>(\n  step: NavigatingIteratorStep<T>,\n  start?: T | undefined,\n  maxIterations = Number.MAX_SAFE_INTEGER\n): Iterator<T> {\n  if (isDefined(start)) yield start;\n  while (maxIterations-- && isDefined((start = step(start)))) {\n    yield start;\n  }\n}\n\nconst sliceIterator = <T>(\n  source: Iterable<T>,\n  start = 0,\n  end?: number\n): Iterable<T> => {\n  if (!start && !isDefined(end)) {\n    return source;\n  }\n\n  if (source[\"slice\"]) {\n    return source[\"slice\"](start, end);\n  } else if (start < 0 || (end as any) < 0) {\n    return sliceIterator([...source], start, end);\n  }\n\n  return (function* () {\n    end ??= Number.MAX_SAFE_INTEGER;\n\n    for (const item of source) {\n      if (start--) continue;\n      if (!end--) break;\n      yield item;\n    }\n  })();\n};\n\nexport type Filter<S extends IteratorSource> = (\n  value: IteratorItem<S>,\n  index: number\n) => any;\n\nconst filterIterator = <T>(\n  source: Iterable<T>,\n  filter: (item: T, index: number) => any\n): Iterable<T> => {\n  if (isArray(source)) return source.filter(filter);\n  return (function* () {\n    let i = 0;\n    for (const item of source) {\n      if (filter(item, i++)) {\n        yield item;\n      }\n    }\n  })();\n};\n\nconst enum IterationFlag {\n  Yield = 0,\n  Skip = 1,\n  YieldThenEnd = 2,\n  End = 3,\n}\n\nfunction* createControllableIterator<\n  S extends Iterable<any>,\n  P = IteratorItem<S>\n>(\n  source: S,\n  action: IteratorAction<S, P> = (item) => item as any,\n  collect?: (result: P) => void\n) {\n  let i = 0;\n  let flag = IterationFlag.Yield;\n  let result: P | undefined;\n  const control: IteratorControl<S> = {\n    prev: undefined,\n    source,\n    skip: () => (flag = IterationFlag.Skip),\n    end: (value?: any) => (\n      (flag = isDefined(value)\n        ? IterationFlag.YieldThenEnd\n        : IterationFlag.End),\n      value\n    ),\n  };\n\n  for (const item of source) {\n    if ((result = action(item, i++, control)!) !== undefined && !(flag % 2)) {\n      if (!collect) {\n        yield result;\n      } else {\n        collect(result);\n      }\n      control.prev = item;\n    }\n    if (flag > 1) {\n      break;\n    }\n    flag = IterationFlag.Yield;\n  }\n}\n\nconst mapIterator = <S extends IteratorSource>(\n  source: S,\n  start?: any,\n  end?: any\n) => {\n  if (isIterable(source, true)) {\n    return start || end\n      ? sliceIterator(mapIterator(source), start, end)\n      : source;\n  }\n  if (!isDefined(source)) return [];\n  if (isObject(source)) return mapIterator(Object.entries(source), start, end);\n  if (isFunction(source)) return createNavigatingIterator(source, start, end);\n  return createRangeIterator(source as number, start);\n};\n\nexport const project: {\n  <S extends IteratorSource, R, RT extends AnyTuple>(\n    source: S,\n    projection?: IteratorAction<S, R | RT> | null,\n    ...rest: StartEndArgs<S>\n  ): IteratorProjection<S, R, RT>[];\n} = (source, projection, ...rest) => {\n  return createControllableIterator(\n    mapIterator(source, ...rest),\n    projection as any\n  ) as any;\n};\n\nexport function* flatProject<S extends IteratorSource, R, RT extends AnyTuple>(\n  source: S,\n  projection?: IteratorAction<S, R | RT> | null,\n  ...rest: StartEndArgs<S>\n): Iterable<FlatIteratorItem<IteratorProjection<S, R, RT>>> {\n  for (const item of project(\n    mapIterator(source, ...(rest as any)),\n    projection as any\n  )) {\n    if (isIterable(item)) {\n      yield* item;\n    } else if (isObject(item)) {\n      yield* Object.entries(item) as any;\n    } else {\n      yield item;\n    }\n  }\n}\n\nexport const map: {\n  <S extends IteratorSource, R, RT extends AnyTuple>(\n    source: S,\n    projection?: IteratorAction<S, R | RT> | null,\n    ...rest: StartEndArgs<S>\n  ): IteratorProjection<S, R, RT>[];\n  <S extends IteratorSource, R, RT extends AnyTuple>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): IteratorProjection<S, R, RT>[];\n} = ((source: any, projection: any, ...rest: any[]) => {\n  if (!isFunction(projection) && hasValue(projection)) {\n    // The \"projection\" parameter is the start index.\n    rest.unshift(projection);\n    projection = null;\n  }\n  source = mapIterator(source, ...rest);\n  return projection\n    ? projection.length < 3 && hasMethod(source, \"map\")\n      ? source[\"map\"](projection).filter(isDefined)\n      : [...createControllableIterator(source as any, projection)]\n    : (toArray(source, true) as any);\n}) as any;\n\ntype FlatIteratorItem<S extends IteratorSource> =\n  IteratorItem<S> extends Iterable<infer T>\n    ? T\n    : IteratorItem<S> extends Record<infer K, infer V>\n    ? [K, V]\n    : IteratorItem<S>;\n\nexport const flatMap = <\n  S extends IteratorSourceOf<any | Iterable<any>>,\n  R,\n  RT extends AnyTuple\n>(\n  source: S,\n  action: IteratorAction<S, R> = (item) => item as any,\n  ...rest: StartEndArgs<S>\n): FlatIteratorItem<IteratorProjection<S, R, RT>>[] =>\n  map(flatProject(source, action, ...rest)) as any;\n\nexport const forEach = <S extends IteratorSource, R>(\n  source: S,\n  action: IteratorAction<S, R>,\n  ...rest: StartEndArgs<S>\n): R | undefined => {\n  let returnValue: R | undefined = undefined;\n  let innerReturnValue: any;\n  source = mapIterator(source, ...rest);\n  if (action.length < 3 && hasMethod(source, \"forEach\")) {\n    source.forEach(\n      (item: any, index: any) =>\n        isDefined((innerReturnValue = (action as any)(item, index))) &&\n        (returnValue = innerReturnValue)\n    );\n  } else {\n    for (const _ of createControllableIterator(\n      source as any,\n      action as any,\n      (value) => (returnValue = value as any)\n    ));\n  }\n  return returnValue;\n};\n\nexport const flatForEach = <S extends IteratorSourceOf<any | Iterable<any>>, R>(\n  source: S,\n  action: IteratorAction<FlatIteratorItem<S>, R>,\n  ...rest: StartEndArgs<S>\n): R | undefined =>\n  forEach(\n    flatProject(source, undefined, ...(rest as any)),\n    action as any\n  ) as any;\n\nexport const toObject: {\n  <S extends IteratorSourceOf<[keyof any, any]>>(\n    source: S,\n    selector?: null,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<S>;\n  <S extends IteratorSource, P extends [keyof any, any]>(\n    source: S,\n    selector: IteratorAction<S, P>,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<P[]>;\n} = (source: any, selector: any, ...rest: any[]) =>\n  Object.fromEntries((map as any)(source, selector, ...rest));\n\nexport const reduce = <\n  S extends IteratorSource,\n  Reducer extends (\n    ...args: [\n      accumulator: unknown extends Accumulator\n        ? any\n        : GeneralizeContstants<Accumulator>,\n      ...rest: Parameters<IteratorAction<S, Accumulator>>\n    ]\n  ) => GeneralizeContstants<Accumulator>,\n  Accumulator\n>(\n  source: S,\n  reducer: Reducer,\n  seed?: Accumulator,\n  ...rest: StartEndArgs<S>\n): Reducer extends (...args: any) => infer R\n  ? R | (unknown extends Accumulator ? undefined : never)\n  : never =>\n  forEach(\n    source,\n    (value, index, control) =>\n      (seed =\n        (reducer(seed as any, value, index, control as any) as any) ?? seed),\n    ...rest\n  ) ?? (seed as any);\n\nexport const filter = <\n  S extends IteratorSource,\n  MapToArray extends boolean = false\n>(\n  source: S,\n  filter: Filter<S> = isTruish,\n  map?: MapToArray,\n  ...rest: StartEndArgs<S>\n): S extends any[] | null | undefined | (MapToArray extends true ? any : never)\n  ? IteratorItem<S>[]\n  : Iterable<IteratorItem<S>> =>\n  map\n    ? toArray((filter as any)(source, filter, false, ...rest))\n    : (filterIterator(mapIterator(source, ...rest) as any, filter) as any);\n\nlet filterInternal = filter;\n\nexport const count = <S extends IteratorSource>(\n  source: S,\n  filter?: Filter<S> | null,\n  ...rest: StartEndArgs<S>\n): number => {\n  if (filter) {\n    source = filterInternal(source, filter, false, ...rest) as any;\n  } else {\n    source = mapIterator(source, ...rest);\n  }\n  let n = source![\"length\"] ?? source![\"size\"];\n  return isDefined(n) ? n : reduce(source, (n) => n + 1, 0, ...rest);\n};\n\nexport const sum: {\n  <S extends IteratorSourceOf<number>>(\n    source: S,\n    selector?: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n  <S extends IteratorSource>(\n    source: S,\n    selector: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n} = (source: any, selector: any = (item: any) => item, ...rest: any) =>\n  reduce(\n    source,\n    (sum, value, index, control) =>\n      sum + (selector(value, index, control) ?? 0),\n    0,\n    ...rest\n  );\n\nexport const some = <S extends IteratorSource>(\n  source: S,\n  filter?: Filter<S> | null,\n  ...rest: StartEndArgs<S>\n) =>\n  hasMethod(source, \"some\")\n    ? source.some(\n        filter ? (item: any, index: number) => filter(item, index) : isTruish\n      )\n    : filter\n    ? some(filterInternal(source as any, filter, false, ...rest))\n    : forEach<any, boolean>(source, (item, index, { end }) => end(true)) ??\n      false;\n\nexport const every = <S extends IteratorSource>(\n  source: S,\n  filter?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) =>\n  !some(\n    source,\n    filter ? (item, index) => !filter(item, index) : isFalsish,\n    ...rest\n  );\n","import { isArray, map } from \"@tailjs/util\";\r\nimport {\r\n  Binders,\r\n  Listener,\r\n  Unbinder,\r\n  createBinders,\r\n  createEvent,\r\n  mergeBinders,\r\n} from \".\";\r\n\r\ntype PageListenerArgs = [visible: boolean, loaded: boolean];\r\nconst [addListener, dispatch] = createEvent<PageListenerArgs>();\r\n\r\ntype AllMaps = WindowEventMap &\r\n  GlobalEventHandlersEventMap &\r\n  DocumentEventMap &\r\n  HTMLElementEventMap;\r\n\r\nexport const listen = <K extends keyof AllMaps>(\r\n  target: {\r\n    addEventListener(\r\n      type: string,\r\n      listener: EventListenerOrEventListenerObject,\r\n      options?: boolean | AddEventListenerOptions\r\n    ): void;\r\n    removeEventListener(\r\n      type: string,\r\n      listener: EventListenerOrEventListenerObject,\r\n      options?: boolean | EventListenerOptions\r\n    ): void;\r\n  },\r\n  name: K | K[],\r\n  listener: (\r\n    ev: AllMaps[K extends any[] ? K[number] : K],\r\n    unbind?: Unbinder\r\n  ) => any,\r\n  options: AddEventListenerOptions = { capture: true, passive: true }\r\n): Binders => {\r\n  return isArray(name)\r\n    ? mergeBinders(\r\n        ...map(name, (name) => listen(target, name as any, listener, options))\r\n      )\r\n    : createBinders(\r\n        listener,\r\n        (listener) => target.addEventListener(name, listener, options),\r\n        (listener) => target.addEventListener(name, listener, options)\r\n      );\r\n};\r\n\r\nlet binders: ReturnType<typeof addListener>;\r\nexport const addPageListener = (\r\n  listener: Listener<PageListenerArgs>,\r\n  triggerLoaded = true\r\n) => (\r\n  (binders = addListener(listener)),\r\n  loaded && triggerLoaded && listener(visible, false, binders[0]),\r\n  binders\r\n);\r\n\r\nlet visible = true;\r\nlet loaded = false;\r\n\r\nconst dispatchVisible = () =>\r\n  (!loaded || !visible) &&\r\n  dispatch((visible = true), loaded || !(loaded = true));\r\n\r\nlisten(\r\n  window,\r\n  \"pagehide\",\r\n  () => (visible || loaded) && dispatch((visible = false), (loaded = false))\r\n);\r\nlisten(window, \"pageshow\", dispatchVisible);\r\nlisten(document, \"visibilitychange\", () =>\r\n  document.visibilityState === \"visible\"\r\n    ? dispatchVisible()\r\n    : visible && dispatch((visible = false), loaded)\r\n);\r\n","import {\r\n  GeneralizeContstants,\r\n  IsAny,\r\n  KeyValuePairsToObject,\r\n  NotFunction,\r\n  forEach,\r\n  hasMethod,\r\n  isArray,\r\n  isDefined,\r\n  isFunction,\r\n  isObject,\r\n  isUndefined,\r\n} from \".\";\r\n\r\n// #region Shared types\r\ntype MapLike<K = any, V = any> = {\r\n  has?(key: K): boolean;\r\n  get(key: K): V | undefined;\r\n  set(key: K, value: V): any;\r\n  delete(key: K): any;\r\n};\r\n\r\ntype SetLike<K = any> = {\r\n  has?(key: K): boolean;\r\n  add(key: K): any;\r\n  delete(key: K): any;\r\n};\r\n\r\ntype PropertyContainer<K extends any = any, V extends any = any> =\r\n  | {\r\n      [P in keyof K]: V;\r\n    }\r\n  | MapLike<K, V>\r\n  | SetLike<K>;\r\n\r\nexport type KeyType<T extends PropertyContainer> = T extends MapLike<\r\n  infer K,\r\n  any\r\n>\r\n  ? K\r\n  : T extends SetLike<infer K>\r\n  ? K\r\n  : T extends any[]\r\n  ? number\r\n  : keyof T;\r\n\r\nexport type ValueType<\r\n  T extends PropertyContainer,\r\n  K,\r\n  Default = never\r\n> = IsAny<T> extends true\r\n  ? any\r\n  : T extends MapLike<any, infer V>\r\n  ? V | Default\r\n  : T extends SetLike\r\n  ? boolean | Default\r\n  : T extends (infer T)[]\r\n  ? T | Default\r\n  : K extends keyof T\r\n  ? T[K] | Default\r\n  : any;\r\n\r\n// #endregion\r\n\r\n// #region get\r\n\r\nexport const get = <T extends PropertyContainer, K extends KeyType<T>>(\r\n  target: T,\r\n  key: K,\r\n  initializer?: Updater<T, K, ValueType<T, K>, false, true>\r\n): ValueType<T, K, undefined> => {\r\n  let value = hasMethod(target, \"get\")\r\n    ? target.get(key)\r\n    : hasMethod(target, \"has\")\r\n    ? target.has(key)\r\n    : (target as any)[key];\r\n  if (!isDefined(value) && isDefined(initializer)) {\r\n    isDefined(\r\n      (value = isFunction(initializer) ? (initializer as any)() : initializer)\r\n    ) && set(target, key, value);\r\n  }\r\n  return value;\r\n};\r\n\r\n// #endregion\r\n\r\n// #region set and update\r\n\r\ntype UpdateFunction<\r\n  T extends PropertyContainer,\r\n  Key,\r\n  Current,\r\n  Factory\r\n> = Factory extends false\r\n  ? (\r\n      current: Current,\r\n      key: Key,\r\n      target: T\r\n    ) => GeneralizeContstants<ValueType<T, Key>> | undefined\r\n  : (key: Key, target: T) => GeneralizeContstants<ValueType<T, Key>>;\r\n\r\ntype Updater<\r\n  T extends PropertyContainer,\r\n  Key,\r\n  Current = ValueType<T, Key>,\r\n  SettersOnly = false,\r\n  Factory = false\r\n> = SettersOnly extends true\r\n  ? ValueType<T, Key, Factory extends true ? never : undefined>\r\n  : IsAny<T> extends true\r\n  ? NotFunction | UpdateFunction<any, any, any, Factory>\r\n  :\r\n      | (ValueType<T, Key> extends Function\r\n          ? never\r\n          : ValueType<T, Key, Factory extends true ? never : undefined>)\r\n      | UpdateFunction<T, Key, Current, Factory>;\r\n\r\ntype UpdaterType<T, SettersOnly = false> = SettersOnly extends true\r\n  ? T\r\n  : T extends (...args: any) => infer T\r\n  ? T\r\n  : T;\r\n\r\ntype PropertiesToTuples<T, SettersOnly = false, K = keyof T> = K extends any\r\n  ? [K, UpdaterType<T, SettersOnly>]\r\n  : never;\r\n\r\ntype BulkUpdateObject<\r\n  T extends PropertyContainer,\r\n  SettersOnly = false,\r\n  Factory = false\r\n> = T extends MapLike | SetLike | any[]\r\n  ? {\r\n      [P in KeyType<T>]: Updater<T, P, ValueType<T, P>, SettersOnly, Factory>;\r\n    }\r\n  : { [P in keyof T & KeyType<T>]?: Updater<T, P, T[P], SettersOnly, Factory> };\r\n\r\ntype BulkUpdateKeyValue<\r\n  T extends PropertyContainer,\r\n  SettersOnly = false,\r\n  Factory = false,\r\n  K extends keyof T = keyof T\r\n> = IsAny<T> extends true\r\n  ? [any, Updater<T, any, any, SettersOnly, Factory>]\r\n  : T extends MapLike | SetLike | any[]\r\n  ? [\r\n      KeyType<T>,\r\n      Updater<T, KeyType<T>, ValueType<T, KeyType<T>>, SettersOnly, Factory>\r\n    ]\r\n  : K extends any\r\n  ? [K, Updater<T, KeyType<T>, any, SettersOnly, Factory>]\r\n  : never;\r\n\r\ntype BulkUpdates<\r\n  T extends PropertyContainer,\r\n  SettersOnly = false,\r\n  Factory = false\r\n> =\r\n  | BulkUpdateObject<T, SettersOnly, Factory>\r\n  | Iterable<\r\n      | BulkUpdateKeyValue<T, SettersOnly, Factory>\r\n      | BulkUpdateObject<T, SettersOnly, Factory>\r\n    >;\r\n\r\ntype UnwrapBulkUpdates<T, SettersOnly = false> = T extends (infer T)[]\r\n  ? T extends [infer K, infer V]\r\n    ? [K, UpdaterType<V, SettersOnly>]\r\n    : PropertiesToTuples<T, SettersOnly>\r\n  : PropertiesToTuples<T>;\r\n\r\ntype SetOrUpdateFunction<SettersOnly> = {\r\n  <\r\n    T extends PropertyContainer,\r\n    U extends Updater<T, K, ValueType<T, K>, SettersOnly>,\r\n    K extends KeyType<T>\r\n  >(\r\n    target: T,\r\n    key: K,\r\n    value: U\r\n  ): UpdaterType<U>; //  UpdaterType<U, SettersOnly>;\r\n  <T extends PropertyContainer>(\r\n    target: T,\r\n    values: BulkUpdates<T, SettersOnly>\r\n  ): T;\r\n};\r\n\r\nconst createSetOrUpdateFunction =\r\n  <B extends boolean>(settersOnly: B): SetOrUpdateFunction<B> =>\r\n  (target: PropertyContainer, ...args: any[]) => {\r\n    let bulk: boolean;\r\n    let [key, value] = args;\r\n    const setSingle = ([key, value]: [any, any]) => {\r\n      if (!settersOnly && isFunction(value)) {\r\n        value = value(get(target, key));\r\n      }\r\n\r\n      if (isUndefined(value)) {\r\n        return clear(target, key);\r\n      }\r\n\r\n      if (bulk || get(target, key) !== value) {\r\n        hasMethod(target, \"set\")\r\n          ? target.set(key, value)\r\n          : hasMethod(target, \"add\")\r\n          ? value\r\n            ? target.add(key)\r\n            : target.delete(key)\r\n          : (target[key] = value);\r\n      }\r\n\r\n      return value;\r\n    };\r\n\r\n    if ((bulk = args.length === 1)) {\r\n      // Fast path\r\n      if (settersOnly) {\r\n        if (isArray(key) && key.every((item) => isObject(item))) {\r\n          key = Object.assign({}, ...key);\r\n        }\r\n        if (isObject(key)) {\r\n          Object.assign(target, key);\r\n          Object.entries(key).forEach(\r\n            ([k, v]) => !isDefined(v) && delete target[k]\r\n          );\r\n          return target;\r\n        }\r\n      }\r\n      if (isObject(key)) {\r\n        forEach(key, setSingle);\r\n      } else {\r\n        forEach(key, (item) =>\r\n          isObject(item) ? forEach(item, setSingle) : setSingle(item)\r\n        );\r\n      }\r\n      return target;\r\n    }\r\n    return setSingle([key, value]);\r\n  };\r\n\r\nexport const set = createSetOrUpdateFunction(true);\r\nexport const update = createSetOrUpdateFunction(false);\r\n\r\n// #endregion\r\n\r\nexport const add = <T extends PropertyContainer<any, boolean>>(\r\n  target: T,\r\n  key: KeyType<T>\r\n) => get(target, key) !== set(target, key, true as any);\r\n\r\nexport const has = <T extends PropertyContainer>(target: T, key: KeyType<T>) =>\r\n  hasMethod(target, \"has\")\r\n    ? target.has(key)\r\n    : isDefined((target as any).get?.(key) ?? (target as any)[key]);\r\n\r\nexport const clear: {\r\n  <T extends PropertyContainer>(target: T, key: KeyType<T>): ValueType<\r\n    T,\r\n    KeyType<T>,\r\n    true\r\n  >;\r\n  <T extends PropertyContainer>(target: T, ...keys: KeyType<T>[]): ValueType<\r\n    T,\r\n    KeyType<T>,\r\n    true\r\n  >[];\r\n} = (target: PropertyContainer, key: any, ...keys: any[]) => {\r\n  if (keys.length) {\r\n    return keys.map((key) => clear(target, key));\r\n  }\r\n\r\n  const current = get(target, key);\r\n  hasMethod(target, \"delete\")\r\n    ? target.delete(key)\r\n    : isArray(target)\r\n    ? target.splice(key, 1)\r\n    : delete target[key];\r\n\r\n  return current;\r\n};\r\n","import { isNumber, tryCatchAsync } from \"@tailjs/util\";\r\nimport { MaybePromise, promise } from \".\";\r\n\r\nexport const now = () => Math.trunc(performance.timeOrigin + performance.now());\r\nexport type CancelableCallback = () => MaybePromise<void | boolean>;\r\n\r\nexport interface Clock {\r\n  readonly active: boolean;\r\n  readonly busy: boolean;\r\n  restart(callback?: CancelableCallback, frequency?: number): Clock;\r\n  toggle(start: boolean, trigger?: boolean): Clock;\r\n  trigger(skipQueue?: boolean): Promise<boolean>;\r\n}\r\n\r\nexport interface ClockSettings {\r\n  frequency?: number;\r\n  queue?: boolean;\r\n  paused?: boolean;\r\n}\r\n\r\ntype ClockSettingsParameter = ClockSettings & { frequency: number };\r\n\r\nexport const clock: {\r\n  (callback: CancelableCallback, frequency: number): Clock;\r\n  (callback: CancelableCallback, settings: ClockSettingsParameter): Clock;\r\n} = (\r\n  callback: CancelableCallback,\r\n  settings: number | ClockSettingsParameter\r\n): Clock => {\r\n  let {\r\n    queue = true,\r\n    paused = false,\r\n    frequency,\r\n  } = isNumber(settings) ? { frequency: settings } : settings;\r\n\r\n  let timeoutId = 0;\r\n  const mutex = promise().resolve();\r\n\r\n  const outerCallback = async (skipQueue?: boolean) => {\r\n    if (!timeoutId || (!queue && !mutex.resolved && skipQueue !== true)) {\r\n      return false;\r\n    }\r\n    (instance as any).busy = true;\r\n    if (skipQueue !== true) {\r\n      await mutex;\r\n    }\r\n\r\n    mutex.reset();\r\n    ((await tryCatchAsync(callback, false, () => mutex.resolve())) === false ||\r\n      frequency < 0) &&\r\n      reset(true);\r\n\r\n    (instance as any).busy = false;\r\n    return true;\r\n  };\r\n\r\n  const reset = (start: boolean) => {\r\n    clearInterval(timeoutId);\r\n    (instance as any).active = !!(timeoutId = start\r\n      ? setInterval(outerCallback, frequency < 0 ? -frequency : frequency)\r\n      : 0);\r\n    return instance;\r\n  };\r\n\r\n  const instance: Clock = {\r\n    active: false,\r\n    busy: false,\r\n    restart: (newCallback, newFrequency) => {\r\n      callback = newCallback ?? callback;\r\n      frequency = newFrequency ?? frequency;\r\n      return newCallback || newFrequency || !timeoutId ? reset(true) : instance;\r\n    },\r\n    toggle: (start, trigger) =>\r\n      start !== instance.active\r\n        ? start\r\n          ? trigger\r\n            ? (instance.trigger(), instance)\r\n            : reset(true)\r\n          : reset(false)\r\n        : instance,\r\n    trigger: async (skipQueue) =>\r\n      (await outerCallback(skipQueue)) && (reset(true), true),\r\n  };\r\n  return instance.toggle(!paused);\r\n};\r\n\r\nexport const wait = (timeout: number = 0) =>\r\n  new Promise<void>((resolve) =>\r\n    timeout ? setTimeout(resolve, timeout) : resolve()\r\n  );\r\n","import { isDefined, isUndefined, tryCatchAsync } from \"@tailjs/util\";\r\nimport { bindStorage, wait } from \".\";\r\n\r\nexport type MaybePromise<T> = T extends PromiseLike<infer T>\r\n  ? MaybePromise<T>\r\n  : T | PromiseLike<T>;\r\n\r\nexport interface OpenPromise<T = void> extends PromiseLike<T> {\r\n  readonly resolved: (T extends void ? boolean : T) | undefined;\r\n  reset(): OpenPromise<T>;\r\n  resolve(value: T, reset?: boolean): OpenPromise<T>;\r\n  reject(error: any): OpenPromise<T>;\r\n  signal(value: T): OpenPromise<T>;\r\n  wait(timeout: number): Promise<T | undefined>;\r\n}\r\n\r\nexport const promise = <T = void>(initialValue?: T): OpenPromise<T> => {\r\n  let capturedResolve: (value: T) => void;\r\n  let capturedReject: (value: T) => void;\r\n  let currentPromise: Promise<T>;\r\n  const resetPromise = () => {\r\n    (instance as any).resolved = undefined;\r\n    currentPromise = new Promise<T>(\r\n      (resolve, reject) => (\r\n        (capturedResolve = (value: any) => {\r\n          (instance as any).resolved = !isDefined(value) || value;\r\n          resolve(value);\r\n        }),\r\n        (capturedReject = reject)\r\n      )\r\n    );\r\n  };\r\n\r\n  const instance: OpenPromise<T> = {\r\n    resolved: undefined,\r\n    reset: () => (resetPromise(), instance),\r\n    resolve: (value) => (capturedResolve(value), instance),\r\n    reject: (value) => (capturedReject(value), instance),\r\n    signal: (value) => (capturedResolve(value), instance.reset()),\r\n    then: (...args) => currentPromise.then(...args),\r\n    wait: (timeout) => Promise.race([wait(timeout), currentPromise]) as any,\r\n  };\r\n  instance.reset();\r\n  return initialValue ? instance.resolve(initialValue) : instance;\r\n};\r\n\r\nexport type Lock = <T = void>(action: () => Promise<T> | T) => Promise<T>;\r\n\r\nexport const createLock = (id: string, timeout = 1000): Lock => {\r\n  const storage = bindStorage<boolean>(id);\r\n  let waitHandle = promise();\r\n  storage.observe((value) => {\r\n    if (isUndefined(value)) {\r\n      waitHandle.signal();\r\n    }\r\n  });\r\n\r\n  return async <T>(action: () => Promise<T>) => {\r\n    let timeouts = 0;\r\n    while (storage.get()) {\r\n      if (timeouts > 3) {\r\n        throw new Error(`Could not acquire lock after ${timeouts} attempts.`);\r\n      }\r\n      await waitHandle.wait(timeout);\r\n    }\r\n    storage.update(() => true);\r\n    return await tryCatchAsync(action, true, () => storage.delete());\r\n  };\r\n};\r\n","import { now } from \".\";\r\n\r\nexport type UUID = string;\r\n\r\nexport let TAB_ID =\r\n  now().toString(36) +\r\n  Math.trunc(1296 * Math.random()) //\r\n    .toString(36)\r\n    .padStart(2, \"0\");\r\n\r\nlet localId = 0;\r\nexport const nextId = () => TAB_ID + \"_\" + nextLocalId();\r\nexport const nextLocalId = () => ++localId;\r\n","import { filter, some } from \"@tailjs/util\";\r\n\r\nexport type Rebinder = () => boolean;\r\nexport type Unbinder = () => boolean;\r\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\r\n\r\nexport type SourceListener<Args extends any[]> = (...args: Args) => void;\r\nexport type Listener<Args extends any[]> = (\r\n  ...args: [...args: Args, unbind: Unbinder]\r\n) => void;\r\n\r\nexport const createBinders = <Args extends any[]>(\r\n  listener: Listener<Args>,\r\n  attach: (listener: SourceListener<Args>) => void,\r\n  detach: (listener: SourceListener<Args>) => void\r\n): Binders => {\r\n  let bound = false;\r\n\r\n  const outerListener = (...args: Args) => listener(...args, unbind);\r\n\r\n  const unbind = () =>\r\n    bound !== (bound = false) && (detach(outerListener), true);\r\n\r\n  const rebind = () =>\r\n    bound !== (bound = true) && (attach(outerListener), true);\r\n\r\n  rebind();\r\n  return [unbind, rebind];\r\n};\r\n\r\nexport const mergeBinders = (...binders: (Binders | undefined)[]): Binders => (\r\n  (binders = filter(binders)),\r\n  [\r\n    () => some(binders, (binder) => binder![0]()),\r\n    () => some(binders, (binder) => binder![1]()),\r\n  ]\r\n);\r\n\r\nexport type EventHandler<Args extends any[]> = (...payload: Args) => void;\r\n\r\nexport const createEvent = <Args extends any[]>(): [\r\n  listen: (listener: Listener<Args>) => Binders,\r\n  dispatch: (...payload: Args) => void\r\n] => {\r\n  const listeners = new Set<SourceListener<Args>>();\r\n\r\n  return [\r\n    (handler) =>\r\n      createBinders(\r\n        handler,\r\n        (handler) => listeners.add(handler),\r\n        (handler) => listeners.delete(handler)\r\n      ),\r\n    (...payload) => listeners.forEach((handler) => handler(...payload)),\r\n  ];\r\n};\r\n","const codes: number[] = [];\nconst chars: number[] = [];\nexport const charCode = (s: string, index = 0) => s.charCodeAt(index);\nexport const fromCharCodes = (chars: number[]) => String.fromCharCode(...chars);\n\n[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"].forEach(\n  (p, i) => (codes[(chars[i] = p.charCodeAt(0))] = i)\n);\n\n/**\n * Encodes an array of bytes to Base64URL without padding (URL safe Base64 using `-` and `_` instead of `+` and `/`).\n *\n * (thanks to Jon Leighton at https://gist.github.com/jonleighton/958841).\n */\nexport const to64u = (bytes: Uint8Array) => {\n  let i = 0;\n  let chunk: number;\n  const n = bytes.length;\n\n  const base64: number[] = [];\n  while (i < n) {\n    chunk = (bytes[i++] << 16) | (bytes[i++] << 8) | bytes[i++];\n    base64.push(\n      chars[(chunk & 16515072) >> 18],\n      chars[(chunk & 258048) >> 12],\n      chars[(chunk & 4032) >> 6],\n      chars[chunk & 63]\n    );\n  }\n  base64.length += n - i;\n\n  return fromCharCodes(base64);\n};\n\n/**\n * Decodes a BaseURL encoded string (without padding).\n */\nexport const from64u = (encoded: string) => {\n  let i = 0;\n  let j = 0;\n  let p: number;\n  const n = encoded.length;\n  const bytes = new Uint8Array(3 * ((n / 4) | 0) + (((n + 3) & 3) % 3));\n  while (i < n) {\n    bytes[j++] =\n      (codes[charCode(encoded, i++)] << 2) |\n      ((p = codes[charCode(encoded, i++)]) >> 4);\n    if (i < n) {\n      bytes[j++] = ((p & 15) << 4) | ((p = codes[charCode(encoded, i++)]) >> 2);\n      if (i < n) {\n        bytes[j++] = ((p & 3) << 6) | codes[charCode(encoded, i++)];\n      }\n    }\n  }\n  return bytes;\n};\n","import { hasValue, isBoolean } from \"..\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  <B extends boolean>(source: T, numeric: B): B extends true ? number : string;\n  (source: T, bits?: 32 | 64 | 128): string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key = \"\"): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (iw = 0; iw < key.length; mixer0 += window0[iw] = key.charCodeAt(iw++));\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero it all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: any, numericOrBits: any = 64) => {\n      if (!hasValue(source)) return null;\n      let bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n","(function () {\r\n\t\"use strict\";\r\n\r\n\t// Serializes a value to a MessagePack byte array.\r\n\t//\r\n\t// data: The value to serialize. This can be a scalar, array or object.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple values in data are concatenated to multiple MessagePack arrays.\r\n\t// - invalidTypeReplacement: The value that is used to replace values of unsupported types, or a function that returns such a value, given the original value as parameter.\r\n\tfunction serialize(data, options) {\r\n\t\tif (options && options.multiple && !Array.isArray(data)) {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\r\n\t\t}\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet floatBuffer, floatView;\r\n\t\tlet array = new Uint8Array(128);\r\n\t\tlet length = 0;\r\n\t\tif (options && options.multiple) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tappend(data[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tappend(data);\r\n\t\t}\r\n\t\treturn array.subarray(0, length);\r\n\r\n\t\tfunction append(data, isReplacement) {\r\n\t\t\tswitch (typeof data) {\r\n\t\t\t\tcase \"undefined\":\r\n\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\tappendBoolean(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tappendNumber(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tappendString(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif (data === null)\r\n\t\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\telse if (data instanceof Date)\r\n\t\t\t\t\t\tappendDate(data);\r\n\t\t\t\t\telse if (Array.isArray(data))\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\r\n\t\t\t\t\t\tappendBinArray(data);\r\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\r\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\r\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tappendObject(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\r\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendNull(data) {\r\n\t\t\tappendByte(0xc0);\r\n\t\t}\r\n\r\n\t\tfunction appendBoolean(data) {\r\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\r\n\t\t}\r\n\r\n\t\tfunction appendNumber(data) {\r\n\t\t\tif (isFinite(data) && Math.floor(data) === data) {\r\n\t\t\t\t// Integer\r\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0 && data >= -0x20) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\r\n\t\t\t\t\tappendBytes([0xcc, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\r\n\t\t\t\t\tappendBytes([0xd0, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\r\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\r\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\r\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\r\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\r\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\r\n\t\t\t\t\t// 32 bits for bitwise operations.\r\n\t\t\t\t\tlet hi = data / pow32;\r\n\t\t\t\t\tlet lo = data % pow32;\r\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\r\n\t\t\t\t\tappendByte(0xd3);\r\n\t\t\t\t\tappendInt64(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0) {   // below int64\r\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t\telse {   // above uint64\r\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Float\r\n\t\t\t\tif (!floatView) {\r\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\r\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\r\n\t\t\t\t}\r\n\t\t\t\tfloatView.setFloat64(0, data);\r\n\t\t\t\tappendByte(0xcb);\r\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendString(data) {\r\n\t\t\tlet bytes = encodeUtf8(data);\r\n\t\t\tlet length = bytes.length;\r\n\r\n\t\t\tif (length <= 0x1f)\r\n\t\t\t\tappendByte(0xa0 + length);\r\n\t\t\telse if (length <= 0xff)\r\n\t\t\t\tappendBytes([0xd9, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(bytes);\r\n\t\t}\r\n\r\n\t\tfunction appendArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x90 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let index = 0; index < length; index++) {\r\n\t\t\t\tappend(data[index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendBinArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendBytes([0xc4, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(data);\r\n\t\t}\r\n\r\n\t\tfunction appendObject(data) {\r\n\t\t\tlet length = 0;\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tif (data[key] !== undefined) {\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x80 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tlet value = data[key];\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tappend(key);\r\n\t\t\t\t\tappend(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendDate(data) {\r\n\t\t\tlet sec = data.getTime() / 1000;\r\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\r\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\r\n\t\t\t\tappendInt64(sec);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendByte(byte) {\r\n\t\t\tif (array.length < length + 1) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + 1)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray[length] = byte;\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\tfunction appendBytes(bytes) {\r\n\t\t\tif (array.length < length + bytes.length) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + bytes.length)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray.set(bytes, length);\r\n\t\t\tlength += bytes.length;\r\n\t\t}\r\n\r\n\t\tfunction appendInt64(value) {\r\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\r\n\t\t\t// bitwise operations.\r\n\t\t\tlet hi, lo;\r\n\t\t\tif (value >= 0) {\r\n\t\t\t\t// Same as uint64\r\n\t\t\t\thi = value / pow32;\r\n\t\t\t\tlo = value % pow32;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\r\n\t\t\t\tvalue++;\r\n\t\t\t\thi = Math.abs(value) / pow32;\r\n\t\t\t\tlo = Math.abs(value) % pow32;\r\n\t\t\t\thi = ~hi;\r\n\t\t\t\tlo = ~lo;\r\n\t\t\t}\r\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deserializes a MessagePack byte array to a value.\r\n\t//\r\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple concatenated MessagePack arrays are returned as an array.\r\n\tfunction deserialize(array, options) {\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet pos = 0;\r\n\t\tif (array instanceof ArrayBuffer) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\r\n\t\t}\r\n\t\tif (!array.length) {\r\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\r\n\t\t}\r\n\t\tif (!(array instanceof Uint8Array)) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tlet data;\r\n\t\tif (options && options.multiple) {\r\n\t\t\t// Read as many messages as are available\r\n\t\t\tdata = [];\r\n\t\t\twhile (pos < array.length) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Read only one message and ignore additional data\r\n\t\t\tdata = read();\r\n\t\t}\r\n\t\treturn data;\r\n\r\n\t\tfunction read() {\r\n\t\t\tconst byte = array[pos++];\r\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\r\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\r\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\r\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\r\n\t\t\tif (byte === 0xc0) return null;   // nil\r\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\r\n\t\t\tif (byte === 0xc2) return false;   // false\r\n\t\t\tif (byte === 0xc3) return true;   // true\r\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\r\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\r\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\r\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\r\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\r\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\r\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\r\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\r\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\r\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\r\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\r\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\r\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\r\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\r\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\r\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\r\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\r\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\r\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\r\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\r\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\r\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\r\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\r\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\r\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\r\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\r\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\r\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\r\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\r\n\t\t\tconsole.debug(\"msgpack array:\", array);\r\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\r\n\t\t}\r\n\r\n\t\tfunction readInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\tlet first = true;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tlet byte = array[pos++];\r\n\t\t\t\t\tvalue += byte & 0x7f;\r\n\t\t\t\t\tif (byte & 0x80) {\r\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvalue *= 256;\r\n\t\t\t\t\tvalue += array[pos++];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readUInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tvalue *= 256;\r\n\t\t\t\tvalue += array[pos++];\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readFloat(size) {\r\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\r\n\t\t\tpos += size;\r\n\t\t\tif (size === 4)\r\n\t\t\t\treturn view.getFloat32(0, false);\r\n\t\t\tif (size === 8)\r\n\t\t\t\treturn view.getFloat64(0, false);\r\n\t\t}\r\n\r\n\t\tfunction readBin(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = array.subarray(pos, pos + size);\r\n\t\t\tpos += size;\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readMap(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = {};\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tlet key = read();\r\n\t\t\t\tdata[key] = read();\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readArray(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = [];\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readStr(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet start = pos;\r\n\t\t\tpos += size;\r\n\t\t\treturn decodeUtf8(array, start, size);\r\n\t\t}\r\n\r\n\t\tfunction readExt(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet type = readUInt(1);\r\n\t\t\tlet data = readBin(size);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 255:\r\n\t\t\t\t\treturn readExtDate(data);\r\n\t\t\t}\r\n\t\t\treturn { type: type, data: data };\r\n\t\t}\r\n\r\n\t\tfunction readExtDate(data) {\r\n\t\t\tif (data.length === 4) {\r\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\treturn new Date(sec * 1000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 8) {\r\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\r\n\t\t\t\t\t((data[1] << 14) >>> 0) +\r\n\t\t\t\t\t((data[2] << 6) >>> 0) +\r\n\t\t\t\t\t(data[3] >>> 2);\r\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\r\n\t\t\t\t\t((data[4] << 24) >>> 0) +\r\n\t\t\t\t\t((data[5] << 16) >>> 0) +\r\n\t\t\t\t\t((data[6] << 8) >>> 0) +\r\n\t\t\t\t\tdata[7];\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 12) {\r\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\tpos -= 8;\r\n\t\t\t\tlet sec = readInt(8);\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Encodes a string to UTF-8 bytes.\r\n\tfunction encodeUtf8(str) {\r\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\r\n\t\tlet ascii = true, length = str.length;\r\n\t\tfor (let x = 0; x < length; x++) {\r\n\t\t\tif (str.charCodeAt(x) > 127) {\r\n\t\t\t\tascii = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\r\n\t\tfor (let ci = 0; ci !== length; ci++) {\r\n\t\t\tlet c = str.charCodeAt(ci);\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tbytes[i++] = c;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c < 2048) {\r\n\t\t\t\tbytes[i++] = c >> 6 | 192;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\r\n\t\t\t\t\tif (++ci >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\r\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\r\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\r\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\r\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\r\n\t\t\t\t}\r\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\r\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\r\n\t\t\t}\r\n\t\t\tbytes[i++] = c & 63 | 128;\r\n\t\t}\r\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\r\n\t}\r\n\r\n\t// Decodes a string from UTF-8 bytes.\r\n\tfunction decodeUtf8(bytes, start, length) {\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = start, str = \"\";\r\n\t\tlength += start;\r\n\t\twhile (i < length) {\r\n\t\t\tlet c = bytes[i++];\r\n\t\t\tif (c > 127) {\r\n\t\t\t\tif (c > 191 && c < 224) {\r\n\t\t\t\t\tif (i >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\r\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 223 && c < 240) {\r\n\t\t\t\t\tif (i + 1 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\r\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 239 && c < 248) {\r\n\t\t\t\t\tif (i + 2 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\r\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\r\n\t\t\t}\r\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\r\n\t\t\telse if (c <= 0x10ffff) {\r\n\t\t\t\tc -= 0x10000;\r\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\r\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\r\n\t\t\t}\r\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\r\n\t// The exported functions\r\n\tlet msgpack = {\r\n\t\tserialize: serialize,\r\n\t\tdeserialize: deserialize,\r\n\r\n\t\t// Compatibility with other libraries\r\n\t\tencode: serialize,\r\n\t\tdecode: deserialize\r\n\t};\r\n\r\n\t// Environment detection\r\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\r\n\t\t// Node.js\r\n\t\tmodule.exports = msgpack;\r\n\t}\r\n\telse {\r\n\t\t// Global object\r\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\r\n\t}\r\n\r\n})();\r\n","import { deserialize, serialize } from \"@ygoe/msgpack\";\n\nimport { HashFunction, from64u, lfsr, to64u } from \".\";\nimport {\n  IsNever,\n  Nullish,\n  hasValue,\n  isArray,\n  isDefined,\n  isFunction,\n  isIterable,\n  isNull,\n  isObject,\n  isSymbol,\n  isUndefined,\n  nil,\n  tryCatch,\n} from \"..\";\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\nexport type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the constract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properies that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param validate This property has no effect other than letting TypeScript validate whether the value can be deserialized back to its original form without losing properties.\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  (value: any, validate?: false): string;\n  <T = Encodable>(value: T & EncodableContract<T>, validate: true): string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(encoded: string | Nullish) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\nconst floatBuffer = new ArrayBuffer(8);\nconst floatView = new DataView(floatBuffer);\n\n/**\n * Misc. fixes to the msgpack library. For example, it does not handle exponential numbers well.\n */\nconst patchSerialize = (value: any) => {\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number;\n  const patchProperty = (\n    value: any,\n    key: any,\n    val = value[key],\n    patched = inner(val)\n  ) => (\n    (val !== patched || isSymbol(key)) &&\n      ((value[key] = patched), addCleaner(() => (value[key] = val))),\n    val\n  );\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (value == null || isFunction(value) || isSymbol(value)) {\n      return null;\n    }\n\n    if (Number.isFinite(value) && !Number.isSafeInteger(value)) {\n      floatView.setFloat64(0, value, true);\n\n      return { \"\": [...new Uint32Array(floatBuffer)] };\n    }\n\n    if (!isObject(value, true)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if (isDefined((refIndex = (refs ??= new Map()).get(value)))) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isObject(value)) {\n      refs.set(value, refs.size + 1);\n\n      Object.keys(value).forEach(\n        (k) =>\n          (isUndefined(patchProperty(value, k)) || isSymbol(k)) &&\n          delete value[k]\n      );\n    } else if (isIterable(value)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  const serialized = serialize(inner(value));\n  cleaners?.forEach((cleaner) => cleaner());\n  return serialized;\n};\n\nconst patchDeserialize = (value: Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value, true)) return value;\n\n    if (isArray(value[\"\"]) && (value = value[\"\"]).length === 2) {\n      return new DataView(new Uint32Array(value).buffer).getFloat64(0, true);\n    }\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return hasValue(value)\n    ? tryCatch(\n        () => inner(deserialize(value)),\n        () => undefined\n      )\n    : undefined;\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<string>\n];\n\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lsfr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (\n  key?: null | string,\n  json = false\n): Transport => {\n  const [encrypt, decrypt, hash] = lfsr(key ?? \"\");\n  return json\n    ? [\n        (data: any) => JSON.stringify(data),\n        (encoded) =>\n          encoded == null\n            ? undefined\n            : tryCatch(() => JSON.parse(encoded, undefined)),\n        (data: any, numericOrBits?: any) =>\n          hash(serialize(data), numericOrBits) as any,\n      ]\n    : [\n        (data: any) => to64u(encrypt(patchSerialize(data))),\n        (encoded: any) =>\n          hasValue(encoded)\n            ? patchDeserialize(decrypt(from64u(encoded)))\n            : null,\n        (data: any, numericOrBits?: any) =>\n          hash(patchSerialize(data), numericOrBits) as any,\n      ];\n};\n\nexport const defaultTransport = createTransport();\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\n","import { isUndefined } from \"@tailjs/util\";\r\nimport { createTransport } from \"@tailjs/util/transport\";\r\nimport {\r\n  Binders,\r\n  DEBUG,\r\n  Listener,\r\n  TAB_ID,\r\n  addPageListener,\r\n  createEvent,\r\n  error,\r\n  listen,\r\n  mergeBinders,\r\n} from \".\";\r\n\r\nexport type Metadata<T = any> = [value: T, source?: string, expires?: number];\r\n\r\nexport type StorageProviderObserver<T = any> = (\r\n  newValue: Metadata<T> | undefined,\r\n  oldValue: Metadata<T> | undefined,\r\n  key: string | null\r\n) => void;\r\n\r\nexport interface StorageProvider {\r\n  getItem<T = any>(key: string): Metadata<T> | null;\r\n  setItem<T = any>(key: string, value: Metadata<T>): void;\r\n  removeItem(key: string): void;\r\n  observe?<T = any>(key: string, observer: StorageProviderObserver<T>): Binders;\r\n}\r\n\r\ntype TypedStorageObserverArgs<T = any> = [\r\n  newValue: T | undefined,\r\n  context: {\r\n    key: string | null;\r\n    oldValue: string | undefined;\r\n    source?: string | undefined;\r\n    self?: boolean;\r\n  }\r\n];\r\nexport type TypedStorageObserver<T = any> = Listener<\r\n  TypedStorageObserverArgs<T>\r\n>;\r\n\r\nexport interface TypedStorage {\r\n  get<T = any>(key: string): T | undefined;\r\n  set<T>(key: string, value: T, timeout?: number): T;\r\n  delete(key: string): void;\r\n  update<T = any>(\r\n    key: string,\r\n    newValue: (current: T | undefined) => T,\r\n    timeout?: number\r\n  ): T;\r\n  observe?<T = any>(\r\n    key: string,\r\n    observer: TypedStorageObserver<T>,\r\n    includeSelf?: boolean\r\n  ): Binders;\r\n}\r\n\r\nexport interface BoundStorage<T = any> {\r\n  get(): T | undefined;\r\n  set<Undefined extends undefined | never = never>(\r\n    value: T | undefined,\r\n    timeout?: number\r\n  ): T | Undefined;\r\n  delete(): void;\r\n  update<Undefined extends undefined | T = T>(\r\n    newValue: (current: T | undefined) => T | Undefined,\r\n    timeout?: number\r\n  ): T | Undefined;\r\n  observe?(observer: TypedStorageObserver<T>, includeSelf?: boolean): Binders;\r\n}\r\n\r\nconst [serialize, deserialize] = createTransport(\"foo\", DEBUG);\r\n\r\nexport const mapStorage = <P extends StorageProvider>(\r\n  provider: P\r\n): P[\"observe\"] extends undefined ? TypedStorage : Required<TypedStorage> => {\r\n  const [addOwnListener, dispatchOwn] = createEvent<TypedStorageObserverArgs>();\r\n\r\n  const get = (key: string) => provider.getItem(key)?.[0];\r\n  const set = <T>(key: string, value: T | undefined, timeout?: number) => {\r\n    const oldValue = get(key);\r\n    if (isUndefined(value)) {\r\n      provider.removeItem(key);\r\n      dispatchOwn(undefined, { key, oldValue, source: TAB_ID, self: true });\r\n    } else {\r\n      provider.setItem(key, [value, TAB_ID, timeout]);\r\n      dispatchOwn(value, { key, oldValue, source: TAB_ID, self: true });\r\n    }\r\n    return value as any;\r\n  };\r\n\r\n  let retries = 0;\r\n  const update = <T>(\r\n    key: string,\r\n    newValue: (current: T | undefined) => T | undefined,\r\n    timeout: number\r\n  ) => {\r\n    if (retries++ > 3) {\r\n      error(`Race condition ('${key}').`, true);\r\n    }\r\n    const value = set(key, newValue(provider.getItem<T>(key)?.[0]));\r\n    const writtenValue = provider.getItem(key);\r\n    if (writtenValue?.[1] && writtenValue?.[1] !== TAB_ID) {\r\n      return update(key, newValue, timeout);\r\n    }\r\n    retries = 0;\r\n    return value;\r\n  };\r\n\r\n  return {\r\n    get,\r\n    set,\r\n    delete: (key) => set(key, undefined),\r\n    update,\r\n    observe: provider.observe\r\n      ? (key, listener, includeSelf) => {\r\n          const [unbind, bind] = mergeBinders(\r\n            provider.observe!(key, (newValue, oldValue, key) =>\r\n              listener(\r\n                newValue?.[0],\r\n                { key, oldValue: oldValue?.[0], source: newValue?.[1] },\r\n                unbind\r\n              )\r\n            ),\r\n            includeSelf\r\n              ? addOwnListener(\r\n                  (value, context, unbind) =>\r\n                    context.key === key && listener(value, context, unbind)\r\n                )\r\n              : undefined\r\n          );\r\n          return [unbind, bind];\r\n        }\r\n      : undefined,\r\n  } as TypedStorage as any;\r\n};\r\n\r\nexport const sharedStorage = mapStorage({\r\n  getItem: (key) => deserialize(localStorage.getItem(key)) ?? null,\r\n  setItem: (key, value) =>\r\n    localStorage.setItem(\r\n      key,\r\n      serialize(value.filter((value) => value != null))\r\n    ),\r\n  removeItem: (key) => localStorage.removeItem(key),\r\n  observe: (key, observer) => {\r\n    const [unbind, bind] = listen(\r\n      window,\r\n      \"storage\",\r\n      ({ key: changedKey, newValue, oldValue }) =>\r\n        key == changedKey &&\r\n        observer(deserialize(newValue), deserialize(oldValue), key)\r\n    );\r\n\r\n    return mergeBinders(\r\n      [unbind, bind],\r\n      addPageListener(\r\n        (visible, loaded) => !loaded && (visible ? bind() : unbind())\r\n      )\r\n    );\r\n  },\r\n});\r\n\r\nexport const bindStorage: {\r\n  <T>(key: string, storage?: Required<TypedStorage>): Required<BoundStorage<T>>;\r\n  <T>(key: string, storage: TypedStorage): BoundStorage<T>;\r\n} = <T>(\r\n  key: string,\r\n  storage: TypedStorage = sharedStorage\r\n): Required<BoundStorage<T>> => ({\r\n  get: () => storage.get<T>(key),\r\n  set: (value, timeout) => storage.set(key, value as any, timeout),\r\n  delete: () => storage.delete(key),\r\n  update: (updater, timeout) => storage.update(key, updater as any, timeout),\r\n  observe: storage.observe\r\n    ? (observer, includeSelf) => storage.observe!(key, observer, includeSelf)\r\n    : undefined!,\r\n});\r\n","export const DEBUG = true;\r\nexport const TAB_HEARTBEAT = 5_000;\r\nexport const STATE_KEY = \"_t.sr\";\r\n","import { isDefined } from \"@tailjs/util\";\r\nimport { TAB_ID, bindStorage, sharedStorage } from \".\";\r\n\r\nexport type Channel<T> = {\r\n  post(sender: string, payload: T): void;\r\n  unsubscribe: () => void;\r\n};\r\n\r\nexport type SynchronizedStorage<T> = {\r\n  get(): T | null;\r\n  update<V extends T | null>(update: (oldValue: T | null) => V): V;\r\n};\r\n\r\ntype ChannelPayload<T> = {\r\n  sender: string;\r\n  payload: T;\r\n  target?: string;\r\n};\r\n\r\nexport const createChannel = <T>(\r\n  id: string,\r\n  handler: (sender: string, payload: T) => void\r\n): Channel<T> => {\r\n  const storage = bindStorage<ChannelPayload<T>>(id, sharedStorage);\r\n\r\n  return {\r\n    post: (sender, payload) => {\r\n      storage.set({ sender, payload });\r\n      storage.delete();\r\n    },\r\n    unsubscribe: storage.observe((value) => {\r\n      if (isDefined(value) && (!value.target || value.target === TAB_ID)) {\r\n        handler(value.sender, value.payload);\r\n      }\r\n    })[0],\r\n  };\r\n};\r\n\r\nlet chatChannel: Channel<string> | undefined;\r\nexport const error: {\r\n  (message: string, fatal: boolean): void;\r\n  (message: string, cause?: any, fatal?: boolean);\r\n} = (message: string, error?: any, throwError = false) => {\r\n  if (typeof error === \"boolean\") {\r\n    throwError = error;\r\n    error = null;\r\n  }\r\n  if (error?.message) {\r\n    message += \"(\" + error.message;\r\n    error.stack && (message += \"\\n\\n\" + error.stack);\r\n    message += \")\";\r\n  }\r\n  console.error(message);\r\n  if (throwError) {\r\n    throw new Error(message);\r\n  }\r\n};\r\nexport const log = (message: any) => {\r\n  const source = message;\r\n  typeof message === \"object\" && (message = JSON.stringify(message));\r\n\r\n  (chatChannel ??= createChannel<string>(\"chat\", (sender, message) => {\r\n    console.log(`Other tab (${sender}): ${message}`);\r\n  })).post(TAB_ID, message);\r\n  console.log(`This tab: ${message}`);\r\n  return source;\r\n};\r\n","import { clear, forEach, set } from \"@tailjs/util\";\r\nimport {\r\n  STATE_KEY,\r\n  TAB_HEARTBEAT,\r\n  TAB_ID,\r\n  addPageListener,\r\n  bindStorage,\r\n  createEvent,\r\n  now,\r\n  clock,\r\n  sharedStorage,\r\n} from \".\";\r\n\r\nexport type TabState = {\r\n  hearbeat: number;\r\n  view?: number;\r\n  navigated?: number;\r\n};\r\n\r\nexport type State = {\r\n  knownTabs: Record<string, TabState>;\r\n  variables: Record<string, any>;\r\n};\r\n\r\nconst initialState: State = {\r\n  knownTabs: {},\r\n  variables: {},\r\n};\r\n\r\nconst [addStateListener, dispatch] =\r\n  createEvent<[event: \"ready\" | \"update\", state: State]>();\r\n\r\nconst storage = bindStorage<State>(STATE_KEY, sharedStorage);\r\n\r\nconst heartbeat = clock(() => toggleTab(true), TAB_HEARTBEAT);\r\nlet tabState: TabState = { hearbeat: now() };\r\n\r\nconst toggleTab = (loading: boolean) => {\r\n  const deadline = now() - TAB_HEARTBEAT * 2;\r\n  heartbeat.toggle(loading, true);\r\n\r\n  return dispatch(\r\n    \"ready\",\r\n    storage.update((state) => {\r\n      forEach(\r\n        state?.knownTabs,\r\n        // Remove interval tabs.\r\n        ([tabId, tabState]) =>\r\n          tabState[0] < deadline && clear(state!.knownTabs, tabId)\r\n      );\r\n\r\n      tabState.hearbeat = now();\r\n\r\n      return (\r\n        set(\r\n          (state ??= initialState).knownTabs,\r\n          TAB_ID,\r\n          loading ? tabState : undefined\r\n        ),\r\n        state\r\n      );\r\n    })\r\n  );\r\n};\r\n\r\naddPageListener((visible, loaded) => !loaded && toggleTab(visible));\r\n\r\nexport const updateTabState = (update: (tabState: TabState) => void) => (\r\n  update(tabState), toggleTab(true)\r\n);\r\n\r\nexport { addStateListener };\r\n","import { clock, createLock, listen, now, updateTabState, wait } from \"./lib2\";\r\n\r\n//const lck = createLock(\"test\");\r\nexport const attach = async () => {\r\n  let invocations = 0;\r\n  let clicked = false;\r\n  const pump = clock(\r\n    async () => {\r\n      const capturedClick = clicked;\r\n      if (!clicked && invocations % 2 === 1) {\r\n        await wait(1500);\r\n      }\r\n      console.log(`${++invocations}, clicked: ${capturedClick}.`);\r\n    },\r\n    { frequency: 1000, queue: false }\r\n  );\r\n\r\n  listen(document.body, \"click\", async (e) => {\r\n    clicked = true;\r\n    console.log(pump.active, pump.busy);\r\n    e.shiftKey && pump.toggle(!pump.active);\r\n    console.log(await pump.trigger(true));\r\n    (async () => {\r\n      clicked = false;\r\n    })();\r\n  });\r\n  // listen(document.body, \"click\", () => {\r\n  //   updateTabState((tab) => (tab.navigated = now()));\r\n\r\n  //   lck(async () => {\r\n  //     console.log(\"Lock acquired.\");\r\n  //     await wait(5000);\r\n  //   });\r\n  // });\r\n  // listen(\r\n  //   window,\r\n  //   \"pageshow\",\r\n  //   () =>\r\n  //     activeTabs.update(\r\n  //       (current) => (\r\n  //         ((current = cast(current, isObject) ?? {})[TAB_ID] = now()), current\r\n  //       )\r\n  //     )\r\n  //   //activeStorage.update((current) => (current ?? 0) + 1)\r\n  // );\r\n  // listen(\r\n  //   window,\r\n  //   \"pagehide\",\r\n  //   () =>\r\n  //     activeTabs.update(\r\n  //       (current) => (isObject(current) && delete current[TAB_ID], current)\r\n  //     )\r\n  //   // activeStorage.update((current: any) =>\r\n  //   //   current > 0 ? current - 1 : current\r\n  //   // )\r\n  // );\r\n};\r\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\n//import { initializeTracker } from \"./initializeTracker\";\n//import { F, T, define, window } from \"./lib\";\nimport { attach } from \"./pusher\";\n\n// This assumes the script is loaded from the RequestHandler's ?cfg route.\n\n// To prevent external scripts from eaves-dropping and get a hold of the storage key, this is how initialization works:\n// 1: The configuration scripts appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overriden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nwindow[INITIALIZE_TRACKER_FUNCTION] = (callback: any) => {\n  callback(attach);\n};\n\n// let loaded = F;\n// define(window, {\n//   [INITIALIZE_TRACKER_FUNCTION]: [\n//     (callback: (init: typeof initializeTracker) => void) => {\n//       if (loaded === (loaded = T)) return;\n//       callback(initializeTracker);\n//     },\n//   ],\n// });\n"],"names":["undefined","tryCatch","expression","errorHandler","clean","e","isBoolean","console","error","isUndefined","value","isDefined","hasValue","isTruish","capturedIsArray","Array","isArray","toArray","clone","isIterable","isObject","acceptIterables","hasMethod","name","isSymbol","isFunction","acceptStrings","Symbol","iterator","isString","sliceIterator","source","start","end","item","Number","MAX_SAFE_INTEGER","createControllableIterator","action","collect","result","i","flag","control","prev","skip","binders","mapIterator","Object","entries","step","maxIterations","createNavigatingIterator","length","offset","createRangeIterator","forEach","rest","innerReturnValue","returnValue","index","_","filter","map","filterIterator","filterInternal","some","get","target","key","initializer","has","set","args","bulk","setSingle","clear","add","delete","every","assign","k","v","keys","current","splice","now","Math","trunc","performance","timeOrigin","clock","callback","settings","queue","paused","frequency","timeoutId","mutex","initialValue","capturedResolve","capturedReject","currentPromise","instance","resolved","Promise","resolve","reject","reset","then","timeout","race","wait","promise","outerCallback","async","skipQueue","busy","tryCatchAsync","clearInterval","active","setInterval","restart","newCallback","newFrequency","toggle","trigger","setTimeout","TAB_ID","toString","random","padStart","createBinders","listener","attach","detach","bound","outerListener","unbind","rebind","mergeBinders","binder","createEvent","listeners","Set","handler","payload","addListener","dispatch","listen","options","capture","passive","projection","unshift","addEventListener","addPageListener","triggerLoaded","loaded","visible","dispatchVisible","window","document","visibilityState","codes","chars","charCode","s","charCodeAt","p","FNVs","entropy","max","serialize","data","multiple","Error","floatBuffer","floatView","pow32","array","Uint8Array","append","subarray","isReplacement","appendNull","appendByte","appendBoolean","isFinite","floor","appendBytes","hi","lo","appendInt64","ArrayBuffer","DataView","setFloat64","appendNumber","bytes","str","ascii","x","ci","c","c2","encodeUtf8","appendString","Date","sec","getTime","getMilliseconds","ns","appendDate","appendArray","Uint8ClampedArray","appendBinArray","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","appendObject","invalidTypeReplacement","byte","newLength","newArray","abs","deserialize","pos","push","read","readMap","readArray","readStr","readBin","readExt","readFloat","readUInt","readInt","debug","size","first","view","buffer","byteOffset","getFloat32","getFloat64","lengthSize","String","fromCharCode","decodeUtf8","type","readExtDate","msgpack","encode","decode","module","exports","msgpackJsName","REF_PROP","patchSerialize","cleaners","refs","refIndex","patchProperty","val","patched","inner","addCleaner","cleaner","isSafeInteger","toJSON","Map","serialized","createTransport","json","encrypt","decrypt","hash","n","j","pad","prime","mixer","mixer255","iw","mixer0","window0","resetMixer","updateMixer","ENTROPY","cipher","numericOrBits","bits","BigInt","asUintN","MIN_SAFE_INTEGER","lfsr","JSON","stringify","encoded","parse","chunk","base64","to64u","from64u","matchedRef","sharedStorage","provider","addOwnListener","dispatchOwn","getItem","oldValue","removeItem","self","setItem","retries","update","newValue","writtenValue","observe","includeSelf","bind","context","mapStorage","localStorage","observer","changedKey","message","throwError","stack","initialState","knownTabs","variables","addStateListener","storage","updater","bindStorage","heartbeat","toggleTab","tabState","hearbeat","loading","deadline","TAB_HEARTBEAT","state","tabId","invocations","clicked","pump","capturedClick","log","body","shiftKey"],"mappings":"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","x_google_ignoreList":[11]}