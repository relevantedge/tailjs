{"version":3,"file":"tail.js","sources":["../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/util/src/types.ts","../../../../../npm/packages/@tailjs/util/src/iterators.ts","../../../../../npm/packages/@tailjs/util/src/accessors.ts","../../../../../npm/packages/@tailjs/util/src/time.ts","../../../../../npm/packages/@tailjs/util/src/concurrency.ts","../../../../../npm/packages/@tailjs/util/src/events.ts","../../../../../npm/packages/@tailjs/client/src/lib2/ids.ts","../../../../../npm/packages/@tailjs/client/src/lib2/page-events.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/base64.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/lfsr.ts","../../../../../npm/node_modules/.pnpm/@ygoe+msgpack@1.0.3/node_modules/@ygoe/msgpack/msgpack.js","../../../../../npm/packages/@tailjs/util/src/transport.pkg/transport.ts","../../../../../npm/packages/@tailjs/client/src/lib2/storage.ts","../../../../../npm/packages/@tailjs/client/src/lib2/consts.ts","../../../../../npm/packages/@tailjs/client/src/lib2/channel.ts","../../../../../npm/packages/@tailjs/client/src/lib2/shared-state.ts","../../../../../npm/packages/@tailjs/client/src/lib2/request.ts","../../../../../npm/packages/@tailjs/client/src/pusher.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["export const MUTEX_REQUEST_COOKIE = \".tail.rq\";\nexport const MUTEX_RESPONSE_COOKIE = \".tail.rs\";\nexport const CONTEXT_MENU_COOKIE = \".tail.cm\";\n\nexport const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_MENU_QUERY = \"mnt\";\n","import { toObject, type reduce, forEach, update, map } from \".\";\n\nexport type IsNever<T> = [T] extends [never] ? true : false;\n\n/**\n * Shorthand for a value that is optionally awaitable.\n */\nexport type MaybePromise<T> = PromiseLike<T> | T;\n\nexport type ValueOrDefault<T, R, D = undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? D\n  : R;\n\n/** Shorter than writing all this out, and slightly easier to read. */\nexport type Nullish = null | undefined;\n\n/**\n * Removes null'ish values from a union.\n */\nexport type OmitNullish<T> = T extends Nullish ? never : T;\n\n/**\n * Common function type used for projection of [key,value] entries.\n */\nexport type KeyValueProjection<K, V, R> = (\n  entry: [key: K, value: V],\n  index: number\n) => R;\n\n/**\n * Shorthand for a type that is inferred from a parameter and can either be the item in an iterable, or just the type itself.\n */\nexport type IterableOrSelf<T> = IterableOrArrayLike<T> | T;\n\ntype FunctionComparisonEqualsWrapped<T> = T extends (\n  T extends {} ? infer R & {} : infer R\n)\n  ? { [P in keyof R]: R[P] }\n  : never;\n\ntype FunctionComparisonEquals<A, B> = (<\n  T\n>() => T extends FunctionComparisonEqualsWrapped<A> ? 1 : 2) extends <\n  T\n>() => T extends FunctionComparisonEqualsWrapped<B> ? 1 : 2\n  ? true\n  : false;\n\n/**\n * Tests if a type is `any`. The test used is technically impossable to succeed unless the type is in fact `any`.\n */\nexport type IsAny<T> = FunctionComparisonEquals<T, any>;\n\n/**\n * Utility type to allow `as const` to be used on tuples returned from functions without actually making them `readonly` (which is annoying).\n * Normally TypeScript considers the return value of a function like `x=>[10,\"four\"]` to be `(string|number)[]` (which is also annoying).\n */\nexport type ConstToTuples<T> = T extends readonly any[]\n  ? { -readonly [P in keyof T]: ConstToTuples<T[P]> }\n  : Voidefined<T>;\n\n/**\n * Goes with {@link Nulls} to simplify the expression.\n */\nexport type ArgNulls<T, Arg> = (T | Nullish) & Arg;\n\n/**\n *  TypeScript may be very literal when it infers types. The type fo a function parameter with the value `10` may be inferred as `10` and not `number`.\n *  This is an issue in e.g. {@link reduce}.\n */\nexport type GeneralizeContstants<T> = T extends number\n  ? number\n  : T extends string\n  ? string\n  : T extends boolean\n  ? boolean\n  : unknown extends T\n  ? unknown\n  : {\n      [P in keyof T]: GeneralizeContstants<T[P]>;\n    };\n\n/**\n * The eclectic type found everywhere on the Internet.\n * It convers a union like `{a:1}|{b:2}` to the intersection `{a:1, b:2}`\n */\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never;\n\n/**\n * Makes a union of objects like `{a:1}&{b:2}` appear as `{a:1,b:2}` in intellisense.\n */\nexport type PrettifyIntersection<T> = T extends { [P in infer K]: any }\n  ? { [P in K]: T[P] }\n  : never;\n\n/**\n * Makes an array of key/value pairs to an object with the corresponding properties.\n */\nexport type KeyValuePairsToObject<T> = UnionToIntersection<\n  T extends readonly [infer K & keyof any, infer V]\n    ? { [P in K & keyof any]: V }\n    : ((value: T) => never) extends (\n        value: [infer K & keyof any, infer V]\n      ) => never\n    ? { [P in K & keyof any]: ConstToTuples<V> }\n    : unknown\n>;\n\n/**\n * Anything but a function.\n */\nexport type NotFunction =\n  | bigint\n  | boolean\n  | null\n  | number\n  | string\n  | symbol\n  | undefined\n  | {\n      [key: string | number | symbol]: any;\n      [Symbol.hasInstance]?: never;\n    };\n\n/**\n * Trick for having a function that returns a non-null value, if a formal paramter always has a non-null value,\n * simliar to .NET's [NotNullIfNotNull].\n *\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\n/**\n * Typescript has the distinction between `void` and `undefined`.\n * I'm sure there is a theorically sound explanation. Both that and the distinction are annoying so this little utility type maps `void` to `undefined`.\n *\n * The ampersand union trick makes TypeScript relax instead of the \"The type T could be instantiated etc...\" error.\n */\nexport type Voidefined<T> = T extends void ? T & undefined : T;\n\n/**\n * An extension to T[] and Iterable<T> that also correctly captures weird things like NodeListOf<T>\n */\nexport type IterableOrArrayLike<T> =\n  | Iterable<T>\n  | { [item: number]: T; length: number };\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = (value: any, parse?: boolean) => T | undefined;\n\nexport const undefined = void 0;\nexport const nil = null;\n\nconst createConverter =\n  <T>(typeTester: TypeTester<T>, parser?: (value: any) => T | undefined) =>\n  (value: any, parse = true) =>\n    typeTester(value)\n      ? value\n      : parser && parse && isDefined((value = parser(value)))\n      ? value\n      : undefined;\n\nexport const tryCatch = <T, C = undefined>(\n  expression: () => T,\n  errorHandler: boolean | ((error: any) => C) = true as any,\n  clean?: () => void\n): T | C => {\n  try {\n    return expression();\n  } catch (e) {\n    if (!isBoolean(errorHandler)) {\n      return errorHandler?.(e) as any;\n    }\n    if (errorHandler) {\n      throw e;\n    }\n    console.error(e);\n    return undefined as any;\n  } finally {\n    clean?.();\n  }\n};\n\nexport const tryCatchAsync = async <T, C = void>(\n  expression: () => PromiseLike<T> | T,\n  errorHandler:\n    | boolean\n    | ((error: any, last: boolean) => Promise<C> | C) = true as any,\n  clean?: () => void,\n  retries = 1\n): Promise<T | C> => {\n  while (retries--) {\n    try {\n      return await expression();\n    } catch (e) {\n      if (!isBoolean(errorHandler)) {\n        (await errorHandler(e, !retries)) as any;\n      } else if (errorHandler && !retries) {\n        throw e;\n      } else {\n        console.error(e);\n      }\n    } finally {\n      clean?.();\n    }\n  }\n  return undefined as any;\n};\n\nexport const as = <T, D = undefined, Args extends any[] = []>(\n  value: any,\n  converter: (value: any, ...rest: Args) => T | undefined,\n  defaultValue?: D,\n  ...args: Args\n): T | D => ((value = converter(value, ...args)) ?? defaultValue) as any;\n\nexport const cast = <T, V, Args extends any[] = []>(\n  value: V,\n  typeTest: (value: any, ...args: Args) => value is T,\n  ...args: Args\n): V extends T ? V : undefined =>\n  typeTest(value, ...args) ? (value as any) : undefined;\n\nexport const isNull = (value: any): value is null => value === nil;\n\nexport const isUndefined = (value: any): value is undefined | void =>\n  value === undefined;\n\nexport const isDefined = <T>(value: T): value is Exclude<T, undefined | void> =>\n  value !== undefined;\n\nexport const isNullish = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value == nil;\n\nexport const hasValue = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value != nil;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\n\nexport const parseBoolean = createConverter(isBoolean, (value) => !!value);\nexport const isTruish = (value: any) => !!value;\nexport const isFalsish = (value: any) => !value;\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\nexport const parseNumber = createConverter(isNumber, (value) =>\n  parseFloat(value)\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\nexport const parseBigInt = createConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createConverter(isString, (value) =>\n  hasValue(value) ? \"\" + value : value\n);\n\nconst capturedIsArray = Array.isArray;\nexport const isArray = (value: any): value is any[] => capturedIsArray(value);\n\nexport const toArray = <T>(value: T | Iterable<T>, clone = false): T[] =>\n  value == null\n    ? []\n    : !clone && isArray(value)\n    ? value\n    : isIterable(value, true)\n    ? [...value]\n    : ([value] as any);\n\nexport const isObject = (\n  value: any,\n  acceptIterables = false\n): value is Record<keyof any, any> & { [Symbol.hasInstance]?: never } =>\n  value && typeof value === \"object\" && (acceptIterables || !isIterable(value));\n\nexport const hasMethod = <T, Name extends keyof any>(\n  value: T,\n  name: Name | keyof T\n): value is T &\n  Record<\n    Name,\n    T extends { [P in Name]?: (...args: infer Args) => infer R }\n      ? (...args: Args) => R\n      : (...args: any) => any\n  > => typeof (value as any)?.[name] === \"function\";\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\n\nexport const isIterable = (\n  value: any,\n  acceptStrings = false\n): value is Iterable<any> =>\n  !!value?.[Symbol.iterator] && (acceptStrings || !isString(value));\n\nexport const toIterable = <T>(value: T | Iterable<T>): Iterable<T> =>\n  isIterable(value) ? value : [value];\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == nil\n    ? value === nil\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\nexport const identity = <T = any>(value: T) => value;\n\nexport const clone = <T>(value: T, deep = true): T =>\n  isArray(value)\n    ? deep\n      ? (map as any)(value, (value: any) => clone(value, true))\n      : [...value]\n    : isObject(value)\n    ? deep\n      ? toObject(map(value as any, ([k, v]) => [k, clone(v, true)]))\n      : { ...value }\n    : isSet(value)\n    ? new Set<any>(\n        (map as any)(value, (value: any) => (deep ? clone(value, true) : value))\n      )\n    : isMap(value)\n    ? new Map<any, any>(\n        (map as any)(value, (value: any) =>\n          // Does not clone keys.\n          deep ? [value[0], clone(value[1], true)] : value\n        )\n      )\n    : (value as any);\n\ntype CaptureCallback<Args extends any[], R> = (\n  ...args: [...args: Args, self: CaptureCallback<Args, R>]\n) => R;\n\n/**\n * Evaluates a function that can be used to capture values using parameter default values.\n *\n * For example `(previous=current)=>(current+=2, previous)\n */\nexport const capture = <R>(capture: (...args: any[]) => R) => capture();\n","import {\n  ConstToTuples,\n  GeneralizeContstants,\n  IsAny,\n  KeyValuePairsToObject,\n  hasMethod,\n  hasValue,\n  isArray,\n  isDefined,\n  isFalsish,\n  isFunction,\n  isIterable,\n  isObject,\n  isTruish,\n  toArray,\n} from \".\";\n\nexport const UTF16MAX = 0xffff;\n\nexport const toCharCodes = (s: string) =>\n  [...new Array(s.length)].map((_, i) => s.charCodeAt(i));\nexport const codePoint = (string: string, index: number = 0) =>\n  string.codePointAt(index)!;\n\nexport type IteratorSource =\n  | any\n  | null\n  | undefined\n  | number\n  | Iterable<any>\n  | { [P in keyof any]: any }\n  | NavigatingIteratorStep;\n\nexport type IteratorSourceOf<T> =\n  | (T extends number ? number : never)\n  | Iterable<T>\n  | (T extends [infer K, infer V]\n      ? K extends keyof any\n        ? { [P in K]: V }\n        : never\n      : never)\n  | NavigatingIteratorStep<T>;\n\ntype IteratorItem<S extends IteratorSource> = IsAny<S> extends true\n  ? any\n  : S extends number\n  ? number\n  : S extends Record<any, any> & { [Symbol.iterator]?: never }\n  ? S extends (...args: any) => infer T | undefined\n    ? T\n    : [keyof S, S[keyof S]]\n  : S extends Iterable<infer T>\n  ? T extends string\n    ? string\n    : T\n  : never;\n\nexport interface IteratorControl<S extends IteratorSource> {\n  source: S;\n  prev: IteratorItem<S> | undefined;\n  skip(): void;\n  end(): void;\n  end<P>(value: P): P;\n}\n\nexport type IteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = IteratorItem<S>\n> = (\n  value: IteratorItem<S>,\n  index: number,\n  control: IteratorControl<S>\n) => Projection | undefined | void;\n\ntype AnyTuple = [any, ...any[]];\n\ntype IteratorProjection<\n  S extends IteratorSource,\n  Projection,\n  TupleProjection extends AnyTuple\n> = unknown extends Projection\n  ? IteratorItem<S>\n  : TupleProjection extends Projection\n  ? ConstToTuples<TupleProjection>\n  : ConstToTuples<Projection>;\n\ntype StartEndArgs<S extends IteratorSource> = S extends number\n  ? [offset?: number]\n  : S extends NavigatingIteratorStep<infer T>\n  ? [offset?: T, maxIterations?: number]\n  : [start?: number, end?: number];\n\nexport type NavigatingIteratorStep<T = any> = (\n  current: T | undefined\n) => T | undefined;\n\nfunction* createRangeIterator(length = 0, offset = 0): Iterable<number> {\n  while (length--) yield offset++;\n}\n\nexport function* createStringIterator(\n  input: string,\n  start: number,\n  end: number\n): Iterable<[char: string, codePoint: number]> {\n  while (start < end) {\n    const codePoint = input.codePointAt(start)!;\n    let p = input[start++];\n    if (codePoint > UTF16MAX) {\n      start++;\n      p = String.fromCodePoint(codePoint);\n    }\n    yield [p, codePoint];\n  }\n}\n\nexport function* createNavigatingIterator<T>(\n  step: NavigatingIteratorStep<T>,\n  start?: T | undefined,\n  maxIterations = Number.MAX_SAFE_INTEGER\n): Iterator<T> {\n  if (isDefined(start)) yield start;\n  while (maxIterations-- && isDefined((start = step(start)))) {\n    yield start;\n  }\n}\n\nconst sliceIterator = <T>(\n  source: Iterable<T>,\n  start = 0,\n  end?: number\n): Iterable<T> => {\n  if (!start && !isDefined(end)) {\n    return source;\n  }\n\n  if (source[\"slice\"]) {\n    return source[\"slice\"](start, end);\n  } else if (start < 0 || (end as any) < 0) {\n    return sliceIterator([...source], start, end);\n  }\n\n  return (function* () {\n    end ??= Number.MAX_SAFE_INTEGER;\n\n    for (const item of source) {\n      if (start--) continue;\n      if (!end--) break;\n      yield item;\n    }\n  })();\n};\n\nexport type Filter<S extends IteratorSource> = (\n  value: IteratorItem<S>,\n  index: number\n) => any;\n\nconst filterIterator = <T>(\n  source: Iterable<T>,\n  filter: (item: T, index: number) => any\n): Iterable<T> => {\n  if (isArray(source)) return source.filter(filter);\n  return (function* () {\n    let i = 0;\n    for (const item of source) {\n      if (filter(item, i++)) {\n        yield item;\n      }\n    }\n  })();\n};\n\nconst enum IterationFlag {\n  Yield = 0,\n  Skip = 1,\n  YieldThenEnd = 2,\n  End = 3,\n}\n\nfunction* createControllableIterator<\n  S extends Iterable<any>,\n  P = IteratorItem<S>\n>(\n  source: S,\n  action: IteratorAction<S, P> = (item) => item as any,\n  collect?: (result: P) => void\n) {\n  let i = 0;\n  let flag = IterationFlag.Yield;\n  let result: P | undefined;\n  const control: IteratorControl<S> = {\n    prev: undefined,\n    source,\n    skip: () => (flag = IterationFlag.Skip),\n    end: (value?: any) => (\n      (flag = isDefined(value)\n        ? IterationFlag.YieldThenEnd\n        : IterationFlag.End),\n      value\n    ),\n  };\n\n  for (const item of source) {\n    if ((result = action(item, i++, control)!) !== undefined && !(flag % 2)) {\n      if (!collect) {\n        yield result;\n      } else {\n        collect(result);\n      }\n      control.prev = item;\n    }\n    if (flag > 1) {\n      break;\n    }\n    flag = IterationFlag.Yield;\n  }\n}\n\nconst mapIterator = <S extends IteratorSource>(\n  source: S,\n  start?: any,\n  end?: any\n) => {\n  if (isIterable(source, true)) {\n    return start || end\n      ? sliceIterator(mapIterator(source), start, end)\n      : source;\n  }\n  if (!isDefined(source)) return [];\n  if (isObject(source)) return mapIterator(Object.entries(source), start, end);\n  if (isFunction(source)) return createNavigatingIterator(source, start, end);\n  return createRangeIterator(source as number, start);\n};\n\nexport const project: {\n  <S extends IteratorSource, R, RT extends AnyTuple>(\n    source: S,\n    projection?: IteratorAction<S, R | RT> | null,\n    ...rest: StartEndArgs<S>\n  ): IteratorProjection<S, R, RT>[];\n} = (source, projection, ...rest) => {\n  return createControllableIterator(\n    mapIterator(source, ...rest),\n    projection as any\n  ) as any;\n};\n\nexport function* flatProject<S extends IteratorSource, R, RT extends AnyTuple>(\n  source: S,\n  projection?: IteratorAction<S, R | RT> | null,\n  ...rest: StartEndArgs<S>\n): Iterable<FlatIteratorItem<IteratorProjection<S, R, RT>>> {\n  for (const item of project(\n    mapIterator(source, ...(rest as any)),\n    projection as any\n  )) {\n    if (isIterable(item)) {\n      yield* item;\n    } else if (isObject(item)) {\n      yield* Object.entries(item) as any;\n    } else {\n      yield item;\n    }\n  }\n}\n\nexport const map: {\n  <S extends IteratorSource, R, RT extends AnyTuple>(\n    source: S,\n    projection?: IteratorAction<S, R | RT> | null,\n    ...rest: StartEndArgs<S>\n  ): IteratorProjection<S, R, RT>[];\n  <S extends IteratorSource, R, RT extends AnyTuple>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): IteratorProjection<S, R, RT>[];\n} = ((source: any, projection: any, ...rest: any[]) => {\n  if (!isFunction(projection) && hasValue(projection)) {\n    // The \"projection\" parameter is the start index.\n    rest.unshift(projection);\n    projection = null;\n  }\n  source = mapIterator(source, ...rest);\n  return projection\n    ? projection.length < 3 && hasMethod(source, \"map\")\n      ? source[\"map\"](projection).filter(isDefined)\n      : [...createControllableIterator(source as any, projection)]\n    : (toArray(source, true) as any);\n}) as any;\n\ntype FlatIteratorItem<S extends IteratorSource> =\n  IteratorItem<S> extends Iterable<infer T>\n    ? T\n    : IteratorItem<S> extends Record<infer K, infer V>\n    ? [K, V]\n    : IteratorItem<S>;\n\nexport const flatMap = <\n  S extends IteratorSourceOf<any | Iterable<any>>,\n  R,\n  RT extends AnyTuple\n>(\n  source: S,\n  action: IteratorAction<S, R> = (item) => item as any,\n  ...rest: StartEndArgs<S>\n): FlatIteratorItem<IteratorProjection<S, R, RT>>[] =>\n  map(flatProject(source, action, ...rest)) as any;\n\nexport const forEach = <S extends IteratorSource, R>(\n  source: S,\n  action: IteratorAction<S, R>,\n  ...rest: StartEndArgs<S>\n): R | undefined => {\n  let returnValue: R | undefined = undefined;\n  let innerReturnValue: any;\n  source = mapIterator(source, ...rest);\n  if (action.length < 3 && hasMethod(source, \"forEach\")) {\n    source.forEach(\n      (item: any, index: any) =>\n        isDefined((innerReturnValue = (action as any)(item, index))) &&\n        (returnValue = innerReturnValue)\n    );\n  } else {\n    for (const _ of createControllableIterator(\n      source as any,\n      action as any,\n      (value) => (returnValue = value as any)\n    ));\n  }\n  return returnValue;\n};\n\nexport const flatForEach = <S extends IteratorSourceOf<any | Iterable<any>>, R>(\n  source: S,\n  action: IteratorAction<FlatIteratorItem<S>, R>,\n  ...rest: StartEndArgs<S>\n): R | undefined =>\n  forEach(\n    flatProject(source, undefined, ...(rest as any)),\n    action as any\n  ) as any;\n\nexport const toObject: {\n  <S extends IteratorSourceOf<[keyof any, any]>>(\n    source: S,\n    selector?: null,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<S>;\n  <S extends IteratorSource, P extends [keyof any, any]>(\n    source: S,\n    selector: IteratorAction<S, P>,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<P[]>;\n} = (source: any, selector: any, ...rest: any[]) =>\n  Object.fromEntries((map as any)(source, selector, ...rest));\n\nexport const reduce = <\n  S extends IteratorSource,\n  Reducer extends (\n    ...args: [\n      accumulator: unknown extends Accumulator\n        ? any\n        : GeneralizeContstants<Accumulator>,\n      ...rest: Parameters<IteratorAction<S, Accumulator>>\n    ]\n  ) => GeneralizeContstants<Accumulator>,\n  Accumulator\n>(\n  source: S,\n  reducer: Reducer,\n  seed?: Accumulator,\n  ...rest: StartEndArgs<S>\n): Reducer extends (...args: any) => infer R\n  ? R | (unknown extends Accumulator ? undefined : never)\n  : never =>\n  forEach(\n    source,\n    (value, index, control) =>\n      (seed =\n        (reducer(seed as any, value, index, control as any) as any) ?? seed),\n    ...rest\n  ) ?? (seed as any);\n\nexport const filter = <\n  S extends IteratorSource,\n  MapToArray extends boolean = false\n>(\n  source: S,\n  filter: Filter<S> = isTruish,\n  map?: MapToArray,\n  ...rest: StartEndArgs<S>\n): S extends any[] | null | undefined | (MapToArray extends true ? any : never)\n  ? IteratorItem<S>[]\n  : Iterable<IteratorItem<S>> =>\n  map\n    ? toArray((filter as any)(source, filter, false, ...rest))\n    : (filterIterator(mapIterator(source, ...rest) as any, filter) as any);\n\nlet filterInternal = filter;\n\nexport const count = <S extends IteratorSource>(\n  source: S,\n  filter?: Filter<S> | null,\n  ...rest: StartEndArgs<S>\n): number => {\n  if (filter) {\n    source = filterInternal(source, filter, false, ...rest) as any;\n  } else {\n    source = mapIterator(source, ...rest);\n  }\n  let n = source![\"length\"] ?? source![\"size\"];\n  return isDefined(n) ? n : reduce(source, (n) => n + 1, 0, ...rest);\n};\n\nexport const sum: {\n  <S extends IteratorSourceOf<number>>(\n    source: S,\n    selector?: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n  <S extends IteratorSource>(\n    source: S,\n    selector: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n} = (source: any, selector: any = (item: any) => item, ...rest: any) =>\n  reduce(\n    source,\n    (sum, value, index, control) =>\n      sum + (selector(value, index, control) ?? 0),\n    0,\n    ...rest\n  );\n\nexport const some = <S extends IteratorSource>(\n  source: S,\n  filter?: Filter<S> | null,\n  ...rest: StartEndArgs<S>\n) =>\n  hasMethod(source, \"some\")\n    ? source.some(\n        filter ? (item: any, index: number) => filter(item, index) : isTruish\n      )\n    : filter\n    ? some(filterInternal(source as any, filter, false, ...rest))\n    : forEach<any, boolean>(source, (item, index, { end }) => end(true)) ??\n      false;\n\nexport const every = <S extends IteratorSource>(\n  source: S,\n  filter?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) =>\n  !some(\n    source,\n    filter ? (item, index) => !filter(item, index) : isFalsish,\n    ...rest\n  );\n\nexport const binarySearch: {\n  (arr: Array<number>, find: number): number;\n  <T = number>(arr: Array<T>, find: T, compare: (x: T, y: T) => number): number;\n} = <T = number>(\n  arr: Array<T>,\n  find: T,\n  compare: (x: T, y: T) => number = ((x: any, y: any) => x - y) as any\n) => {\n  let m = 0;\n  let n = arr.length - 1;\n  let cmp: number;\n  let k: number;\n  while (m <= n) {\n    k = (n + m) >> 1;\n    cmp = compare(find, arr[k]);\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return k;\n    }\n  }\n  return ~m;\n};\n","import {\r\n  GeneralizeContstants,\r\n  IsAny,\r\n  NotFunction,\r\n  forEach,\r\n  hasMethod,\r\n  isArray,\r\n  isDefined,\r\n  isFunction,\r\n  isObject,\r\n  isUndefined,\r\n} from \".\";\r\n\r\n// #region Shared types\r\ntype MapLike<K = any, V = any> = {\r\n  has?(key: K): boolean;\r\n  get(key: K): V | undefined;\r\n  set(key: K, value: V): any;\r\n  delete(key: K): any;\r\n};\r\n\r\ntype SetLike<K = any> = {\r\n  has?(key: K): boolean;\r\n  add(key: K): any;\r\n  delete(key: K): any;\r\n};\r\n\r\ntype PropertyContainer<K extends any = any, V extends any = any> =\r\n  | {\r\n      [P in keyof K]: V;\r\n    }\r\n  | MapLike<K, V>\r\n  | SetLike<K>;\r\n\r\nexport type KeyType<T extends PropertyContainer> = T extends MapLike<\r\n  infer K,\r\n  any\r\n>\r\n  ? K\r\n  : T extends SetLike<infer K>\r\n  ? K\r\n  : T extends any[]\r\n  ? number\r\n  : keyof T;\r\n\r\nexport type ValueType<\r\n  T extends PropertyContainer,\r\n  K,\r\n  Default = never\r\n> = IsAny<T> extends true\r\n  ? any\r\n  : T extends MapLike<any, infer V>\r\n  ? V | Default\r\n  : T extends SetLike\r\n  ? boolean | Default\r\n  : T extends (infer T)[]\r\n  ? T | Default\r\n  : K extends keyof T\r\n  ? T[K] | Default\r\n  : any;\r\n\r\n// #endregion\r\n\r\n// #region get\r\n\r\nexport const get = <T extends PropertyContainer, K extends KeyType<T>>(\r\n  target: T,\r\n  key: K,\r\n  initializer?: Updater<T, K, ValueType<T, K>, false, true>\r\n): ValueType<T, K, undefined> => {\r\n  let value = hasMethod(target, \"get\")\r\n    ? target.get(key)\r\n    : hasMethod(target, \"has\")\r\n    ? target.has(key)\r\n    : (target as any)[key];\r\n  if (!isDefined(value) && isDefined(initializer)) {\r\n    isDefined(\r\n      (value = isFunction(initializer) ? (initializer as any)() : initializer)\r\n    ) && set(target, key, value);\r\n  }\r\n  return value;\r\n};\r\n\r\n// #endregion\r\n\r\n// #region set and update\r\n\r\ntype UpdateFunction<\r\n  T extends PropertyContainer,\r\n  Key,\r\n  Current,\r\n  Factory\r\n> = Factory extends false\r\n  ? (\r\n      current: Current,\r\n      key: Key,\r\n      target: T\r\n    ) => GeneralizeContstants<ValueType<T, Key>> | undefined\r\n  : (key: Key, target: T) => GeneralizeContstants<ValueType<T, Key>>;\r\n\r\ntype Updater<\r\n  T extends PropertyContainer,\r\n  Key,\r\n  Current = ValueType<T, Key>,\r\n  SettersOnly = false,\r\n  Factory = false\r\n> = SettersOnly extends true\r\n  ? ValueType<T, Key, Factory extends true ? never : undefined>\r\n  : IsAny<T> extends true\r\n  ? NotFunction | UpdateFunction<any, any, any, Factory>\r\n  :\r\n      | (ValueType<T, Key> extends Function\r\n          ? never\r\n          : ValueType<T, Key, Factory extends true ? never : undefined>)\r\n      | UpdateFunction<T, Key, Current, Factory>;\r\n\r\ntype UpdaterType<T, SettersOnly = false> = SettersOnly extends true\r\n  ? T\r\n  : T extends (...args: any) => infer T\r\n  ? T\r\n  : T;\r\n\r\ntype PropertiesToTuples<T, SettersOnly = false, K = keyof T> = K extends any\r\n  ? [K, UpdaterType<T, SettersOnly>]\r\n  : never;\r\n\r\ntype BulkUpdateObject<\r\n  T extends PropertyContainer,\r\n  SettersOnly = false,\r\n  Factory = false\r\n> = T extends MapLike | SetLike | any[]\r\n  ? {\r\n      [P in KeyType<T>]: Updater<T, P, ValueType<T, P>, SettersOnly, Factory>;\r\n    }\r\n  : { [P in keyof T & KeyType<T>]?: Updater<T, P, T[P], SettersOnly, Factory> };\r\n\r\ntype BulkUpdateKeyValue<\r\n  T extends PropertyContainer,\r\n  SettersOnly = false,\r\n  Factory = false,\r\n  K extends keyof T = keyof T\r\n> = IsAny<T> extends true\r\n  ? [any, Updater<T, any, any, SettersOnly, Factory>]\r\n  : T extends MapLike | SetLike | any[]\r\n  ? [\r\n      KeyType<T>,\r\n      Updater<T, KeyType<T>, ValueType<T, KeyType<T>>, SettersOnly, Factory>\r\n    ]\r\n  : K extends any\r\n  ? [K, Updater<T, KeyType<T>, any, SettersOnly, Factory>]\r\n  : never;\r\n\r\ntype BulkUpdates<\r\n  T extends PropertyContainer,\r\n  SettersOnly = false,\r\n  Factory = false\r\n> =\r\n  | BulkUpdateObject<T, SettersOnly, Factory>\r\n  | Iterable<\r\n      | BulkUpdateKeyValue<T, SettersOnly, Factory>\r\n      | BulkUpdateObject<T, SettersOnly, Factory>\r\n    >;\r\n\r\ntype UnwrapBulkUpdates<T, SettersOnly = false> = T extends (infer T)[]\r\n  ? T extends [infer K, infer V]\r\n    ? [K, UpdaterType<V, SettersOnly>]\r\n    : PropertiesToTuples<T, SettersOnly>\r\n  : PropertiesToTuples<T>;\r\n\r\ntype SetOrUpdateFunction<SettersOnly> = {\r\n  <\r\n    T extends PropertyContainer,\r\n    U extends Updater<T, K, ValueType<T, K>, SettersOnly>,\r\n    K extends KeyType<T>\r\n  >(\r\n    target: T,\r\n    key: K,\r\n    value: U\r\n  ): UpdaterType<U>; //  UpdaterType<U, SettersOnly>;\r\n  <T extends PropertyContainer>(\r\n    target: T,\r\n    values: BulkUpdates<T, SettersOnly>\r\n  ): T;\r\n};\r\n\r\nconst createSetOrUpdateFunction =\r\n  <B extends boolean>(settersOnly: B): SetOrUpdateFunction<B> =>\r\n  (target: PropertyContainer, ...args: any[]) => {\r\n    let bulk: boolean;\r\n    let [key, value] = args;\r\n    const setSingle = ([key, value]: [any, any]) => {\r\n      if (!settersOnly && isFunction(value)) {\r\n        value = value(get(target, key));\r\n      }\r\n\r\n      if (isUndefined(value)) {\r\n        return clear(target, key);\r\n      }\r\n\r\n      if (bulk || get(target, key) !== value) {\r\n        hasMethod(target, \"set\")\r\n          ? target.set(key, value)\r\n          : hasMethod(target, \"add\")\r\n          ? value\r\n            ? target.add(key)\r\n            : target.delete(key)\r\n          : (target[key] = value);\r\n      }\r\n\r\n      return value;\r\n    };\r\n\r\n    if ((bulk = args.length === 1)) {\r\n      // Fast path\r\n      if (settersOnly) {\r\n        if (isArray(key) && key.every((item) => isObject(item))) {\r\n          key = Object.assign({}, ...key);\r\n        }\r\n        if (isObject(key)) {\r\n          Object.assign(target, key);\r\n          Object.entries(key).forEach(\r\n            ([k, v]) => !isDefined(v) && delete target[k]\r\n          );\r\n          return target;\r\n        }\r\n      }\r\n      if (isObject(key)) {\r\n        forEach(key, setSingle);\r\n      } else {\r\n        forEach(key, (item) =>\r\n          isObject(item) ? forEach(item, setSingle) : setSingle(item)\r\n        );\r\n      }\r\n      return target;\r\n    }\r\n    return setSingle([key, value]);\r\n  };\r\n\r\nexport const set = createSetOrUpdateFunction(true);\r\nexport const update = createSetOrUpdateFunction(false);\r\n\r\n// #endregion\r\n\r\nexport const add = <T extends PropertyContainer<any, boolean>>(\r\n  target: T,\r\n  key: KeyType<T>\r\n) => get(target, key) !== set(target, key, true as any);\r\n\r\nexport const has = <T extends PropertyContainer>(target: T, key: KeyType<T>) =>\r\n  hasMethod(target, \"has\")\r\n    ? target.has(key)\r\n    : isDefined((target as any).get?.(key) ?? (target as any)[key]);\r\n\r\nexport const clear: {\r\n  <T extends PropertyContainer>(target: T, key: KeyType<T>): ValueType<\r\n    T,\r\n    KeyType<T>,\r\n    true\r\n  >;\r\n  <T extends PropertyContainer>(target: T, ...keys: KeyType<T>[]): ValueType<\r\n    T,\r\n    KeyType<T>,\r\n    true\r\n  >[];\r\n} = (target: PropertyContainer, key: any, ...keys: any[]) => {\r\n  if (keys.length) {\r\n    return keys.map((key) => clear(target, key));\r\n  }\r\n\r\n  const current = get(target, key);\r\n  hasMethod(target, \"delete\")\r\n    ? target.delete(key)\r\n    : isArray(target)\r\n    ? target.splice(key, 1)\r\n    : delete target[key];\r\n\r\n  return current;\r\n};\r\n","import {\r\n  MaybePromise,\r\n  isDefined,\r\n  isNumber,\r\n  isObject,\r\n  isUndefined,\r\n  promise,\r\n  tryCatchAsync,\r\n} from \".\";\r\n\r\nexport let now = () =>\r\n  typeof performance !== \"undefined\"\r\n    ? Math.trunc(performance.timeOrigin + performance.now())\r\n    : Date.now();\r\n\r\nexport type CancellableCallback = (cancel: () => void) => MaybePromise<any>;\r\n\r\nexport type Timer = {\r\n  (toggle?: boolean): number;\r\n};\r\n\r\nexport const createTimer = (started = true): Timer => {\r\n  let t0 = started ? now() : undefined;\r\n  let elapsed = 0;\r\n  return (toggle) => {\r\n    isDefined(t0) && (elapsed += now() - t0);\r\n    isDefined(toggle) && (t0 = toggle ? Date.now() : undefined);\r\n    return elapsed;\r\n  };\r\n};\r\n\r\nexport interface Clock {\r\n  readonly active: boolean;\r\n  readonly busy: boolean;\r\n  restart(frequency?: number, callback?: CancellableCallback): Clock;\r\n  toggle(start: boolean, trigger?: boolean): Clock;\r\n  trigger(skipQueue?: boolean): Promise<boolean>;\r\n}\r\n\r\nexport interface ClockSettings {\r\n  frequency?: number;\r\n  queue?: boolean;\r\n  paused?: boolean;\r\n  trigger?: boolean;\r\n  once?: boolean;\r\n}\r\n\r\ntype ClockSettingsParameter = ClockSettings & { frequency: number };\r\n\r\nexport const clock: {\r\n  (callback: CancellableCallback, frequency: number): Clock;\r\n  (callback: CancellableCallback, settings: ClockSettingsParameter): Clock;\r\n} = (\r\n  callback: CancellableCallback,\r\n  settings: number | ClockSettingsParameter\r\n): Clock => {\r\n  let {\r\n    frequency,\r\n    queue = true,\r\n    paused = false,\r\n    trigger = false,\r\n    once = false,\r\n  } = isNumber(settings)\r\n    ? ({ frequency: settings } as ClockSettingsParameter)\r\n    : settings;\r\n\r\n  let timeoutId = 0;\r\n  const mutex = promise().resolve();\r\n\r\n  const outerCallback = async (skipQueue?: boolean) => {\r\n    if (!timeoutId || (!queue && !mutex.resolved && skipQueue !== true)) {\r\n      return false;\r\n    }\r\n    (instance as any).busy = true;\r\n    if (skipQueue !== true) {\r\n      await mutex;\r\n    }\r\n\r\n    mutex.reset();\r\n    let cancelled = frequency < 0 || once;\r\n    await tryCatchAsync(\r\n      () => callback(() => (cancelled = true)),\r\n      false,\r\n      () => mutex.resolve()\r\n    );\r\n    if (cancelled) {\r\n      reset(false);\r\n    }\r\n\r\n    (instance as any).busy = false;\r\n    return true;\r\n  };\r\n\r\n  const reset = (start: boolean) => {\r\n    clearInterval(timeoutId);\r\n    (instance as any).active = !!(timeoutId = start\r\n      ? (setInterval(\r\n          outerCallback,\r\n          frequency < 0 ? -frequency : frequency\r\n        ) as any)\r\n      : 0);\r\n    return instance;\r\n  };\r\n\r\n  const instance: Clock = {\r\n    active: false,\r\n    busy: false,\r\n    restart: (newFrequency, newCallback) => {\r\n      frequency = newFrequency ?? frequency;\r\n      callback = newCallback ?? callback;\r\n      return reset(true);\r\n    },\r\n    toggle: (start, trigger) =>\r\n      start !== instance.active\r\n        ? start\r\n          ? trigger\r\n            ? (reset(true), instance.trigger(), instance)\r\n            : reset(true)\r\n          : reset(false)\r\n        : instance,\r\n    trigger: async (skipQueue) =>\r\n      (await outerCallback(skipQueue)) && (reset(instance.active), true),\r\n  };\r\n\r\n  return instance.toggle(!paused, trigger);\r\n};\r\n","import { isDefined } from \".\";\r\n\r\nexport type Lock<D = any> = {\r\n  <T = void>(action: () => Promise<T> | T): Promise<T>;\r\n  <T = void>(action: () => Promise<T> | T, waitTimeout: number): Promise<\r\n    [value: T | undefined, acquired: boolean]\r\n  >;\r\n  data: {\r\n    get(): D | undefined;\r\n    update<Undefined extends undefined | never = never>(\r\n      newValue: (current: D | undefined) => D | Undefined\r\n    ): D | Undefined;\r\n  };\r\n};\r\n\r\nexport interface OpenPromise<T = void> extends PromiseLike<T> {\r\n  readonly resolved: (T extends void ? boolean : T) | undefined;\r\n  reset(): OpenPromise<T>;\r\n  resolve(value: T, reset?: boolean): OpenPromise<T>;\r\n  reject(error: any): OpenPromise<T>;\r\n  signal(value: T): OpenPromise<T>;\r\n  wait(timeout: number): Promise<T | undefined>;\r\n}\r\n\r\nexport const promise = <T = void>(initialValue?: T): OpenPromise<T> => {\r\n  let capturedResolve: (value: T) => void;\r\n  let capturedReject: (value: T) => void;\r\n  let currentPromise: Promise<T>;\r\n  const resetPromise = () => {\r\n    (instance as any).resolved = undefined;\r\n    currentPromise = new Promise<T>(\r\n      (resolve, reject) => (\r\n        (capturedResolve = (value: any) => {\r\n          (instance as any).resolved = !isDefined(value) || value;\r\n          resolve(value);\r\n        }),\r\n        (capturedReject = reject)\r\n      )\r\n    );\r\n  };\r\n\r\n  const instance: OpenPromise<T> = {\r\n    resolved: undefined,\r\n    reset: () => (resetPromise(), instance),\r\n    resolve: (value) => (capturedResolve(value), instance),\r\n    reject: (value) => (capturedReject(value), instance),\r\n    signal: (value) => (capturedResolve(value), instance.reset()),\r\n    then: (...args) => currentPromise.then(...args),\r\n    wait: (timeout) => Promise.race([delay(timeout), currentPromise]) as any,\r\n  };\r\n  instance.reset();\r\n  return initialValue ? instance.resolve(initialValue) : instance;\r\n};\r\n\r\nexport const delay = <T = void>(timeout: number = 0, value?: T): Promise<T> =>\r\n  new Promise<any>((resolve) =>\r\n    timeout ? setTimeout(() => resolve(value), timeout) : resolve(value)\r\n  );\r\n","import { filter, isUndefined, reduce } from \".\";\r\n\r\nexport type Rebinder = () => boolean;\r\nexport type Unbinder = () => boolean;\r\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\r\n\r\nexport type SourceListener<Args extends any[]> = (...args: Args) => void;\r\nexport type Listener<Args extends any[]> = (\r\n  ...args: [...args: Args, unbind: Unbinder]\r\n) => void;\r\n\r\nexport const createEventBinders = <Args extends any[]>(\r\n  listener: Listener<Args>,\r\n  attach: (listener: SourceListener<Args>) => void,\r\n  detach: (listener: SourceListener<Args>) => void\r\n): Binders => {\r\n  let bound = false;\r\n\r\n  const outerListener = (...args: Args) => listener(...args, unbind);\r\n\r\n  const unbind = () =>\r\n    bound !== (bound = false) && (detach(outerListener), true);\r\n\r\n  const rebind = () =>\r\n    bound !== (bound = true) && (attach(outerListener), true);\r\n\r\n  rebind();\r\n  return [unbind, rebind];\r\n};\r\n\r\nexport const joinEventBinders = (\r\n  ...binders: (Binders | undefined)[]\r\n): Binders => (\r\n  (binders = filter(binders)),\r\n  [\r\n    () => reduce(binders, (changed, binder) => binder![0]() || changed, false),\r\n    () => reduce(binders, (changed, binder) => binder![1]() || changed, false),\r\n  ]\r\n);\r\n\r\nexport type EventHandler<Args extends any[]> = (...payload: Args) => void;\r\n\r\nexport const createEvent = <Args extends any[]>(): [\r\n  listen: (listener: Listener<Args>, triggerCurrent?: boolean) => Binders,\r\n  dispatch: (...payload: Args) => void\r\n] => {\r\n  const listeners = new Set<SourceListener<Args>>();\r\n  let dispatchedArgs: Args | undefined;\r\n  return [\r\n    (handler, trigger) => {\r\n      const binders = createEventBinders(\r\n        handler,\r\n        (handler) => listeners.add(handler),\r\n        (handler) => listeners.delete(handler)\r\n      );\r\n      trigger && dispatchedArgs && handler(...dispatchedArgs, binders[0]);\r\n      return binders;\r\n    },\r\n    (...payload) => (\r\n      (dispatchedArgs = payload),\r\n      listeners.forEach((handler) => handler(...payload))\r\n    ),\r\n  ];\r\n};\r\n\r\nexport type ChainedEventHandler<Args extends any[], T> = (\r\n  ...args: [\r\n    ...args: Args,\r\n    next: {\r\n      (): T;\r\n      (...args: Args): T;\r\n    },\r\n    unbind: Unbinder\r\n  ]\r\n) => T;\r\n\r\ntype LinkedNode<T> = [\r\n  prev: LinkedNode<T> | undefined,\r\n  item: T,\r\n  next: LinkedNode<T> | undefined\r\n];\r\n\r\nexport const createChainedEvent = <T = void, Args extends any[] = []>(): [\r\n  register: (\r\n    handler: ChainedEventHandler<Args, T>,\r\n    priority?: number\r\n  ) => Binders,\r\n  invoke: (...args: Args) => T | undefined\r\n] => {\r\n  type Item = [\r\n    handler: ChainedEventHandler<Args, T>,\r\n    priority: number,\r\n    binders: Binders\r\n  ];\r\n  type Node = LinkedNode<Item>;\r\n  let head: Node | undefined;\r\n  let tail: Node | undefined;\r\n  let next: Node | undefined;\r\n\r\n  const register = (\r\n    handler: ChainedEventHandler<Args, T>,\r\n    // Make sure that handler gets rebound at their previous priority without jumping discrete increments.\r\n    // (It is deseriable to be able to specfiy priority 0 or  10 without having to think about how many 0s there are)\r\n    priority = (tail?.[1][1] ?? 0) + 0.000001\r\n  ) => {\r\n    const registerNode = (node?: Node) => {\r\n      let bound = true;\r\n      node ??= [\r\n        undefined,\r\n        [\r\n          handler,\r\n          priority,\r\n          [\r\n            () => {\r\n              if (!bound) return false;\r\n              node![0] ? (node![0][2] = node![2]) : (head = node![2]);\r\n              node![2] ? (node![2][0] = node![0]) : (tail = node![0]);\r\n              node![0] = node![2] = undefined;\r\n              return !(bound = false);\r\n            },\r\n            () => (bound ? false : (registerNode(node), (bound = true))),\r\n          ],\r\n        ],\r\n        undefined,\r\n      ];\r\n      next = head;\r\n      if (!next) {\r\n        head = tail = node;\r\n      } else if (priority >= tail![1][1]) {\r\n        node[0] = tail;\r\n        tail = tail![2] = node;\r\n      } else {\r\n        // INV: priority < tail.priority, so next will be non-null after loop;\r\n        while ((next![1][1] as any) <= priority) {\r\n          next = next[2]!;\r\n        }\r\n\r\n        (node[0] = (node[2] = next)[0]) ? (node[0][2] = node) : (head = node);\r\n        next[0] = node;\r\n      }\r\n\r\n      return node[1][2];\r\n    };\r\n    return registerNode();\r\n  };\r\n\r\n  const invoke = (node: Node | undefined, args: Args) => (\r\n    (next = node?.[2]),\r\n    node\r\n      ? node[1][0](\r\n          ...args,\r\n          (...nextArgs: Args) =>\r\n            invoke(next!, nextArgs.length ? nextArgs : args),\r\n          node[1][2][0]\r\n        )\r\n      : undefined\r\n  );\r\n\r\n  return [register, (...args) => invoke(head, args)];\r\n};\r\n","import { now } from \"@tailjs/util\";\r\n\r\nexport type UUID = string;\r\n\r\nexport let TAB_ID =\r\n  now().toString(36) +\r\n  Math.trunc(1296 * Math.random()) //\r\n    .toString(36)\r\n    .padStart(2, \"0\");\r\n\r\nlet localId = 0;\r\nexport const nextId = () => TAB_ID + \"_\" + nextLocalId();\r\nexport const nextLocalId = () => ++localId;\r\n","import {\r\n  Binders,\r\n  Listener,\r\n  Unbinder,\r\n  clock,\r\n  createEvent,\r\n  createEventBinders,\r\n  createTimer,\r\n  isArray,\r\n  joinEventBinders,\r\n  map,\r\n} from \"@tailjs/util\";\r\n\r\ntype AllMaps = WindowEventMap &\r\n  GlobalEventHandlersEventMap &\r\n  DocumentEventMap &\r\n  HTMLElementEventMap;\r\n\r\nexport const listen = <K extends keyof AllMaps>(\r\n  target: {\r\n    addEventListener(\r\n      type: string,\r\n      listener: EventListenerOrEventListenerObject,\r\n      options?: boolean | AddEventListenerOptions\r\n    ): void;\r\n    removeEventListener(\r\n      type: string,\r\n      listener: EventListenerOrEventListenerObject,\r\n      options?: boolean | EventListenerOptions\r\n    ): void;\r\n  },\r\n  name: K | K[],\r\n  listener: (\r\n    ev: AllMaps[K extends any[] ? K[number] : K],\r\n    unbind?: Unbinder\r\n  ) => any,\r\n  options: AddEventListenerOptions = { capture: true, passive: true }\r\n): Binders => {\r\n  return isArray(name)\r\n    ? joinEventBinders(\r\n        ...map(name, (name) => listen(target, name as any, listener, options))\r\n      )\r\n    : createEventBinders(\r\n        listener,\r\n        (listener) => target.addEventListener(name, listener, options),\r\n        (listener) => target.addEventListener(name, listener, options)\r\n      );\r\n};\r\n\r\ntype PageLoadListenerArgs = [loaded: boolean];\r\nconst [addPageLoadedListener, dispatchPageLoaded] =\r\n  createEvent<PageLoadListenerArgs>();\r\n\r\nlet loaded = true;\r\nlisten(\r\n  window,\r\n  \"pagehide\",\r\n  () => loaded && dispatchPageLoaded((loaded = false))\r\n);\r\nlisten(\r\n  window,\r\n  \"pageshow\",\r\n  () => !loaded && dispatchPageLoaded((loaded = true))\r\n);\r\nlisten(\r\n  document,\r\n  \"visibilitychange\",\r\n  () =>\r\n    document.visibilityState === \"visible\" &&\r\n    !loaded &&\r\n    dispatchPageLoaded((loaded = true))\r\n);\r\n\r\ndispatchPageLoaded(loaded);\r\n\r\ntype PageActivatedListenerArgs = [activated: boolean, totalDuration: number];\r\nlet activated = false;\r\nlet activeTime = createTimer(false);\r\n\r\nconst [addPageActivatedListener, dispatchPageActivated] =\r\n  createEvent<PageActivatedListenerArgs>();\r\n\r\nconst activationTimeout = clock(\r\n  () =>\r\n    activated && dispatchPageActivated((activated = false), activeTime(false)),\r\n  {\r\n    frequency: 20000,\r\n    once: true,\r\n    paused: true,\r\n  }\r\n);\r\nconst setActivated = () =>\r\n  !activated &&\r\n  (dispatchPageActivated((activated = true), activeTime(true)),\r\n  activationTimeout.restart());\r\n\r\nlisten(window, \"focus\", setActivated);\r\nlisten(window, \"blur\", () => activationTimeout.trigger());\r\n\r\nlisten(document.body, \"keydown\", setActivated);\r\nlisten(document.body, \"pointermove\", setActivated);\r\nlisten(window, \"scroll\", setActivated);\r\n\r\nsetActivated();\r\n\r\nexport const getActiveTime = () => activeTime();\r\nexport { addPageLoadedListener, addPageActivatedListener };\r\n","const codes: number[] = [];\nconst chars: number[] = [];\nexport const charCode = (s: string, index = 0) => s.charCodeAt(index);\nexport const fromCharCodes = (chars: number[]) => String.fromCharCode(...chars);\n\n[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"].forEach(\n  (p, i) => (codes[(chars[i] = p.charCodeAt(0))] = i)\n);\n\n/**\n * Encodes an array of bytes to Base64URL without padding (URL safe Base64 using `-` and `_` instead of `+` and `/`).\n *\n * (thanks to Jon Leighton at https://gist.github.com/jonleighton/958841).\n */\nexport const to64u = (bytes: Uint8Array) => {\n  let i = 0;\n  let chunk: number;\n  const n = bytes.length;\n\n  const base64: number[] = [];\n  while (i < n) {\n    chunk = (bytes[i++] << 16) | (bytes[i++] << 8) | bytes[i++];\n    base64.push(\n      chars[(chunk & 16515072) >> 18],\n      chars[(chunk & 258048) >> 12],\n      chars[(chunk & 4032) >> 6],\n      chars[chunk & 63]\n    );\n  }\n  base64.length += n - i;\n\n  return fromCharCodes(base64);\n};\n\n/**\n * Decodes a BaseURL encoded string (without padding).\n */\nexport const from64u = (encoded: string) => {\n  let i = 0;\n  let j = 0;\n  let p: number;\n  const n = encoded.length;\n  const bytes = new Uint8Array(3 * ((n / 4) | 0) + (((n + 3) & 3) % 3));\n  while (i < n) {\n    bytes[j++] =\n      (codes[charCode(encoded, i++)] << 2) |\n      ((p = codes[charCode(encoded, i++)]) >> 4);\n    if (i < n) {\n      bytes[j++] = ((p & 15) << 4) | ((p = codes[charCode(encoded, i++)]) >> 2);\n      if (i < n) {\n        bytes[j++] = ((p & 3) << 6) | codes[charCode(encoded, i++)];\n      }\n    }\n  }\n  return bytes;\n};\n","import { hasValue, isBoolean } from \"..\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  (value: T, bits?: 32 | 64 | 128): string;\n  <B extends boolean>(value: T, numeric: B): B extends true ? number : string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key = \"\"): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (iw = 0; iw < key.length; mixer0 += window0[iw] = key.charCodeAt(iw++));\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero it all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: Uint8Array, numericOrBits: any = 64) => {\n      if (!hasValue(source)) return null;\n      bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n","﻿(function () {\r\n\t\"use strict\";\r\n\r\n\t// Serializes a value to a MessagePack byte array.\r\n\t//\r\n\t// data: The value to serialize. This can be a scalar, array or object.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple values in data are concatenated to multiple MessagePack arrays.\r\n\t// - invalidTypeReplacement: The value that is used to replace values of unsupported types, or a function that returns such a value, given the original value as parameter.\r\n\tfunction serialize(data, options) {\r\n\t\tif (options && options.multiple && !Array.isArray(data)) {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\r\n\t\t}\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet floatBuffer, floatView;\r\n\t\tlet array = new Uint8Array(128);\r\n\t\tlet length = 0;\r\n\t\tif (options && options.multiple) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tappend(data[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tappend(data);\r\n\t\t}\r\n\t\treturn array.subarray(0, length);\r\n\r\n\t\tfunction append(data, isReplacement) {\r\n\t\t\tswitch (typeof data) {\r\n\t\t\t\tcase \"undefined\":\r\n\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\tappendBoolean(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tappendNumber(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tappendString(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif (data === null)\r\n\t\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\telse if (data instanceof Date)\r\n\t\t\t\t\t\tappendDate(data);\r\n\t\t\t\t\telse if (Array.isArray(data))\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\r\n\t\t\t\t\t\tappendBinArray(data);\r\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\r\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\r\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tappendObject(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\r\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendNull(data) {\r\n\t\t\tappendByte(0xc0);\r\n\t\t}\r\n\r\n\t\tfunction appendBoolean(data) {\r\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\r\n\t\t}\r\n\r\n\t\tfunction appendNumber(data) {\r\n\t\t\tif (isFinite(data) && Math.floor(data) === data) {\r\n\t\t\t\t// Integer\r\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0 && data >= -0x20) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\r\n\t\t\t\t\tappendBytes([0xcc, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\r\n\t\t\t\t\tappendBytes([0xd0, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\r\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\r\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\r\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\r\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\r\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\r\n\t\t\t\t\t// 32 bits for bitwise operations.\r\n\t\t\t\t\tlet hi = data / pow32;\r\n\t\t\t\t\tlet lo = data % pow32;\r\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\r\n\t\t\t\t\tappendByte(0xd3);\r\n\t\t\t\t\tappendInt64(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0) {   // below int64\r\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t\telse {   // above uint64\r\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Float\r\n\t\t\t\tif (!floatView) {\r\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\r\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\r\n\t\t\t\t}\r\n\t\t\t\tfloatView.setFloat64(0, data);\r\n\t\t\t\tappendByte(0xcb);\r\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendString(data) {\r\n\t\t\tlet bytes = encodeUtf8(data);\r\n\t\t\tlet length = bytes.length;\r\n\r\n\t\t\tif (length <= 0x1f)\r\n\t\t\t\tappendByte(0xa0 + length);\r\n\t\t\telse if (length <= 0xff)\r\n\t\t\t\tappendBytes([0xd9, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(bytes);\r\n\t\t}\r\n\r\n\t\tfunction appendArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x90 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let index = 0; index < length; index++) {\r\n\t\t\t\tappend(data[index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendBinArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendBytes([0xc4, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(data);\r\n\t\t}\r\n\r\n\t\tfunction appendObject(data) {\r\n\t\t\tlet length = 0;\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tif (data[key] !== undefined) {\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x80 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tlet value = data[key];\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tappend(key);\r\n\t\t\t\t\tappend(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendDate(data) {\r\n\t\t\tlet sec = data.getTime() / 1000;\r\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\r\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\r\n\t\t\t\tappendInt64(sec);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendByte(byte) {\r\n\t\t\tif (array.length < length + 1) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + 1)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray[length] = byte;\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\tfunction appendBytes(bytes) {\r\n\t\t\tif (array.length < length + bytes.length) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + bytes.length)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray.set(bytes, length);\r\n\t\t\tlength += bytes.length;\r\n\t\t}\r\n\r\n\t\tfunction appendInt64(value) {\r\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\r\n\t\t\t// bitwise operations.\r\n\t\t\tlet hi, lo;\r\n\t\t\tif (value >= 0) {\r\n\t\t\t\t// Same as uint64\r\n\t\t\t\thi = value / pow32;\r\n\t\t\t\tlo = value % pow32;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\r\n\t\t\t\tvalue++;\r\n\t\t\t\thi = Math.abs(value) / pow32;\r\n\t\t\t\tlo = Math.abs(value) % pow32;\r\n\t\t\t\thi = ~hi;\r\n\t\t\t\tlo = ~lo;\r\n\t\t\t}\r\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deserializes a MessagePack byte array to a value.\r\n\t//\r\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple concatenated MessagePack arrays are returned as an array.\r\n\tfunction deserialize(array, options) {\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet pos = 0;\r\n\t\tif (array instanceof ArrayBuffer) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\r\n\t\t}\r\n\t\tif (!array.length) {\r\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\r\n\t\t}\r\n\t\tif (!(array instanceof Uint8Array)) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tlet data;\r\n\t\tif (options && options.multiple) {\r\n\t\t\t// Read as many messages as are available\r\n\t\t\tdata = [];\r\n\t\t\twhile (pos < array.length) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Read only one message and ignore additional data\r\n\t\t\tdata = read();\r\n\t\t}\r\n\t\treturn data;\r\n\r\n\t\tfunction read() {\r\n\t\t\tconst byte = array[pos++];\r\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\r\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\r\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\r\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\r\n\t\t\tif (byte === 0xc0) return null;   // nil\r\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\r\n\t\t\tif (byte === 0xc2) return false;   // false\r\n\t\t\tif (byte === 0xc3) return true;   // true\r\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\r\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\r\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\r\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\r\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\r\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\r\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\r\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\r\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\r\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\r\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\r\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\r\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\r\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\r\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\r\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\r\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\r\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\r\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\r\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\r\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\r\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\r\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\r\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\r\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\r\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\r\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\r\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\r\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\r\n\t\t\tconsole.debug(\"msgpack array:\", array);\r\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\r\n\t\t}\r\n\r\n\t\tfunction readInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\tlet first = true;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tlet byte = array[pos++];\r\n\t\t\t\t\tvalue += byte & 0x7f;\r\n\t\t\t\t\tif (byte & 0x80) {\r\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvalue *= 256;\r\n\t\t\t\t\tvalue += array[pos++];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readUInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tvalue *= 256;\r\n\t\t\t\tvalue += array[pos++];\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readFloat(size) {\r\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\r\n\t\t\tpos += size;\r\n\t\t\tif (size === 4)\r\n\t\t\t\treturn view.getFloat32(0, false);\r\n\t\t\tif (size === 8)\r\n\t\t\t\treturn view.getFloat64(0, false);\r\n\t\t}\r\n\r\n\t\tfunction readBin(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = array.subarray(pos, pos + size);\r\n\t\t\tpos += size;\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readMap(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = {};\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tlet key = read();\r\n\t\t\t\tdata[key] = read();\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readArray(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = [];\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readStr(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet start = pos;\r\n\t\t\tpos += size;\r\n\t\t\treturn decodeUtf8(array, start, size);\r\n\t\t}\r\n\r\n\t\tfunction readExt(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet type = readUInt(1);\r\n\t\t\tlet data = readBin(size);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 255:\r\n\t\t\t\t\treturn readExtDate(data);\r\n\t\t\t}\r\n\t\t\treturn { type: type, data: data };\r\n\t\t}\r\n\r\n\t\tfunction readExtDate(data) {\r\n\t\t\tif (data.length === 4) {\r\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\treturn new Date(sec * 1000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 8) {\r\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\r\n\t\t\t\t\t((data[1] << 14) >>> 0) +\r\n\t\t\t\t\t((data[2] << 6) >>> 0) +\r\n\t\t\t\t\t(data[3] >>> 2);\r\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\r\n\t\t\t\t\t((data[4] << 24) >>> 0) +\r\n\t\t\t\t\t((data[5] << 16) >>> 0) +\r\n\t\t\t\t\t((data[6] << 8) >>> 0) +\r\n\t\t\t\t\tdata[7];\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 12) {\r\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\tpos -= 8;\r\n\t\t\t\tlet sec = readInt(8);\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Encodes a string to UTF-8 bytes.\r\n\tfunction encodeUtf8(str) {\r\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\r\n\t\tlet ascii = true, length = str.length;\r\n\t\tfor (let x = 0; x < length; x++) {\r\n\t\t\tif (str.charCodeAt(x) > 127) {\r\n\t\t\t\tascii = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\r\n\t\tfor (let ci = 0; ci !== length; ci++) {\r\n\t\t\tlet c = str.charCodeAt(ci);\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tbytes[i++] = c;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c < 2048) {\r\n\t\t\t\tbytes[i++] = c >> 6 | 192;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\r\n\t\t\t\t\tif (++ci >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\r\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\r\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\r\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\r\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\r\n\t\t\t\t}\r\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\r\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\r\n\t\t\t}\r\n\t\t\tbytes[i++] = c & 63 | 128;\r\n\t\t}\r\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\r\n\t}\r\n\r\n\t// Decodes a string from UTF-8 bytes.\r\n\tfunction decodeUtf8(bytes, start, length) {\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = start, str = \"\";\r\n\t\tlength += start;\r\n\t\twhile (i < length) {\r\n\t\t\tlet c = bytes[i++];\r\n\t\t\tif (c > 127) {\r\n\t\t\t\tif (c > 191 && c < 224) {\r\n\t\t\t\t\tif (i >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\r\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 223 && c < 240) {\r\n\t\t\t\t\tif (i + 1 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\r\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 239 && c < 248) {\r\n\t\t\t\t\tif (i + 2 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\r\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\r\n\t\t\t}\r\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\r\n\t\t\telse if (c <= 0x10ffff) {\r\n\t\t\t\tc -= 0x10000;\r\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\r\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\r\n\t\t\t}\r\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\r\n\t// The exported functions\r\n\tlet msgpack = {\r\n\t\tserialize: serialize,\r\n\t\tdeserialize: deserialize,\r\n\r\n\t\t// Compatibility with other libraries\r\n\t\tencode: serialize,\r\n\t\tdecode: deserialize\r\n\t};\r\n\r\n\t// Environment detection\r\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\r\n\t\t// Node.js\r\n\t\tmodule.exports = msgpack;\r\n\t}\r\n\telse {\r\n\t\t// Global object\r\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\r\n\t}\r\n\r\n})();\r\n","import { deserialize, serialize } from \"@ygoe/msgpack\";\n\nimport { HashFunction, from64u, lfsr, to64u } from \".\";\nimport {\n  IsNever,\n  Nullish,\n  hasValue,\n  isArray,\n  isDefined,\n  isFunction,\n  isIterable,\n  isNumber,\n  isObject,\n  isString,\n  isSymbol,\n  isUndefined,\n  map,\n  tryCatch,\n} from \"..\";\nimport { isStringObject } from \"util/types\";\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\nexport type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the constract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properies that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param validate This property has no effect other than letting TypeScript validate whether the value can be deserialized back to its original form without losing properties.\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  (value: any, validate?: false): string;\n  <T = Encodable>(value: T & EncodableContract<T>, validate: true): string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(encoded: string | Nullish) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\nconst floatBuffer = new ArrayBuffer(8);\nconst floatView = new DataView(floatBuffer);\n\n/**\n * Misc. fixes to the msgpack library. For example, it does not handle exponential numbers well.\n */\nconst patchSerialize = (value: any) => {\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number;\n  const patchProperty = (\n    value: any,\n    key: any,\n    val = value[key],\n    patched = inner(val)\n  ) => (\n    (val !== patched || isSymbol(key)) &&\n      ((value[key] = patched), addCleaner(() => (value[key] = val))),\n    val\n  );\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (value == null || isFunction(value) || isSymbol(value)) {\n      return null;\n    }\n\n    if (Number.isFinite(value) && !Number.isSafeInteger(value)) {\n      floatView.setFloat64(0, value, true);\n\n      return { \"\": [...new Uint32Array(floatBuffer)] };\n    }\n\n    if (!isObject(value, true)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if (isDefined((refIndex = (refs ??= new Map()).get(value)))) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isObject(value)) {\n      refs.set(value, refs.size + 1);\n\n      Object.keys(value).forEach(\n        (k) =>\n          (isUndefined(patchProperty(value, k)) || isSymbol(k)) &&\n          delete value[k]\n      );\n    } else if (isIterable(value)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  const serialized = serialize(inner(value));\n  cleaners?.forEach((cleaner) => cleaner());\n  return serialized;\n};\n\nconst patchDeserialize = (value: Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value, true)) return value;\n\n    if (isArray(value[\"\"]) && (value = value[\"\"]).length === 2) {\n      return new DataView(new Uint32Array(value).buffer).getFloat64(0, true);\n    }\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return hasValue(value)\n    ? tryCatch(\n        () => inner(deserialize(value)),\n        () => undefined\n      )\n    : undefined;\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<any>\n];\n\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lsfr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (\n  key?: null | string,\n  json = false\n): Transport => {\n  const [encrypt, decrypt, hash] = lfsr(key ?? \"\");\n  const fastStringHash = (value: any, bitsOrNumeric: any) => {\n    if (isNumber(value) && bitsOrNumeric === true) return value;\n\n    value = isString(value)\n      ? new Uint8Array(map(value.length, (i) => value.charCodeAt(i) & 255))\n      : json\n      ? JSON.stringify(value)\n      : patchSerialize(value);\n    return hash(value, bitsOrNumeric);\n  };\n  return json\n    ? [\n        (data: any) => JSON.stringify(data),\n        (encoded) =>\n          encoded == null\n            ? undefined\n            : tryCatch(() => JSON.parse(encoded, undefined)),\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ]\n    : [\n        (data: any) => to64u(encrypt(patchSerialize(data))),\n        (encoded: any) =>\n          hasValue(encoded)\n            ? patchDeserialize(decrypt(from64u(encoded)))\n            : null,\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ];\n};\n\nexport const defaultTransport = createTransport();\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\n","import {\r\n  Binders,\r\n  Listener,\r\n  clear,\r\n  clock,\r\n  createEvent,\r\n  forEach,\r\n  isDefined,\r\n  isString,\r\n  isUndefined,\r\n  joinEventBinders,\r\n  now,\r\n} from \"@tailjs/util\";\r\nimport { createTransport } from \"@tailjs/util/transport\";\r\nimport { DEBUG, TAB_ID, addPageLoadedListener, error, listen, log } from \".\";\r\n\r\nexport type Metadata<T = any> = [value: T, source?: string, expires?: number];\r\n\r\nexport type StorageProviderObserver<T = any> = (\r\n  newValue: T | undefined,\r\n  oldValue: T | undefined,\r\n  key: string | null\r\n) => void;\r\n\r\nexport interface StorageProvider {\r\n  getItem<T = any>(key: string): [value: T, source?: string] | undefined;\r\n  setItem<T = any>(\r\n    key: string,\r\n    value: T,\r\n    source?: string,\r\n    timeout?: number\r\n  ): void;\r\n  removeItem(key: string): void;\r\n  observe?<T = any>(key: string, observer: StorageProviderObserver<T>): Binders;\r\n}\r\n\r\ntype TypedStorageObserverArgs<T = any> = [\r\n  newValue: T | undefined,\r\n  context: {\r\n    key: string | null;\r\n    oldValue: string | undefined;\r\n    source?: string | undefined;\r\n    self?: boolean;\r\n  }\r\n];\r\nexport type TypedStorageObserver<T = any> = Listener<\r\n  TypedStorageObserverArgs<T>\r\n>;\r\n\r\nexport interface TypedStorage {\r\n  get<T = any>(key: string): T | undefined;\r\n  set<T>(key: string, value: T, timeout?: number): T;\r\n  delete(key: string): void;\r\n  update<T = any>(\r\n    key: string,\r\n    newValue: (current: T | undefined) => T,\r\n    timeout?: number\r\n  ): T;\r\n  observe?<T = any>(\r\n    key: string,\r\n    observer: TypedStorageObserver<T>,\r\n    includeSelf?: boolean\r\n  ): Binders;\r\n}\r\n\r\nexport interface BoundStorage<T = any> {\r\n  get(): T | undefined;\r\n  set<Undefined extends undefined | never = never>(\r\n    value: T | undefined,\r\n    timeout?: number\r\n  ): T | Undefined;\r\n  delete(): void;\r\n  update<Undefined extends undefined | T = T>(\r\n    newValue: (current: T | undefined) => T | Undefined,\r\n    timeout?: number\r\n  ): T | Undefined;\r\n  observe?(observer: TypedStorageObserver<T>, observeSelf?: boolean): Binders;\r\n}\r\n\r\n// TODO: Initialize from tailjs.init.\r\nexport const [serialize, deserialize] = createTransport(\"foo\", DEBUG);\r\n\r\nexport const mapStorage = <P extends StorageProvider>(\r\n  provider: P\r\n): P[\"observe\"] extends undefined ? TypedStorage : Required<TypedStorage> => {\r\n  const [addOwnListener, dispatchOwn] = createEvent<TypedStorageObserverArgs>();\r\n\r\n  const get = (key: string) => provider.getItem(key)?.[0];\r\n\r\n  const set = <T>(key: string, value: T | undefined, timeout?: number) => {\r\n    const oldValue = get(key);\r\n    if (isUndefined(value)) {\r\n      provider.removeItem(key);\r\n      dispatchOwn(undefined, { key, oldValue, source: TAB_ID, self: true });\r\n    } else {\r\n      provider.setItem(key, value, TAB_ID, timeout);\r\n      dispatchOwn(value, { key, oldValue, source: TAB_ID, self: true });\r\n    }\r\n    if ((timeout as any) <= 0) {\r\n      provider.removeItem(key);\r\n    }\r\n    return value as any;\r\n  };\r\n\r\n  let retries = 0;\r\n  const update = <T>(\r\n    key: string,\r\n    newValue: (current: T | undefined) => T | undefined,\r\n    timeout: number\r\n  ) => {\r\n    if (retries++ > 3) {\r\n      error(`Race condition ('${key}').`, true);\r\n    }\r\n    const value = set(key, newValue(provider.getItem<T>(key)?.[0]), timeout);\r\n    const writtenValue = provider.getItem(key);\r\n    if (writtenValue?.[1] && writtenValue?.[1] !== TAB_ID) {\r\n      return update(key, newValue, timeout);\r\n    }\r\n    retries = 0;\r\n    return value;\r\n  };\r\n\r\n  return {\r\n    get,\r\n    set,\r\n    delete: (key) => set(key, undefined),\r\n    update,\r\n    observe: provider.observe\r\n      ? (key, listener, observeSelf) => {\r\n          const [unbind, bind] = joinEventBinders(\r\n            provider.observe!(key, (newValue, oldValue, key) =>\r\n              listener(\r\n                newValue?.[0],\r\n                { key, oldValue: oldValue?.[0], source: newValue?.[1] },\r\n                unbind\r\n              )\r\n            ),\r\n            observeSelf\r\n              ? addOwnListener(\r\n                  (value, context, unbind) =>\r\n                    context.key === key && listener(value, context, unbind)\r\n                )\r\n              : undefined\r\n          );\r\n          return [unbind, bind];\r\n        }\r\n      : undefined,\r\n  } as TypedStorage as any;\r\n};\r\n\r\nconst parsePayload = (value: any): [value: string, timeout?: number] => {\r\n  if (!isString(value)) return [value];\r\n\r\n  const [, payload, parsedTimeout] = value.match(/(.*?)(?:@:([0-9a-z]+))?$/)!;\r\n  return [\r\n    payload,\r\n    isDefined(parsedTimeout) ? parseInt(parsedTimeout, 36) : undefined,\r\n  ];\r\n};\r\nconst purgeIfExpired = (key: string, value: any) => {\r\n  const [payload, timeout] = parsePayload(value);\r\n  if (timeout && timeout - now() < 0) {\r\n    clear(localStorage, key);\r\n    return undefined;\r\n  }\r\n  return payload;\r\n};\r\n\r\nexport const sharedStorage = mapStorage({\r\n  getItem: (key) => deserialize(purgeIfExpired(key, localStorage.getItem(key))),\r\n  setItem: (key, value, source, timeout) =>\r\n    localStorage.setItem(\r\n      key,\r\n      serialize([value, source]) +\r\n        (timeout! > 0 ? `@:${(now() + timeout!).toString(36)}` : \"\")\r\n    ),\r\n  removeItem: (key) => localStorage.removeItem(key),\r\n  observe: (key, observer) => {\r\n    const [unbind, bind] = listen(\r\n      window,\r\n      \"storage\",\r\n      ({ key: changedKey, newValue, oldValue }) =>\r\n        key == changedKey &&\r\n        observer(\r\n          deserialize(parsePayload(newValue)[0]),\r\n          deserialize(parsePayload(oldValue)[0]),\r\n          key\r\n        )\r\n    );\r\n\r\n    return joinEventBinders(\r\n      [unbind, bind],\r\n      addPageLoadedListener((loaded) => (loaded ? bind() : unbind()))\r\n    );\r\n  },\r\n});\r\n\r\nconst purgeTask = clock(\r\n  () => {\r\n    forEach(localStorage, ([key, value]) => !purgeIfExpired(key as any, value));\r\n  },\r\n  {\r\n    frequency: 2000,\r\n    trigger: true,\r\n  }\r\n);\r\naddPageLoadedListener((loaded) => purgeTask.toggle(loaded));\r\n\r\nexport const bindStorage: {\r\n  <T>(\r\n    key: string,\r\n    defaultTimeout?: number,\r\n    storage?: Required<TypedStorage>\r\n  ): Required<BoundStorage<T>>;\r\n  <T>(\r\n    key: string,\r\n    defaultTimeout?: number,\r\n    storage?: TypedStorage\r\n  ): BoundStorage<T>;\r\n} = <T>(\r\n  key: string,\r\n  defaultTimeout?: number,\r\n  storage: TypedStorage = sharedStorage\r\n): Required<BoundStorage<T>> => ({\r\n  get: () => storage.get<T>(key),\r\n  set: (value, timeout) =>\r\n    storage.set(key, value as any, timeout ?? defaultTimeout),\r\n  delete: () => storage.delete(key),\r\n  update: (updater, timeout) =>\r\n    storage.update(key, updater as any, timeout ?? defaultTimeout),\r\n  observe: storage.observe\r\n    ? (observer, includeSelf) => storage.observe!(key, observer, includeSelf)\r\n    : undefined!,\r\n});\r\n","export const DEBUG = true;\r\nexport const TAB_HEARTBEAT = 5_000;\r\nexport const STATE_KEY = \"_t.sr\";\r\n","import {\r\n  filter,\r\n  isDefined,\r\n  isObject,\r\n  joinEventBinders,\r\n  map,\r\n} from \"@tailjs/util\";\r\nimport { TAB_ID, bindStorage, sharedStorage } from \".\";\r\n\r\n/**\r\n * A channel is used by tabs to communicate with each other.\r\n */\r\nexport type Channel<T> = {\r\n  /**\r\n   * Posts a message in the channel.\r\n   *\r\n   * @param payload The payload of the message.\r\n   * @param target If specified, on the tab with this ID will get the message.\r\n   */\r\n  post(payload: T, target?: string): void;\r\n\r\n  /**\r\n   * Stop receiving messages from the channel.\r\n   * A tab automatically subscribes/unsubscribes when it enters and leaves bfcache.\r\n   */\r\n  unsubscribe: () => void;\r\n};\r\n\r\ntype ChannelPayload<T> = [sender: string, payload: T, target?: string];\r\n\r\n/**\r\n * Subscribes to the channel with the specified id.\r\n */\r\nexport const subscribeChannel = <T>(\r\n  id: string,\r\n  handler: (sender: string, payload: T, direct: boolean) => void,\r\n  listenSelf = false,\r\n  storage = sharedStorage\r\n): Channel<T> => {\r\n  const channel = bindStorage<ChannelPayload<T>>(id, 0, storage);\r\n  return {\r\n    post: (payload, target) => channel.set([TAB_ID, payload, target]),\r\n    unsubscribe: channel.observe(\r\n      (value) =>\r\n        isDefined(value) &&\r\n        (!value[2] || value[2] === TAB_ID) &&\r\n        handler(value[0], value[1], isDefined(value[2])),\r\n      listenSelf\r\n    )[0],\r\n  };\r\n};\r\n\r\nlet chatChannel: Channel<[message: string, error?: string]> | undefined;\r\nexport const error: {\r\n  (message: string, fatal: boolean): void;\r\n  (message: string, cause?: any, fatal?: boolean);\r\n} = (message: string, error?: any, throwError = false) => {\r\n  if (typeof error === \"boolean\") {\r\n    throwError = error;\r\n    error = null;\r\n  }\r\n  log(error ? message : null, error ?? message);\r\n  if (throwError) {\r\n    throw new Error(message);\r\n  }\r\n};\r\n\r\nexport const log = (message: any, error?: any) => {\r\n  const source = message;\r\n  if (error) {\r\n    error = JSON.stringify(\r\n      (error = isObject(error)\r\n        ? {\r\n            message: error.message ?? error,\r\n            stack: error.stack,\r\n          }\r\n        : error)\r\n    );\r\n  }\r\n\r\n  message = JSON.stringify(message);\r\n  (chatChannel ??= subscribeChannel<[string, string]>(\r\n    \"chat\",\r\n    (sender, parts) =>\r\n      console[parts[1] ? \"error\" : \"log\"](\r\n        sender === TAB_ID ? \"This tab\" : `Other tab (${sender})`,\r\n        ...map(filter(parts), (value) => JSON.parse(value))\r\n      ),\r\n    true\r\n  )).post([message, error]);\r\n  return source;\r\n};\r\n","import { clear, clock, createEvent, forEach, now, set } from \"@tailjs/util\";\r\nimport {\r\n  TAB_HEARTBEAT,\r\n  TAB_ID,\r\n  addPageLoadedListener,\r\n  subscribeChannel,\r\n} from \".\";\r\n\r\nexport type TabState = {\r\n  id: string;\r\n  hearbeat: number;\r\n  viewId?: string;\r\n  navigated?: number;\r\n};\r\n\r\nexport type State = {\r\n  knownTabs: Record<string, TabState>;\r\n  variables: Record<string, any>;\r\n};\r\n\r\nconst tabState: TabState = {\r\n  id: TAB_ID,\r\n  hearbeat: now(),\r\n};\r\n\r\nconst state: State = {\r\n  knownTabs: {\r\n    [TAB_ID]: tabState,\r\n  },\r\n  variables: {},\r\n};\r\n\r\ntype StateMessage =\r\n  | { type: \"query\"; data?: undefined }\r\n  | {\r\n      type: \"set\";\r\n      data: State;\r\n    }\r\n  | {\r\n      type: \"patch\";\r\n      data: State[\"variables\"];\r\n    }\r\n  | {\r\n      type: \"tab\";\r\n      data?: TabState;\r\n    };\r\n\r\nconst initTimeout = clock(() => dispatchState(\"ready\", { state }), -25);\r\nconst stateChannel = subscribeChannel<StateMessage>(\r\n  \"state\",\r\n  (sender, { type, data }) => {\r\n    if (type === \"query\") {\r\n      !initTimeout.active &&\r\n        stateChannel.post({ type: \"set\", data: state }, sender);\r\n    } else if (type === \"set\" && initTimeout.active) {\r\n      set(state, data);\r\n      initTimeout.trigger();\r\n    } else if (type === \"patch\") {\r\n      set(state, data);\r\n      dispatchState(\"update\", { state, variables: data });\r\n    } else if (type === \"tab\") {\r\n      set(state.knownTabs, sender, data);\r\n      dispatchState(\"update\", { state, tab: data });\r\n    }\r\n  }\r\n);\r\n\r\nconst [addStateListener, dispatchState] = createEvent<\r\n  [\r\n    event: \"ready\" | \"update\",\r\n    state: {\r\n      state: State;\r\n      variables?: State[\"variables\"];\r\n      tab?: TabState;\r\n    }\r\n  ]\r\n>();\r\n\r\nconst heartbeat = clock(() => {\r\n  const timeout = now() - TAB_HEARTBEAT * 2;\r\n  forEach(\r\n    state?.knownTabs,\r\n    // Remove interval tabs.\r\n    ([tabId, tabState]) =>\r\n      tabState[0] < timeout && clear(state!.knownTabs, tabId)\r\n  );\r\n  tabState.hearbeat = now();\r\n  stateChannel.post({ type: \"tab\", data: tabState });\r\n}, TAB_HEARTBEAT);\r\n\r\nconst toggleTab = (loading: boolean) => {\r\n  stateChannel.post({ type: \"tab\", data: loading ? tabState : undefined });\r\n  if (loading) {\r\n    initTimeout.restart();\r\n    stateChannel.post({ type: \"query\" });\r\n  } else {\r\n    initTimeout.toggle(false);\r\n  }\r\n  heartbeat.toggle(loading);\r\n};\r\n\r\naddPageLoadedListener((loaded) => toggleTab(loaded), true);\r\n\r\nexport { addStateListener };\r\n","import { clock } from \"@tailjs/util\";\r\nimport { listen, log } from \".\";\r\n\r\nconst eventQueue: string[] = [];\r\n\r\nconst poster = clock(() => {\r\n  if (eventQueue.length) {\r\n    //log([\"Posting\", eventQueue.splice(0)]);\r\n  }\r\n}, 5000);\r\n\r\nexport const enqueueEvent = (event: string) => {\r\n  eventQueue.push(event);\r\n};\r\n\r\nlisten(\r\n  document,\r\n  \"visibilitychange\",\r\n  () => document.visibilityState === \"hidden\" && poster.trigger()\r\n);\r\n\r\n// const postLock = createLock<string[]>(\"test_queue_lck\", 2000);\r\n// export const post = async (data: string[]) => {\r\n//   if (\r\n//     !(\r\n//       await postLock(async () => {\r\n//         let pending: string[] | undefined;\r\n//         await tryCatchAsync(\r\n//           async () => {\r\n//             for (;;) {\r\n//               postLock.data.update(\r\n//                 (current) => ((pending = current!), undefined)\r\n//               );\r\n//               if (data) {\r\n//                 pending = [...(pending ?? []), ...data];\r\n//                 data = undefined as any;\r\n//               }\r\n//               if (!pending) {\r\n//                 break;\r\n//               }\r\n\r\n//               log([\"Posting\", pending]);\r\n//               await delay(2000);\r\n//               if (Math.random() < 0.5) {\r\n//                 throw new Error(\"Eeek!\");\r\n//               }\r\n//               log(`Posted ${pending.length} item(s).`);\r\n//             }\r\n//           },\r\n//           async (e, last) => {\r\n//             if (last) {\r\n//               error(\r\n//                 `Post failed 3 times in a row, events will not be sent.`,\r\n//                 e\r\n//               );\r\n//               throw e;\r\n//             } else {\r\n//               pending &&\r\n//                 postLock.data.update(\r\n//                   (current) => ((current ??= []).unshift(...pending!), current)\r\n//                 );\r\n//               error(`Post failed, retrying...`, e);\r\n//               await delay(250);\r\n//             }\r\n//           },\r\n//           undefined,\r\n//           3\r\n//         );\r\n//       }, 0)\r\n//     )[1]\r\n//   ) {\r\n//     postLock.data.update(\r\n//       (current) => ((current ??= []).push(...data), current)\r\n//     );\r\n//     log(\"Another post is active. Queued data.\");\r\n//   }\r\n// };\r\n","import {\r\n  addPageActivatedListener,\r\n  addStateListener,\r\n  getActiveTime,\r\n  listen,\r\n  log,\r\n  enqueueEvent,\r\n} from \"./lib2\";\r\n\r\n//const lck = createLock(\"test\");\r\nexport const attach = async () => {\r\n  addPageActivatedListener((activated) => {\r\n    // console.log(\r\n    //   `Activated: ${activated}. Total active time: ${getActiveTime()}.`\r\n    // );\r\n  }, true);\r\n\r\n  addStateListener((event, state) => {\r\n    log(state.tab);\r\n  });\r\n\r\n  listen(document.body, \"click\", () => {\r\n    enqueueEvent(\"Click!\");\r\n  });\r\n\r\n  // let invocations = 0;\r\n  // let clicked = false;\r\n  // const pump = clock(\r\n  //   async () => {\r\n  //     const capturedClick = clicked;\r\n  //     if (!clicked && invocations % 2 === 1) {\r\n  //       await wait(1500);\r\n  //     }\r\n  //     console.log(`${++invocations}, clicked: ${capturedClick}.`);\r\n  //   },\r\n  //   { frequency: 1000, queue: false }\r\n  // );\r\n\r\n  // let testId = 1;\r\n  // listen(document.body, \"click\", async (e) => {\r\n  //   // clicked = true;\r\n  //   // console.log(pump.active, pump.busy);\r\n  //   // e.shiftKey && pump.toggle(!pump.active);\r\n  //   // console.log(await pump.trigger(true));\r\n  //   // (async () => {\r\n  //   //   clicked = false;\r\n  //   // })();\r\n  //   post([`Test ${testId++}`]);\r\n  // });\r\n  // listen(document.body, \"click\", () => {\r\n  //   updateTabState((tab) => (tab.navigated = now()));\r\n\r\n  //   lck(async () => {\r\n  //     console.log(\"Lock acquired.\");\r\n  //     await wait(5000);\r\n  //   });\r\n  // });\r\n  // listen(\r\n  //   window,\r\n  //   \"pageshow\",\r\n  //   () =>\r\n  //     activeTabs.update(\r\n  //       (current) => (\r\n  //         ((current = cast(current, isObject) ?? {})[TAB_ID] = now()), current\r\n  //       )\r\n  //     )\r\n  //   //activeStorage.update((current) => (current ?? 0) + 1)\r\n  // );\r\n  // listen(\r\n  //   window,\r\n  //   \"pagehide\",\r\n  //   () =>\r\n  //     activeTabs.update(\r\n  //       (current) => (isObject(current) && delete current[TAB_ID], current)\r\n  //     )\r\n  //   // activeStorage.update((current: any) =>\r\n  //   //   current > 0 ? current - 1 : current\r\n  //   // )\r\n  // );\r\n};\r\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\n//import { initializeTracker } from \"./initializeTracker\";\n//import { F, T, define, window } from \"./lib\";\nimport { attach } from \"./pusher\";\n\n// This assumes the script is loaded from the RequestHandler's ?cfg route.\n\n// To prevent external scripts from eaves-dropping and get a hold of the storage key, this is how initialization works:\n// 1: The configuration scripts appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overriden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nwindow[INITIALIZE_TRACKER_FUNCTION] = (callback: any) => {\n  callback(attach);\n};\n\n// let loaded = F;\n// define(window, {\n//   [INITIALIZE_TRACKER_FUNCTION]: [\n//     (callback: (init: typeof initializeTracker) => void) => {\n//       if (loaded === (loaded = T)) return;\n//       callback(initializeTracker);\n//     },\n//   ],\n// });\n"],"names":["undefined","tryCatch","expression","errorHandler","clean","e","isBoolean","console","error","isUndefined","value","isDefined","hasValue","isTruish","isNumber","isString","capturedIsArray","Array","isArray","toArray","clone","isIterable","isObject","acceptIterables","hasMethod","name","isSymbol","isFunction","acceptStrings","Symbol","iterator","sliceIterator","source","start","end","item","Number","MAX_SAFE_INTEGER","createControllableIterator","action","collect","result","i","flag","control","prev","skip","mapIterator","Object","entries","step","maxIterations","createNavigatingIterator","length","offset","createRangeIterator","map","projection","rest","unshift","filter","forEach","innerReturnValue","returnValue","index","_","reduce","reducer","seed","filterIterator","get","target","key","initializer","has","set","args","bulk","setSingle","clear","add","delete","every","assign","k","v","keys","current","splice","now","performance","Math","trunc","timeOrigin","Date","clock","callback","settings","frequency","queue","paused","trigger","once","timeoutId","mutex","promise","resolve","outerCallback","async","skipQueue","resolved","instance","busy","reset","cancelled","retries","tryCatchAsync","clearInterval","active","setInterval","restart","newFrequency","newCallback","toggle","initialValue","capturedResolve","capturedReject","currentPromise","Promise","reject","signal","then","wait","timeout","race","delay","setTimeout","createEventBinders","listener","attach","detach","bound","outerListener","unbind","rebind","joinEventBinders","binders","changed","binder","createEvent","dispatchedArgs","listeners","Set","handler","payload","TAB_ID","toString","random","padStart","listen","options","capture","passive","addEventListener","addPageLoadedListener","dispatchPageLoaded","loaded","window","document","visibilityState","activated","activeTime","started","t0","elapsed","createTimer","addPageActivatedListener","dispatchPageActivated","activationTimeout","setActivated","body","codes","chars","charCode","s","charCodeAt","p","FNVs","entropy","max","serialize","data","multiple","Error","floatBuffer","floatView","pow32","array","Uint8Array","append","subarray","isReplacement","appendNull","appendByte","appendBoolean","isFinite","floor","appendBytes","hi","lo","appendInt64","ArrayBuffer","DataView","setFloat64","appendNumber","bytes","str","ascii","x","ci","c","c2","encodeUtf8","appendString","sec","getTime","getMilliseconds","ns","appendDate","appendArray","Uint8ClampedArray","appendBinArray","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","appendObject","invalidTypeReplacement","byte","newLength","newArray","abs","deserialize","pos","push","read","readMap","readArray","readStr","readBin","readExt","readFloat","readUInt","readInt","debug","size","first","view","buffer","byteOffset","getFloat32","getFloat64","lengthSize","String","fromCharCode","decodeUtf8","type","readExtDate","msgpack","encode","decode","module","exports","msgpackJsName","REF_PROP","patchSerialize","cleaners","refs","refIndex","patchProperty","val","patched","inner","addCleaner","cleaner","isSafeInteger","toJSON","Map","serialized","createTransport","json","encrypt","decrypt","hash","n","j","pad","bits","prime","mixer","mixer255","iw","mixer0","window0","resetMixer","updateMixer","ENTROPY","cipher","numericOrBits","BigInt","asUintN","MIN_SAFE_INTEGER","lfsr","fastStringHash","bitsOrNumeric","JSON","stringify","encoded","parse","chunk","base64","to64u","from64u","matchedRef","parsePayload","parsedTimeout","match","parseInt","purgeIfExpired","localStorage","sharedStorage","provider","addOwnListener","dispatchOwn","getItem","oldValue","removeItem","self","setItem","update","newValue","writtenValue","observe","observeSelf","bind","context","mapStorage","observer","changedKey","purgeTask","chatChannel","subscribeChannel","id","listenSelf","storage","channel","defaultTimeout","updater","includeSelf","bindStorage","post","unsubscribe","message","throwError","log","stack","sender","parts","tabState","hearbeat","state","knownTabs","variables","initTimeout","dispatchState","stateChannel","tab","addStateListener","heartbeat","TAB_HEARTBEAT","tabId","toggleTab","loading","poster","event"],"mappings":"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","x_google_ignoreList":[11]}