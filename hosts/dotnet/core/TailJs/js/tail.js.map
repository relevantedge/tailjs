{"version":3,"file":"tail.js","sources":["../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/client/src/lib2/storage.ts","../../../../../npm/packages/@tailjs/util/src/types.ts","../../../../../npm/packages/@tailjs/client/src/lib2/ids.ts","../../../../../npm/packages/@tailjs/client/src/lib2/dom.ts","../../../../../npm/packages/@tailjs/client/src/lib2/channel.ts","../../../../../npm/packages/@tailjs/client/src/pusher.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["// MUST MATCH packages\\@tailjs\\engine\\src\\RequestHandler.ts\nexport const MUTEX_REQUEST_COOKIE = \".tail.rq\";\nexport const MUTEX_RESPONSE_COOKIE = \".tail.rs\";\nexport const CONTEXT_MENU_COOKIE = \".tail.cm\";\n\nexport const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_MENU_QUERY = \"mnt\";\n","import { tryCatch } from \"@tailjs/util\";\r\nimport { Binders, TAB_ID, error, listen } from \".\";\r\n\r\ntype Observer<T = any> = (\r\n  newValue: T | null,\r\n  oldValue: T | null,\r\n  key: string | null\r\n) => void;\r\n\r\nexport type Metadata<T = any> = [value: T, source?: string, expires?: number];\r\n\r\nexport interface StorageProvider {\r\n  getItem<T = any>(key: string): Metadata<T> | null;\r\n  setItem<T>(key: string, value: Metadata<T>): void;\r\n  removeItem(key: string): void;\r\n  observe?<T>(key: string, observer: Observer<T>): Binders;\r\n}\r\n\r\nexport interface TypedStorage {\r\n  get<T = any>(key: string): T | null;\r\n  set<T>(key: string, value: T, timeout?: number): T;\r\n  delete(key: string): void;\r\n  update<T = any>(\r\n    key: string,\r\n    newValue: (current: T | null) => T,\r\n    timeout?: number\r\n  ): T;\r\n  observe?<T = any>(key: string, observer: Observer<T>): Binders;\r\n}\r\n\r\nexport interface BoundStorage<T = any> {\r\n  get(): T | null;\r\n  set<Nulls extends null | undefined = never>(\r\n    value: T | Nulls,\r\n    timeout?: number\r\n  ): T | Nulls;\r\n  delete(): void;\r\n  update<Nulls extends null | undefined = never>(\r\n    newValue: (current: T | null) => T | Nulls,\r\n    timeout?: number\r\n  ): T | Nulls;\r\n  observe?(observer: Observer<T>): Binders;\r\n}\r\n\r\nconst serialize = JSON.stringify;\r\n\r\nconst deserialize: {\r\n  <T = any>(payload: string | null | undefined): T | null;\r\n} = (payload: string | null) =>\r\n  payload == null\r\n    ? null\r\n    : tryCatch(\r\n        () => JSON.parse(payload),\r\n        () => null\r\n      );\r\n\r\nexport const mapStorage = <P extends StorageProvider>(\r\n  provider: P\r\n): P[\"observe\"] extends undefined ? TypedStorage : Required<TypedStorage> => {\r\n  const set = <T>(key: string, value: T | null, timeout?: number) => {\r\n    if (value == null) {\r\n      provider.removeItem(key);\r\n    } else {\r\n      provider.setItem(key, [value, TAB_ID, timeout]);\r\n    }\r\n    return value as any;\r\n  };\r\n\r\n  let retries = 0;\r\n  const update = <T>(\r\n    key: string,\r\n    newValue: (current: T | null) => T | null,\r\n    timeout: number\r\n  ) => {\r\n    if (retries++ > 3) {\r\n      error(`Race condition ('${key}').`, true);\r\n    }\r\n    const value = set(key, newValue(provider.getItem<T>(key)?.[0] ?? null));\r\n    const writtenValue = provider.getItem(key);\r\n    if (writtenValue?.[1] && writtenValue?.[1] !== TAB_ID) {\r\n      return update(key, newValue, timeout);\r\n    }\r\n    retries = 0;\r\n    return value;\r\n  };\r\n\r\n  return {\r\n    get: (key) => provider.getItem(key)?.[0] ?? null,\r\n    set,\r\n    delete: (key) => set(key, null),\r\n    update,\r\n    observe: provider.observe ? provider.observe.bind(provider) : undefined,\r\n  };\r\n};\r\n\r\nexport const sharedStorage = mapStorage({\r\n  getItem: (key) => deserialize(localStorage.getItem(key)),\r\n  setItem: (key, value) =>\r\n    localStorage.setItem(\r\n      key,\r\n      serialize(value.filter((value) => value != null))\r\n    ),\r\n  removeItem: (key) => localStorage.removeItem(key),\r\n  observe: (key, observer) => {\r\n    const [unbind, bind] = listen(\r\n      window,\r\n      \"storage\",\r\n      ({ key: changedKey, newValue, oldValue }) =>\r\n        key == changedKey &&\r\n        observer(deserialize(newValue), deserialize(oldValue), key)\r\n    );\r\n\r\n    const [unbindShow, bindShow] = listen(window, \"pageshow\", bind);\r\n    const [unbindHide, bindHide] = listen(window, \"pagehide\", unbind);\r\n\r\n    return [\r\n      () => {\r\n        unbindHide();\r\n        unbindShow();\r\n        return unbind();\r\n      },\r\n      () => {\r\n        bindHide();\r\n        bindShow();\r\n        return bind();\r\n      },\r\n    ];\r\n  },\r\n});\r\n\r\nexport const bindStorage: {\r\n  <T>(key: string, storage?: Required<TypedStorage>): Required<BoundStorage<T>>;\r\n  <T>(key: string, storage: TypedStorage): BoundStorage<T>;\r\n} = <T>(\r\n  key: string,\r\n  storage: TypedStorage = sharedStorage\r\n): Required<BoundStorage<T>> => ({\r\n  get: () => storage.get<T>(key),\r\n  set: (value, timeout) => storage.set(key, value, timeout),\r\n  delete: () => storage.delete(key),\r\n  update: (updater, timeout) => storage.update(key, updater as any, timeout),\r\n  observe: storage.observe\r\n    ? (observer) => storage.observe!(key, observer)\r\n    : undefined!,\r\n});\r\n\r\nexport const bindStickyStorage = <T>(\r\n  key: string,\r\n  storage: Required<TypedStorage> = sharedStorage\r\n): Required<BoundStorage<T>> => {\r\n  if (!storage.observe) {\r\n    throw new TypeError(\"Storage must be observable.\");\r\n  }\r\n\r\n  type V = [value: T | null, version: number];\r\n\r\n  const inner = bindStorage<V>(key, storage);\r\n  let current: V = inner.get() ?? [null, 0];\r\n  let stored: V | null;\r\n\r\n  const isValid = (stored: any | null) =>\r\n    stored === null || (stored.length === 2 && typeof stored[1] === \"number\");\r\n  const isStale = (stored: V | null) => !((stored?.[1] as any) >= current[1]);\r\n\r\n  const ensureValue = () => {\r\n    stored = inner.get();\r\n    if (isStale(stored)) {\r\n      inner.set(current);\r\n      return current;\r\n    }\r\n    return (current = stored!);\r\n  };\r\n\r\n  inner.observe((value) => {\r\n    if (isStale(value)) {\r\n      ensureValue();\r\n    } else {\r\n      current = value!;\r\n    }\r\n  });\r\n\r\n  return {\r\n    get: () => ensureValue()[0],\r\n    set: (value, timeout) =>\r\n      inner.set(\r\n        value === null ? null : ([value, ensureValue()[1] + 1] as any),\r\n        timeout\r\n      )?.[0],\r\n    delete: () => inner.delete(),\r\n    update: (updater, timeout) =>\r\n      inner.update(() => {\r\n        const current = ensureValue();\r\n        return [updater(current[0]), current[1] + 1] as any;\r\n      }, timeout),\r\n    observe: (observer) =>\r\n      inner.observe!((newValue, previousValue, key) => {\r\n        if (!isValid(newValue)) return;\r\n        if (!isStale(newValue)) {\r\n          observer(\r\n            newValue![0],\r\n            (isValid(previousValue) && previousValue?.[0]) || null,\r\n            key\r\n          );\r\n        }\r\n      }),\r\n  };\r\n};\r\n","export type IsNever<T> = [T] extends [never] ? true : false;\n\n/**\n * Shorthand for a value that is optionally awaitable.\n */\nexport type MaybePromise<T> = PromiseLike<T> | T;\n\nexport type ValueOrDefault<T, R, D = undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? D\n  : R;\n\n/** Shorter than writing all this out, and slightly easier to read. */\nexport type Nullish = null | undefined;\n\n/**\n * Removes null'ish values from a union.\n */\nexport type OmitNullish<T> = T extends Nullish ? never : T;\n\n/**\n * Common function type used for projection of [key,value] entries.\n */\nexport type KeyValueProjection<K, V, R> = (\n  entry: [key: K, value: V],\n  index: number\n) => R;\n\n/**\n * Shorthand for a type that is inferred from a parameter and can either be the item in an iterable, or just the type itself.\n */\nexport type IterableOrSelf<T> = IterableOrArrayLike<T> | T;\n\ntype FunctionComparisonEqualsWrapped<T> = T extends (\n  T extends {} ? infer R & {} : infer R\n)\n  ? { [P in keyof R]: R[P] }\n  : never;\n\ntype FunctionComparisonEquals<A, B> = (<\n  T\n>() => T extends FunctionComparisonEqualsWrapped<A> ? 1 : 2) extends <\n  T\n>() => T extends FunctionComparisonEqualsWrapped<B> ? 1 : 2\n  ? true\n  : false;\n\n/**\n * Tests if a type is `any`. The test used is technically impossable to succeed unless the type is in fact `any`.\n */\nexport type IsAny<T> = FunctionComparisonEquals<T, any>;\n\n//export type MergeUnion\n\n/**\n * Utility type to allow `as const` to be used on tuples returned from functions without actually making them `readonly` (which is annoying).\n * Normally TypeScript considers the return value of a function like `x=>[10,\"four\"]` to be `(string|number)[]` (which is also annoying).\n */\nexport type ConstToTuples<T> = T extends readonly any[]\n  ? { -readonly [P in keyof T]: T[P] }\n  : Voidefined<T>;\n\n/**\n * Goes with {@link Nulls} to simplify the expression.\n */\nexport type ArgNulls<T, Arg> = (T | Nullish) & Arg;\n\n/**\n * Trick for having a function that returns a non-null value, if a formal paramter always has a non-null value.\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\n/**\n * Typescript has the distinction between `void` and `undefined`.\n * I'm sure there is a theorically sound explanation. Both that and the distinction are annoying so this little utility type maps `void` to `undefined`.\n *\n * The ampersand union trick makes TypeScript relax instead of the \"The type T could be instantiated etc...\" error.\n */\nexport type Voidefined<T> = T extends void ? T & undefined : T;\n\n/**\n * An extension to T[] and Iterable<T> that also correctly captures weird things like NodeListOf<T>\n */\nexport type IterableOrArrayLike<T> =\n  | Iterable<T>\n  | { [item: number]: T; length: number };\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = (value: any, parse?: boolean) => T | undefined;\n\nexport const undefined = void 0;\nexport const nil = null;\n\nconst createConverter =\n  <T>(typeTester: TypeTester<T>, parser?: (value: any) => T | undefined) =>\n  (value: any, parse = true) =>\n    typeTester(value)\n      ? value\n      : parser && parse && isDefined((value = parser(value)))\n      ? value\n      : undefined;\n\nexport const tryCatch = <T, C = undefined>(\n  expression: () => T,\n  errorHandler?: (error: any) => C,\n  clean?: () => void\n): T | C => {\n  try {\n    return expression();\n  } catch (e) {\n    return errorHandler?.(e) as any;\n  } finally {\n    clean?.();\n  }\n};\n\nexport const tryCatchAsync = async <T, C = undefined>(\n  expression: () => Promise<T> | T,\n  errorHandler?: (error: any) => Promise<C> | C,\n  always?: () => void\n): Promise<T | C> => {\n  try {\n    return await expression();\n  } catch (e) {\n    return (await errorHandler?.(e)) as any;\n  } finally {\n    always?.();\n  }\n};\n\nexport const isNull = (value: any): value is null => value === nil;\nexport const isUndefined = (value: any): value is undefined | void =>\n  value === undefined;\nexport const isDefined = <T>(value: T): value is Exclude<T, undefined | void> =>\n  !isUndefined(value);\n\nexport const hasValue = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value != nil;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\nexport const parseBoolean = createConverter(isBoolean, (value) => !!value);\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\nexport const parseNumber = createConverter(isNumber, (value) =>\n  parseFloat(value)\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\nexport const parseBigInt = createConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createConverter(isString, (value) =>\n  hasValue(value) ? \"\" + value : value\n);\n\nexport const isArray = Array.isArray;\nexport const toArray = <T>(value: T | Iterable<T>): T[] =>\n  value == null\n    ? []\n    : isArray(value)\n    ? value\n    : isIterable(value, true)\n    ? [...value]\n    : ([value] as any);\n\nexport const isObject = (value: any): value is object =>\n  value && typeof value === \"object\";\n\n/** Tests whether a value is an object but not an array. */\nexport const isPureObject = (\n  value: any\n): value is object & { [Symbol.iterator]?: never } =>\n  isObject(value) && !isIterable(value);\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\n\nexport const isIterable = (\n  value: any,\n  acceptStrings = false\n): value is Iterable<any> =>\n  !!value?.[Symbol.iterator] && (acceptStrings || !isString(value));\n\nexport const toIterable = <T>(value: T | Iterable<T>): Iterable<T> =>\n  isIterable(value) ? value : [value];\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == nil\n    ? value === nil\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\nexport const identity = <T = any>(value: T) => value;\n\nexport const clone = <T>(value: T): T =>\n  isArray(value)\n    ? [...value]\n    : isPureObject(value)\n    ? { ...value }\n    : (value as any);\n\ntype UseCallback<Args extends any[], R> = (\n  ...args: [...args: Args, self: UseCallback<Args, R>]\n) => R;\nexport const use = <Args extends any[], R>(\n  ...args: [...args: Args, callback: UseCallback<Args, R>]\n) => args[args.length - 1](...args);\nexport const useSome = <Args extends any[], R>(\n  ...args: [...args: Args, callback: UseCallback<Args, R>]\n) => (args.some((v) => v) ? use(...args) : undefined);\nexport const useEvery = <Args extends any[], R>(\n  ...args: [...args: Args, callback: UseCallback<Args, R>]\n) => (args.every((v) => v) ? use(...args) : undefined);\n","export type UUID = string;\r\n\r\nexport const now = () => Math.trunc(performance.timeOrigin + performance.now());\r\n\r\nexport const TAB_ID =\r\n  now().toString(36) +\r\n  Math.trunc(1296 * Math.random())\r\n    .toString(36)\r\n    .padStart(2, \"0\");\r\n\r\nlet localId = 0;\r\nexport const nextId = () => TAB_ID + \"_\" + (++localId).toString(36);\r\n","type AllMaps = WindowEventMap &\r\n  GlobalEventHandlersEventMap &\r\n  DocumentEventMap &\r\n  HTMLElementEventMap;\r\n\r\nexport type Rebinder = () => boolean;\r\nexport type Unbinder = () => boolean;\r\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\r\n\r\nexport const combine = <T extends (...args: any) => any>(\r\n  ...functions: T[]\r\n): T extends (...args: infer A) => infer R\r\n  ? (...args: A) => R extends void ? void : R[]\r\n  : never => ((...args: any[]) => functions.map((f) => f(...args))) as any;\r\n\r\nexport type Listener<Arg> = (arg: Arg, unbind: Unbinder) => void;\r\nexport const createBinders = <Arg>(\r\n  listener: Listener<Arg>,\r\n  attach: (listener: (arg: Arg) => void) => void,\r\n  detach: (listener: (arg: Arg) => void) => void\r\n): Binders => {\r\n  let bound = false;\r\n  const unbind = () =>\r\n    bound !== (bound = false) && (detach(outerListener), true);\r\n  const rebind = () =>\r\n    bound !== (bound = true) && (attach(outerListener), true);\r\n\r\n  const outerListener = (arg: Arg) => listener(arg, unbind);\r\n  rebind();\r\n  return [unbind, rebind];\r\n};\r\n\r\nexport const listen = <K extends keyof AllMaps>(\r\n  target: {\r\n    addEventListener(\r\n      type: string,\r\n      listener: EventListenerOrEventListenerObject,\r\n      options?: boolean | AddEventListenerOptions\r\n    ): void;\r\n    removeEventListener(\r\n      type: string,\r\n      listener: EventListenerOrEventListenerObject,\r\n      options?: boolean | EventListenerOptions\r\n    ): void;\r\n  },\r\n  name: K,\r\n  listener: (ev: AllMaps[K], unbind?: Unbinder) => any,\r\n  options: AddEventListenerOptions = { capture: true, passive: true }\r\n) =>\r\n  createBinders(\r\n    listener,\r\n    (listener) => target.addEventListener(name, listener, options),\r\n    (listener) => target.addEventListener(name, listener, options)\r\n  );\r\n\r\n// export const listen = <K extends keyof AllMaps>(\r\n//   el: any,\r\n//   names: K[] | K,\r\n//   cb: (ev: AllMaps[K], unbind: () => void) => void,\r\n//   capture = true,\r\n//   passive = true\r\n// ) => {\r\n//   let unbinders: any[] = [];\r\n\r\n//   return (\r\n//     toArray(names).map((name, i) => {\r\n//       const mapped = (ev: any) => {\r\n//         cb(ev, unbinders[i]);\r\n//       };\r\n//       push(unbinders, () => el.removeEventListener(name, mapped, capture));\r\n//       return el.addEventListener(name, mapped, { capture, passive });\r\n//     }),\r\n//     () =>\r\n//       unbinders.length > 0 && map(unbinders, (unbind) => unbind())\r\n//         ? ((unbinders = []), T)\r\n//         : F\r\n//   );\r\n// };\r\n","import { TAB_ID, bindStorage, sharedStorage } from \".\";\r\n\r\nexport type Channel<T> = {\r\n  post(sender: string, payload: T): void;\r\n  unsubscribe: () => void;\r\n};\r\n\r\nexport type SynchronizedStorage<T> = {\r\n  get(): T | null;\r\n  update<V extends T | null>(update: (oldValue: T | null) => V): V;\r\n};\r\n\r\ntype ChannelPayload<T> = {\r\n  sender: string;\r\n  payload: T;\r\n  target?: string;\r\n};\r\n\r\nexport const createChannel = <T>(\r\n  id: string,\r\n  handler: (sender: string, payload: T) => void\r\n): Channel<T> => {\r\n  const storage = bindStorage<ChannelPayload<T>>(id, sharedStorage);\r\n\r\n  return {\r\n    post: (sender, payload) => {\r\n      storage.set({ sender, payload });\r\n      storage.delete();\r\n    },\r\n    unsubscribe: storage.observe((value) => {\r\n      if (value && (!value.target || value.target === TAB_ID)) {\r\n        handler(value.sender, value.payload);\r\n      }\r\n    })[0],\r\n  };\r\n};\r\n\r\nlet chatChannel: Channel<string> | undefined;\r\nexport const error: {\r\n  (message: string, fatal: boolean): void;\r\n  (message: string, cause?: any, fatal?: boolean);\r\n} = (message: string, error?: any, throwError = false) => {\r\n  if (typeof error === \"boolean\") {\r\n    throwError = error;\r\n    error = null;\r\n  }\r\n  if (error?.message) {\r\n    message += \"(\" + error.message;\r\n    error.stack && (message += \"\\n\\n\" + error.stack);\r\n    message += \")\";\r\n  }\r\n  console.error(message);\r\n  if (throwError) {\r\n    throw new Error(message);\r\n  }\r\n};\r\nexport const log = (message: any) => {\r\n  typeof message === \"object\" && (message = JSON.stringify(message));\r\n\r\n  (chatChannel ??= createChannel<string>(\"chat\", (sender, message) => {\r\n    console.log(`Other tab (${sender}): ${message}`);\r\n  })).post(TAB_ID, message);\r\n  console.log(`This tab: ${message}`);\r\n};\r\n\r\n// export const createSynchronizedStorage = <T>(id: string) => {\r\n//   type V = { serial: number; value: null };\r\n\r\n//   let currentValue: V = { serial: 0, value: null };\r\n\r\n//   const refresh = () => {\r\n//     const storedValue = deserialize<V>(localStorage.getItem(id));\r\n//     if (storedValue && storedValue.serial > currentValue.serial) {\r\n//       log(\"Value updated.\");\r\n//       currentValue = storedValue;\r\n//     } else if (\r\n//       !storedValue?.serial ||\r\n//       storedValue.serial < currentValue.serial\r\n//     ) {\r\n//       log(\"Restored the value.\");\r\n//       // Someone deleted the key, or the current value is not compatible with us.\r\n//       localStorage.setItem(id, serialize(currentValue));\r\n//     }\r\n//     return currentValue;\r\n//   };\r\n\r\n//   const storageHandler = ({ key }: StorageEvent) => {\r\n//     if (key === id) {\r\n//       refresh();\r\n//     }\r\n//   };\r\n\r\n//   const recover = () => {\r\n//     const storedValue = deserialize<V>(localStorage.getItem(id));\r\n//     if (!storedValue?.serial || storedValue.serial < currentValue.serial) {\r\n//       //localStorage.setItem\r\n//     }\r\n//   };\r\n//   const wire = () => {\r\n//     refresh();\r\n//     window.addEventListener(\"storage\", storageHandler);\r\n//   };\r\n\r\n//   const unwire = () => window.removeEventListener(\"storage\", storageHandler);\r\n\r\n//   window.addEventListener(\"pageshow\", wire);\r\n//   window.addEventListener(\"pagehide\", unwire);\r\n\r\n//   wire();\r\n\r\n//   let storage: SynchronizedStorage<T> = {\r\n//     get: () => refresh().value,\r\n//     update: (update) => {\r\n//       const updated = update(refresh().value);\r\n//       localStorage.setItem(\r\n//         id,\r\n//         serialize(\r\n//           (currentValue = {\r\n//             serial: currentValue.serial + 1,\r\n//             value: updated as any,\r\n//           })\r\n//         )\r\n//       );\r\n//       return updated;\r\n//     },\r\n//   };\r\n//   return storage;\r\n// };\r\n","import { forEach, isPureObject, map } from \"@tailjs/util\";\r\nimport { TAB_ID, bindStorage, listen, now } from \"./lib2\";\r\n\r\nconst enum TabState {\r\n  Open = 1,\r\n  Active = 2,\r\n  Closed = 3,\r\n}\r\n\r\ntype ChatMessage = {\r\n  message?: string;\r\n  tab?: TabState;\r\n};\r\n\r\ntype TabData = {};\r\n\r\ntype State = {\r\n  openTabs: Record<string, TabData>;\r\n};\r\n\r\nconst state: State = {\r\n  openTabs: { [TAB_ID]: {} },\r\n};\r\n\r\nconst activeTabs = bindStorage<Record<string, number>>(\"active2\");\r\n\r\nexport const attach = async () => {\r\n  listen(\r\n    window,\r\n    \"pageshow\",\r\n    () =>\r\n      activeTabs.update(\r\n        (current) => (\r\n          ((current = isPureObject(current) ? current : {})[TAB_ID] = now()),\r\n          current\r\n        )\r\n      )\r\n    //activeStorage.update((current) => (current ?? 0) + 1)\r\n  );\r\n  listen(\r\n    window,\r\n    \"pagehide\",\r\n    () =>\r\n      activeTabs.update(\r\n        (current) => (isPureObject(current) && delete current[TAB_ID], current)\r\n      )\r\n    // activeStorage.update((current: any) =>\r\n    //   current > 0 ? current - 1 : current\r\n    // )\r\n  );\r\n};\r\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\n//import { initializeTracker } from \"./initializeTracker\";\n//import { F, T, define, window } from \"./lib\";\nimport { attach } from \"./pusher\";\n\n// This assumes the script is loaded from the RequestHandler's ?cfg route.\n\n// To prevent external scripts from eaves-dropping and get a hold of the storage key, this is how initialization works:\n// 1: The configuration scripts appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overriden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nwindow[INITIALIZE_TRACKER_FUNCTION] = (callback: any) => {\n  callback(attach);\n};\n\n// let loaded = F;\n// define(window, {\n//   [INITIALIZE_TRACKER_FUNCTION]: [\n//     (callback: (init: typeof initializeTracker) => void) => {\n//       if (loaded === (loaded = T)) return;\n//       callback(initializeTracker);\n//     },\n//   ],\n// });\n"],"names":["provider","set","retries","update","isPureObject","value","isIterable","acceptStrings","Symbol","iterator","now","Math","trunc","performance","timeOrigin","TAB_ID","toString","random","padStart","listen","target","name","listener","options","capture","passive","bound","unbind","addEventListener","outerListener","rebind","arg","serialize","JSON","stringify","deserialize","payload","parse","e","tryCatch","sharedStorage","get","key","getItem","timeout","removeItem","setItem","delete","newValue","error","writtenValue","observe","localStorage","filter","observer","bind","window","changedKey","oldValue","unbindShow","bindShow","unbindHide","bindHide","message","throwError","stack","console","Error","activeTabs","storage","updater","attach","async","current","callback"],"mappings":"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"}