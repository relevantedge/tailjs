{"version":3,"file":"tail.js","sources":["../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/util/src/types/conversions.ts","../../../../../npm/packages/@tailjs/util/src/iterators.ts","../../../../../npm/packages/@tailjs/util/src/accessors.ts","../../../../../npm/packages/@tailjs/util/src/types/strings.ts","../../../../../npm/packages/@tailjs/util/src/enums.ts","../../../../../npm/packages/@tailjs/util/src/types/validation.ts","../../../../../npm/packages/@tailjs/types/src/DataClassification.ts","../../../../../npm/packages/@tailjs/types/src/DataPurposes.ts","../../../../../npm/packages/@tailjs/types/src/UserConsent.ts","../../../../../npm/packages/@tailjs/types/src/protocol/Variable.ts","../../../../../npm/packages/@tailjs/types/src/protocol/VariableSetter.ts","../../../../../npm/packages/@tailjs/types/src/util/type-test.ts","../../../../../npm/packages/@tailjs/client/src/lib/objects.ts","../../../../../npm/packages/@tailjs/client/src/lib/regex.ts","../../../../../npm/packages/@tailjs/types/src/events/TrackedEvent.ts","../../../../../npm/packages/@tailjs/types/src/events/ViewEvent.ts","../../../../../npm/packages/@tailjs/types/src/events/ViewEndedEvent.ts","../../../../../npm/packages/@tailjs/types/src/util/parseTagString.ts","../../../../../npm/packages/@tailjs/client/src/lib/alias.ts","../../../../../npm/packages/@tailjs/client/src/lib/dom-alias.ts","../../../../../npm/packages/@tailjs/client/src/lib/util.ts","../../../../../npm/packages/@tailjs/client/src/lib/type-test.ts","../../../../../npm/packages/@tailjs/client/src/lib/iteration.ts","../../../../../npm/packages/@tailjs/client/src/lib/promise.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/base64.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/lfsr.ts","../../../../../npm/node_modules/.pnpm/@ygoe+msgpack@1.0.3/node_modules/@ygoe/msgpack/msgpack.js","../../../../../npm/packages/@tailjs/client/src/lib/dom.ts","../../../../../npm/packages/@tailjs/util/src/transport.pkg/transport.ts","../../../../../npm/packages/@tailjs/client/src/lib/cipher.ts","../../../../../npm/packages/@tailjs/client/src/lib/time.ts","../../../../../npm/packages/@tailjs/client/src/lib/ids.ts","../../../../../npm/packages/@tailjs/client/src/lib/config.ts","../../../../../npm/packages/@tailjs/client/src/lib/env.ts","../../../../../npm/packages/@tailjs/client/src/lib/eventSet.ts","../../../../../npm/packages/@tailjs/client/src/lib/dom-data.ts","../../../../../npm/packages/@tailjs/client/src/lib/storage.ts","../../../../../npm/packages/@tailjs/client/src/lib/dependencyManager.ts","../../../../../npm/packages/@tailjs/client/src/lib/channel.ts","../../../../../npm/packages/@tailjs/client/src/lib/shared-state.ts","../../../../../npm/packages/@tailjs/client/src/lib/coordinate-commits.ts","../../../../../npm/packages/@tailjs/client/src/lib/requestMutex.ts","../../../../../npm/packages/@tailjs/client/src/lib/eventQueue.ts","../../../../../npm/packages/@tailjs/client/src/lib/registerViewEndAction.ts","../../../../../npm/packages/@tailjs/client/src/extensions/deviceDetection.ts","../../../../../npm/packages/@tailjs/client/src/extensions/context.ts","../../../../../npm/packages/@tailjs/client/src/extensions/userInteraction.ts","../../../../../npm/packages/@tailjs/client/src/extensions/commerce.ts","../../../../../npm/packages/@tailjs/client/src/extensions/components.ts","../../../../../npm/packages/@tailjs/client/src/initializeTracker.ts","../../../../../npm/packages/@tailjs/client/src/lib/scanComponents.ts","../../../../../npm/packages/@tailjs/client/src/extensions/scroll.ts","../../../../../npm/packages/@tailjs/client/src/extensions/forms.ts","../../../../../npm/packages/@tailjs/client/src/extensions/defaultExtensions.ts","../../../../../npm/packages/@tailjs/client/src/commands/shared.ts","../../../../../npm/packages/@tailjs/client/src/commands/CartCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ChangeUserCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ConfigCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ToggleCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/BoundaryCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ExtensionCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/FlushCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/GetCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ListenerCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/OrderCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/ScanComponentsCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/SetCommand.ts","../../../../../npm/packages/@tailjs/client/src/commands/TrackerAvailableCommand.ts","../../../../../npm/packages/@tailjs/client/src/lib/variables.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["export const MUTEX_REQUEST_COOKIE = \".tail.rq\";\nexport const MUTEX_RESPONSE_COOKIE = \".tail.rs\";\nexport const CONTEXT_MENU_COOKIE = \".tail.cm\";\n\nexport const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_MENU_QUERY = \"mnt\";\n","import type { Defined, MaybePromise, MaybeUndefined } from \"..\";\nimport { tryCatch } from \"..\";\n\n/**\n * Trick for having a function that returns a non-null value, if a formal paramter always has a non-null value,\n * simliar to .NET's [NotNullIfNotNull].\n *\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\nexport type AllKeys<Ts> = Ts extends infer T ? keyof T : never;\n/**\n * Creates a new type where with all the properties from any of the specified types.\n * This can make life easier for code working with polymorphic types.\n */\n\nexport type CommonTypeTemplate<Ts> = {\n  [P in AllKeys<Ts>]?: Ts extends infer T\n    ? P extends keyof T\n      ? T[P]\n      : never\n    : never;\n};\n\nexport type ExpandTypes<\n  Ts,\n  Common = CommonTypeTemplate<Ts>\n> = Ts extends infer T\n  ? {\n      [P in keyof Common]: P extends keyof T ? T[P] : Common[P];\n    }\n  : never;\n\n/**\n * Typescript has the distinction between `void` and `undefined`.\n * I'm sure there is a theorically sound explanation. Both that and the distinction are annoying so this little utility type maps `void` to `undefined`.\n *\n * The ampersand union trick makes TypeScript relax instead of the \"The type T could be instantiated etc...\" error.\n */\nexport type Voidefined<T> = T extends void ? T & undefined : T;\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = (value: any, parse?: boolean) => T | undefined;\n\nexport const undefined = void 0;\nexport const nil = null;\n\n/** Caching this value potentially speeds up tests rather than using `Number.MAX_SAFE_INTEGER`. */\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/** Using this cached value speeds up testing if an object is iterable seemingly by an order of magnitude. */\nexport const symbolIterator = Symbol.iterator;\n\n/** Using this cached value speeds up testing if an object is iterable seemingly by an order of magnitude. */\nexport const symbolAsyncIterator = Symbol.asyncIterator;\n\nconst createConverter =\n  <T>(typeTester: TypeTester<T>, parser?: (value: any) => T | undefined) =>\n  (value: any, parse = true) =>\n    typeTester(value)\n      ? value\n      : parser && parse && isDefined((value = parser(value)))\n      ? value\n      : undefined;\n\nexport const isNull = (value: any): value is null => value === nil;\n\nexport const isUndefined = (value: any): value is undefined | void =>\n  value === undefined;\n\nexport const isDefined = <T>(value: T): value is Defined<T> =>\n  value !== undefined;\n\nexport const ifDefined = <T, R>(\n  value: T,\n  result: (value: NonNullable<T>) => R\n): MaybeUndefined<T, R> =>\n  value !== undefined ? (result(value as any) as any) : undefined;\n\nexport const isNullish = (value: any): value is undefined | void | null =>\n  value == nil;\n\nexport const hasValue = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value != nil;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\n\nexport const parseBoolean = createConverter(isBoolean, (value) => !!value);\nexport const isTruish = (value: any) => !!value;\n\nexport type Falsish = void | null | undefined | 0 | \"\" | false;\n\nexport const isFalsish = (value: any): value is Falsish => !value;\n\nexport const isInteger: (value: any) => value is number =\n  Number.isSafeInteger as any;\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\n\nexport const isFinite: (value: any) => value is number = Number.isFinite as any;\n\nexport const parseNumber = createConverter(isNumber, (value) =>\n  parseFloat(value)\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\nexport const parseBigInt = createConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createConverter(isString, (value) =>\n  hasValue(value) ? \"\" + value : value\n);\n\nexport const isArray: (value: any) => value is readonly any[] = Array.isArray;\n\n/**\n * Returns the value as an array following these rules:\n * - If the value is undefined (this does not include `null`), so is the return value.\n * - If the value is already an array its original value is returned unless `clone` is true. In that case a copy of the value is returned.\n * - If the value is iterable, an array containing its values is returned\n * - Otherwise, an array with the value as its single item is returned.\n */\nexport const toArray: {\n  // <T>(value: AsyncIterable<T>, clone?: boolean): MaybeUndefined<\n  //   [T][0],\n  //   Promise<T[]>\n  // >;\n  <T>(value: T | Iterable<T>, clone?: boolean): MaybeUndefined<[T][0], T[]>;\n} = (value: any, clone = false): any =>\n  isUndefined(value)\n    ? undefined\n    : !clone && isArray(value)\n    ? value\n    : isIterable(value)\n    ? [...value]\n    : // : isAsyncIterable(value)\n      // ? toArrayAsync(value)\n      ([value] as any);\n\nconst toArrayAsync = async (\n  values: AsyncIterable<any>,\n  results: any[] = []\n) => {\n  for await (const value of values) {\n    results.push(value);\n  }\n  return results;\n};\n\nexport const isObject = <AcceptIterables extends boolean = false>(\n  value: any,\n  acceptIterables: AcceptIterables = false as any\n): value is AcceptIterables extends true\n  ? object & (Record<keyof any, any> | Iterable<any>)\n  : object & Record<keyof any, any> & { [Symbol.iterator]?: never } =>\n  value != null &&\n  typeof value === \"object\" &&\n  (acceptIterables || !value[symbolIterator]);\n\nexport const hasMethod = <T, Name extends keyof any>(\n  value: T | unknown,\n  name: Name | keyof T\n): value is {\n  [P in keyof T]: P extends Name\n    ? T extends { [P in Name]?: (...args: infer Args) => infer R }\n      ? Args extends unknown\n        ? (...args: any) => any\n        : (...args: Args) => R\n      : (...args: any) => any\n    : T[P];\n} => typeof (value as any)?.[name] === \"function\";\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\n\nexport const isIterable = (\n  value: any,\n  acceptStrings = false\n): value is Iterable<any> =>\n  !!(value?.[symbolIterator] && (typeof value === \"object\" || acceptStrings));\n\nexport const isAsyncIterable = (value: any): value is AsyncIterable<any> =>\n  !!value?.[symbolAsyncIterator];\n\nexport const toIterable = <T>(value: T | Iterable<T>): Iterable<T> =>\n  isIterable(value) ? value : [value];\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == nil\n    ? value === nil\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\n/**\n * Evaluates a function that can be used to capture values using parameter default values.\n *\n * For example `(previous=current)=>(current+=2, previous)\n */\nexport const capture = <R>(capture: (...args: any[]) => R) => capture();\n","import {\n  add,\n  ConstToNormal,\n  GeneralizeContstants,\n  get,\n  hasMethod,\n  IsAny,\n  isArray,\n  isDefined,\n  isFalsish,\n  isFunction,\n  isObject,\n  isSet,\n  isTruish,\n  IterableOrArrayLike,\n  KeyValuePairsToObject,\n  MAX_SAFE_INTEGER,\n  Minus,\n  NotFunction,\n  RecordType,\n  symbolIterator,\n  toArray,\n  undefined,\n  MaybeUndefined,\n  Nullish,\n  isNumber,\n} from \".\";\n\nexport const UTF16MAX = 0xffff;\n\nlet stopInvoked = false;\nexport const stop = (yieldValue?: any) => ((stopInvoked = true), yieldValue);\n\nexport const toCharCodes = (s: string) =>\n  [...new Array(s.length)].map((_, i) => s.charCodeAt(i));\nexport const codePoint = (string: string, index: number = 0) =>\n  string.codePointAt(index)!;\n\nexport type IteratorSource =\n  | any\n  | null\n  | undefined\n  | number\n  | Iterable<any>\n  | NotFunction\n  | NavigatingIteratorStep;\n\nexport type IteratorSourceOf<T> =\n  | (T extends number ? number : never)\n  | Iterable<T>\n  | (T extends readonly [infer K, infer V]\n      ? K extends keyof any\n        ? { [P in K]: V }\n        : never\n      : never)\n  | NavigatingIteratorStep<T>;\n\ntype IteratorItem<S extends IteratorSource> = IsAny<S> extends true\n  ? any\n  : S extends number\n  ? number\n  : S extends RecordType\n  ? readonly [keyof S, S[keyof S]]\n  : S extends (...args: any) => infer T | undefined\n  ? T\n  : S extends Iterable<infer T>\n  ? T\n  : never;\n\nexport type IteratorItems<S extends IteratorSource[]> = S extends readonly [\n  infer S\n]\n  ? IteratorItem<S>\n  : S extends readonly [infer S, ...infer Rest]\n  ? IteratorItem<S> | IteratorItems<Rest>\n  : S extends readonly (infer S)[]\n  ? IteratorItem<S>\n  : never;\n\nexport interface IteratorControl<S extends IteratorSource> {\n  source: S;\n  prev: IteratorItem<S> | undefined;\n  skip(): void;\n  end(): void;\n  end<P>(value: P): P;\n}\n\nexport type IteratorAction<\n  S extends IteratorSource = IteratorSource,\n  Projection = IteratorItem<S>,\n  Value = IteratorItem<S>\n> = (\n  value: Value,\n  index: number\n) => Projection | typeof stop | undefined | void;\n\ntype IteratorProjection<\n  S extends IteratorSource,\n  Projection\n> = unknown extends Projection ? IteratorItem<S> : ConstToNormal<Projection>;\n\ntype StartEndArgs<S extends IteratorSource> =\n  | []\n  | (S extends number\n      ? [offset?: number | Nullish]\n      : S extends NavigatingIteratorStep<infer T>\n      ? [seed?: T, maxIterations?: number]\n      : [start: number | Nullish, end?: number | Nullish]);\n\nexport type NavigatingIteratorStep<T = any> = (\n  current: T | undefined\n) => T | undefined;\n\ntype FlatIteratorItem<T, D extends number = 1, O = false> = T extends\n  | undefined\n  | void\n  ? never\n  : D extends 0\n  ? T\n  : T extends Iterable<any> | (O extends true ? Record<keyof any, any> : never)\n  ? D extends 1\n    ? IteratorItem<T>\n    : FlatIteratorItem<IteratorItem<T>, Minus<D, 1>, O>\n  : T;\n\ntype ProjectedItem<P> = Exclude<P, undefined | void | typeof stop>;\n\nfunction* createFilteringIterator<\n  S extends IteratorSource,\n  P = IteratorItem<S>\n>(source: S, projection?: IteratorAction<S, P>): Iterable<ProjectedItem<P>> {\n  if (!source) return;\n\n  let i = 0;\n  for (let item of source as any) {\n    projection && (item = projection(item, i++));\n    if (item !== undefined) {\n      yield item;\n    }\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n}\n\nfunction* createObjectIterator<\n  S extends Record<keyof any, any>,\n  P = IteratorItem<S>\n>(source: S, action?: IteratorAction<S, P>): Iterable<P> {\n  let i = 0;\n  for (const key in source) {\n    let value = [key, source[key]] as any;\n    action && (value = action(value, i++));\n\n    if (value !== undefined) {\n      yield value;\n    }\n    if (stopInvoked) {\n      stopInvoked = false;\n      break;\n    }\n  }\n}\n\nfunction* createRangeIterator(length = 0, offset = 0): Iterable<number> {\n  while (length--) yield offset++;\n}\n\nexport function* createStringIterator(\n  input: string,\n  start: number,\n  end: number\n): Iterable<[char: string, codePoint: number]> {\n  while (start < end) {\n    const codePoint = input.codePointAt(start)!;\n    let p = input[start++];\n    if (codePoint > UTF16MAX) {\n      start++;\n      p = String.fromCodePoint(codePoint);\n    }\n    yield [p, codePoint];\n  }\n}\n\nexport function* createNavigatingIterator<T>(\n  step: NavigatingIteratorStep<T>,\n  start?: T | undefined,\n  maxIterations = Number.MAX_SAFE_INTEGER\n): Iterator<T> {\n  if (isDefined(start)) yield start;\n  while (maxIterations-- && isDefined((start = step(start)))) {\n    yield start;\n  }\n}\n\nconst sliceAction = <\n  S extends IteratorSource,\n  A extends IteratorAction<S, any> | undefined\n>(\n  action: A,\n  start: any,\n  end: any\n): A =>\n  (start ?? end) !== undefined\n    ? ((start ??= 0),\n      (end ??= MAX_SAFE_INTEGER),\n      (value, index) =>\n        start--\n          ? undefined\n          : end!--\n          ? action\n            ? action(value, index)\n            : value\n          : end)\n    : (action as any);\n\nexport type Filter<S extends IteratorSource> = (\n  value: IteratorItem<S>,\n  index: number\n) => any;\n\nconst createIterator = <\n  S extends IteratorSource,\n  P = ConstToNormal<IteratorItem<S>>\n>(\n  source: S,\n  projection?: IteratorAction<S, P>,\n  start?: any,\n  end?: any\n): Iterable<P> =>\n  source == null\n    ? ([] as any)\n    : source[symbolIterator]\n    ? createFilteringIterator(\n        source,\n        start === undefined\n          ? projection\n          : sliceAction(projection, start as any, end)\n      )\n    : typeof source === \"object\"\n    ? createObjectIterator(\n        source as any,\n        sliceAction(projection, start as any, end)\n      )\n    : createIterator(\n        isFunction(source)\n          ? createNavigatingIterator(source, start, end)\n          : (createRangeIterator(source as number, start as any) as any),\n        projection\n      );\n\nconst mapToArray = <T, M>(\n  projected: Iterable<T>,\n  map: M\n): true extends M ? T[] : Iterable<T> =>\n  map && !isArray(projected) ? [...projected] : (projected as any);\n\ntype ProjectFunction = {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): Iterable<IteratorProjection<S, R>>;\n  <S extends IteratorSource>(source: S, ...rest: StartEndArgs<S>): Iterable<\n    IteratorItem<S>\n  >;\n};\n\ntype MapFunction = {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): MaybeUndefined<S, IteratorProjection<S, R>[]>;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): MaybeUndefined<S, IteratorItem<S>[]>;\n};\n\ntype FlatProjectFunction = <\n  S extends IteratorSource,\n  D extends number = 1,\n  R = IteratorItem<S>,\n  O extends boolean = false\n>(\n  source: S,\n  projection?: FlatIteratorAction<S, R, D, O>,\n  depth?: D,\n  expandObjects?: O,\n  ...rest: StartEndArgs<S>\n) => FlatIteratorItem<Iterable<R>, D>;\n\nexport const project: ProjectFunction = ((\n  source: any,\n  projection: any,\n  start: any,\n  end: any\n) =>\n  isNumber(projection)\n    ? // The second argument is the value of `start`.\n      createIterator(source, undefined, projection, start)\n    : createIterator(source, projection, start, end)) as any;\n\nexport const flatProject: FlatProjectFunction = function (\n  source,\n  projection?,\n  depth = 1 as any,\n  expandObjects: any = false,\n  start?: any,\n  end?: any\n) {\n  return createIterator(\n    flatten(\n      createIterator(source, undefined, start, end),\n      depth + 1,\n      expandObjects,\n      false\n    ),\n    projection\n  ) as any;\n\n  function* flatten(\n    value: any,\n    depth: number,\n    expandObjects: boolean,\n    nested: boolean\n  ) {\n    if (value != null) {\n      if (\n        value?.[symbolIterator] ||\n        (expandObjects && value && typeof value === \"object\")\n      ) {\n        for (const item of nested ? createIterator(value) : value) {\n          if (depth > 1 || depth <= 0) {\n            yield* flatten(item, depth - 1, expandObjects, true);\n          } else {\n            yield item;\n          }\n        }\n      } else {\n        yield value;\n      }\n    }\n  }\n};\n\nexport const map: MapFunction = (\n  source: any,\n  projection?: any,\n  start?: any,\n  end?: any\n) => {\n  if (isArray(source)) {\n    let i = 0;\n    const mapped: any[] = [];\n    isNumber(projection) &&\n      ([projection, start, end] = [undefined, projection, start]);\n    start = start! < 0 ? source.length + start! : start ?? 0;\n    end = end! < 0 ? source.length + end! : end ?? source.length;\n    for (; start < end && !stopInvoked; start++) {\n      let value = source[start];\n      if (projection && value !== undefined) {\n        value = projection(value, i++);\n      }\n      if (value !== undefined) {\n        mapped.push(value);\n      }\n    }\n    stopInvoked = false;\n    return mapped;\n  }\n  return source !== undefined\n    ? toArray(project(source, projection, start, end))\n    : (undefined as any);\n};\n\nexport const zip = <Lhs extends IteratorSource, Rhs extends IteratorSource>(\n  lhs: Lhs,\n  rhs: Rhs\n): Iterable<[IteratorItem<Lhs>, IteratorItem<Rhs> | undefined]> => {\n  const it2 = createIterator(rhs)[Symbol.iterator]();\n  return createIterator(lhs, (lhs) => [lhs, it2.next()?.value] as [any, any]);\n};\n\nexport const distinct: {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorProjection<S, R>>;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : Set<IteratorItem<S>>;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  isDefined(source)\n    ? new Set<any>([...project(source, projection, start, end)])\n    : undefined;\n\nexport const single: {\n  <S extends IteratorSource, R>(\n    source: S,\n    projection?: IteratorAction<S, R> | null,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorProjection<S, R> | undefined;\n  <S extends IteratorSource>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): S extends undefined ? undefined : IteratorItem<S> | undefined;\n} = (source: any, projection?: any, start?: any, end?: any) =>\n  !source\n    ? undefined\n    : (source = mapDistinct(source, projection, start, end) as any).length > 1\n    ? undefined\n    : source[0];\n\nexport const mapDistinct: MapFunction = (\n  source: any,\n  projection?: any,\n  start?: any,\n  end?: any\n) =>\n  isDefined(source)\n    ? [...(distinct as any)(source, projection, start, end)]\n    : source;\n\nexport function* concatIterators<S extends IteratorSource[]>(\n  ...iterators: S\n): Iterable<IteratorItems<S>> {\n  for (const iterator of iterators) {\n    if (!iterator) continue;\n    yield* createIterator(iterator);\n  }\n}\n\ntype AllCanBeUndefined<T extends any[]> = T extends readonly [infer S]\n  ? undefined extends S\n    ? true\n    : false\n  : T extends readonly [infer S, ...infer Rest]\n  ? AllCanBeUndefined<Rest> extends false\n    ? false\n    : undefined extends S\n    ? true\n    : false\n  : true;\n\nexport const concat = <S extends (IterableOrArrayLike<any> | undefined)[]>(\n  ...iterators: S\n):\n  | (AllCanBeUndefined<S> extends true ? undefined : never)\n  | IteratorItems<S>[] =>\n  iterators.reduce(\n    (r: undefined | any[], it) => (it ? (r ?? []).concat(toArray(it)) : r),\n    undefined\n  ) as any;\n\nexport const intersection = <\n  T,\n  A extends Iterable<T> | undefined,\n  B extends Iterable<T> | undefined,\n  MapToArray extends boolean = A extends any[]\n    ? true\n    : B extends any[]\n    ? true\n    : false\n>(\n  a: A,\n  b: B,\n  mapToArray?: MapToArray\n): MapToArray extends true ? T[] : Iterable<T> => {\n  if (!a || !b) return [];\n  isSet(b) && ([b, a] = [a, b] as any);\n  const lookup = isSet(a) ? a : new Set(a);\n  return filter(b, (value) => lookup.has(value), mapToArray) as any;\n};\n\nexport const intersects = (\n  a: Iterable<any> | undefined,\n  b: Iterable<any> | undefined\n) => !!count(intersection(a, b));\n\ntype FlatIteratorAction<\n  S extends IteratorSource,\n  R = FlatIteratorItem<S>,\n  D extends number = 1,\n  O = false\n> = IteratorAction<S, R, FlatIteratorItem<S, D, O>>;\n\nexport const flatMap = <\n  S extends IteratorSource,\n  D extends number = 1,\n  O extends boolean = false,\n  R = IteratorItem<S>\n>(\n  source: S,\n  action: FlatIteratorAction<S, R, D, O> = (item) => item as any,\n  depth: D = 1 as any,\n  expandObjects: O = false as any,\n  ...rest: StartEndArgs<S>\n): FlatIteratorItem<R, D>[] =>\n  map(flatProject(source, action, depth, expandObjects, ...rest)) as any;\n\nconst traverseInternal = <T>(\n  root: T | T[] | undefined,\n  selector: (current: T) => Iterable<T> | undefined,\n  include: boolean,\n  results: T[],\n  seen: Set<T>\n) => {\n  if (isArray(root)) {\n    forEachInternal(root, (item) =>\n      traverseInternal(item, selector, include, results, seen)\n    );\n    return results;\n  }\n  if (!root || !add(seen, root)) {\n    return undefined;\n  }\n  include && results.push(root);\n  forEachInternal(selector(root), (item) =>\n    traverseInternal(item, selector, true, results, seen)\n  );\n\n  return results;\n};\n\ntype JoinResult<T> = T extends readonly []\n  ? never\n  : T extends readonly [infer Item, ...infer Rest]\n  ?\n      | Exclude<Item extends Iterable<infer T> ? T : Item, undefined>\n      | JoinResult<Rest>\n  : never;\n\nexport const join = <T extends readonly any[]>(...items: T): JoinResult<T>[] =>\n  items.flatMap((item) => toArray(item) ?? []).filter(isDefined) as any;\n\nexport const expand = <T>(\n  root: T | T[],\n  selector: (\n    current: Exclude<T, undefined>\n  ) => Iterable<T | undefined> | undefined,\n  includeSelf = true\n): T extends undefined ? undefined : Exclude<T, undefined>[] =>\n  traverseInternal(root, selector, includeSelf, [], new Set()) as any;\n\nconst forEachArray = (\n  source: readonly any[],\n  action: any,\n  start: any,\n  end: any\n) => {\n  let returnValue: any;\n  let i = 0;\n  start = start! < 0 ? source.length + start! : start ?? 0;\n  end = end! < 0 ? source.length + end! : end ?? source.length;\n  for (; start < end; start++) {\n    if (\n      source[start] !== undefined &&\n      ((returnValue = action(source[start], i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachItereable = (source: Iterable<any>, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let value of source as any) {\n    if (\n      value !== undefined &&\n      ((returnValue = action(value, i++) ?? returnValue), stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachObject = (source: any, action: any) => {\n  let returnValue: any;\n  let i = 0;\n  for (let key in source) {\n    if (\n      ((returnValue = action([key, source[key]], i++) ?? returnValue),\n      stopInvoked)\n    ) {\n      stopInvoked = false;\n      break;\n    }\n  }\n  return returnValue;\n};\n\nconst forEachInternal: <S extends IteratorSource, R>(\n  source: S,\n  action: IteratorAction<S, R>,\n  start?: any,\n  end?: any\n) => R | undefined = (source, action, start?: any, end?: any) => {\n  if (source == null) return;\n\n  if (isArray(source)) return forEachArray(source, action, start, end);\n  if (start === undefined) {\n    if (source[symbolIterator]) return forEachItereable(source as any, action);\n    if (typeof source === \"object\") return forEachObject(source, action);\n  }\n  let returnValue: any;\n  for (const value of createIterator(source, action, start, end)) {\n    returnValue = (value as any) ?? returnValue;\n  }\n\n  return returnValue;\n};\n\nexport const forEach = forEachInternal as <S extends IteratorSource, R>(\n  source: S,\n  action: IteratorAction<S, R>,\n  ...rest: StartEndArgs<S>\n) => R | undefined;\n\nexport const flatForEach = <\n  S extends IteratorSource,\n  R,\n  Depth extends number,\n  O extends boolean = false\n>(\n  source: S,\n  action: FlatIteratorAction<S, R, Depth, O>,\n  depth: Depth = 1 as any,\n  expandObjects: O = false as any,\n  ...rest: StartEndArgs<S>\n): R | undefined =>\n  forEachInternal(\n    flatProject(source, undefined, depth, expandObjects, ...(rest as any)),\n    action as any\n  ) as any;\n\nexport const obj: {\n  <S extends IteratorSource, P extends readonly [keyof any, any]>(\n    source: S,\n    selector: IteratorAction<S, P>,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<P>;\n  <S extends IteratorSourceOf<readonly [keyof any, any]>>(\n    source: S,\n    ...rest: StartEndArgs<S>\n  ): KeyValuePairsToObject<IteratorItem<S>>;\n} = ((source: any, selector: any, ...rest: any[]) =>\n  Object.fromEntries((map as any)(source, selector, ...rest))) as any;\n\nexport const groupReduce: <\n  S extends IteratorSource,\n  Key,\n  Accumulator = unknown\n>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  reducer: (\n    accumulator: GeneralizeContstants<Accumulator>,\n    ...rest: Parameters<IteratorAction<S, Accumulator>>\n  ) => Accumulator,\n  seed?: Accumulator | (() => Accumulator),\n  ...reset: StartEndArgs<S>\n) => Map<Key, Accumulator> = (\n  source,\n  keySelector,\n  reducer,\n  seed,\n  start?: any,\n  end?: any\n) => {\n  const groups = new Map<any, any>();\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  const action: IteratorAction<any, any> = (item, index) => {\n    const key = keySelector(item, index);\n    let acc = groups.get(key) ?? seedFactory();\n    const value = reducer(acc, item, index);\n    if (isDefined(value)) {\n      groups.set(key, value);\n    }\n  };\n  forEachInternal(source, action, start, end);\n  return groups as any;\n};\n\nexport const group: <S extends IteratorSource, Key, R = IteratorItem<S>>(\n  source: S,\n  keySelector: (item: IteratorItem<S>, index: number) => Key,\n  valueSelector?: (item: IteratorItem<S>, index: number) => R,\n  ...rest: StartEndArgs<S>\n) => S extends undefined ? undefined : Map<Key, R[]> = (\n  source,\n  keySelector,\n  valueSelector = (item: any) => item,\n  start?: any,\n  end?: any\n) => {\n  if (source == null) return undefined as any;\n  const groups = new Map<any, any[]>();\n  (forEachInternal as any)(\n    source,\n    (item: any, index: number) => {\n      const key = keySelector(item, index);\n      const value = valueSelector(item, index);\n      get(groups, key as any, () => []).push(value);\n    },\n    start,\n    end\n  );\n  return groups as any;\n};\n\nexport const reduce: <\n  S extends IteratorSource,\n  Reducer extends (\n    ...args: [\n      accumulator: unknown extends Accumulator\n        ? any\n        : GeneralizeContstants<Accumulator>,\n      ...rest: Parameters<IteratorAction<S, Accumulator>>\n    ]\n  ) => GeneralizeContstants<Accumulator>,\n  Accumulator\n>(\n  source: S,\n  reducer: Reducer,\n  seed?: Accumulator | (() => Accumulator),\n  ...rest: StartEndArgs<S>\n) => Reducer extends (...args: any) => infer R\n  ? R | (unknown extends Accumulator ? undefined : never)\n  : never = (source, reducer, seed, start?: any, end?: any) => {\n  const seedFactory = () => (isFunction(seed) ? seed() : seed);\n  return (\n    forEachInternal(\n      source,\n      (value, index) =>\n        (seed =\n          ((reducer as any)(seed as any, value, index) as any) ??\n          seedFactory()),\n      start,\n      end\n    ) ?? (seedFactory() as any)\n  );\n};\n\ntype FilterItem<S extends IteratorSource, F> = F extends (\n  value: any,\n  ...args: any\n) => value is infer T\n  ? T\n  : IteratorItem<S>;\n\nexport const filter: {\n  <\n    S extends IteratorSource,\n    MapToArray extends boolean = S extends any[] ? true : false,\n    P extends Filter<S> = Filter<S>\n  >(\n    source: S,\n    predicate?: P,\n    map?: MapToArray,\n    ...rest: StartEndArgs<S>\n  ): MapToArray extends true\n    ? MaybeUndefined<S, FilterItem<S, P>[]>\n    : Iterable<FilterItem<S, P>>;\n} = (\n  source: IteratorSource,\n  predicate: Filter<any> = (item: any) => item != null,\n  map = isArray(source) as any,\n  start?: any,\n  end?: any\n) =>\n  mapToArray(\n    createIterator(\n      source,\n      (item, index) => (predicate(item, index) ? item : undefined),\n      start,\n      end\n    ),\n    map\n  ) as any;\n\nlet filterInternal = filter;\n\nexport const count: <S>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, number> = (\n  source: IteratorSource,\n  filter?: Filter<IteratorSource>,\n  start?: any,\n  end?: any\n) => {\n  if (!source) return undefined as any;\n\n  let n: number;\n  if (filter) {\n    source = filterInternal(source, filter, false, start, end) as any;\n  } else {\n    if (isDefined((n = source![\"length\"] ?? source![\"size\"]))) {\n      return n;\n    }\n    if (!source[symbolIterator]) {\n      return Object.keys(source).length;\n    }\n  }\n  n = 0;\n  return forEachInternal(source, () => ++n) as any;\n};\n\nexport const sum: {\n  <S extends IteratorSourceOf<number>>(\n    source: S,\n    selector?: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n  <S extends IteratorSource>(\n    source: S,\n    selector: IteratorAction<S, number>,\n    ...rest: StartEndArgs<S>\n  ): number;\n} = (\n  source: any,\n  selector: any = (item: any) => item,\n  start?: any,\n  end?: any\n) =>\n  reduce(\n    source,\n    (sum, value, index) => sum + (selector(value, index) ?? 0),\n    0,\n    start,\n    end\n  );\n\nexport const values: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<\n  S,\n  IteratorItem<S> extends readonly [any, infer Item] ? Item : IteratorItem<S>\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isObject(source) ? (item: any) => item[1] : (item: any) => item,\n    start,\n    end\n  );\n\nexport const keys: <S extends IteratorSource>(\n  source: S,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<\n  S,\n  IteratorItem<S> extends readonly [infer Key, any] ? Key : number\n> = (source, start?: any, end?: any) =>\n  (map as any)(\n    source,\n    isObject(source) ? (item: any) => item[0] : (_item: any, i: number) => i,\n    start,\n    end\n  );\n\nexport const first: <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: Filter<any>,\n  start?: any,\n  end?: any\n) =>\n  !source || isArray(source)\n    ? source?.[0]\n    : forEachInternal(\n        source,\n        (value, i) =>\n          !predicate || predicate(value, i) ? stop(value) : undefined,\n        start,\n        end\n      );\n\nexport const last: <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => IteratorItem<S> | undefined = (\n  source,\n  predicate?: any,\n  start?: any,\n  end?: any\n) =>\n  !source\n    ? undefined\n    : isArray(source)\n    ? source[source.length - 1]\n    : forEachInternal(\n        source,\n        (item, i) => (!predicate || predicate(item, i) ? item : undefined),\n        start,\n        end\n      );\n\nexport const find: <S extends IteratorSource>(\n  source: S,\n  predicate: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, IteratorItem<S>> = (\n  source,\n  predicate,\n  start?: any,\n  end?: any\n) =>\n  !source\n    ? undefined\n    : (source as any).find\n    ? (source as any).find(predicate)\n    : first(filterInternal(source as any, predicate, false, start, end));\n\nexport const rank = <S extends IteratorSource>(source: S) =>\n  createIterator(source, (item, i) => [item, i] as const);\n\nexport const some: <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, boolean> = (source, predicate, start?: any, end?: any) =>\n  source === undefined\n    ? undefined\n    : hasMethod(source, \"some\")\n    ? source.some(predicate ?? isTruish)\n    : forEachInternal<any, boolean>(\n        source,\n        predicate\n          ? (item, index) => (predicate(item, index) ? stop(true) : false)\n          : () => stop(true),\n        start,\n        end\n      ) ?? false;\n\nexport const every: <S extends IteratorSource>(\n  source: S,\n  predicate?: Filter<S>,\n  ...rest: StartEndArgs<S>\n) => MaybeUndefined<S, boolean> = (source, predicate, start?: any, end?: any) =>\n  !source\n    ? undefined\n    : (!(some as any)(\n        source,\n        predicate\n          ? (item: any, index: number) => !predicate(item, index)\n          : isFalsish,\n        start,\n        end\n      ) as any);\n\nexport const binarySearch: {\n  (arr: Array<number>, find: number): number;\n  <T = number>(arr: Array<T>, find: T, compare: (x: T, y: T) => number): number;\n} = <T = number>(\n  arr: Array<T>,\n  find: T,\n  compare: (x: T, y: T) => number = ((x: any, y: any) => x - y) as any\n) => {\n  let m = 0;\n  let n = arr.length - 1;\n  let cmp: number;\n  let k: number;\n  while (m <= n) {\n    k = (n + m) >> 1;\n    cmp = compare(find, arr[k]);\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return k;\n    }\n  }\n  return ~m;\n};\n","import {\n  And,\n  Extends,\n  GeneralizeContstants,\n  If,\n  IsAny,\n  Minus,\n  NotFunction,\n  PrettifyIntersection,\n  Primitives,\n  RecordType,\n  UnionToIntersection,\n  count,\n  forEach,\n  hasMethod,\n  isArray,\n  isAwaitable,\n  isDefined,\n  isFunction,\n  isMap,\n  isObject,\n  isSet,\n  isUndefined,\n  map,\n  obj,\n  throwError,\n} from \".\";\n\ntype ReadonlyMapLike<K = any, V = any> = {\n  has?(key: K): boolean;\n  get(key: K): V | undefined;\n};\n\n// #region Shared types\ntype MapLike<K = any, V = any> = ReadonlyMapLike<K, V> & {\n  set(key: K, value: V): any;\n  delete(key: K): any;\n};\n\ntype ReadonlySetLike<K = any> = {\n  has(key: K): boolean;\n};\ntype SetLike<K = any> = ReadonlySetLike<K> & {\n  add(key: K): any;\n  delete(key: K): any;\n};\n\ntype ReadonlyPropertyContainer<K extends any = any, V extends any = any> =\n  | {\n      [P in keyof K]: V;\n    }\n  | ReadonlyMapLike<K, V>\n  | ReadonlySetLike<K>;\n\ntype PropertyContainer<K extends any = any, V extends any = any> =\n  | ReadonlyPropertyContainer<K, V>\n  | MapLike<K, V>\n  | SetLike<K>;\n\nexport type TupleIndices<T extends readonly any[]> = T extends readonly []\n  ? never\n  : number extends T[\"length\"]\n  ? number\n  : T extends readonly [any, ...infer Rest]\n  ? TupleIndices<Rest> | Rest[\"length\"]\n  : never;\n\nexport type KeyType<T extends ReadonlyPropertyContainer | null | undefined> =\n  T extends Primitives\n    ? never\n    : T extends ReadonlyMapLike<infer K, any> | ReadonlySetLike<infer K>\n    ? K\n    : T extends readonly any[]\n    ? TupleIndices<T>\n    : keyof T;\n\nexport type ValueType<\n  T extends ReadonlyPropertyContainer | null | undefined,\n  K = KeyType<T>,\n  Context extends undefined | \"get\" | \"set\" = undefined\n> = IsAny<T> extends true\n  ? any\n  : T extends null | undefined | void\n  ? never\n  : K extends KeyType<T>\n  ? T extends ReadonlyMapLike<K, infer V>\n    ? V | If<Extends<Context, \"get\" | \"set\">, undefined>\n    : T extends ReadonlySetLike<K>\n    ? boolean\n    : T[K] | If<And<Extends<T, RecordType>, Extends<Context, \"set\">>, undefined>\n  : never;\n\ntype AcceptUnknownContainers<\n  T extends ReadonlyPropertyContainer | null | undefined\n> = IsAny<T> extends true\n  ? T\n  : T extends null | undefined | void\n  ? never\n  : T extends MapLike\n  ? MapLike<unknown, unknown> | T\n  : T extends SetLike\n  ? SetLike<unknown> | T\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? readonly unknown[] | [] | T\n    : T\n  : T;\n\n// #endregion\n\n// #region get\n\nconst updateSingle = (target: any, key: any, value: any) =>\n  setSingle(target, key, isFunction(value) ? value(get(target, key)) : value);\n\nconst setSingle = (target: any, key: any, value: any) => {\n  value === undefined\n    ? target.delete\n      ? target.delete(key)\n      : delete target[key]\n    : target.set\n    ? target.set(key, value)\n    : target.add\n    ? value\n      ? target.add(key)\n      : target.delete(key)\n    : (target[key] = value);\n\n  return value;\n};\n\nexport const setSingleIfNotDefined = (\n  target: any,\n  key: any,\n  value: any,\n  error: (\n    key: string,\n    currentValue: any,\n    newValue: any,\n    target: any\n  ) => string | Error\n) => {\n  const currentValue = get(target, key);\n  if (isDefined(currentValue)) {\n    throwError(error(key, currentValue, value, target));\n  }\n  return setSingle(target, key, value);\n};\n\nexport const get: {\n  <\n    T extends ReadonlyPropertyContainer | null | undefined,\n    K extends KeyType<T>\n  >(\n    target: T,\n    key: K\n  ): ValueType<T, K, \"get\">;\n  <\n    T extends ReadonlyPropertyContainer | null | undefined,\n    K extends KeyType<T>,\n    R extends\n      | ValueType<T, K>\n      | (() => ValueType<T, K>)\n      | undefined\n      | (() => ValueType<T, K> | undefined)\n  >(\n    target: T,\n    key: K,\n    initializer: R\n  ): ValueType<\n    T,\n    K,\n    R extends ValueType<T, K> | (() => ValueType<T, K>) ? undefined : \"get\"\n  >;\n} = <\n  T extends ReadonlyPropertyContainer | null | undefined,\n  K extends KeyType<T>,\n  R extends ValueType<T, K> | undefined = undefined\n>(\n  target: T,\n  key: K | undefined,\n  initializer?: (() => R) | R\n) => {\n  if (!target) return undefined as any;\n\n  let value = (target as any).get\n    ? (target as any).get(key)\n    : (target as any).has\n    ? (target as any).has(key)\n    : target[key as any];\n\n  if (isUndefined(value) && isDefined(initializer)) {\n    isDefined(\n      (value = isFunction(initializer) ? (initializer as any)() : initializer)\n    ) && setSingle(target, key, value);\n  }\n  return value;\n};\n\n// #endregion\n\n// #region set and update\n\ntype UpdateFunction<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current,\n  Factory\n> = Factory extends false\n  ? (\n      current: Current,\n      key: Key,\n      target: T\n    ) => GeneralizeContstants<ValueType<T, Key>> | undefined\n  : (key: Key, target: T) => GeneralizeContstants<ValueType<T, Key>>;\n\ntype Updater<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current = ValueType<T, Key>,\n  SettersOnly = false,\n  Factory = false\n> = SettersOnly extends true\n  ? ValueType<T, Key> | (Factory extends true ? never : undefined)\n  : IsAny<T> extends true\n  ? NotFunction | UpdateFunction<any, any, any, Factory>\n  :\n      | (ValueType<T, Key> extends Function\n          ? never\n          : ValueType<T, Key> | (Factory extends true ? never : undefined))\n      | UpdateFunction<T, Key, Current, Factory>;\n\ntype UpdaterType<T, SettersOnly = false> = SettersOnly extends true\n  ? T\n  : T extends (...args: any) => infer T\n  ? T\n  : T;\n\ntype BulkUpdateObject<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> = T extends MapLike | SetLike | any[]\n  ? {\n      [P in KeyType<T>]: Updater<T, P, ValueType<T, P>, SettersOnly, Factory>;\n    }\n  : { [P in keyof T & KeyType<T>]?: Updater<T, P, T[P], SettersOnly, Factory> };\n\ntype BulkUpdateKeyValue<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false,\n  K extends keyof T = keyof T\n> = IsAny<T> extends true\n  ? [any, Updater<T, any, any, SettersOnly, Factory>]\n  : T extends MapLike | SetLike | any[]\n  ? [\n      KeyType<T>,\n      Updater<T, KeyType<T>, ValueType<T, KeyType<T>>, SettersOnly, Factory>\n    ]\n  : K extends any\n  ? [K, Updater<T, KeyType<T>, any, SettersOnly, Factory>]\n  : never;\n\ntype BulkUpdates<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> =\n  | BulkUpdateObject<T, SettersOnly, Factory>\n  | Iterable<\n      | BulkUpdateKeyValue<T, SettersOnly, Factory>\n      | BulkUpdateObject<T, SettersOnly, Factory>\n    >;\n\ntype SetErrorHandler<T extends ReadonlyPropertyContainer | null | undefined> = (\n  key: KeyType<T>,\n  currentValue: ValueType<T>,\n  newValue: ValueType<T>,\n  target: T\n) => string | Error;\n\ntype SettableKeyType<T extends PropertyContainer> = T extends readonly any[]\n  ? // `KeyType<T>` won't do.\n    // If this `keyof` constraint is not set TypeScript will only constrain values for readonly tuple items to T[number] and not T[K].\n    keyof T\n  : T extends RecordType\n  ? keyof any\n  : KeyType<T>;\n\ntype SettableValueType<T extends PropertyContainer, K> = K extends KeyType<T>\n  ?\n      | ValueType<T, K>\n      // `undefined` removes elements from maps and sets so also allowed.\n      | (T extends MapLike | SetLike ? undefined : never)\n  : T extends RecordType\n  ? any\n  : never;\n\ntype SettableValueFunctionType<T extends PropertyContainer, K, V> = (\n  current: SettableValueType<T, K>\n) => V;\n\ntype IsGeneralKey<T, S = keyof any> = S extends T ? true : false;\n\n/** List of keys in T that has undefined values. If Template does not allow undefined values for a key it is excluded from the reuslts. */\ntype UndefinedKeys<\n  T,\n  Template = {},\n  K extends keyof T = keyof T\n> = K extends keyof T\n  ? T[K] extends undefined\n    ? K extends keyof Template\n      ? undefined extends Template[K]\n        ? K\n        : never\n      : K\n    : never\n  : never;\n\ntype SetSingleResultType<\n  T extends PropertyContainer,\n  K,\n  V\n> = T extends RecordType\n  ? AssignRecord<T, { [P in K & keyof any]: V }>\n  : K extends KeyType<T>\n  ? V extends ValueType<T, K> | (T extends readonly any[] ? never : undefined)\n    ? T\n    : never\n  : never;\n\ntype SettableKeyValueTuple<T extends PropertyContainer> =\n  KeyType<T> extends keyof any\n    ?\n        | {\n            [P in KeyType<T>]: readonly [P, SettableValueType<T, P>];\n          }[KeyType<T>]\n        | (T extends RecordType ? [keyof any, any] : never)\n    : readonly [KeyType<T>, SettableValueType<T, KeyType<T>>];\n\ntype SettableKeyValueRecord<T extends PropertyContainer> =\n  SettableKeyType<T> extends keyof any\n    ? RecordType &\n        ({\n          [P in KeyType<T>]?: SettableValueType<T, P>;\n        } & {\n          [P in SettableKeyType<T>]?: P extends KeyType<T>\n            ? ValueType<T, P>\n            : SettableValueType<T, P>;\n        })\n    : never;\n\ntype SettableValueList<T extends PropertyContainer> = T extends Primitives\n  ? never\n  :\n      | SettableKeyValueRecord<T>\n      | readonly (SettableKeyValueRecord<T> | SettableKeyValueTuple<T>)[];\n\ntype AllKeys<T> = T extends infer T ? keyof T : never;\ntype AnyValue<T, K> = T extends infer T\n  ? K extends keyof T\n    ? T[K]\n    : never\n  : never;\n\ntype MergeObjects<T> = {\n  [P in AllKeys<T>]: AnyValue<T, P>;\n};\n\ntype KeyValueTupleToRecord<Item> = Item extends readonly [infer K, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : Item extends readonly (infer KV)[]\n  ? { [P in KV & keyof any]: KV }\n  : Item extends RecordType\n  ? Item\n  : never;\n\ntype AssignRecord<T, S> = {\n  [P in Exclude<\n    keyof T | keyof S,\n    IsGeneralKey<keyof T | keyof S> extends true ? never : UndefinedKeys<S, T>\n  >]: P extends keyof S\n    ? IsGeneralKey<P> extends true\n      ? AnyValue<S | T, P>\n      : P extends keyof T\n      ? S[P] extends T[P]\n        ? GeneralizeContstants<S[P]> extends T[P]\n          ? GeneralizeContstants<S[P]>\n          : S[P]\n        : never\n      : GeneralizeContstants<S[P]>\n    : P extends keyof T\n    ? T[P]\n    : never;\n};\n\ntype SetResult<\n  T extends PropertyContainer,\n  V extends any\n> = T extends RecordType\n  ? PrettifyIntersection<\n      AssignRecord<\n        T,\n        V extends RecordType\n          ? V\n          : MergeObjects<KeyValueTupleToRecord<V[keyof V]>>\n      >\n    >\n  : T;\n\ntype SetOrUpdateFunction<\n  SettersOnly,\n  ErrorHandler = false,\n  Readonly = false\n> = {\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined,\n    U extends Updater<\n      T extends null | undefined ? never : T,\n      K,\n      ValueType<T, K>,\n      SettersOnly\n    >,\n    K extends KeyType<T>\n  >(\n    target: T,\n    key: K,\n    value: U,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): UpdaterType<U>;\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined\n  >(\n    target: T,\n    values: BulkUpdates<T extends null | undefined ? never : T, SettersOnly>,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): T;\n};\n\nconst createSetOrUpdateFunction =\n  <SettersOnly, Error>(\n    setter: (target: any, key: any, value: any, error?: any) => any\n  ): SetOrUpdateFunction<SettersOnly, Error> =>\n  (target: PropertyContainer, key: any, value?: any, error?: any) => {\n    if (!target) return undefined;\n    if (value) {\n      return setter(target, key, value, error);\n    }\n\n    forEach(key, (item) =>\n      isArray(item)\n        ? setter(target, item[0], item[1])\n        : forEach(item, ([key, value]) => setter(target, key, value))\n    );\n\n    return target;\n  };\n\nexport const assign = createSetOrUpdateFunction<true, false>(setSingle);\nexport const update = createSetOrUpdateFunction<false, false>(updateSingle);\nexport const assignIfUndefined = createSetOrUpdateFunction<false, true>(\n  setSingleIfNotDefined\n);\n\nexport const swap = <T extends PropertyContainer, K extends KeyType<T>>(\n  target: T,\n  key: K,\n  value: ValueType<T, K>\n): ValueType<T, K, \"get\"> => {\n  const current = get(target, key) as any;\n  if (value !== current) setSingle(target, key, value);\n  return current as any;\n};\n\n// #endregion\n\nexport const add = <T extends PropertyContainer<any, boolean>>(\n  target: T,\n  key: KeyType<T>\n) =>\n  target instanceof Set\n    ? target.has(key)\n      ? false\n      : (target.add(key), true)\n    : get(target, key) !== assign(target, key, true as any);\n\nexport const has = <T extends ReadonlyPropertyContainer>(\n  target: T,\n  key: KeyType<T>\n) =>\n  hasMethod(target, \"has\")\n    ? target.has(key)\n    : isDefined((target as any).get?.(key) ?? (target as any)[key]);\n\ntype RemoveDeepArgs<\n  T,\n  Current extends any[] = [],\n  Depth extends number = 20\n> = T extends PropertyContainer\n  ? Depth extends 0\n    ? Current\n    :\n        | (Depth extends 20 ? never : Current)\n        | RemoveDeepArgs<\n            ValueType<T>,\n            [...Current, KeyType<T>[] | KeyType<T>],\n            Minus<Depth, 1>\n          >\n  : Current;\n\ntype RemoveDeepValue<\n  T,\n  Args extends any[],\n  ArrayIt = false\n> = T extends PropertyContainer\n  ? ArrayIt extends true\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>[]]\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>]\n    ? ValueType<T> | undefined\n    : Args extends [infer R, ...infer Rest]\n    ? RemoveDeepValue<ValueType<T>, Rest, R extends any[] ? true : ArrayIt>\n    : never\n  : never;\n\nconst clearSingle = (target: any, key: any) => {\n  if (isUndefined(target ?? key)) return undefined;\n\n  let current = get(target, key);\n\n  if (hasMethod(target, \"delete\")) {\n    target.delete(key);\n  } else {\n    delete target[key];\n  }\n  return current;\n};\n\n/**\n * Removes one or more values from a property container specified by the provided key or array of keys.\n *\n * If more than one level of key arguments are specified, values will be removed from the property container at the deepest level.\n * If a property container becomes empty along the path of keys, it will be removed from its parent.\n *\n */\nexport const clear = <\n  T extends PropertyContainer | null | undefined,\n  Args extends RemoveDeepArgs<T>\n>(\n  target: T,\n  ...keys: Args\n): RemoveDeepValue<T, Args> => {\n  const removed: any[] = [];\n  let array = false;\n\n  const clearStep = (\n    target: any,\n    index: number,\n    parent?: any,\n    parentKey?: any\n  ) => {\n    if (!target) return;\n    const targetKeys = keys[index];\n    if (index === keys.length - 1) {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) => removed.push(clearSingle(target, key)));\n      } else {\n        removed.push(clearSingle(target, targetKeys));\n      }\n    } else {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) =>\n          clearStep(get(target, key), index + 1, target, key)\n        );\n      } else {\n        clearStep(get(target, targetKeys), index + 1, target, targetKeys);\n      }\n      if (!count(target) && parent) {\n        remove(parent, parentKey);\n      }\n    }\n  };\n  clearStep(target, 0);\n  return array ? removed : removed[0];\n};\n\n/**\n * Removes the specified keys from a  property container.\n *\n * The difference between {@link clear} and this function is that it does not consider nested property containers and that arrays will be spliced (as opposed to `clear` where the index will be set to `undefined`).\n */\nexport const remove: {\n  <T extends PropertyContainer | null | undefined>(\n    target: T,\n    key: KeyType<T> | undefined\n  ): T extends null | undefined ? T : ValueType<T, KeyType<T>> | undefined;\n  <T extends PropertyContainer | null | undefined>(\n    target: T,\n    ...keys: (KeyType<T> | undefined)[]\n  ): (T extends null | undefined ? T : ValueType<T, KeyType<T>> | undefined)[];\n} = (target: PropertyContainer, key: any, ...keys: any[]) => {\n  if (!target) return undefined;\n\n  if (keys.length) {\n    // Sort array keys descending as they would otherwise not match their offset as the array is spliced along the way.\n    return (isArray(target) ? keys.sort((x, y) => y - x) : keys).map((key) =>\n      remove(target, key)\n    );\n  }\n\n  return isArray(target)\n    ? key < target.length\n      ? (target as any[]).splice(key, 1)[0]\n      : undefined\n    : clearSingle(target, key);\n};\n\ntype EntryToObject<Item> = Item extends readonly [infer K & keyof any, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : never;\n\ntype EntriesToObject<Entries> = UnionToIntersection<\n  InlinePropertyDescriptors<\n    Entries extends null | undefined | boolean\n      ? {}\n      : Entries extends readonly [\n          Partial<Readonly<PropertyDescriptor>>,\n          ...infer Rest\n        ]\n      ? EntriesToObject<Rest[number]>\n      : Entries extends readonly [infer Item, ...infer Rest]\n      ? EntryToObject<Item> & EntriesToObject<Rest>\n      : Entries extends readonly (infer Items)[]\n      ? EntryToObject<Items>\n      : Entries\n  >\n>;\n\ntype InlinePropertyDescriptors<T> = {\n  [P in keyof T]: T[P] extends () => infer V | { value: infer V }\n    ? V\n    : T[P] extends { get(): infer V }\n    ? V\n    : T[P];\n};\n\ntype PropertyList =\n  | boolean\n  | null\n  | undefined\n  | readonly [defaults: Partial<PropertyDescriptor>, ...items: PropertyList[]]\n  | readonly (readonly [key: keyof any, value: any])[]\n  | RecordType;\n\nexport const define: {\n  <T, P extends readonly PropertyList[]>(\n    target: T,\n    ...properties: P\n  ): (T extends Function ? T : {}) &\n    PrettifyIntersection<T & EntriesToObject<P[number]>>;\n} = (target: any, ...args: readonly any[]) => {\n  const add = (arg: any, defaults?: any) => {\n    if (!arg) return;\n    let properties: readonly any[];\n    if (isArray(arg)) {\n      if (isObject(arg[0])) {\n        // Tuple with the first item the defaults and the next the definitions with those defaults,\n        // ([{enumerable: false, ...}, ...])\n        (arg as any[]).splice(1).forEach((items) => add(items, arg[0]));\n        return;\n      }\n      // ([[key1, value1], [key2, value2], ...])\n      properties = arg;\n    } else {\n      // An object.\n      properties = map(arg)!;\n    }\n\n    properties.forEach(([key, value]) =>\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        writable: false,\n        ...defaults,\n        ...(isObject(value) && (\"get\" in value || \"value\" in value)\n          ? value\n          : isFunction(value) && !value.length\n          ? { get: value }\n          : { value }),\n      })\n    );\n  };\n\n  args.forEach((arg) => add(arg));\n  return target as any;\n};\n\ntype PropertySelector<T> =\n  | keyof T\n  | {\n      [P in keyof T]?: PropertySelector<T[P]> | [...keys: (keyof T[P])[]];\n    };\n\ntype SinglePickResult<T, Selected> = Selected extends\n  | (string & infer K)\n  | (infer K)[]\n  ? { [P in keyof T & K]: T[P] }\n  : keyof Selected extends infer Keys\n  ? {\n      [P in Keys & keyof any & keyof Selected]: P extends keyof T\n        ? Selected[P] extends true\n          ? T[P]\n          : SinglePickResult<T[P], Selected[P]>\n        : never;\n    }\n  : never;\n\ntype PickResults<T, Selectors> = PrettifyIntersection<\n  Selectors extends [infer Item, ...infer Rest]\n    ? SinglePickResult<T, Item> & SinglePickResult<T, Rest>\n    : never\n>;\n\nexport const pick = <T, Selectors extends PropertySelector<T>[], U>(\n  source: T | (null | (undefined & U)),\n  ...args: Selectors\n): U extends undefined ? undefined : PickResults<T, Selectors> => {\n  if (source === undefined) return undefined as any;\n\n  return Object.fromEntries(\n    args.flatMap((arg) =>\n      isObject(arg, true)\n        ? isArray(arg)\n          ? arg.map((args) =>\n              isArray(args)\n                ? args.length === 1\n                  ? [args[0], source![args[0]]]\n                  : pick(source![args[0]], ...(args[1] as any[]))\n                : [args[0], source![args[1]]]\n            )\n          : Object.entries(args).map(([key, value]) => [\n              key,\n              value === true ? source![key] : pick(source![key], value),\n            ])\n        : ([[arg, source![arg]]] as any)\n    )\n  ) as any;\n};\n\nexport type Wrapped<T> = T | (() => Wrapped<T>);\n\nexport type AsyncWrapped<T> = PromiseLike<\n  T | (() => Wrapped<T>) | ((arg: any, ...args: any) => never)\n>;\n\nexport type Unwrap<T> = T extends Wrapped<infer T>\n  ? T\n  : T extends AsyncWrapped<infer T>\n  ? PromiseLike<T>\n  : never;\n\nexport const unwrap: {\n  <T extends Wrapped<any>>(value: T): Unwrap<T>;\n  <T>(value: AsyncWrapped<T>): PromiseLike<T>;\n  <T>(value: Wrapped<T>): T;\n} = (value: Wrapped<any>): any =>\n  isFunction(value)\n    ? unwrap(value())\n    : isAwaitable(value)\n    ? value.then((result) => unwrap(result))\n    : value;\n\nexport const unlock = <T extends ReadonlyPropertyContainer>(\n  readonly: T\n): T extends ReadonlyMapLike<infer K, infer V>\n  ? MapLike<K, V>\n  : T extends ReadonlySetLike<infer T>\n  ? SetLike<T>\n  : T => readonly as any;\n\nexport const wrapFunction = <F extends ((...args: any) => any) | undefined>(\n  original: F,\n  wrap: (\n    original: NonNullable<F>,\n    ...args: Parameters<NonNullable<F>>\n  ) => ReturnType<NonNullable<F>>\n): F => original && (((...args: any) => wrap(original, ...args)) as any);\n\nexport const clone = <T>(value: T, depth: number | boolean = true): T =>\n  isObject(value, true)\n    ? isArray(value)\n      ? depth\n        ? value.map((value) => clone(value, depth === true || --(depth as any)))\n        : [...value]\n      : isSet(value)\n      ? new Set<any>(\n          depth\n            ? (map as any)(value, (value: any) =>\n                clone(value, depth === true || --(depth as any))\n              )\n            : value\n        )\n      : isMap(value)\n      ? new Map<any, any>(\n          depth\n            ? (map as any)(value, (value: any) =>\n                // Does not clone keys.\n                [value[0], clone(value[1], depth === true || --(depth as any))]\n              )\n            : value\n        )\n      : depth\n      ? obj(\n          map(value as any, ([k, v]) => [\n            k,\n            clone(v, depth === true || --(depth as any)),\n          ])!\n        )\n      : { ...value }\n    : (value as any);\n","import {\r\n  IterableOrArrayLike,\r\n  MaybeArray,\r\n  MaybeUndefined,\r\n  ifDefined,\r\n  isArray,\r\n  isIterable,\r\n  last,\r\n  map,\r\n} from \"..\";\r\n\r\nexport const pluralize = <T>(\r\n  noun: T,\r\n  count: number\r\n): MaybeUndefined<T, string> =>\r\n  ifDefined(noun, () => noun + (count !== 1 ? \"s\" : \"\"));\r\n\r\nexport const conjunct = <T>(\r\n  values: T,\r\n  conjunction = \"and\"\r\n): MaybeUndefined<T, string> =>\r\n  ifDefined(\r\n    values,\r\n    (values: any) => (\r\n      (values = isIterable(values)\r\n        ? map(values, (value) => value + \"\")\r\n        : [values + \"\"]),\r\n      values.length === 0\r\n        ? \"\"\r\n        : values.length === 1\r\n        ? values[0]\r\n        : `${values.slice(0, -1).join(\", \")} ${conjunction} ${last(values)}`\r\n    )\r\n  );\r\n\r\nexport const quote = <T>(\r\n  item: T\r\n): MaybeUndefined<\r\n  T,\r\n  T extends string\r\n    ? string\r\n    : T extends IterableOrArrayLike<any>\r\n    ? string[]\r\n    : string\r\n> =>\r\n  ifDefined(item, (item) =>\r\n    isIterable(item) ? map(item, (item) => \"'\" + item + \"'\") : \"'\" + item + \"'\"\r\n  ) as any;\r\n\r\nexport const capitalize = <T extends string | undefined>(\r\n  sentence: T\r\n): MaybeUndefined<T, string> =>\r\n  ifDefined(sentence, (sentence) =>\r\n    sentence.length > 0\r\n      ? sentence.slice(0, 1).toUpperCase() + sentence.slice(1)\r\n      : \"\"\r\n  );\r\n","import {\r\n  Entries,\r\n  IsAny,\r\n  IsUnknown,\r\n  Not,\r\n  Nullish,\r\n  define,\r\n  isDefined,\r\n  isNumber,\r\n  isString,\r\n  throwError,\r\n  undefined,\r\n} from \".\";\r\nimport { conjunct, quote } from \"./types/strings\";\r\n\r\nexport type ParsedValue<\r\n  T extends EnumHelper<any, any, any>,\r\n  V\r\n> = V extends Nullish\r\n  ? V\r\n  : T extends EnumHelper<infer T, any, any>\r\n  ? V extends keyof T\r\n    ? T[V]\r\n    : V extends T[keyof T]\r\n    ? V\r\n    : number\r\n  : never;\r\n\r\nexport type ParsableEnumValue<\r\n  T extends EnumHelper<any, any, any>,\r\n  Numeric\r\n> = T extends EnumHelper<infer T, any, any> & {\r\n  values: readonly (infer Enum)[];\r\n  pure?: infer PureFlags;\r\n}\r\n  ? Extract<\r\n      ParsableEnumTypeValue<\r\n        T,\r\n        Numeric,\r\n        Not<IsUnknown<PureFlags>>,\r\n        Enum & number\r\n      >,\r\n      string | number | string[] | number[] | (string | undefined | number)[]\r\n    >\r\n  : never;\r\n\r\nexport type EnumHelper<\r\n  T extends EnumSource,\r\n  Flags extends boolean,\r\n  PureFlags extends number\r\n> = ParseFunction<T, Flags, \"numeric\", never, true> &\r\n  Readonly<\r\n    {\r\n      /**\r\n       * The number of possible unqiue values in the enumeration.\r\n       */\r\n      length: number;\r\n      /**\r\n       * Converts the provided value to its numeric value or throws an exception if it does not match a value in the enumeration.\r\n       */\r\n      parse: ParseFunction<T, Flags, \"numeric\">;\r\n\r\n      /**\r\n       * Converts the provided value to its numeric value or returns `undefined` if it does not match a value in the enumeration.\r\n       */\r\n      tryParse: ParseFunction<T, Flags, \"numeric\", undefined>;\r\n\r\n      /**\r\n       * All values of the enumeration.\r\n       */\r\n      values: T[keyof T][];\r\n\r\n      /**\r\n       * All names and values of the enumeration.\r\n       */\r\n      entries: string extends keyof T\r\n        ? readonly [string, T[keyof T]][]\r\n        : Entries<T>;\r\n\r\n      /**\r\n       * Looks up a value and returns its name or array of names if the enumeration represents flags.\r\n       */\r\n      lookup: ParseFunction<T, Flags, \"lookup\">;\r\n\r\n      /**\r\n       * Looks up a value and returns its name if it matches a single value in the enumeration ,\r\n       * or an array of names if the enumeration represents flags and the value matches more than one.\r\n       */\r\n      format: ParseFunction<T, Flags, \"format\">;\r\n\r\n      /**\r\n       * Pretty prints an enumeration value with its name and values suitable for logging and error messages.\r\n       * For example \"The values 'test 1' or 'test 2'\".\r\n       */\r\n      logFormat(value: ParsableArg<T, Flags>, conjunction?: string): string;\r\n    } & (Flags extends true\r\n      ? {\r\n          /** Flag values that are not a combination of other flags (that is, a single bit). */\r\n          pure: readonly EntriesByValue<T, PureFlags>[];\r\n          map<R = T[keyof T]>(\r\n            flags: ParsableEnumTypeValue<T, boolean | undefined, Flags>,\r\n            map?: (entry: EntriesByValue<T, PureFlags>, index: number) => R\r\n          ): R[];\r\n        }\r\n      : {})\r\n  >;\r\n\r\ntype EnumSource = Record<string, string | number>;\r\n\r\ntype MaybeArray<T, Flags, ArrayIfArray = false> = Flags extends true\r\n  ? (ArrayIfArray extends true ? never : T) | T[]\r\n  : T;\r\n\r\ntype Lowercased<T extends EnumSource> = {\r\n  [P in keyof T & string as Lowercase<P>]: T[P];\r\n};\r\n\r\ntype Lookup<T extends EnumSource, V, Name extends boolean> = V extends never\r\n  ? never\r\n  : {\r\n      [P in keyof T]: V extends T[P] ? (Name extends true ? P : T[P]) : never;\r\n    } extends infer T\r\n  ? T[keyof T]\r\n  : never;\r\n\r\ntype ParsedValueInternal<T extends EnumSource, V, Flags> = V extends keyof T\r\n  ? T[V]\r\n  : V extends T[keyof T]\r\n  ? Lookup<T, V, false>\r\n  : [Flags, V] extends [true, number]\r\n  ? T[keyof T]\r\n  : never;\r\n\r\ntype ParsableEnumTypeValue<\r\n  T extends EnumSource,\r\n  Numeric,\r\n  Flags extends boolean,\r\n  Enum extends number = T[keyof T] & number\r\n> =\r\n  | (boolean extends Numeric\r\n      ? MaybeArray<\r\n          | (Flags extends true ? number | Enum : Enum)\r\n          | keyof T\r\n          | (Flags extends true ? \"any\" | \"none\" : never),\r\n          Flags\r\n        >\r\n      : Numeric extends true\r\n      ? Flags extends true\r\n        ? Enum | (number & {})\r\n        : Enum\r\n      : Flags extends true\r\n      ? keyof T | readonly (keyof T)[]\r\n      : keyof T)\r\n  | (undefined extends Numeric ? undefined : never);\r\n\r\ntype ParsableArg<\r\n  T extends EnumSource,\r\n  Flags extends boolean\r\n> = ParsableEnumTypeValue<T, boolean | undefined, Flags>;\r\n\r\ntype ParseFunction<\r\n  T extends EnumSource,\r\n  Flags extends boolean,\r\n  Type extends \"numeric\" | \"lookup\" | \"format\",\r\n  InvalidValue extends undefined | never = never,\r\n  MainFunction = false\r\n> = {\r\n  <V extends string | number | symbol | null | undefined>(\r\n    value:\r\n      | V\r\n      | ParsableArg<T, Flags>\r\n      | (Flags extends true ? V[] | ParsableArg<T, Flags>[] : never),\r\n    ...args: MainFunction extends true ? [] : [validateNumbers?: boolean]\r\n  ): V extends null | undefined\r\n    ? undefined\r\n    : Type extends \"lookup\" | \"format\"\r\n    ? MaybeArray<\r\n        | (ParsedValueInternal<T, V, Flags> extends never\r\n            ? V extends string | number\r\n              ? keyof T | \"any\" | \"none\" | InvalidValue\r\n              : InvalidValue\r\n            : Lookup<T, ParsedValueInternal<T, V, Flags>, true>)\r\n        | (Type extends \"format\"\r\n            ? V extends keyof T | T[keyof T]\r\n              ? never\r\n              : \"any\" | \"none\"\r\n            : never),\r\n        Flags,\r\n        Type extends \"lookup\" ? true : false\r\n      >\r\n    : ParsedValueInternal<T, V, Flags> extends never\r\n    ? string extends V\r\n      ? T[keyof T] | InvalidValue\r\n      : InvalidValue\r\n    : ParsedValueInternal<T, V, Flags>;\r\n};\r\n\r\ntype EntriesByValue<T extends Record<keyof any, any>, V extends keyof any> = {\r\n  [P in keyof T as T[P]]: readonly [P, T[P]];\r\n}[V] extends infer T // Use the infer trick to make vscode intellisense expand the values.\r\n  ? T\r\n  : never;\r\n\r\nexport const createEnumAccessor = <\r\n  T extends EnumSource,\r\n  Flags extends boolean,\r\n  PureFlags extends number = 0\r\n>(\r\n  sourceEnum: T,\r\n  flags: Flags,\r\n  enumName: string,\r\n  pureFlags?: PureFlags\r\n): EnumHelper<Lowercased<T>, Flags, PureFlags> => {\r\n  const names: Record<string, number> = Object.fromEntries(\r\n    Object.entries(sourceEnum as any)\r\n      .filter(([key, value]) => isString(key) && isNumber(value))\r\n      .map(([key, value]) => [key.toLowerCase(), value])\r\n  ) as any;\r\n\r\n  const entries = Object.entries(names);\r\n  const values = Object.values(names);\r\n  const any = values.reduce((any, flag) => any | flag, 0);\r\n\r\n  const nameLookup: Record<string, number> = flags\r\n    ? { ...names, any, none: 0 }\r\n    : names;\r\n  const valueLookup = Object.fromEntries(\r\n    entries.map(([key, value]) => [value, key])\r\n  );\r\n\r\n  const parseValue = (value: any, validateNumbers?: boolean) =>\r\n    isString(value)\r\n      ? nameLookup[value] ?? nameLookup[value.toLowerCase()]\r\n      : isNumber(value)\r\n      ? !flags && validateNumbers\r\n        ? isDefined(valueLookup[value])\r\n          ? value\r\n          : undefined\r\n        : value\r\n      : undefined;\r\n\r\n  const [tryParse, lookup] = flags\r\n    ? [\r\n        (value: any, validateNumbers?: boolean) =>\r\n          Array.isArray(value)\r\n            ? value.reduce(\r\n                (flags, flag) =>\r\n                  (flag = parseValue(flag, validateNumbers)) == null\r\n                    ? flags\r\n                    : (flags ?? 0) | flag,\r\n                undefined as number | undefined\r\n              )\r\n            : parseValue(value),\r\n        (value: any, format: boolean) =>\r\n          (value = tryParse(value, false)) == null\r\n            ? undefined\r\n            : format && (value & any) === any\r\n            ? \"any\"\r\n            : ((value = entries\r\n                .filter(([, flag]) => value & flag)\r\n                .map(([name]) => name)),\r\n              format\r\n                ? value.length\r\n                  ? value.length === 1\r\n                    ? value[0]\r\n                    : value\r\n                  : \"none\"\r\n                : value),\r\n      ]\r\n    : [\r\n        parseValue,\r\n        (value: any) =>\r\n          (value = parseValue(value)) != null ? valueLookup[value] : undefined,\r\n      ];\r\n\r\n  let originalValue: any;\r\n  const parse = (value: any, validateNumbers?: boolean) =>\r\n    value == null\r\n      ? undefined\r\n      : (value = tryParse((originalValue = value), validateNumbers)) == null\r\n      ? throwError(\r\n          new TypeError(\r\n            `${JSON.stringify(originalValue)} is not a valid ${enumName} value.`\r\n          )\r\n        )\r\n      : value;\r\n\r\n  const pure = entries.filter(([, value]) => !pureFlags || pureFlags & value);\r\n  return define(\r\n    (value: any) => parse(value),\r\n    [\r\n      { configurable: false, enumerable: false },\r\n      {\r\n        parse,\r\n        tryParse,\r\n        entries,\r\n        values,\r\n        lookup,\r\n        length: entries.length,\r\n        format: (value: any) => lookup(value, true),\r\n        logFormat: (value: any, c = \"or\") => (\r\n          (value = lookup(value, true)),\r\n          value === \"any\"\r\n            ? \"any \" + enumName\r\n            : `the ${enumName} ${conjunct(quote(value), c)}`\r\n        ),\r\n      } as const,\r\n      flags &&\r\n        ({\r\n          pure,\r\n          map: (flags: any, map?: (flag: any, index: number) => any) => (\r\n            (flags = parse(flags)),\r\n            pure\r\n              .filter(([, flag]) => flag & flags)\r\n              .map(map ?? (([, flag]) => flag))\r\n          ),\r\n        } as const),\r\n    ]\r\n  ) as any;\r\n};\r\n","import {\r\n  Defined,\r\n  Falsish,\r\n  IsAny,\r\n  MaybePromise,\r\n  NotFunction,\r\n  OmitNullish,\r\n  Wrapped,\r\n  isArray,\r\n  isBoolean,\r\n  isDefined,\r\n  isFunction,\r\n  isString,\r\n  unwrap,\r\n} from \"..\";\r\n\r\nexport type ErrorGenerator = string | Error | (() => string | Error);\r\n\r\nexport const throwError = (\r\n  error: ErrorGenerator,\r\n  transform: (string: string) => Error = (message) => new TypeError(message)\r\n): never => {\r\n  throw isString((error = unwrap(error))) ? transform(error) : error;\r\n};\r\n\r\ntype CombineTypeTests<T> = T extends []\r\n  ? {}\r\n  : T extends [infer F, ...infer Rest]\r\n  ? F extends (value: any) => value is infer R\r\n    ? (IsAny<R> extends true ? T : R) & CombineTypeTests<Rest>\r\n    : never\r\n  : never;\r\n\r\nexport const validate = <\r\n  T,\r\n  Validator extends\r\n    | ((candidate: T) => candidate is any)\r\n    | ((candiate: T) => R)\r\n    | [\r\n        validate: (candiate: T) => any,\r\n        ...typeTests: ((candidate: T) => candidate is any)[]\r\n      ]\r\n    | (R & NotFunction),\r\n  R\r\n>(\r\n  value: T,\r\n  validate: Validator | R,\r\n  validationError?: ErrorGenerator,\r\n  undefinedError?: ErrorGenerator\r\n): Defined<\r\n  Validator extends [any, ...infer TypeTests]\r\n    ? CombineTypeTests<TypeTests>\r\n    : Validator extends ((value: any) => infer R) | infer R\r\n    ? R extends Falsish\r\n      ? never\r\n      : Validator extends (value: any) => value is infer R\r\n      ? IsAny<R> extends true\r\n        ? T\r\n        : Defined<R>\r\n      : T\r\n    : never\r\n> =>\r\n  (\r\n    isArray(validate)\r\n      ? validate.every((test) => test(value))\r\n      : isFunction(validate)\r\n      ? validate(value)\r\n      : validate\r\n  )\r\n    ? value\r\n    : required(value, undefinedError ?? validationError) &&\r\n      (throwError(validationError ?? \"Validation failed.\") as any);\r\n\r\nexport class InvariantViolatedError extends Error {\r\n  constructor(invariant?: string) {\r\n    super(invariant ? \"INV: \" + invariant : \"An invariant was violated.\");\r\n  }\r\n}\r\n\r\n/** Tests whether a value equals at least one of some other values.  */\r\nexport const eq: <T extends readonly any[]>(\r\n  target: any,\r\n  ...values: T\r\n) => target is T[number] = ((\r\n  target: any,\r\n  singleValue: any,\r\n  ...otherValues: any\r\n) =>\r\n  target === singleValue ||\r\n  (otherValues.length > 0 &&\r\n    otherValues.some((value) => target === value))) as any;\r\n\r\n/**\r\n * States an invariant.\r\n */\r\nexport const invariant = <T>(\r\n  test: Wrapped<T | false>,\r\n  description?: string\r\n): Defined<T> => {\r\n  const valid = unwrap(test);\r\n  return isDefined(valid) && valid !== false\r\n    ? (valid as any)\r\n    : throwError(new InvariantViolatedError(description));\r\n};\r\n\r\nexport const required = <T>(value: T, error?: ErrorGenerator): OmitNullish<T> =>\r\n  value != null\r\n    ? (value as any)\r\n    : throwError(\r\n        error ?? \"A required value is missing\",\r\n        (text) => new TypeError(text.replace(\"...\", \" is required.\"))\r\n      );\r\n\r\nexport const tryCatch = <T, C = undefined>(\r\n  expression: () => T,\r\n  errorHandler: boolean | ((error: any) => C) = true as any,\r\n  clean?: () => void\r\n): T | (C extends Error ? T : C) => {\r\n  try {\r\n    return expression();\r\n  } catch (e) {\r\n    if (!isBoolean(errorHandler)) {\r\n      const error = errorHandler?.(e) as any;\r\n      if (error instanceof Error) throw error;\r\n      return error;\r\n    }\r\n    if (errorHandler) {\r\n      throw e;\r\n    }\r\n    console.error(e);\r\n    return undefined as any;\r\n  } finally {\r\n    clean?.();\r\n  }\r\n};\r\n\r\nexport const tryCatchAsync = async <T, C = void>(\r\n  expression: Wrapped<MaybePromise<T>>,\r\n  errorHandler:\r\n    | boolean\r\n    | ((error: any, last: boolean) => Promise<C> | C) = true as any,\r\n  clean?: () => void,\r\n  retries = 1\r\n): Promise<T | C> => {\r\n  while (retries--) {\r\n    try {\r\n      return (await unwrap(expression)) as any;\r\n    } catch (e) {\r\n      if (!isBoolean(errorHandler)) {\r\n        const error = (await errorHandler?.(e, !retries)) as any;\r\n        if (error instanceof Error) throw error;\r\n        return error;\r\n      } else if (errorHandler && !retries) {\r\n        throw e;\r\n      } else {\r\n        console.error(e);\r\n      }\r\n    } finally {\r\n      clean?.();\r\n    }\r\n  }\r\n  return undefined as any;\r\n};\r\n","import { ParsableEnumValue, createEnumAccessor } from \"@tailjs/util\";\n\n/**\n * Defines to which extend a piece of information relates to a natural person (user of your app or website).\n *\n * Tail.js requires all data points (data types and their properties) to be classified to prevent any data from being stored or otherwise used beyond a user's consent.\n *\n * YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with its default settings, intended design or implementation.\n */\nexport enum DataClassification {\n  /**\n   * The data cannot reasonably be linked to a specific user after the user leaves the website or app, and their session ends.\n   *\n   * Tail.js will collect this kind of data in a way that does not use cookies or rely on other information persisted in the user's device.\n   *\n   * Identifying returning visitors will not be possible at this level.\n   * In-session personalization will be possible based on the actions a user has taken such as adding or removing things to a shopping basket, or reading an article.\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with its default settings, intended design or implementation.\n   */\n  Anonymous = 0,\n\n  /**\n   * The data may possibly identify the user if put into context with other data, yet not specifically on its own.\n   *\n   * Examples of data you should classify as at least indirect personal data are IP addresses, detailed location data, and randomly generated device IDs persisted over time to track returning visitors.\n   *\n   * Identifying returning visitors will be possible at this level of consent, but not across devices.\n   * Some level of personalization to returning visitors will be possible without knowing their specific preferences with certainty.\n   *\n   * This level is the default when a user has consented to necessary infomration being collected via a  cookie discalimer or similar.\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with its default settings, intended design or implementation.\n   */\n  Indirect = 1,\n\n  /**\n   * The data directly identifies the user on its own.\n   *\n   * Examples are name, username, street address and email address.\n   *\n   * Identifying returning visitors across devices will be possible at this level of consent.\n   * Personalization based on past actions such as purchases will also be possible.\n   *\n   * This level is the default should be considered the default level if users are offered an option to create a user profile or link an existing user profile from an external identity provider (Google, GitHub, Microsoft etc.).\n   *\n   * Please note it is possible to access user data even when nothing is tracked beyond the bla... level\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with default settings.\n   */\n  Direct = 2,\n\n  /**\n   * Sensitive data about a user.\n   *\n   * Examples are data related to health, financial matters, race, political and religious views, and union membership.\n   * If the user is given the option to consent at this level, it should be very clear, and you must make sure that all levels of your tail.js implementation and connected services meets the necessary levels of compliance for this in your infrastructure.\n   *\n   * Identifying returning visitors across devices will be possible at this level of consent.\n   * and so will advanced personalization.\n   *\n   * As always, YOU (or client and/or employer) are responsible for the legality of the collection of data, its classification at any level of consent for any duration of time - not tail.js, even with default settings.\n   */\n  Sensitive = 3,\n}\n\nexport const dataClassification = createEnumAccessor(\n  DataClassification as typeof DataClassification,\n  false,\n  \"data classification\"\n);\n\nexport type DataClassificationValue<Numeric = boolean> = ParsableEnumValue<\n  typeof dataClassification,\n  Numeric\n> extends infer T\n  ? T\n  : never;\n","import { ParsableEnumValue, createEnumAccessor } from \"@tailjs/util\";\r\n\r\n// Grrr... We need to write out the calculated numbers for each enum value. Otherwise stupid JSON schema generator won't work.\r\n\r\n/** Purposes data can be used for, including combinations of {@link DataPurpose} */\r\nexport enum DataPurposeFlags {\r\n  /** Data without a purpose will not get stored and cannot be used for any reason. This can be used to disable parts of a schema. */\r\n  None = 0,\r\n\r\n  /**\r\n   * Data stored for this purpose is vital for the system, website or app to function.\r\n   */\r\n  Necessary = 1,\r\n\r\n  /**\r\n   * Data stored for this purpose is used for personalization or otherwise adjust the appearance of a website or app\r\n   * according to a user's preferences.\r\n   *\r\n   * DO NOT use this category if the data may be shared with third parties or otherwise used for targeted marketing outside the scope\r\n   * of the website or app. Use {@link DataPurposeFlags.Targeting} instead.\r\n   *\r\n   * It may be okay if the data is only used for different website and apps that relate to the same product or service.\r\n   * This would be the case if a user is able to use an app and website interchangably for the same service. Different areas of a brand may\r\n   * also be distributed across multiple domain names.\r\n   *\r\n   */\r\n  Functionality = 2,\r\n\r\n  /**\r\n   * Data stored for this purpose is used to gain insights on how users interact with a website or app optionally including\r\n   * demographics and similar traits with the purpose of optimizing the website or app.\r\n   *\r\n   * DO NOT use this category if the data may be shared with third parties or otherwise used for targeted marketing outside the scope\r\n   * of the website or app. Use {@link DataPurposeFlags.Targeting} instead.\r\n   *\r\n   * It may be okay if the data is only used for different website and apps that relate to the same product or service.\r\n   * This would be the case if a user is able to use an app and website interchangably for the same service. Different areas of a brand may\r\n   * also be distributed across multiple domain names.\r\n   *\r\n   */\r\n  Performance = 4,\r\n\r\n  /**\r\n   * Data stored for this purpose may be similar to both functionality and performance data, however it may be shared with third parties\r\n   * or otherwise used to perform marketing outside the scope of the specific website or app.\r\n   *\r\n   * If the data is only used for different website and apps that relate to the same product or service, it might not be necessary\r\n   * to use this category.\r\n   * This would be the case if a user is able to use an app and website interchangably for the same service. Different areas of a brand may\r\n   * also be distributed across multiple domain names.\r\n   */\r\n  Targeting = 8,\r\n\r\n  /**\r\n   * Data stored for this purpose is used for security purposes. As examples, this can both be data related to securing an authenticated user's session,\r\n   * or for a website to guard itself against various kinds of attacks.\r\n   *\r\n   * This is implicitly also `Necessary`.\r\n   */\r\n  Security = 16,\r\n\r\n  /**\r\n   * Data stored for this purpose may be similar to the performance category, however it is specifically\r\n   * only used for things such as health monitoring, system performance and error logging and unrelated to user behavior.\r\n   *\r\n   * This is implicitly also `Necessary`.\r\n   */\r\n  Infrastructure = 32,\r\n\r\n  /**\r\n   * All purposes that are permissable for anonymous users.\r\n   */\r\n  Anonymous = 49, //DataPurposes.Necessary | DataPurposes.Infrastructure | DataPurposes.Security,\r\n\r\n  /**\r\n   * Data can be used for any purpose.\r\n   */\r\n  Any = 63,\r\n}\r\n\r\nexport type DataPurpose =\r\n  | DataPurposeFlags.Necessary\r\n  | DataPurposeFlags.Functionality\r\n  | DataPurposeFlags.Performance\r\n  | DataPurposeFlags.Targeting\r\n  | DataPurposeFlags.Security\r\n  | DataPurposeFlags.Infrastructure;\r\n\r\nconst purePurposes: DataPurpose =\r\n  DataPurposeFlags.Necessary |\r\n  DataPurposeFlags.Functionality |\r\n  DataPurposeFlags.Performance |\r\n  DataPurposeFlags.Targeting |\r\n  DataPurposeFlags.Security |\r\n  DataPurposeFlags.Infrastructure;\r\n\r\nexport const dataPurposes = createEnumAccessor(\r\n  DataPurposeFlags as typeof DataPurposeFlags,\r\n  true,\r\n  \"data purpose\",\r\n  purePurposes\r\n);\r\n\r\nexport const singleDataPurpose = createEnumAccessor(\r\n  DataPurposeFlags as typeof DataPurposeFlags,\r\n  false,\r\n  \"data purpose\"\r\n);\r\n\r\nexport type DataPurposeValue<Numeric = boolean> = ParsableEnumValue<\r\n  typeof dataPurposes,\r\n  Numeric\r\n> extends infer T\r\n  ? T\r\n  : never;\r\n","import { required } from \"@tailjs/util\";\r\nimport {\r\n  DataClassification,\r\n  DataClassificationValue,\r\n  DataPurposeValue,\r\n  DataPurposeFlags,\r\n  VariableClassification,\r\n  dataClassification,\r\n  dataPurposes,\r\n} from \".\";\r\n\r\n/** A user's consent choices.  */\r\nexport interface UserConsent<NumericEnums = boolean> {\r\n  /**\r\n   * The highest level of data classification the user has consented to be stored.\r\n   */\r\n  level: DataClassificationValue<NumericEnums>;\r\n\r\n  /**\r\n   * The purposes the user has consented their data to be used for.\r\n   */\r\n  purposes: DataPurposeValue<NumericEnums>;\r\n}\r\n\r\nexport const NoConsent: Readonly<UserConsent> = Object.freeze({\r\n  level: DataClassification.Anonymous,\r\n  purposes: DataPurposeFlags.Anonymous,\r\n});\r\n\r\nexport const FullConsent: Readonly<UserConsent> = Object.freeze({\r\n  level: DataClassification.Sensitive,\r\n  purposes: DataPurposeFlags.Any,\r\n});\r\n\r\nexport const isUserConsent = (value: any) => !!value?.[\"level\"];\r\n\r\nexport const validateConsent = (\r\n  source:\r\n    | { classification?: DataClassificationValue; purposes?: DataPurposeValue }\r\n    | undefined,\r\n  consent:\r\n    | UserConsent\r\n    | { classification: DataClassificationValue; purposes: DataPurposeValue },\r\n  defaultClassification?: Partial<VariableClassification>\r\n) => {\r\n  if (!source) return undefined;\r\n  const classification =\r\n    dataClassification.parse(source.classification, false) ??\r\n    required(\r\n      dataClassification(defaultClassification?.classification),\r\n      \"The source has not defined a data classification and no default was provided.\"\r\n    );\r\n  let purposes =\r\n    dataPurposes.parse(source.purposes, false) ??\r\n    required(\r\n      dataPurposes.parse(defaultClassification?.purposes, false),\r\n      \"The source has not defined data purposes and no default was provided.\"\r\n    );\r\n\r\n  return (\r\n    source &&\r\n    classification! <=\r\n      dataClassification.parse(\r\n        consent[\"classification\"] ?? consent[\"level\"],\r\n        false\r\n      ) &&\r\n    (purposes &\r\n      // No matter what is defined in the consent, it will always include the \"anonymous\" purposes.\r\n      (dataPurposes.parse(consent.purposes, false) |\r\n        DataPurposeFlags.Anonymous)) >\r\n      0\r\n  );\r\n};\r\n","import {\n  MaybeUndefined,\n  Nullish,\n  ParsableEnumValue,\n  createEnumAccessor,\n  isUndefined,\n} from \"@tailjs/util\";\nimport {\n  DataClassification,\n  DataClassificationValue,\n  DataPurposeFlags,\n  DataPurposeValue,\n  Timestamp,\n  dataClassification,\n  dataPurposes,\n  singleDataPurpose,\n} from \"..\";\n\nexport enum VariableScope {\n  /** Global variables. */\n  Global = 0,\n\n  /** Variables related to sessions. */\n  Session = 1,\n\n  /** Variables related to a device (browser or app). */\n  Device = 2,\n\n  /** Variables related to an identified user. */\n  User = 3,\n\n  /**\n   * Variables related to an external identity.\n   * One use case could be used to augment data a CMS with real-time data related to personalization or testing.\n   */\n  Entity = 4,\n}\n\nexport const variableScope = createEnumAccessor(\n  VariableScope as typeof VariableScope,\n  false,\n  \"variable scope\"\n);\n\nexport type VariableScopeValue<Numeric extends boolean | undefined = boolean> =\n  ParsableEnumValue<typeof variableScope, Numeric>;\n\n/** Transforms properties with known enum types to their parsable counterparts. */\nexport type Parsable<T, Numeric extends boolean | undefined = boolean> = {\n  [P in keyof T]: T[P] extends DataClassification | undefined | null\n    ? DataClassificationValue<MaybeUndefined<T[P], Numeric>>\n    : T[P] extends DataPurposeFlags | undefined | null\n    ? DataPurposeValue<MaybeUndefined<T[P], Numeric>>\n    : T[P] extends VariableScope | undefined | null\n    ? VariableScopeValue<MaybeUndefined<T[P], Numeric>>\n    : Parsable<T[P], Numeric>;\n};\n\n/**\n * Uniquely addresses a variable by scope, target and key name.\n */\nexport interface VariableKey<NumericEnums extends boolean = boolean> {\n  /** The scope the variable belongs to. */\n  scope: VariableScopeValue<NumericEnums>;\n\n  /**\n   * The name of the variable.\n   *\n   * A key may have a prefix that decides which variable storage it is routed to.\n   * The prefix and the key are separated by colon (`prefix:key`). Additional colons will be considered part of the variable name.\n   * To address a variable with a colon in its name without prefix use `:key`, for example `:colon:in:my:name`.\n   */\n  key: string;\n\n  /**\n   * The ID of the entity in the scope the variable belongs to.\n   * This is ignored for global variables, and can be set to `\"\"`.\n   */\n  targetId?: string;\n}\n\n/**\n * A {@link VariableKey} that optionally includes the expected version of a variable value.\n * This is used for \"if none match\" queries to invalidate caches efficiently.\n */\nexport interface VersionedVariableKey<NumericEnums extends boolean = boolean>\n  extends VariableKey<NumericEnums> {\n  version?: string;\n}\n\n/**\n * Defines how the value of variable is classified and for which purposes it can be used.\n */\nexport interface VariableClassification<\n  NumericEnums extends boolean = boolean\n> {\n  /**\n   * The legal classification of the kind of data a variable holds.\n   * This limits which data will be stored based on a user's consent.\n   */\n  classification: DataClassificationValue<NumericEnums>;\n\n  /**\n   * Optionally defines the possible uses of the data a variables holds (they are binary flags).\n   * When a variable is requested by some logic, it may be stated what the data is used for.\n   * If the user has not consented to data being used for this purpose the variable will not be avaiable.\n   */\n  purposes: DataPurposeValue<NumericEnums>;\n}\n\nexport interface VariableMetadata {\n  /**\n   * Optionally categorizes variables.\n   *\n   * For example, the tag `address` could be used for all variables related to a user's address,\n   * or `newsletter` for everything related to newsletter subscriptions.\n   */\n  tags?: string[];\n}\n\n/**\n * Information about when a variable's value was modified and a unqiue version (ETag) used for conflict resolution\n * in case multiple processes try to update it at the same time (optimistic concurrency).\n *\n * Only the version, and not the modified timestamp must be relied on during conflict resolution.\n */\nexport interface VariableVersion {\n  /**\n   * Timestamp for when the variable was created.\n   */\n  created?: Timestamp;\n\n  /**\n   * Timestamp for when the variable was created or modified.\n   */\n  modified?: Timestamp;\n\n  /**\n   * A unique token that changes everytime a variable is changed.\n   * It follows the semantics of a \"weak\" ETag in the HTTP protocol.\n   * How the value is generated is an internal implementation detail specific to the storage that manages the variable.\n   *\n   * The value is only undefined if it is not assumed to exist before a set operation.\n   */\n  version?: string | undefined;\n}\n\n/**\n * All data related to a variable except its value.\n */\nexport interface VariableHeader<NumericEnums extends boolean = true>\n  extends VariableKey<NumericEnums>,\n    VariableClassification<NumericEnums>,\n    VariableMetadata,\n    VariableVersion {}\n\n/**\n * A variable is a specific piece of information that can be classified and changed independently.\n * A variable can either be global or related to a specific entity or tracker scope.\n */\nexport interface Variable<T = any, NumericEnums extends boolean = true>\n  extends VariableHeader<NumericEnums> {\n  /**\n   * The value of the variable is read-only. Trying to update its value in its storage will result in an error.\n   */\n  readonly?: boolean;\n\n  /**\n   * The value of the variable. It must only be undefined in a set operation in which case it means \"delete\".\n   */\n  value: T;\n}\n\n/**\n * The information needed about a variable to validate whether it complies with a user's consents,\n * or meets other authorization based requirements.\n */\nexport type VariableValidationBasis<NumericEnums extends boolean = boolean> =\n  VariableKey<NumericEnums> & Partial<VariableClassification<NumericEnums>>;\n\n/** Returns a description of a key that can be used for logging and error messages.  */\nexport const formatKey = (key: VariableKey<true> | VariableKey) =>\n  `'${key.key}' in ${variableScope.format(key.scope)} scope`;\n\n/** The individual parts of a key specifed as string. */\nexport type ParsedKey = {\n  /** The prefix of the key, or the empty string if none. */\n  prefix: string;\n\n  /** The excluding its prefix. */\n  key: string;\n\n  /** The original key string. */\n  sourceKey: string;\n\n  /** For queries. */\n  not?: boolean;\n};\n\nexport const stripPrefix = <T extends VariableKey | undefined>(key: T): T =>\n  key && { ...key, key: parseKey(key.key).key };\n\n/** Returns the individual parts of a key specified as a string.  */\nexport const parseKey = <T extends string | undefined>(\n  sourceKey: T\n): MaybeUndefined<T, ParsedKey> => {\n  if (isUndefined(sourceKey)) return undefined as any;\n  const not = sourceKey[0] === \"!\";\n  if (not) {\n    sourceKey = (sourceKey.slice(1) as T)!;\n  }\n  const prefixIndex = sourceKey.indexOf(\":\");\n  const prefix = prefixIndex < 0 ? \"\" : sourceKey.substring(0, prefixIndex);\n  const key = prefixIndex > -1 ? sourceKey.slice(prefixIndex + 1) : sourceKey;\n\n  return {\n    prefix,\n    key,\n    sourceKey,\n    not,\n  } as any;\n};\n\ntype EnumPropertyType<\n  P extends keyof any,\n  Default,\n  Props\n> = Props extends readonly []\n  ? Default\n  : Props extends readonly [\n      readonly [infer Key, { values: (infer T)[] }],\n      ...infer Rest\n    ]\n  ? P extends Key\n    ? T\n    : EnumPropertyType<P, Default, Rest>\n  : never;\n\nconst enumProperties = [\n  [\"scope\", variableScope],\n  [\"purpose\", singleDataPurpose],\n  [\"purposes\", dataPurposes],\n  [\"classification\", dataClassification],\n] as const;\n\nexport const toNumericVariable: <T>(value: T) => T extends Nullish\n  ? T\n  : {\n      [P in keyof T]: EnumPropertyType<P, T[P], typeof enumProperties>;\n    } = (value: any) => {\n  if (!value) return value;\n\n  enumProperties.forEach(\n    ([prop, helper]) => (value[prop] = helper.parse(value[prop]))\n  );\n\n  return value as any;\n};\n","import {\r\n  If,\r\n  MaybeArray,\r\n  MaybePromise,\r\n  Nullish,\r\n  ParsableEnumValue,\r\n  PickPartial,\r\n  VariableTupleOrArray,\r\n  createEnumAccessor,\r\n  isArray,\r\n  isDefined,\r\n  isFunction,\r\n  throwError,\r\n} from \"@tailjs/util\";\r\nimport {\r\n  Variable,\r\n  VariableClassification,\r\n  VariableGetResult,\r\n  VariableGetResults,\r\n  VariableGetSuccessResult,\r\n  VariableKey,\r\n  VariableMetadata,\r\n  VariableScope,\r\n  VariableVersion,\r\n  VersionedVariableKey,\r\n  formatKey,\r\n} from \"..\";\r\n\r\nexport type TargetedVariableScope =\r\n  | VariableScope.Session\r\n  | VariableScope.Device\r\n  | VariableScope.User\r\n  | VariableScope.Entity;\r\n\r\nexport enum VariableResultStatus {\r\n  Success = 200,\r\n  Created = 201,\r\n  Unchanged = 304,\r\n  Conflict = 409,\r\n  Unsupported = 501,\r\n  Denied = 403,\r\n  ReadOnly = 405,\r\n  NotFound = 404,\r\n  Invalid = 400,\r\n  Error = 500,\r\n}\r\n\r\nexport const resultStatus = createEnumAccessor(\r\n  VariableResultStatus as typeof VariableResultStatus,\r\n  false,\r\n  \"variable set status\"\r\n);\r\n\r\nexport type ResultStatusValue<Numeric extends boolean | undefined = boolean> =\r\n  ParsableEnumValue<typeof resultStatus, Numeric>;\r\n\r\nexport type VariableSetResult<\r\n  T = any,\r\n  Source extends VariableSetter<T, any> = VariableSetter<T, any>,\r\n  SuccessOnly = boolean\r\n> =\r\n  | VariableSetSuccessResult<T, Source>\r\n  | (SuccessOnly extends false\r\n      ? {\r\n          source: Source;\r\n        } & (\r\n          | {\r\n              status: VariableResultStatus.Conflict;\r\n              current: Source extends VariableSetter<undefined>\r\n                ? Variable<T, true> | undefined\r\n                : Variable<T, true>;\r\n            }\r\n          | ((\r\n              | {\r\n                  status:\r\n                    | VariableResultStatus.ReadOnly\r\n                    | VariableResultStatus.Invalid\r\n                    | VariableResultStatus.Denied\r\n                    | VariableResultStatus.NotFound\r\n                    | VariableResultStatus.Unsupported;\r\n\r\n                  error?: any;\r\n                }\r\n              | {\r\n                  status: VariableResultStatus.Error;\r\n                  transient?: boolean;\r\n                  error: any;\r\n                }\r\n            ) & { current?: never })\r\n        )\r\n      : never);\r\n\r\nexport type VariableSetSuccessResult<\r\n  T = any,\r\n  Source extends VariableSetter<T> = VariableSetter<T>\r\n> = {\r\n  source: Source;\r\n  status:\r\n    | VariableResultStatus.Success\r\n    | VariableResultStatus.Unchanged\r\n    | VariableResultStatus.Created;\r\n  current: Source extends VariableSetter<undefined>\r\n    ? Variable<T, true> | undefined\r\n    : Variable<T, true>;\r\n};\r\n\r\nexport interface VariablePatchSource<\r\n  T = any,\r\n  NumericEnums extends boolean = boolean\r\n> extends VariableVersion,\r\n    VariableClassification<NumericEnums>,\r\n    VariableMetadata {\r\n  value: T;\r\n}\r\n\r\nexport type VariablePatchResult<T = any, Validated = boolean> =\r\n  | (VariableMetadata &\r\n      (Partial<VariableClassification<If<Validated, true, boolean>>> & {\r\n        value: T;\r\n      }))\r\n  | undefined;\r\n\r\nexport type VariablePatchAction<T = any, Validated = boolean> = (\r\n  current: VariablePatchSource<T, If<Validated, true, boolean>> | undefined\r\n) => MaybePromise<VariablePatchResult<T, Validated> | undefined>;\r\n\r\nexport enum VariablePatchType {\r\n  Add = 0,\r\n  Min = 1,\r\n  Max = 2,\r\n  IfMatch = 3,\r\n  IfNoneMatch = 4,\r\n}\r\n\r\nexport type VariablePatchTypeValue<\r\n  Numeric extends boolean | undefined = boolean\r\n> = ParsableEnumValue<typeof patchType, Numeric>;\r\n\r\nexport const patchType = createEnumAccessor(\r\n  VariablePatchType as typeof VariablePatchType,\r\n  false,\r\n  \"variable patch type\"\r\n);\r\n\r\nexport type VariableValuePatch<T = any> = {\r\n  selector?: string;\r\n} & (\r\n  | {\r\n      type: VariablePatchType.Add | \"add\";\r\n      by: number;\r\n    }\r\n  | {\r\n      type: VariablePatchType.Min | VariablePatchType.Max | \"min\" | \"max\";\r\n      value: number;\r\n    }\r\n  | {\r\n      type: VariablePatchType.IfMatch | \"ifMatch\";\r\n      match: T | undefined;\r\n      value: T | undefined;\r\n    }\r\n  | {\r\n      type: VariablePatchType.IfNoneMatch | \"ifNoneMatch\";\r\n      match: T | undefined;\r\n      value: T | undefined;\r\n    }\r\n);\r\nexport type VariablePatchActionSetter<\r\n  T = any,\r\n  Validated = boolean\r\n> = VariableKey<If<Validated, true, boolean>> &\r\n  VariableKey &\r\n  Partial<Variable<T, If<Validated, true, boolean>>> & {\r\n    patch: VariablePatchAction<T, Validated>;\r\n  };\r\n\r\nexport type VariableValuePatchSetter<\r\n  T = any,\r\n  Validated = boolean\r\n> = VariableKey<If<Validated, true, boolean>> &\r\n  Partial<Variable<T, If<Validated, true, boolean>>> &\r\n  (Partial<VariableClassification<If<Validated, true, boolean>>> & {\r\n    patch: VariableValuePatch<T>;\r\n  });\r\n\r\nexport type VariablePatch<T = any, Validated = boolean> =\r\n  | VariablePatchActionSetter<T, Validated>\r\n  | VariableValuePatchSetter<T, Validated>;\r\n\r\nexport type VariableValueSetter<\r\n  T = any,\r\n  NumericEnums extends boolean = boolean\r\n> = PickPartial<Variable<T, NumericEnums>, \"classification\" | \"purposes\">;\r\n\r\nexport type VariableSetter<T = any, Validated = boolean> =\r\n  | ((\r\n      | VariableValueSetter<T, If<Validated, true, boolean>>\r\n      | (VersionedVariableKey<If<Validated, true, boolean>> & {\r\n          value: undefined;\r\n        })\r\n    ) & { patch?: undefined })\r\n  | (VariablePatch<T, Validated> & { value?: never });\r\n\r\ntype MapVariableSetResult<Source, SuccessOnly = boolean> = [Source] extends [\r\n  VariableSetResult<infer T, infer Source, any>\r\n]\r\n  ? VariableSetResult<T, Source, SuccessOnly>\r\n  : Source extends VariableSetter<infer T>\r\n  ? VariableSetResult<T, Source, SuccessOnly>\r\n  : never;\r\n\r\nexport type VariableSetParameter<Validated> = VariableTupleOrArray<\r\n  VariableSetter<any, Validated> | Nullish\r\n>;\r\n\r\n/** @internal */\r\nexport type ParseSuccessOnly<Throw> = Throw extends boolean\r\n  ? Throw\r\n  : Throw extends { throw: infer Throw }\r\n  ? Throw & boolean\r\n  : Throw extends { throw?: false }\r\n  ? false\r\n  : true;\r\n\r\nexport type VariableSetResults<\r\n  K extends readonly any[] = any[],\r\n  SuccessOnly extends boolean | { throw?: boolean } = false\r\n> = K extends readonly []\r\n  ? []\r\n  : K extends readonly [infer Item, ...infer Rest]\r\n  ? [\r\n      MapVariableSetResult<Item, ParseSuccessOnly<SuccessOnly>>,\r\n      ...VariableSetResults<Rest, ParseSuccessOnly<SuccessOnly>>\r\n    ]\r\n  : K extends readonly (infer T)[]\r\n  ? MapVariableSetResult<T, ParseSuccessOnly<SuccessOnly>>[]\r\n  : never;\r\n\r\nexport const isVariablePatch = <Validated>(\r\n  setter: VariableSetter<any, Validated> | undefined\r\n): setter is VariablePatch<any, Validated> => !!setter?.[\"patch\"];\r\n\r\nexport const isVariablePatchAction = (\r\n  setter: any\r\n): setter is VariablePatchActionSetter => isFunction(setter[\"patch\"]);\r\n\r\nexport const isScoped = <T>(value: any): value is T & VariableKey =>\r\n  isDefined(value?.scope);\r\n\r\nexport const handleResultErrors: {\r\n  <T, Throw = true>(\r\n    result: VariableGetResult<T, any, false>,\r\n    throwErrors?: Throw\r\n  ): VariableGetResult<T, Throw>;\r\n  <T, Source extends VariableSetter<T>, Throw = true>(\r\n    result: VariableSetResult<T, Source>\r\n  ): VariableSetResult<T, Source, Throw>;\r\n\r\n  <\r\n    T extends VariableGetResults | readonly (VariableGetResult | undefined)[],\r\n    Throw extends boolean | { throw?: boolean } = true\r\n  >(\r\n    results: T,\r\n    throwErrors?: Throw\r\n  ): VariableGetResults<T, Throw>;\r\n  <\r\n    T extends VariableSetResults | readonly (VariableSetResult | undefined)[],\r\n    Throw extends boolean | { throw?: boolean } = true\r\n  >(\r\n    results: T,\r\n    throwErrors?: Throw\r\n  ): VariableSetResults<T, Throw>;\r\n} = (\r\n  result: MaybeArray<VariableGetResult | VariableSetResult>,\r\n  throwErrors?: any\r\n) => {\r\n  if ((throwErrors?.throw ?? throwErrors) === false) {\r\n    return result;\r\n  }\r\n\r\n  if (isArray(result)) {\r\n    result.forEach(handleResultErrors);\r\n    return result as any;\r\n  }\r\n\r\n  return result.status < 400 || result.status === 404 // Not found can only occur for get requests, and those are all right.\r\n    ? result\r\n    : throwError(\r\n        `${formatKey(\r\n          (result as VariableSetResult).source ?? result\r\n        )} could not be ${\r\n          (result as VariableSetResult).source ||\r\n          result.status !== VariableResultStatus.Error\r\n            ? \"set\"\r\n            : \"read\"\r\n        } because ${\r\n          result.status === VariableResultStatus.Conflict\r\n            ? `of a conflict. The expected version '${result.source.version}' did not match the current version '${result.current?.version}'.`\r\n            : result.status === VariableResultStatus.Denied\r\n            ? result.error ?? \"the operation was denied.\"\r\n            : result.status === VariableResultStatus.Invalid\r\n            ? result.error ?? \"the value does not conform to the schema\"\r\n            : result.status === VariableResultStatus.ReadOnly\r\n            ? \"it is read only.\"\r\n            : result.status === VariableResultStatus.Error\r\n            ? `of an unexpected error: ${result.error}`\r\n            : \"of an unknown reason.\"\r\n        }`\r\n      );\r\n};\r\n","import { TrackedEvent } from \"../events\";\n\nexport const typeTest =\n  <T extends TrackedEvent>(...types: string[]) =>\n  (ev: any): ev is T =>\n    ev?.type && types.some((type) => type === ev?.type);\n","// Utility functions for testing and manipulating values, sets and objects.\n\nimport type {\n  ArgNulls,\n  KeyValueProjection,\n  Nullish,\n  Nulls,\n  OmitNullish,\n} from \"@tailjs/util\";\nimport {\n  F,\n  T,\n  array,\n  assign,\n  entries,\n  filter,\n  forEach,\n  fromEntries,\n  fun,\n  keys,\n  nil,\n  obj,\n} from \".\";\n\n/**\n * Better minifyable way to instantiate a Set.\n */\nexport const hashSet = <T = any>(values?: readonly T[] | null) =>\n  new Set<T>(values);\n\n/**\n * Better minifyable way to instantiate a Map.\n */\nexport const hashMap = <K = any, V = any>(\n  entries?: readonly (readonly [K, V])[] | null\n) => new Map<K, V>(entries);\n\n/**\n * Better minifyable way to instantiate a WeakMap.\n */\nexport const weakMap = <K extends object = any, V = any>(\n  entries?: readonly (readonly [K, V])[] | null\n) => new WeakMap<K, V>(entries);\n\n/**\n * A common pattern used in the code base where something has a `clear` method.\n */\ntype Clearable<A extends any[]> = { clear(...args: A): any };\n\n/**\n *  General function to \"clear\" objects, arrays, sets and maps.\n */\nexport const clear: {\n  <T extends Clearable<A> | Nullish, A extends any[] = []>(\n    map: T,\n    ...args: A\n  ): T;\n  <T extends Record<keyof any, any>>(record: T): T;\n} = (clearable: any, ...args: any[]) => (\n  clearable != nil &&\n    (clearable.clear\n      ? clearable.clear(...args)\n      : array(clearable)\n      ? (clearable.length = 0)\n      : keys(clearable, (key) => del(clearable, key))),\n  clearable\n);\n\n/**\n * Test whether a set has a specified key, and if not, sets it and returns `true`. `false` otherwise.\n *\n * This is useful for recursive iteration where the same element must not be visited more than once (because infinite recursion sucks).\n */\nexport const mark = <K>(\n  set: { has(value: K): boolean; add(value: K): any },\n  value: K\n) => (set.has(value) ? F : (set.add(value), T));\n\n/**\n * A generalized function to get values from maps, test existence in sets and get properties on objects.\n */\nexport const get: {\n  <K, V, Arg>(\n    target: ArgNulls<{ get(key: K): V } | { has(key: K): V }, Arg>,\n    key: K\n  ): V | Nulls<Arg, undefined>;\n  <K extends keyof any, V, Arg>(target: ArgNulls<Record<K, V>, Arg>, key: K):\n    | V\n    | Nulls<Arg, undefined>;\n} = (target: any, key: any) =>\n  target.get?.(key) ?? target?.has(key) ?? target?.[key];\n\n/**\n * A generalized function to remove items from sets and maps, and delete properties from objects.\n * When only a single key/property is specified the deleted value is returned (`undefined` if not present).\n *\n * Multiple keys can be specified as once in which case the target will just be returned (like fluent API or whatever).\n */\n\nexport const del: {\n  (target: null | undefined, keys: string | string[]): undefined;\n  <K, V>(target: { get(key: K): V; delete(key: K): any }, item: K):\n    | V\n    | undefined;\n  <K, R>(\n    target: { has(key: K): boolean; delete(key: K): any },\n    item: K\n  ): boolean;\n  <T extends { delete(key: K): any }, K>(target: T, keys: K[]): T;\n  <T, K extends keyof T>(target: T, key: K): T[K] | undefined;\n  <T>(target: T, keys: (keyof T)[]): T;\n} = <T>(\n  target:\n    | { get?(item: T): any; has?(key: any): boolean; delete?(item: T): any }\n    | null\n    | undefined,\n  key: any\n) =>\n  !target\n    ? undefined\n    : array(key)\n    ? (forEach(key, (key) => target.delete?.(key) ?? delete target[key]),\n      target)\n    : (currentValue = target.has?.(key)) != null\n    ? !currentValue\n      ? undefined\n      : ((currentValue = target.get?.(key)),\n        target.delete!(key),\n        currentValue ?? T)\n    : ((currentValue = target[key]), delete target[key], currentValue);\n\n/**\n * Sets the value for the specified key in a map, toggles the item in a set, or sets the property on an object.\n *\n * The value `undefined` deletes the key/property from maps and objects.\n * For sets `undefined` corresponds to the default value `true`, so here it has the opposite effect.\n */\nlet currentValue: any;\nexport const set: {\n  <T>(\n    set: { add(key: T): void; delete(key: T): void },\n    item: T,\n    toggle?: boolean\n  ): boolean;\n  <K, V>(\n    map: {\n      get(key: K): V | null;\n      set(key: K, value: V): any;\n      delete(key: K): void;\n    },\n    key: K,\n    value: V | ((current: V | null) => V | null) | Nullish\n  ): boolean;\n} = (target: any, key: any, value: any = undefined) =>\n  !!target.add // It's a set\n    ? ((currentValue = target.has(key)),\n      currentValue === (value ??= T) // Toggle? (Default is `true` which we set here).\n        ? F\n        : (value ? target.add(key) : del(target, key), T))\n    : ((currentValue = target.get?.(key) ?? target[key]), // Get item from map / read property from object.\n      fun(value) && (value = value(currentValue)), // Apply optional projection on current value.\n      value === currentValue\n        ? F // No change\n        : (value === undefined // `undefined` means \"delete\".\n            ? del(target, key)\n            : target.set?.(key, value) ?? (target[key] = value),\n          // Return that the value was changed.\n          T));\n\n/**\n * Gets the current item for a key in a map, or a property on an object.\n * If no value is present, it is initialized with the `defaultValue` and then returned.\n */\nexport const getOrSet: {\n  <K, V, R extends V | Readonly<V>>(\n    map:\n      | {\n          has(key: K): boolean;\n          get(key: K): V | Nullish;\n          set(key: K, value: V): void;\n        }\n      | Record<keyof any, any>,\n    key: K,\n    defaultValue: (key: K) => R\n  ): V;\n  <\n    T extends Record<keyof any, any>,\n    K extends keyof T,\n    V,\n    R extends V | Readonly<V>\n  >(\n    target: T,\n    key: K,\n    defaultValue: (key: K) => R\n  ): V;\n} = (map: any, key: any, defaultValue: (key: any) => any) =>\n  map.has?.(key)\n    ? map.get?.(key)\n    : ((currentValue = defaultValue(key)),\n      map.set?.(key, currentValue)\n        ? currentValue\n        : (map[key] ??= defaultValue(key)));\n\n/**\n * Convenient way to use the values from a tuple.\n * If the tuple is null or undefined, that will be returned instead of applying the function.\n */\nexport const decompose = <Values extends any[] | Nullish, R>(\n  tuple: Values,\n  apply: (...values: OmitNullish<Values>) => R\n): R | Nulls<Values> => tuple && apply(...(tuple as any));\n\n/**\n * Creates a new object by projecting or excluding the properties of an existing one.\n */\nexport const transpose = <\n  K extends keyof any,\n  V,\n  KP extends keyof any = K,\n  VP = V\n>(\n  source: Record<K, V>,\n  projection?: KeyValueProjection<K, V, [KP, VP] | null>,\n  additionalEntries?: Record<KP, VP>\n): Record<KP, VP> =>\n  additionalEntries\n    ? assign(transpose(source, projection), additionalEntries)\n    : projection\n    ? (fromEntries(filter(entries(source, projection)) as any) as any)\n    : source;\n\n/** Removes null'ish properties from an object */\nexport const clean = <T extends object>(o: T): Required<T> => {\n  const inner = (o: object) =>\n    forEach(entries(o), ([key, value], F) =>\n      value == nil || (obj(value) && !inner(value)) ? (del(o, key), F) : T\n    );\n  inner(o);\n  return o as any;\n};\n","import type {\n  ConstToNormal,\n  IterableOrSelf,\n  Nullish,\n  Nulls,\n} from \"@tailjs/util\";\nimport {\n  REGEX,\n  TestOrConvertFunction,\n  array,\n  bool,\n  filter,\n  map,\n  str,\n  testOrConvertFunction,\n  undefined,\n  distinct,\n  size,\n  nil,\n  push,\n} from \".\";\n\n/**\n * Common definition of expresions that are used for string matching.\n *\n * If not already a regular expression, a string that starst with `/` and optionally ends with `/` is parsed as regular expressions with flags `gu` applied (global and Unicode).\n * This enables defining regular expression in text based configuration files that do not have native regular expressions.\n *\n * For convenience an asterisk (`*`) can be used to match any number of characters in strings, and  `,` and white-space ` ` are intepreted as list separators.\n * `\\` is used as the escape character so the string `\\/escaped\\*,and\\ this` will only match the strings, literally, `\\/escaped\\*` and `and this`.\n * This also means that intentional backslashes, commas and spaces must be escaped as `\\\\`, `\\,` and `\\ ` respectively.\n *\n * Arrays of strings and/or regular expressions are evaluated as unions (_string 1_ \"or\" _string 2_ \"or\" ...).\n *\n * The special values `null`, `undefined`, the empty string,  and `false` are interpreted as \"never\", and `true` is \"always\".\n *\n * Regarding separators, they may be different in specific contexts. If so, it will be mentioned there.\n */\nexport type ParsableRegExp =\n  | IterableOrSelf<null | undefined | boolean | string | RegExp>\n  | Iterable<ParsableRegExp>;\n\n/**\n * `Regex.test` optimized for minifying.\n */\nexport const test = (s: string | Nullish, match: RegExp | Nullish) =>\n  !!(s && match) && match.test(s);\n\nlet matchSelected: any;\n/**\n * Matches a regular expression against a string and projects the matched parts, if any.\n */\nexport const match: {\n  <R>(\n    s: string | Nullish,\n    match: RegExp | Nullish,\n    selector: (...args: string[]) => R | Nullish,\n    defaultValue: R[]\n  ): ConstToNormal<R>[];\n  <R>(\n    s: string | Nullish,\n    match: RegExp | Nullish,\n    selector: (...args: string[]) => R,\n    defaultValue?: R\n  ): ConstToNormal<R> | undefined;\n  (s: string | Nullish, match: RegExp | Nullish): RegExpMatchArray | null;\n} = <R>(\n  s: string,\n  regex: RegExp,\n  selector?: (...args: string[]) => R,\n  defaultValue?: R\n) =>\n  s &&\n  regex &&\n  (selector\n    ? (array(defaultValue)\n        ? match(\n            s,\n            regex,\n            (...args) =>\n              (matchSelected = selector(...args)) != nil &&\n              push(defaultValue as any, matchSelected)\n          )\n        : s.replace(\n            regex,\n            (...args) => ((defaultValue = selector(...args)), \"\")\n          ),\n      defaultValue)\n    : s.match(regex));\n\n/**\n * Replaces reserved characters to get a regular expression that matches the string.\n */\nexport const escapeRegEx = (input: string) =>\n  input.replace(/[\\^$\\\\.*+?()[\\]{}|]/g, \"\\\\$&\");\n\nconst REGEX_NEVER = /\\z./g;\nconst unionOrNever = (parts: (string | Nullish)[], joined?: string) =>\n  (joined = join(distinct(filter(parts, size)), \"|\"))\n    ? new RegExp(joined, \"gu\")\n    : REGEX_NEVER;\n\nconst stringRuleCache: { [pattern: string]: RegExp } = {};\n/**\n * Tests or parses a regular expression accepting the {@link ParsableRegExp} format.\n *\n * Strings are cached, so there is no need to do additional caching outside this function (as far as the caching would only concern strings).\n */\nexport const regex: TestOrConvertFunction<\n  RegExp,\n  ParsableRegExp,\n  [separators?: string[]]\n> = testOrConvertFunction(\n  REGEX,\n  (input: string | boolean | any[] | Nullish, separators = [\",\", \" \"]) =>\n    regex(input)\n      ? input\n      : array(input) // Parse individual specifiers, and join them into one long regex. An empty array is interpreted as \"never\".\n      ? unionOrNever(\n          map(input, (part) => regex(part, false, separators)?.source)\n        )\n      : bool(input)\n      ? input // `true` is \"always\", `false` is \"never\"\n        ? /./g\n        : REGEX_NEVER // Matches nothing. End of string followed by something is never the case.\n      : str(input)\n      ? (stringRuleCache[input] ??= match(\n          input || \"\",\n          /^(?:\\/(.+?)\\/?|(.*))$/gu,\n          (_, regex, text) =>\n            regex\n              ? new RegExp(regex, \"gu\")\n              : unionOrNever(\n                  map(\n                    split(\n                      text,\n                      new RegExp(\n                        `?<!(?<!\\\\)\\\\)[${join(map(separators, escapeRegEx))}]/`\n                      )\n                    ),\n                    (text) =>\n                      text &&\n                      `^${join(\n                        map(\n                          // Split on non-escaped asterisk (Characterized by a leading backslash that is not itself an escaped backslash).\n                          split(text, /(?<!(?<!\\\\)\\\\)\\*/),\n                          (part) =>\n                            escapeRegEx(\n                              // Remove backslashes used for escaping.\n                              replace(part, /\\\\(.)/g, \"$1\")\n                            )\n                        ),\n                        // Join the parts separated by non-escaped asterisks with the regex wildcard equivalent.\n                        \".*\"\n                      )}$`\n                  )\n                )\n        )!)\n      : undefined\n);\n\n/**\n * Better minifyable version of `String`'s `split` method that allows a null'ish parameter.\n */\nexport const split = <T extends string | Nullish>(\n  s: T,\n  separator: RegExp | string\n): T extends string ? string[] : string[] | Nulls<T> =>\n  s?.split(separator) ?? (s as any);\n\n/**\n * Better minifyable version of `String`'s `replace` method that allows a null'ish parameter.\n */\nexport const replace = <T extends string | Nullish>(\n  s: T,\n  match: RegExp,\n  replaceValue: string | ((...args: string[]) => string)\n): T => s?.replace(match, replaceValue as any) ?? (s as any);\n\n/**\n *  Better minifyable version of `String`'s `join` method that allows a null'ish parameter and removes empty.\n */\nexport const join = <T extends (string | Nullish)[] | Nullish>(\n  s: T,\n  separator = \"\"\n): string | Nulls<T> => (s?.join(separator) ?? s) as any;\n","import type {\n  CartUpdatedEvent,\n  ComponentClickEvent,\n  Integer,\n  LocalID,\n  Session,\n  Tagged,\n  Timestamp,\n  ViewEvent,\n  ImpressionEvent,\n  ImpressionSummaryEvent,\n} from \"..\";\n\n/**\n * The base type for all events that are tracked.\n *\n * The naming convention is:\n * - If the event represents something that can also be considered an entity like \"a page view\", \"a user location\" etc. the name should be a (deverbal) noun.\n * - If the event only indicates something that happend, like \"session started\", \"view ended\" etc. the name should be a verb in the past tense.\n *\n * @id urn:tailjs:core:event\n * @privacy censor-ignore anonymous necessary\n */\nexport interface TrackedEvent extends Tagged {\n  /**\n   * The type name of the event.\n   *\n   * This MUST be set to a constant value in extending interfaces and implementing classes for the event to be registered.\n   * */\n  type: string;\n\n  /**\n   * The ID of the schema the event comes from. It is suggested that the schema ID ends with a hash followed by a SemVer version number. (e.g. urn:tailjs#0.9.0)\n   */\n  schema?: string;\n\n  /**\n   * This may be assigned or transformed by backends if needed.\n   * It is client-assigned for {@link ViewEvent}s\n   */\n  id?: LocalID;\n\n  /**\n   * This is set by the client and can be used to dedupplicate events sent multiple times if the endpoint timed out.\n   */\n  clientId?: LocalID;\n\n  /**\n   * The number of times the client tried to sent the event if the endpoint timed out\n   *\n   * @default 0\n   */\n  retry?: Integer;\n\n  /**\n   * The client ID of the event that caused this event to be triggered or got triggered in the same context.\n   * For example, a {@link NavigationEvent} may trigger a {@link ViewEvent},\n   * a {@link CartUpdatedEvent} my be triggered with a {@link ComponentClickEvent}, and a {@link ImpressionSummaryEvent} applies to a {@link ImpressionEvent}.\n   */\n  relatedEventId?: LocalID;\n\n  /**\n   * The session associated with the event.\n   */\n  session?: Session;\n\n  /**\n   * When applicable, the view where the event happened (related by {@link ViewEvent}).\n   */\n  view?: LocalID;\n\n  /**\n   * This timestamp will always have a value before it reaches a backend.\n   * If specified, it must be a negative number when sent from the client (difference between when the event was generated and when is was posted in milliseconds).\n   *\n   * @default now\n   */\n  timestamp?: Timestamp;\n}\n\nexport const isTrackedEvent = (ev: any): ev is TrackedEvent =>\n  ev && typeof ev.type === \"string\";\n","import type { Domain, Integer, LocalID, Size, TrackedEvent, View } from \"..\";\nimport { typeTest } from \"../util/type-test\";\n\nexport interface ClickIds {\n  google?: string;\n  googleDoubleClick?: string;\n  facebook?: string;\n  microsoft?: string;\n  googleAnalytics?: string;\n}\n\n/**\n * This event is sent whenever a user navigates to a new view (page, screen or similar).\n *\n * Use {@link HeartbeatEvent} and {@link ViewEndedEvent} to determine how long the user was active in the view in processing.\n *\n */\nexport interface ViewEvent extends TrackedEvent {\n  type: \"VIEW\";\n\n  /**\n   * @inheritdoc\n   */\n  clientId: LocalID;\n\n  /**\n   * The primary content used to generate the view including the personalization that led to the decision, if any.\n   */\n  definition?: View;\n\n  /**\n   * The tab where the view was shown.\n   */\n  tab?: LocalID;\n\n  /**\n   * The fully qualified URL as shown in the address line of the browser excluding the domain.\n   */\n  href: string;\n\n  /**\n   * The hash part of the URL (/about-us#address).\n   */\n  hash?: string;\n\n  /**\n   * The path portion of the URL.\n   */\n  path?: string;\n\n  /**\n   * Urchin Tracking Module (UTM) parameters as defined by (Wikipedia)[https://en.wikipedia.org/wiki/UTM_parameters].\n   */\n  utm?: {\n    source?: string;\n    medium?: string;\n    campaign?: string;\n    term?: string;\n    content?: string;\n  };\n  /**\n   * The query string parameters in the URL, e.g. utm_campaign.\n   * Each parameter can have multiple values, for example If the parameter is specified more than once.\n   * If the parameter is only specified once pipes, semicolons and commas are assumed to separate values (in that order).\n   * A parameter without a value will get recorded as an empty string.\n   * @example The URL https://www.foo.com/?utm_source=bar&utm_campaign=campaign1,campaign2&flag&gclid=123xyz&p1=a&p1=b&p2=a;b,c;d has these parameters:\n   *  utm_source = [\"bar\"] \\\n   *  utm_campaign = [\"campaign1\", \"campaign2\"] \\\n   *  gclid = [\"123xyz\"] \\\n   *  flag = [\"\"] \\\n   *  gclid=[\"123xyz\"] \\\n   *  p1=[\"a\", \"b\"] \\\n   *  p2=[\"a\", \"b,c\", \"d\"]\n   */\n  queryString?: Record<string, string[]>;\n\n  // queryString?: {\n  //   source: Record<string, string>;\n  //   parsed: Record<string, string[]>;\n  // };\n\n  /**\n   * The domain part of the href, if any.\n   */\n  domain?: Domain;\n\n  /**\n   * Indicates that this was the first view in the first tab the user opened.\n   * Note that this is NOT tied to the session. If a user closes all tabs and windows for the site and then later navigates back to the site in the same session this flag will be set again.\n   * @default false\n   */\n  landingPage?: boolean;\n\n  /**\n   * Indicates that no other tabs were open when the view happened.\n   * This flag allows a backend to extend the definition of a session that can last indefinitely but still restart after inactivity.\n   * By measuring the time between a view with this flag and the previous event from the same device, it is possible to see for how long the device has been away from the site.\n   * @default false\n   */\n  firstTab?: boolean;\n\n  /**\n   * The 1-indexed view number in the current tab.\n   * This is kept as a convenience, yet technically redundant since it follows from timestamps and context.\n   * @default 1\n   */\n  tabIndex?: Integer;\n\n  /**\n   * Number of redirects that happened during navigation to this view.*/\n  redirects?: Integer;\n\n  /**\n   * Navigation type.\n   */\n  navigationType?: \"navigate\" | \"back-forward\" | \"prerender\" | \"reload\";\n\n  /**\n   * Indicates whether the event was manually triggered through a tracker command, or happened automatically by the tracker's ability to infer navigation.\n   *\n   * @default \"automatic\"\n   */\n  mode?: \"manual\" | \"automatic\";\n\n  /**\n   * External referrer. Internal referrers follows from the event's {@link TrackedEvent[\"relatedView\"]} field.\n   */\n  externalReferrer?: {\n    href?: string;\n    domain?: Domain;\n  };\n\n  /**\n   * The size of the user's view port (e.g. browser window) when the page was opened.\n   */\n  viewport?: Size;\n\n  /**\n   * The type of view, e.g. \"page\" or \"screen\".\n   *\n   * @default \"page\"\n   */\n  viewType?: string;\n}\n\nexport const isViewEvent = typeTest<ViewEvent>(\"VIEW\");\n","import type { TrackedEvent, ViewTimingEvent, ViewEvent } from \"..\";\nimport { typeTest } from \"../util/type-test\";\n\n/**\n * This event is sent when a user leaves a view (page, screen or similar).\n *\n * Due to the chaotic and state-less nature of the Internet, there is no guarantee that every {@link ViewEvent} has a matching end event.\n * In case a view has no end event, the most recent {@link HeartbeatEvent} can be used to approximate when the user left.\n */\nexport interface ViewEndedEvent extends TrackedEvent, ViewTimingEvent {\n  type: \"VIEW_ENDED\";\n}\n\nexport const isViewEndedEvent = typeTest<ViewEndedEvent>(\"VIEW_ENDED\");\n","export type ParsedTag = { ranks: string[]; value?: string };\n\nconst splitRanks = (ranks?: string) =>\n  ranks\n    ?.toLowerCase()\n    .replace(/[^a-zA-Z0-9:.-]/g, \"_\")\n    .split(\":\")\n    .filter((rank) => rank) ?? [];\n\n/**\n * Parses the tags out of a string\n */\nexport const parseTagString = (\n  input: string | string[] | null | undefined,\n  baseRank?: string,\n  target?: Set<string>\n) => {\n  if (!input) return [];\n  if (Array.isArray(input)) input = input.join(\",\");\n  // We have an unescaped percentage sign followed by an uppercase two-digit hexadecimal number. Smells like URI encoding!\n  if (/(?<!(?<!\\\\)\\\\)%[A-Z0-9]{2}/.test(input)) {\n    try {\n      input = decodeURIComponent(\n        input.replace(\n          // Change ampersands to commas (as they are value separators), and quote all values just to be sure nothing gets out of control.\n          // That is, `tag=test&tag2&tag3=Encoded%3A%20%22%F0%9F%A5%B3%22` becomes `tag=\"test\",tag2,tag3=\"Encoded: \\\"🥳\\\"\"\n          /([^=&]+)(?:\\=([^&]+))?(&|$)/g,\n          (_, name, value, sep) =>\n            [\n              name,\n              value && `=\"${value.replace(/(?<!(?<!\\\\)\\\\)(\"|%22)/g, '\\\\\"')}\"`, // Escape double quotes (both encoded `%22` and non-encoded `\"`\"), but ignore quotes that are already escaped (yes, why not?).\n              sep && \",\",\n            ].join(\"\")\n        )\n      );\n      // Need to catch exceptions. `decodeURIComponent` will fail on invalid surrogate code points. `%80` is one of those.\n    } catch {}\n  }\n\n  let tags: ParsedTag[] = [],\n    parsedTag: ParsedTag,\n    baseRanks = splitRanks(baseRank);\n\n  input.replace(\n    // Explained:\n    // 1. Tag (group 1): (\\s*(?=\\=)|(?:\\\\.|[^,=\\r\\n])+). It means \"skip leading white-space\", then either\"\n    //   1.1. \\s*(?=\\=) is \"nothing but a `=`\": a blank tag name causing the expression to skip to the actual value. (\"=80,=43\" are techincally supported but will get omitted unless the are base ranks (*))\n    //   2.1. (?:\\\\.|[^,=\\r\\n])+ is \"something not a linebreak including escaped characters such as \\=\":\n    // 2. Value: (?:\\=\\s*(?:\"((?:\\\\.|[^\"])*)\"|'((?:\\\\.|[^'])*)'|((?:\\\\.|\\s*[^,\\s])*)))?. Anything that starts with a `=` until we find a (non-escaped) comma\n    //  2.1: (group 2) \"((?:\\\\.|[^\"])*)\" is any double-quoted ()`\"`) value, can contain commas, anything escaped, or whatever. Goes well with JSON.\n    //  2.2: (group 3) is same as 2.1 just with a single quote (`'`).\n    //  2.3: (group 4) is anything but a non-escaped comma (`,`)\n    // 3. The end. (?:[,\\s]+|$). This is the tag separator or end of string.\n    //        Since tags cannot have line-breaks in them, this technically allows tags to be separated by line-breaks instead of comma.\n    //        This should not be documented as values can very much have line-breaks, and that syntax will then bite you in the money-maker at some point.\n    //        In the scary example below we get \"tag1\", \"tag21:tag22\" and then \"tag3\" with the value \"value\\tag4=value\"(!).\n    //        `tag1\n    //        tag21:tag22\n    //        tag3=value\n    //        tag4=value`\n    /\\s*(\\s*(?=\\=)|(?:\\\\.|[^,=\\r\\n])+)\\s*(?:\\=\\s*(?:\"((?:\\\\.|[^\"])*)\"|'((?:\\\\.|[^'])*)'|((?:\\\\.|[^,])*)))?\\s*(?:[,\\s]+|$)/g,\n    (_0, tag, quote1, quote2, unquoted) => {\n      let value = quote1 || quote2 || unquoted;\n      let ranks = splitRanks(tag);\n\n      baseRanks.length &&\n        // If we have base ranks (that, is a \"prefix\"), a single tag value is interpreted as a value. E.g. `<a data-name=\"foo\"...` becomes `data:name=foo`.\n        // We have this situation if there is exactly one rank, and no value.\n        // Other examples: `<a data-employee=\"foo:test\" ...` gives `data:employee:foo:test`. `data-employee=\"=test\"` gives us `data:employee=test`, and\n        //    `data-employee=\"id=80\"` gives us `data:employee:id=80`.\n        (ranks.length === 1 && !value && (value = ranks.pop()),\n        (ranks = baseRanks.concat(ranks))),\n        // If we don't have any ranks (only a value), we don't have a tag.\n        ranks.length && // * cf. expression explanition 1.1\n          (tags.push(\n            (parsedTag = {\n              ranks,\n              value: value || undefined,\n            })\n          ),\n          target?.add(encodeTag(parsedTag)));\n      return \"\"; // This is a trick. We are not really replacing anything, we are instead using replace as a for loop.\n    }\n  );\n  return tags;\n};\n\nexport const encodeTag = <T extends ParsedTag | null | undefined>(\n  tag: T\n): T extends ParsedTag ? string : null | undefined =>\n  tag == null\n    ? (tag as any)\n    : `${tag.ranks.join(\":\")}${\n        tag.value ? `=${tag.value.replace(/,/g, \"\\\\,\")}` : \"\"\n      }`;\n","// To let minifier shorten globals as normal variables.\nconst o = Object;\nconst s = Symbol;\nconst a = Array;\nconst undefined = void 0;\nconst nil = null;\nexport const T = true;\nexport const F = false;\n\nexport const fromEntries = Object.fromEntries;\nexport const assign = Object.assign;\nconst st = setTimeout;\nconst pi = parseInt;\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\nexport const random = Math.random;\n\nexport {\n  a as Array,\n  o as Object,\n  s as Symbol,\n  nil,\n  pi as parseInt,\n  st as setTimeout,\n  undefined,\n};\n","import type { Nullish } from \"@tailjs/util\";\n\nexport const SSR = typeof window === \"undefined\";\n\nconst win = window;\nconst doc = document;\nconst nav = navigator;\nconst body = doc.body;\nconst loc = location;\nconst perf = performance;\nconst hist = win.history;\nexport {\n  body,\n  doc as document,\n  hist as history,\n  loc as location,\n  nav as navigator,\n  perf as performance,\n  win as window,\n};\n\nexport const createElement = (tagName: string) => doc.createElement(tagName);\n\nexport const matches = (node: Element | Nullish, selector: string) =>\n  !!node?.matches(selector);\n","// General utility functions.\n\nimport type { ConstToNormal, Nullish } from \"@tailjs/util\";\nimport {\n  F,\n  bool,\n  filter,\n  keys,\n  match,\n  nil,\n  push,\n  size,\n  str,\n  undefined,\n  type Json,\n} from \".\";\n\n/**\n * Raises an error in the UI based on configuration and build settings.\n */\nexport const err = (code: string | Nullish, args?: any, error?: Error): void =>\n  console.error(\n    ...filter([code ?? error?.message ?? error ?? \"error\", args, error])\n  );\n\n/**\n * Applies a function to a value if it is not its types default value.\n * An object without properties and an empty array are considered the \"default\" for those types.\n */\nexport const ifNotDefault = <T, R = T>(\n  value: T,\n  action?: (value: T) => R\n): R | undefined =>\n  (typeof value === \"object\" && size(keys(value as any))) || value\n    ? action\n      ? action(value)\n      : value\n    : (undefined as any);\n\n/**\n * Round a number of to the specified number of decimals.\n */\nexport const round = (x: number, decimals: number | boolean = 0) =>\n  (bool(decimals) ? --(decimals as any) : decimals) < 0\n    ? x\n    : ((decimals = Math.pow(10, decimals as any)),\n      Math.round(x * decimals) / decimals);\n\n/**\n * `decodeURIComponent` for efficient minifying.\n */\nexport const decode = <T extends string | Nullish>(\n  value: T\n): T extends string ? string : null =>\n  value == nil ? nil : (decodeURIComponent(value) as any);\n\n/**\n * `encodeURIComponent` for efficient minifying.\n */\nexport const encode = <T extends string | Nullish>(\n  value: T\n): T extends string ? string : null =>\n  value == nil ? nil : (encodeURIComponent(value) as any);\n\nlet parameters = {};\n/**\n * Parses key/value pairs encoded as a URI query string (blah=foo&bar=gz%25nk).\n *\n * It supports that the same key can be specified multiple times.\n */\nexport const parseParameters = <T extends string | Nullish>(\n  query: T\n): T extends string ? Record<string, string[]> : T =>\n  query == nil\n    ? (query as any)\n    : ((parameters = {}),\n      match(query, /([^&=]+)(?:=([^&]+))?/g, (all, name, value) =>\n        push(\n          (parameters[lowerCase(decode(name))] ??= []),\n          decode(str(value, F))\n        )\n      ),\n      parameters);\n\n/**\n * Convenient way to compare a value against multiple others.\n */\nexport const equals = <T>(value: T, ...values: T[]) =>\n  values.some(value == nil ? (test) => test == nil : (test) => value === test);\n\n/**\n *  Better minifyable version of `String`'s `toLowerCase` method that allows a null'ish parameter.\n */\nexport const lowerCase = <T extends string | Nullish>(s: T): T =>\n  s?.toLowerCase() ?? (s as any);\n\n/**\n * `JSON.stringify` with default settings for pretty-printing any value.\n */\nexport const prettify = (value: any): string => stringify(value, nil, 2) ?? \"\";\n\n/**\n * `JSON.stringify` method for efficient minifying that also ignores null'ish values.\n */\nexport const stringify = <T>(\n  value: T,\n  replacer?: any,\n  space?: string | number\n): T extends Nullish ? null : string =>\n  value == nil ? nil : (JSON.stringify(value, replacer, space) as any);\n\n/**\n * `JSON.parse` method for efficient minifying that also gracefully handles null values.\n */\nexport const parse = <T extends Json = Json>(value: string | null): T =>\n  value == nil ? nil : JSON.parse(value);\n\n/**\n * Fast way to join two optional strings with a space.\n * If they are both nullish, nullish will be returned (unless `defaultValue`).\n */\nexport const concat2 = <\n  T1 extends string | Nullish,\n  T2 extends string | Nullish,\n  Default extends string | Nullish = null\n>(\n  value1: T1,\n  value2: T2,\n  defaultValue: Default = nil as any\n) =>\n  value1 && value2 ? value1 + \" \" + value2 : (value1 || value2) ?? defaultValue;\n","import type { IsAny, IterableOrArrayLike, Nullish } from \"@tailjs/util\";\nimport { F, T, nil } from \".\";\n\n/**\n * Converts various types' common representation of `true` and `false` to actual `true` and `false`.\n */\nexport const parseBoolean = (\n  value: string | boolean | null | number | undefined\n) =>\n  bool(value)\n    ? value\n    : value === 0\n    ? F\n    : value === 1\n    ? T\n    : value === \"false\"\n    ? F\n    : value === \"true\"\n    ? T\n    : undefined;\n\n/** Constants for type testing. */\nexport const STRING = 0,\n  BOOLEAN = 1,\n  NUMBER = 2,\n  FUNCTION = 3,\n  OBJECT = 4,\n  ARRAY = 5,\n  REGEX = 6;\n\n/**\n * When checking the string from `typeof blah`, no more than this is required for type tests.\n */\nconst typePrefixes = [\"s\", \"b\", \"n\", \"f\", \"o\"];\n\n/**\n * Tests whether a given value is of the desired type.\n */\nexport const is = <T extends number>(\n  type: T,\n  value: any\n): value is T extends typeof STRING\n  ? string\n  : T extends typeof BOOLEAN\n  ? boolean\n  : T extends typeof NUMBER\n  ? number\n  : T extends typeof FUNCTION\n  ? (...args: any) => any\n  : T extends typeof OBJECT\n  ? { [P in keyof any]: any }\n  : T extends typeof ARRAY\n  ? any[]\n  : T extends typeof REGEX\n  ? RegExp\n  : never =>\n  type === ARRAY\n    ? Array.isArray(value)\n    : (value != nil && typePrefixes[type] === (typeof value)[0]) ||\n      (type === REGEX && value.exec);\n\ntype UnwrapArray<T, V = any> = IsAny<V> extends true\n  ? T\n  : T extends IterableOrArrayLike<any>\n  ? V extends IterableOrArrayLike<infer V> & { toLowerCase?(): never }\n    ? V[]\n    : T\n  : T;\n\n/**\n * A general pattern used to type test or parse values of various types.\n */\nexport type TestOrConvertFunction<\n  T,\n  AllowParse = never,\n  ConvertArgs extends any[] = []\n> = {\n  <V>(value: V, parseStrict: false, ...args: ConvertArgs): V extends T\n    ? T extends V\n      ? UnwrapArray<T, V>\n      : V\n    : V extends AllowParse\n    ? UnwrapArray<T, V>\n    : T | undefined;\n  <V>(value: V, parseStrict: true): V extends T ? V : T;\n  <V extends T = T>(value: any): value is Exclude<V, Nullish>;\n};\n\n/**\n * Factory creating {@link TestOrConvertFunction}s.\n */\nexport const testOrConvertFunction: {\n  <T, AllowParse = never, ConvertArgs extends any[] = []>(\n    type: number,\n    convert: (value: any, ...args: ConvertArgs) => T | undefined\n  ): TestOrConvertFunction<T, AllowParse, ConvertArgs>;\n  <T>(type: number): <V extends T = T>(\n    value: any\n  ) => value is Exclude<V, Nullish>;\n} =\n  (\n    type: number,\n    convert?: (value: any, parse?: boolean, ...args: any[]) => any\n  ) =>\n  (value: any, parse?: boolean, ...args: any): value is any =>\n    parse === undefined\n      ? is(type, value)\n      : is(type, value)\n      ? value\n      : !parse\n      ? undefined\n      : convert?.(value, parse, ...args);\n\n/**\n * Tests or parses Boolean values.\n */\nexport const bool = testOrConvertFunction<boolean, any>(\n  BOOLEAN,\n  (value) => value !== \"0\" && value !== \"false\" && value !== \"no\" && !!value\n);\n\n/**\n * Tests or parses numerical values.\n */\nexport const num = testOrConvertFunction<number>(\n  NUMBER,\n  (value) => ((value = parseFloat(value)), isNaN(value) ? undefined : value)\n);\n\n/**\n * Tests if a value is a string, and if not, makes one by calling the value's `toString()` method.\n */\nexport const str = testOrConvertFunction<string>(STRING, (value) =>\n  value?.toString()\n);\n\n/**\n * Tests if a value can be invoked as a function.\n */\nexport const fun = testOrConvertFunction<(...args: any[]) => any>(\n  FUNCTION,\n  (_) => undefined\n);\n\n/**\n * Tests if a value is strictly an object (object but not array).\n */\nexport const obj = testOrConvertFunction<object>(OBJECT);\n\n/**\n * Tests if a value is an ECMAScript array (not TypedArray, those are too fancy).\n */\nexport const array = (() =>\n  // Needs wrapped in function, otherwise the multi-line type screws syntax highlighting.\n  testOrConvertFunction<\n    any[],\n    IterableOrArrayLike<any> & { toLowerCase?(): never }\n  >(ARRAY, (value) => (iterable(value) ? [...value] : undefined)))();\n\n/**\n * Utility type for {@link iterable} to help TypeScript know strings are not iterables.\n */\nexport type IterableNotString<T> = T extends string\n  ? never\n  : T extends IterableOrArrayLike<any>\n  ? T\n  : never;\n\n/**\n * Tests if a value is an iterable collection of values (Iterable but not string).\n */\nexport const iterable = <T>(value: T): value is IterableNotString<T> =>\n  value && !str(value) && !!value[Symbol.iterator];\n","// Utility functions for arrays and iterables.\n\nimport {\n  isObject,\n  type ArgNulls,\n  type ConstToNormal,\n  type IterableOrArrayLike,\n  type IterableOrSelf,\n  type KeyValueProjection,\n  type Nullish,\n  type Nulls,\n} from \"@tailjs/util\";\nimport { F, T, array, bool, fun, hashSet, iterable, nil, num, obj } from \".\";\n\n/**\n * Array's `sort` function that offers a single function that is applied on each element instead of having to do it twice (`[...].sort(x,y)=>f(x)-f(y)`).\n * Default is to use the value directly.\n */\nexport const sort = <T = number, Arg = any>(\n  items: ArgNulls<T[], Arg>,\n  sortKey: (item: T) => number = (item) => item as any\n): Nulls<Arg> =>\n  (items?.sort((lhs, rhs) => sortKey(lhs) - sortKey(rhs)), items) as any;\n\n/**\n * Array's `splice` method for efficient minifying.\n */\nexport const splice = <T, Arg>(\n  value: ArgNulls<T[], Arg>,\n  start: number,\n  deleteCount?: number,\n  ...values: T[]\n): T[] | Nulls<Arg> =>\n  value &&\n  (deleteCount != nil\n    ? (value.splice as any)(start, deleteCount, ...values)\n    : (value.splice as any)(start));\n\n/**\n * Array's `unshift` method for efficient minifying that also returns the array itself for fluent convenience.\n */\nexport const unshift = <T extends { unshift(...args: any): any }, Arg>(\n  target: ArgNulls<T, Arg>,\n  ...values: T[\"unshift\"] extends (...args: infer A) => any ? A : never\n): T | Nulls<Arg, undefined> => (target?.unshift(...values), target) as any;\n\n/**\n * Array's `shift` method for efficient minifying.\n */\nexport const shift = <T>(array: { shift(): T } | Nullish) => array?.shift();\n\n/**\n * Array's `push` method for efficient minifying that also returns the array itself for fluent convenience.\n */\nexport const push = <T extends { push(...args: any): any }, Arg>(\n  target: ArgNulls<T, Arg>,\n  ...values: T[\"push\"] extends (...args: infer A) => any ? A : never\n): T | Nulls<Arg, undefined> => (target?.push(...values), target) as any;\n\n/**\n * Array's `pop` method for efficient minifying.\n */\nexport const pop = <T>(array: { pop(): T } | Nullish) => array?.pop();\n\n/**\n * Like Array's `concat` but supports iterables.\n */\nexport const concat = <T>(...sources: (IterableOrSelf<T> | Nullish)[]): T[] =>\n  size((sources = filter(sources))) < 2\n    ? map(sources[0])\n    : ([].concat(...(map(sources as any, map as any) as any)) as any);\n\n/**\n * Gives the distinct elements of the specified values. If a value is iterable it is expanded.\n */\nexport const distinct = <T>(\n  ...values: (IterableOrSelf<T | Nullish> | Nullish)[]\n): T[] => map(hashSet<T>(filter(concat(...values)))) as any;\n\n/**\n * Constructs a range (or empty array) with the given attributes.\n */\nexport const range: {\n  (length: number, empty?: false): number[];\n  (length: number, empty: true): undefined[];\n  <T = number>(length: number, project: (n: number) => T): T[];\n  (start: number, end: number): number[];\n} = (arg0: any, arg1: any) =>\n  arg1 === T\n    ? [...Array(arg0)]\n    : num(arg1)\n    ? range(arg1 - arg0, (n) => arg0 + n)\n    : (fun(arg1) || (arg1 = ((n: number) => n) as any),\n      map(range(arg0, T), (_, i) => (arg1 as any)(i)));\n\n/**\n * The length of an array and strings, size of sets and maps and the number of keys in an object.\n *\n * If the value is a primitive type (not string) the size is defined as 0.\n */\nexport const size = (\n  item:\n    | Iterable<any>\n    | Record<keyof any, any>\n    | { size: number }\n    | { length: number }\n    | Nullish\n) =>\n  item == nil\n    ? 0\n    : item[\"length\"] ?? item[\"size\"] ?? (obj(item) ? keys(item).length : 0);\n\n/**\n * An extended version of Object.entries that also supports maps, sets and arrays.\n */\nexport const entries: {\n  <K, V, P = [K, V]>(\n    map:\n      | {\n          entries(): Iterable<[K, V]>;\n        }\n      | Nullish,\n    project?: KeyValueProjection<K, V, P>\n  ): ConstToNormal<P>[];\n  <V, P = [number, V]>(\n    array: V[],\n    project?: KeyValueProjection<number, V, P>\n  ): ConstToNormal<P>[];\n  <K extends keyof any = keyof any, V = any, P = [K, V]>(\n    record: { [key in K]?: V },\n    project?: KeyValueProjection<K, V, P>\n  ): ConstToNormal<P>[];\n} = (mapOrRecord: any, project?: any) =>\n  !mapOrRecord\n    ? []\n    : array(mapOrRecord)\n    ? map(mapOrRecord, (value, index) =>\n        project ? project(index, value) : [index, value]\n      )\n    : map(mapOrRecord.entries?.() ?? Object.entries(mapOrRecord), project);\n\n/**\n * An extended version of Object.keys that also supports maps and sets.\n */\nexport const keys: {\n  <K = keyof any, P = K>(\n    map:\n      | {\n          keys(): Iterable<K>;\n        }\n      | Nullish,\n    project?: (key: K, index: number) => P\n  ): ConstToNormal<P>[];\n  <K extends keyof any = keyof any, P = K>(\n    record: { [key in K]?: any },\n    project?: (key: K, index: number) => P\n  ): ConstToNormal<P>[];\n} = (mapOrRecord: any, project?: any) =>\n  !mapOrRecord\n    ? []\n    : map(mapOrRecord.keys?.() ?? Object.keys(mapOrRecord), project);\n\n/**\n * An extended version of Object.values that also supports arrays and sets.\n */\nexport const values: {\n  <V, P = V>(\n    map:\n      | {\n          values(): Iterable<V>;\n        }\n      | Nullish,\n    project?: (value: V, index: number) => P\n  ): ConstToNormal<P>[];\n  <V = any, P = V>(\n    record: { [key in keyof any]?: V },\n    project?: (value: V, index: number) => P\n  ): ConstToNormal<P>[];\n} = (mapOrRecord: any, project?: any) =>\n  !mapOrRecord\n    ? []\n    : map(mapOrRecord.values?.() ?? Object.values(mapOrRecord), project);\n\n/**\n * Generalized version of Array's `forEach` method that enables breaking and a return value.\n * Non iterables are intepreted as an array with themselves as the only item.\n *\n * If the `breakSignal` is called, iteration will stop.\n * For convenience the break function can be called with a value that will then be passed through to combine breaking and returning a value.\n * This does not change the return value by itself.\n *\n * `const hasPositive = forEach(numbers, (x,_,stop)=>x > 0 && stop(true))`\n *\n * @returns The last returned value from the action.\n */\nexport const forEach = <T, R = void, InitialValue = undefined>(\n  items: IterableOrSelf<T> | Nullish,\n  action: (\n    item: T,\n    index: number,\n    breakSignal: <T>(passThroughValue?: T) => T,\n    currentValue: R | InitialValue\n  ) => R,\n  initialValue?: InitialValue\n): InitialValue | R => {\n  if (item == nil || !size(iterable(items) ? items : (items = [items] as any)))\n    return initialValue as any;\n\n  const breakSignal = (...args: any) => (\n    (index = 0), size(args) ? args[0] : initialValue\n  );\n\n  let index = 0;\n  for (const item of items as any)\n    if (\n      ((initialValue = action(\n        item,\n        index++,\n        breakSignal,\n        initialValue as any\n      ) as any),\n      !index) // Index is set to zero from the breakSignal\n    )\n      break;\n\n  return initialValue as any;\n};\n\n/**\n * Generalized version of Array's `map` method that also supports iterables and node lists.\n *\n * If called without a projection, it converts whatever is passed to it to an array.\n * When the value is already an array, the `clone` parameter decides whether the array itself or a clone should be returned.\n */\nexport const map: {\n  <T, P = T extends IterableOrArrayLike<infer T> ? T : T>(\n    value: IterableOrSelf<T> | Nullish,\n    projection: (item: T, index: number) => P\n  ): ConstToNormal<P>[];\n  <T, P = T extends IterableOrArrayLike<infer T> ? T : T>(\n    value: IterableOrSelf<T> | Nullish,\n    clone?: boolean\n  ): ConstToNormal<P>[];\n} = (value: any, cloneOrProject?: any): any[] =>\n  value == nil\n    ? []\n    : fun(cloneOrProject)\n    ? (map(value, F).map((value, index) => cloneOrProject(value, index)) as any)\n    : array(value) && !cloneOrProject\n    ? value\n    : (iterable(value) && [...value]) || [value];\n\n/**\n * A generalized version of Array's `flatMap` that also supports iterables and node lists.\n */\nexport const flatMap: {\n  <T, P = T extends Iterable<infer T> ? T : T>(\n    value: IterableOrArrayLike<T> | T | Nullish,\n    project: (item: T, index: number) => P | P[]\n  ): ConstToNormal<P>[];\n} = <T, P = T>(\n  value: T | Iterable<T | Nullish> | Nullish,\n  projection: (item: T, index: number) => P | P[] = (item) => item as any\n): ConstToNormal<P>[] =>\n  value == nil\n    ? []\n    : (filter(map(value, F)).flatMap((item, index) =>\n        projection(item as any, index)\n      ) as any);\n\n/**\n * A convenience method for returning the n'th item from an iterable or the n'th character from a string.\n *\n * If the source is not alrady an array (or indexable by an item method), it will be converted to one first.\n * The latter feature should be used with caution since it adds a terrible performance overhead if used from within a loop.\n */\nexport const item: {\n  <T>(\n    array:\n      | Iterable<T>\n      | T\n      | { [index: number]: T; length: number }\n      | string\n      | null\n      | undefined,\n    index?: number\n  ): T | undefined;\n  (text: string, index?: number): string | undefined;\n} = <T>(source: any, index = 0): T | undefined =>\n  source == nil\n    ? undefined\n    : (source.length == null && (source = map(source)),\n      source.item,\n      source[index < 0 ? (source as T[]).length + index : index]);\n\n/**\n * A generalized version of Array's `filter` that works on all the types supported by {@link map}.\n *\n * In addition it allows an empty result to be returned as `null`\n */\nexport const filter: {\n  <T, R extends T = T, B extends boolean = false>(\n    value: IterableOrSelf<T> | Nullish,\n    predicate: (item: R, index: number) => any,\n    emptyIsNull?: B\n  ): T[] | (B extends true ? null : never);\n  <T, B extends boolean = false>(\n    value: IterableOrSelf<T | Nullish> | Nullish,\n    emptyIsNull?: B\n  ): T[] | (B extends true ? null : never);\n} = <T>(\n  value: IterableOrSelf<T> | Nullish,\n  predicate?: boolean | ((item: T, index: number) => any),\n  emptyIsNull = bool(predicate) || F\n): T[] =>\n  ((value = (map(value) as any).filter((item: any, index: any) =>\n    (fun(predicate, true) ?? ((item: any) => item != nil))(item, index)\n  )),\n  emptyIsNull && !size(value!) ? nil : value) as any;\n\n/**\n * A convenience method to test whether an iterable has any element matching the predicate specified.\n *\n * If the parameter is not iterable is in interpreted as an array with itself as the only element.\n */\nexport const any = <T>(\n  value: IterableOrSelf<T>,\n  predicate: (item: T, index: number) => any = (item) =>\n    item != (nil as any) && item !== F\n): boolean => {\n  return (\n    value != nil &&\n    (iterable(value) || isObject(value)) &&\n    (!predicate\n      ? !!size(value as any)\n      : forEach(value, (item, i, stop) => predicate(item, i) && stop(T), F))\n  );\n};\n\n/**\n * Array's `reduce` method that also works for iterables.\n */\nexport const reduce = <T, V>(\n  items: IterableOrArrayLike<T>,\n  reducer: (previous: V, item: T) => V,\n  initialValue: V\n) =>\n  map(items).reduce(\n    (previous, current) => reducer(previous, current as any),\n    initialValue\n  );\n\n/**\n * Takes the sum of the items in an iterable.\n */\nexport const sum = <T, Arg>(\n  items: ArgNulls<IterableOrArrayLike<T>, Arg>,\n  selector?: (item: T) => number\n): number | Nulls<Arg> =>\n  items &&\n  (reduce(\n    items,\n    (sum, item) => (selector?.(item) ?? (item as number)) + sum,\n    0\n  ) as any);\n\n/**\n * Returns the highest value in a series of numbers.\n */\nexport const max: (typeof Math)[\"max\"] = (...values) => Math.max(...values);\n","import { T, assign, delay, nil, size, undefined } from \".\";\n\nexport const promise: {\n  <T>(): Promise<void>;\n  <T>(...args: ConstructorParameters<typeof Promise<T>>): Promise<T>;\n} = (...args: any[]) =>\n  !args.length ? Promise.resolve() : (new Promise(args[0]) as any);\n\n/**\n * Magic value to reset an  {@link OpenPromise}.\n */\nexport const Reset = Symbol();\n\nexport type OpenPromise<T = boolean> = PromiseLike<T> & {\n  /**\n   * Resolves the promise with the specified value.\n   */\n  (value: T): OpenPromise<T>;\n\n  /**\n   * Resets the promise, optionally only if completed\n   */\n  (reset: typeof Reset, ifCompleted?: boolean): OpenPromise<T>;\n\n  /**\n   * Tests whether the promise is resolved, optionally timed out.\n   */\n  (): T | undefined;\n};\n\n/**\n * Indicates that an {@link OpenPromiseWithTimeout} has timed out.\n */\nexport const Expired = Symbol();\nexport type OpenPromiseWithTimeout<T = boolean> = OpenPromise<\n  T | typeof Expired\n>;\n\n/**\n * Creates a new {@link OpenPromise} or {@link OpenPromiseWithTimeout} if a timeout is specified.\n */\nexport const openPromise: {\n  <T = boolean>(): OpenPromise<T>;\n  <T = boolean>(timeout: number): OpenPromiseWithTimeout<T>;\n} = (timeout?: number): OpenPromise<any> => {\n  let currentResolve: (value: any) => void = nil!;\n  let currentPromise: Promise<any> = nil!;\n  let resolved: any = undefined;\n\n  const reset = () => {\n    resolved = undefined;\n    let capturedResolve: ((value: any) => void) | null = nil;\n\n    currentPromise = promise((resolve) => {\n      currentResolve = capturedResolve = (value) =>\n        capturedResolve &&\n        ((capturedResolve = nil), resolve((resolved = value)));\n    });\n\n    if (timeout) {\n      delay(timeout).then(() => capturedResolve?.(Expired));\n    }\n  };\n  reset();\n  const p = assign(\n    (...args: any[]): any =>\n      !size(args)\n        ? resolved\n        : (args[0] === Reset\n            ? (args[1] !== T || resolved !== undefined) && reset()\n            : currentResolve(args[0]),\n          p),\n    {\n      then: (...args: any) => currentPromise.then(...args),\n    }\n  );\n\n  return p;\n};\n","const codes: number[] = [];\nconst chars: number[] = [];\nexport const charCode = (s: string, index = 0) => s.charCodeAt(index);\nexport const fromCharCodes = (chars: number[]) => String.fromCharCode(...chars);\n\n[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"].forEach(\n  (p, i) => (codes[(chars[i] = p.charCodeAt(0))] = i)\n);\n\n/**\n * Encodes an array of bytes to Base64URL without padding (URL safe Base64 using `-` and `_` instead of `+` and `/`).\n *\n * (thanks to Jon Leighton at https://gist.github.com/jonleighton/958841).\n */\nexport const to64u = (bytes: Uint8Array) => {\n  let i = 0;\n  let chunk: number;\n  const n = bytes.length;\n\n  const base64: number[] = [];\n  while (i < n) {\n    chunk = (bytes[i++] << 16) | (bytes[i++] << 8) | bytes[i++];\n    base64.push(\n      chars[(chunk & 16515072) >> 18],\n      chars[(chunk & 258048) >> 12],\n      chars[(chunk & 4032) >> 6],\n      chars[chunk & 63]\n    );\n  }\n  base64.length += n - i;\n\n  return fromCharCodes(base64);\n};\n\n/**\n * Decodes a BaseURL encoded string (without padding).\n */\nexport const from64u = (encoded: string) => {\n  let i = 0;\n  let j = 0;\n  let p: number;\n  const n = encoded.length;\n  const bytes = new Uint8Array(3 * ((n / 4) | 0) + (((n + 3) & 3) % 3));\n  while (i < n) {\n    bytes[j++] =\n      (codes[charCode(encoded, i++)] << 2) |\n      ((p = codes[charCode(encoded, i++)]) >> 4);\n    if (i < n) {\n      bytes[j++] = ((p & 15) << 4) | ((p = codes[charCode(encoded, i++)]) >> 2);\n      if (i < n) {\n        bytes[j++] = ((p & 3) << 6) | codes[charCode(encoded, i++)];\n      }\n    }\n  }\n  return bytes;\n};\n","import { hasValue, isBoolean } from \"..\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  (value: T, bits?: 32 | 64 | 128): string;\n  <B extends boolean>(value: T, numeric: B): B extends true ? number : string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key = \"\"): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (iw = 0; iw < key.length; mixer0 += window0[iw] = key.charCodeAt(iw++));\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero it all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: Uint8Array, numericOrBits: any = 64) => {\n      if (!hasValue(source)) return null;\n      bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n","﻿(function () {\r\n\t\"use strict\";\r\n\r\n\t// Serializes a value to a MessagePack byte array.\r\n\t//\r\n\t// data: The value to serialize. This can be a scalar, array or object.\r\n\t// options: An object that defines additional options.\r\n\t// - multiple: (boolean) Indicates whether multiple values in data are concatenated to multiple MessagePack arrays. Default: false.\r\n\t// - invalidTypeReplacement:\r\n\t//   (any) The value that is used to replace values of unsupported types.\r\n\t//   (function) A function that returns such a value, given the original value as parameter.\r\n\tfunction serialize(data, options) {\r\n\t\tif (options && options.multiple && !Array.isArray(data)) {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\r\n\t\t}\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet floatBuffer, floatView;\r\n\t\tlet array = new Uint8Array(128);\r\n\t\tlet length = 0;\r\n\t\tif (options && options.multiple) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tappend(data[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tappend(data);\r\n\t\t}\r\n\t\treturn array.subarray(0, length);\r\n\r\n\t\tfunction append(data, isReplacement) {\r\n\t\t\tswitch (typeof data) {\r\n\t\t\t\tcase \"undefined\":\r\n\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\tappendBoolean(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tappendNumber(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tappendString(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif (data === null)\r\n\t\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\telse if (data instanceof Date)\r\n\t\t\t\t\t\tappendDate(data);\r\n\t\t\t\t\telse if (Array.isArray(data))\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\r\n\t\t\t\t\t\tappendBinArray(data);\r\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\r\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\r\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tappendObject(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\r\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendNull(data) {\r\n\t\t\tappendByte(0xc0);\r\n\t\t}\r\n\r\n\t\tfunction appendBoolean(data) {\r\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\r\n\t\t}\r\n\r\n\t\tfunction appendNumber(data) {\r\n\t\t\tif (isFinite(data) && Number.isSafeInteger(data)) {\r\n\t\t\t\t// Integer\r\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0 && data >= -0x20) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\r\n\t\t\t\t\tappendBytes([0xcc, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\r\n\t\t\t\t\tappendBytes([0xd0, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\r\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\r\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\r\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\r\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\r\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\r\n\t\t\t\t\t// 32 bits for bitwise operations.\r\n\t\t\t\t\tlet hi = data / pow32;\r\n\t\t\t\t\tlet lo = data % pow32;\r\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\r\n\t\t\t\t\tappendByte(0xd3);\r\n\t\t\t\t\tappendInt64(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0) {   // below int64\r\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t\telse {   // above uint64\r\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Float\r\n\t\t\t\tif (!floatView) {\r\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\r\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\r\n\t\t\t\t}\r\n\t\t\t\tfloatView.setFloat64(0, data);\r\n\t\t\t\tappendByte(0xcb);\r\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendString(data) {\r\n\t\t\tlet bytes = encodeUtf8(data);\r\n\t\t\tlet length = bytes.length;\r\n\r\n\t\t\tif (length <= 0x1f)\r\n\t\t\t\tappendByte(0xa0 + length);\r\n\t\t\telse if (length <= 0xff)\r\n\t\t\t\tappendBytes([0xd9, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(bytes);\r\n\t\t}\r\n\r\n\t\tfunction appendArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x90 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let index = 0; index < length; index++) {\r\n\t\t\t\tappend(data[index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendBinArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xff)\r\n\t\t\t\tappendBytes([0xc4, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(data);\r\n\t\t}\r\n\r\n\t\tfunction appendObject(data) {\r\n\t\t\tlet length = 0;\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tif (data[key] !== undefined) {\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x80 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tlet value = data[key];\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tappend(key);\r\n\t\t\t\t\tappend(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendDate(data) {\r\n\t\t\tlet sec = data.getTime() / 1000;\r\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\r\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\r\n\t\t\t\tappendInt64(sec);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendByte(byte) {\r\n\t\t\tif (array.length < length + 1) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + 1)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray[length] = byte;\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\tfunction appendBytes(bytes) {\r\n\t\t\tif (array.length < length + bytes.length) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + bytes.length)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray.set(bytes, length);\r\n\t\t\tlength += bytes.length;\r\n\t\t}\r\n\r\n\t\tfunction appendInt64(value) {\r\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\r\n\t\t\t// bitwise operations.\r\n\t\t\tlet hi, lo;\r\n\t\t\tif (value >= 0) {\r\n\t\t\t\t// Same as uint64\r\n\t\t\t\thi = value / pow32;\r\n\t\t\t\tlo = value % pow32;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\r\n\t\t\t\tvalue++;\r\n\t\t\t\thi = Math.abs(value) / pow32;\r\n\t\t\t\tlo = Math.abs(value) % pow32;\r\n\t\t\t\thi = ~hi;\r\n\t\t\t\tlo = ~lo;\r\n\t\t\t}\r\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deserializes a MessagePack byte array to a value.\r\n\t//\r\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\r\n\t// options: An object that defines additional options.\r\n\t// - multiple: (boolean) Indicates whether multiple concatenated MessagePack arrays are returned as an array. Default: false.\r\n\tfunction deserialize(array, options) {\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet pos = 0;\r\n\t\tif (array instanceof ArrayBuffer) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\r\n\t\t}\r\n\t\tif (!array.length) {\r\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\r\n\t\t}\r\n\t\tif (!(array instanceof Uint8Array)) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tlet data;\r\n\t\tif (options && options.multiple) {\r\n\t\t\t// Read as many messages as are available\r\n\t\t\tdata = [];\r\n\t\t\twhile (pos < array.length) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Read only one message and ignore additional data\r\n\t\t\tdata = read();\r\n\t\t}\r\n\t\treturn data;\r\n\r\n\t\tfunction read() {\r\n\t\t\tconst byte = array[pos++];\r\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\r\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\r\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\r\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\r\n\t\t\tif (byte === 0xc0) return null;   // nil\r\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\r\n\t\t\tif (byte === 0xc2) return false;   // false\r\n\t\t\tif (byte === 0xc3) return true;   // true\r\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\r\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\r\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\r\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\r\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\r\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\r\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\r\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\r\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\r\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\r\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\r\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\r\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\r\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\r\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\r\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\r\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\r\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\r\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\r\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\r\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\r\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\r\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\r\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\r\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\r\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\r\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\r\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\r\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\r\n\t\t\tconsole.debug(\"msgpack array:\", array);\r\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\r\n\t\t}\r\n\r\n\t\tfunction readInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\tlet first = true;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tlet byte = array[pos++];\r\n\t\t\t\t\tvalue += byte & 0x7f;\r\n\t\t\t\t\tif (byte & 0x80) {\r\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvalue *= 256;\r\n\t\t\t\t\tvalue += array[pos++];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readUInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tvalue *= 256;\r\n\t\t\t\tvalue += array[pos++];\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readFloat(size) {\r\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\r\n\t\t\tpos += size;\r\n\t\t\tif (size === 4)\r\n\t\t\t\treturn view.getFloat32(0, false);\r\n\t\t\tif (size === 8)\r\n\t\t\t\treturn view.getFloat64(0, false);\r\n\t\t}\r\n\r\n\t\tfunction readBin(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = array.subarray(pos, pos + size);\r\n\t\t\tpos += size;\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readMap(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = {};\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tlet key = read();\r\n\t\t\t\tdata[key] = read();\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readArray(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = [];\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readStr(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet start = pos;\r\n\t\t\tpos += size;\r\n\t\t\treturn decodeUtf8(array, start, size);\r\n\t\t}\r\n\r\n\t\tfunction readExt(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet type = readUInt(1);\r\n\t\t\tlet data = readBin(size);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 255:\r\n\t\t\t\t\treturn readExtDate(data);\r\n\t\t\t}\r\n\t\t\treturn { type: type, data: data };\r\n\t\t}\r\n\r\n\t\tfunction readExtDate(data) {\r\n\t\t\tif (data.length === 4) {\r\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\treturn new Date(sec * 1000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 8) {\r\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\r\n\t\t\t\t\t((data[1] << 14) >>> 0) +\r\n\t\t\t\t\t((data[2] << 6) >>> 0) +\r\n\t\t\t\t\t(data[3] >>> 2);\r\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\r\n\t\t\t\t\t((data[4] << 24) >>> 0) +\r\n\t\t\t\t\t((data[5] << 16) >>> 0) +\r\n\t\t\t\t\t((data[6] << 8) >>> 0) +\r\n\t\t\t\t\tdata[7];\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 12) {\r\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\tpos -= 8;\r\n\t\t\t\tlet sec = readInt(8);\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Encodes a string to UTF-8 bytes.\r\n\tfunction encodeUtf8(str) {\r\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\r\n\t\tlet ascii = true, length = str.length;\r\n\t\tfor (let x = 0; x < length; x++) {\r\n\t\t\tif (str.charCodeAt(x) > 127) {\r\n\t\t\t\tascii = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\r\n\t\tfor (let ci = 0; ci !== length; ci++) {\r\n\t\t\tlet c = str.charCodeAt(ci);\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tbytes[i++] = c;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c < 2048) {\r\n\t\t\t\tbytes[i++] = c >> 6 | 192;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\r\n\t\t\t\t\tif (++ci >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\r\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\r\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\r\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\r\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\r\n\t\t\t\t}\r\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\r\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\r\n\t\t\t}\r\n\t\t\tbytes[i++] = c & 63 | 128;\r\n\t\t}\r\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\r\n\t}\r\n\r\n\t// Decodes a string from UTF-8 bytes.\r\n\tfunction decodeUtf8(bytes, start, length) {\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = start, str = \"\";\r\n\t\tlength += start;\r\n\t\twhile (i < length) {\r\n\t\t\tlet c = bytes[i++];\r\n\t\t\tif (c > 127) {\r\n\t\t\t\tif (c > 191 && c < 224) {\r\n\t\t\t\t\tif (i >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\r\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 223 && c < 240) {\r\n\t\t\t\t\tif (i + 1 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\r\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 239 && c < 248) {\r\n\t\t\t\t\tif (i + 2 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\r\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\r\n\t\t\t}\r\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\r\n\t\t\telse if (c <= 0x10ffff) {\r\n\t\t\t\tc -= 0x10000;\r\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\r\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\r\n\t\t\t}\r\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\r\n\t// The exported functions\r\n\tlet msgpack = {\r\n\t\tserialize: serialize,\r\n\t\tdeserialize: deserialize,\r\n\r\n\t\t// Compatibility with other libraries\r\n\t\tencode: serialize,\r\n\t\tdecode: deserialize\r\n\t};\r\n\r\n\t// Environment detection\r\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\r\n\t\t// Node.js\r\n\t\tmodule.exports = msgpack;\r\n\t}\r\n\telse {\r\n\t\t// Global object\r\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\r\n\t}\r\n\r\n})();\r\n","import {\n  cast,\n  type Domain,\n  type Position,\n  type Rectangle,\n  type ScreenPosition,\n  type Size,\n  type Viewport,\n} from \"@tailjs/types\";\nimport type {\n  ConstToNormal,\n  MaybeUndefined,\n  Nullish,\n  Nulls,\n  ValueOrDefault,\n} from \"@tailjs/util\";\nimport {\n  body,\n  document,\n  entries,\n  err,\n  F,\n  filter,\n  fun,\n  lowerCase,\n  map,\n  match,\n  MAX_SAFE_INTEGER,\n  nil,\n  parseBoolean,\n  push,\n  replace,\n  round,\n  T,\n  undefined,\n  window,\n} from \".\";\n\nexport type NodeWithParentElement = Node | EventTarget | Nullish;\n\nexport let MAX_ANCESTOR_DISTANCE = MAX_SAFE_INTEGER;\n\nexport const forAncestorsOrSelf = <T = any>(\n  el: NodeWithParentElement,\n  action: (\n    el: Element,\n    returnValue: (value: T, replace?: boolean) => void,\n    distance: number\n  ) => any,\n  stoppingCriterion: (el: Element, distance: number) => boolean = (\n    el,\n    distance\n  ) => distance >= MAX_ANCESTOR_DISTANCE\n): T | undefined => {\n  let i = 0,\n    returnValue: any,\n    stop = F;\n  while (\n    el?.[\"nodeType\"] === 1 &&\n    !stoppingCriterion(el as Element, i++) &&\n    action(\n      el as Element,\n      (value, replace) => (\n        value != nil &&\n          ((returnValue = value), (stop = replace !== T && returnValue != nil)),\n        T\n      ),\n      i - 1\n    ) !== F &&\n    !stop\n  ) {\n    const prev = el;\n    el = (el as Element).parentElement;\n    if (el === nil && (prev as Element)?.ownerDocument !== document) {\n      el = (prev as Element)?.ownerDocument.defaultView?.frameElement;\n    }\n  }\n\n  return returnValue;\n};\n\nexport const inElementScope = (node: NodeWithParentElement, name: string) =>\n  forAncestorsOrSelf(node, (el, value) =>\n    value(tagName(el) === name || undefined)\n  );\n\nexport const scopeAttr = (node: NodeWithParentElement, name: string) =>\n  forAncestorsOrSelf(node, (el, value) => value(attr(el, name)));\n\nexport const attrl = (node: NodeWithParentElement, name: string) =>\n  lowerCase(attr(node, name));\n\nlet value: string | null;\nexport const attrb = (node: NodeWithParentElement, name: string) =>\n  (value = attr(node, name)) === \"\" || parseBoolean(value);\n\nexport const attrn = (node: NodeWithParentElement, name: string) =>\n  parseFloat(\"\" + (value = attr(node, name))) ?? undefined;\n\nexport const attrs = <T extends NodeWithParentElement | Nullish>(\n  node: T\n): string[] | Nulls<T, undefined> => (node as any)?.getAttributeNames();\n\nexport const attr = (\n  node: NodeWithParentElement,\n  name: string,\n  value?: string | null\n): string | null =>\n  !(node as any)?.getAttribute\n    ? nil\n    : value === undefined\n    ? (node as Element).getAttribute(name)\n    : (value === nil\n        ? (node as any).removeAttribute(name)\n        : (node as any).setAttribute(name, value),\n      value);\n\nexport const cssProperty = (el: Element, name: string) =>\n  getComputedStyle(el).getPropertyValue(name) || nil;\n\nlet parameters: {};\nexport const define = <\n  T,\n  P extends Record<keyof any, [any, boolean?] | undefined>\n>(\n  target: T,\n  props: P\n): T & P =>\n  ((parameters = {}),\n  (map(\n    filter(entries(props), ([_, value]) => value != nil),\n    ([name, [value, writable = F] = []]) =>\n      (parameters[name] = {\n        writable,\n        configurable: writable,\n        value,\n      })\n  ),\n  Object.defineProperties(target, parameters))) as any;\n\nexport const tagName = <T extends Element | Nullish>(\n  el: T\n): T extends Nullish ? null : string => (el != nil ? (el.tagName as any) : nil);\n\nlet pos: Position;\nexport const relativeScrollPos = (): Position => (\n  (pos = scrollPos(F)),\n  {\n    x: pos.x / (body.offsetWidth - window.innerWidth) || 0,\n    y: pos.y / (body.offsetHeight - window.innerHeight) || 0,\n  }\n);\n\nexport const scrollPos = (int?: boolean): Position => ({\n  x: round(scrollX, int),\n  y: round(scrollY, int),\n});\n\nexport const matchExHash = (href1: string, href2: string) =>\n  replace(href1, /#.*$/, \"\") === replace(href2, /#.*$/, \"\");\n\nlet screenPos: Position | undefined;\nexport const getScreenPos = <T extends Element | Nullish>(\n  el: T,\n  mouseEvent?: MouseEvent,\n  includeFold = T\n): ScreenPosition | Nulls<T> =>\n  (screenPos = getPos(el, mouseEvent)) &&\n  (cast<ScreenPosition>({\n    xpx: screenPos.x,\n    ypx: screenPos.y,\n    x: round(screenPos.x / body.offsetWidth, 4),\n    y: round(screenPos.y / body.offsetHeight, 4),\n    pageFolds: includeFold ? screenPos.y / window.innerHeight : undefined,\n  }) as any);\n\nlet x: number, y: number;\nexport const getPos = <T extends Element | Nullish>(\n  el: T,\n  mouseEvent?: MouseEvent\n): ValueOrDefault<T, Position> =>\n  !!mouseEvent?.[\"pointerType\"] && mouseEvent?.pageY != nil\n    ? { x: mouseEvent.pageX, y: mouseEvent.pageY }\n    : el\n    ? (({ x, y } = getRect(el)), { x, y })\n    : (undefined as any);\n\nlet rect: DOMRect;\nexport const getRect = <T extends Element | Nullish>(\n  el: T\n): MaybeUndefined<T, Rectangle> =>\n  el\n    ? ((rect = el.getBoundingClientRect()),\n      (pos = scrollPos(F)),\n      {\n        x: round(rect.left + pos.x),\n        y: round(rect.top + pos.y),\n        width: round(rect.width),\n        height: round(rect.height),\n      })\n    : (undefined as any);\n\ntype AllMaps = WindowEventMap &\n  GlobalEventHandlersEventMap &\n  DocumentEventMap &\n  HTMLElementEventMap;\n\nexport const listen = <K extends keyof AllMaps>(\n  el: any,\n  names: K[] | K,\n  cb: (ev: AllMaps[K], unbind: () => void) => void,\n  capture = T,\n  passive = T\n) => {\n  let unbinders: any[] = [];\n\n  return (\n    map(names, (name, i) => {\n      const mapped = (ev: any) => {\n        cb(ev, unbinders[i]);\n      };\n      push(unbinders, () => el.removeEventListener(name, mapped, capture));\n      return el.addEventListener(name, mapped, { capture, passive });\n    }),\n    () =>\n      unbinders.length > 0 && map(unbinders, (unbind) => unbind())\n        ? ((unbinders = []), T)\n        : F\n  );\n};\n\nexport const listenOnce = <K extends keyof AllMaps>(\n  el: any,\n  names: K[] | K,\n  cb: (event: AllMaps[K], unbind: () => void) => void,\n  useCapture?: boolean\n) =>\n  listen(\n    el,\n    names,\n    (event, unbind) => (cb(event, unbind), unbind()),\n    useCapture\n  );\n\nexport const parseDomain = <T extends string | Nullish>(\n  href: T\n): T extends string ? { domain?: Domain; href: string } : undefined =>\n  href == nil\n    ? (undefined as any)\n    : match(\n        href,\n        /^(?:([a-zA-Z0-9]+):)?(?:\\/\\/)?([^\\s\\/]*)/,\n        (all, protocol, domainName) =>\n          domainName\n            ? {\n                href: href.substring(all.length),\n                domain: {\n                  protocol,\n                  domainName,\n                } as Domain,\n              }\n            : { href }\n      );\n\nexport const getViewportSize = (): Size => ({\n  width: window.innerWidth,\n  height: window.innerHeight,\n});\n\nexport const getViewport = (): Viewport => (\n  (pos = scrollPos(T)),\n  {\n    ...pos,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    totalWidth: body.offsetWidth,\n    totalHeight: body.offsetHeight,\n  }\n);\n\nexport const tryAsync = async <T, E = void>(\n  action: (() => Promise<T> | T) | Promise<T> | T,\n  error?: ((error: any) => Promise<E> | E) | Promise<E> | E,\n  always?: () => void | Promise<void>\n): Promise<T | E> => {\n  try {\n    return await (fun(action) ? action() : action);\n  } catch (e) {\n    console.error(e);\n    return await (fun(error) ? error(e) : e);\n  } finally {\n    await always?.();\n  }\n};\n\nexport const tryCatch = <T, R = undefined>(\n  action: () => T,\n  error: ((e: any) => R) | any[] | false = (e) => err(nil, nil, e) as R,\n  finallyCallback?: () => void\n): ConstToNormal<T | R | undefined> => {\n  const unbind = listen(window, \"error\", (ev) => ev.stopImmediatePropagation());\n  try {\n    return action() as any;\n  } catch (e) {\n    return error === F\n      ? undefined\n      : fun(error)\n      ? error(e)\n      : ((push(error, e) ?? err(nil, nil, e), undefined as R) as any);\n  } finally {\n    unbind();\n    finallyCallback?.();\n  }\n};\n","import msgpack from \"@ygoe/msgpack\";\nconst { deserialize, serialize } = msgpack;\n\nimport { HashFunction, from64u, lfsr, to64u } from \".\";\nimport {\n  IsNever,\n  Nullish,\n  hasValue,\n  isArray,\n  isDefined,\n  isFunction,\n  isIterable,\n  isNumber,\n  isObject,\n  isString,\n  isSymbol,\n  isUndefined,\n  undefined,\n  map,\n  tryCatch,\n} from \"..\";\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\nexport type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the constract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properies that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param validate This property has no effect other than letting TypeScript validate whether the value can be deserialized back to its original form without losing properties.\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  (value: any, validate?: false): string;\n  <T = Encodable>(value: T & EncodableContract<T>, validate: true): string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(encoded: string | Nullish) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\n/**\n * Misc. fixes to the msgpack library. For example, it does not handle exponential numbers well.\n */\nconst patchSerialize = (value: any) => {\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number;\n  const patchProperty = (\n    value: any,\n    key: any,\n    val = value[key],\n    patched = inner(val)\n  ) => (\n    (val !== patched || isSymbol(key)) &&\n      ((value[key] = patched), addCleaner(() => (value[key] = val))),\n    val\n  );\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (value == null || isFunction(value) || isSymbol(value)) {\n      return null;\n    }\n\n    // if (Number.isFinite(value) && !Number.isSafeInteger(value)) {\n    //   // A bug in @ygoe/msgpack means floats do not get encoded. We need to encode them in a different way.\n    //   // This is how it landed, since data structure is highly unlikely to be encountered,\n    //   // yet it is probably not the best way to do this (apart from fixing the bug ofc.)\n    //   floatView.setFloat64(0, value, true);\n    //   return { \"\": [...new Uint32Array(floatBuffer)] };\n    // }\n\n    if (!isObject(value, true)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if (isDefined((refIndex = (refs ??= new Map()).get(value)))) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isObject(value)) {\n      refs.set(value, refs.size + 1);\n\n      Object.keys(value).forEach(\n        (k) =>\n          (isUndefined(patchProperty(value, k)) || isSymbol(k)) &&\n          delete value[k]\n      );\n    } else if (isIterable(value)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  const serialized = serialize(inner(value));\n  cleaners?.forEach((cleaner) => cleaner());\n  return serialized;\n};\n\nconst patchDeserialize = (value: Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value, true)) return value;\n\n    // if (isArray(value[\"\"]) && (value = value[\"\"]).length === 2) {\n    //   return new DataView(new Uint32Array(value).buffer).getFloat64(0, true);\n    // }\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return hasValue(value) ? inner(deserialize(value)) : undefined;\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<any>\n];\n\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lsfr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (\n  key?: string | Nullish,\n  json = false\n): Transport => {\n  const [encrypt, decrypt, hash] = lfsr(key ?? \"\");\n  const fastStringHash = (value: any, bitsOrNumeric: any) => {\n    if (isNumber(value) && bitsOrNumeric === true) return value;\n\n    value = isString(value)\n      ? new Uint8Array(map(value.length, (i) => value.charCodeAt(i) & 255))\n      : json\n      ? JSON.stringify(value)\n      : patchSerialize(value);\n    return hash(value, bitsOrNumeric);\n  };\n  return json\n    ? [\n        (data: any) => JSON.stringify(data),\n        (encoded) =>\n          encoded == null\n            ? undefined\n            : tryCatch(() => JSON.parse(encoded, undefined)),\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ]\n    : [\n        (data: any) => to64u(encrypt(patchSerialize(data))),\n        (encoded: any) =>\n          hasValue(encoded)\n            ? patchDeserialize(decrypt(from64u(encoded)))\n            : null,\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ];\n};\n\nexport const defaultTransport = createTransport();\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\n","import { type Nullish } from \"@tailjs/util\";\nimport { createTransport } from \"@tailjs/util/transport\";\n\nexport const [httpEncode, httpDecode] = createTransport();\n\nexport let [httpEncrypt, httpDecrypt] = [null, null] as any; // [httpEncode, httpDecode];\n\nexport const setStorageKey = (key: string | Nullish) =>\n  ([httpEncrypt, httpDecrypt] = createTransport(key));\n","import { Timestamp } from \"@tailjs/types\";\nimport { F, SSR, T, nil, performance, promise, setTimeout, undefined } from \".\";\n\nexport const now: (truncate?: boolean) => number = (\n  round = T,\n  _tmp?: number\n) => (\n  (_tmp = SSR ? Date.now() : performance.timeOrigin + performance.now()),\n  round ? Math.trunc(_tmp) : _tmp\n);\n\nexport type Timeout = {\n  (): void; // Clear\n  (callback: () => void, delay?: number): void;\n  clear(delay?: number, cleanup?: () => void): void;\n  wait(delay?: number): Promise<void>;\n  isActive(): boolean;\n  finish(): void;\n  pulse(): Timeout;\n};\n\nexport const delay = (ms: number): Promise<void> =>\n  promise((resolve) => setTimeout(resolve, ms));\n\nexport const formatDuration = (ms: number) =>\n  ms > 250 ? `${(ms / 1000).toFixed(2)}s` : `${Math.round(ms)}ms`;\n\nexport const timeout = (callback?: () => void, delay?: number): Timeout => {\n  let id = 0;\n  let currentCallback = callback;\n  let capturedCallback: typeof callback | null = null;\n\n  const clear = () => (\n    (currentCallback = undefined),\n    id < 0 ? clearInterval(-id) : clearTimeout(id),\n    (id = 0)\n  );\n\n  const timeout = (callback?: () => void, delay?: number) => {\n    clear();\n    if (!callback) return;\n\n    currentCallback = callback;\n    id =\n      delay! < 0\n        ? -setInterval(callback, -delay!)\n        : (setTimeout(\n            () => ((currentCallback = undefined), callback()),\n            delay\n          ) as any);\n  };\n\n  timeout.clear = (delay?: number, cleanup?: () => void, currentId = id) =>\n    id &&\n    (delay\n      ? setTimeout(() => id === currentId && (clear(), cleanup?.()), delay)\n      : (clear(), cleanup?.()));\n\n  timeout.wait = (delay: number): Promise<void> =>\n    promise((resolve) => timeout(resolve, delay));\n\n  timeout.pulse = () => (currentCallback?.(), timeout);\n\n  timeout.isActive = () => currentCallback != nil;\n  timeout.finish = () =>\n    (capturedCallback = currentCallback) && (clear(), capturedCallback());\n\n  return callback && timeout(callback, delay), timeout;\n};\n\nexport const timer = (time = () => now(), started = T) => {\n  let elapsed = 0;\n  let origin = started ? time() : 0;\n\n  const timer = (start?: boolean): Timestamp => {\n    if (origin) {\n      elapsed += -origin + (origin = time());\n    } else if (start === T) {\n      origin = time();\n    }\n\n    if (start === F) {\n      origin = 0;\n    }\n    return elapsed;\n  };\n  timer.reset = () => (origin && (origin = time()), (elapsed = 0));\n  return timer;\n};\n\nexport const defer = (f: VoidFunction, ms = 0) =>\n  ms ? setTimeout(f, ms) : window.queueMicrotask(f);\n","import type { LocalID, UUID } from \"@tailjs/types\";\nimport { now, reduce, replace, split } from \".\";\n\nexport type TabId = string;\n\nconst KEY_PREFIX = \"(t~\";\n\nexport const mapSharedId = (id: string) => `${KEY_PREFIX}${id}`;\n\nconst randomValues = (arg: any) => crypto.getRandomValues(arg);\nexport const uuidv4 = (): UUID =>\n  replace(\n    ([1e7] as any) + -1e3 + -4e3 + -8e3 + -1e11,\n    /[018]/g,\n    (c: any) => (\n      (c *= 1),\n      (c ^ (randomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)\n    )\n  );\n\nexport const randomSafeInt = (arr?: Uint32Array) => (\n  randomValues((arr = new Uint32Array(2))),\n  // keep all 32 bits of the the first, top 20 of the second for 52 random bits\n  arr[0] * (1 << 20) + (arr[1] >>> 12)\n);\n\nconst localIdBuffer = new Uint32Array(2);\nexport const nextId = (): LocalID => randomSafeInt(localIdBuffer).toString(36);\n\nexport const compareTabIds = (id: TabId, other: TabId) =>\n  id.localeCompare(other, \"en\") < 0 ? id : other;\n\nexport const getMinTabId = (id: TabId, ...other: TabId[]) =>\n  other.length === 0\n    ? id\n    : other.length === 1\n    ? compareTabIds(id, other[0])\n    : reduce(other, (min, id) => compareTabIds(id, min), id);\n\nexport const TAB_ID = `${now().toString(36)}-${randomSafeInt().toString(36)}`;\n\nlet tabIdParts: [date: string, random: string];\nexport const formatTabId = (tabId = TAB_ID) => (\n  (tabIdParts = split(tabId, \"-\") as any),\n  `${new Date(parseInt(tabIdParts[0], 36)).toISOString()} (${tabIdParts[1]})`\n);\n","import type { TrackerConfiguration } from \"..\";\n\nexport const isTracker = \"__isTracker\";\n\nexport const trackerConfig: Required<TrackerConfiguration> = {\n  name: \"tail\",\n  src: \"/_t.js\",\n  disabled: false,\n  postEvents: true,\n  postFrequency: 2000,\n  requestTimeout: 5000,\n  heartbeatFrequency: 0,\n  clientKey: null,\n  apiKey: null,\n\n  /**\n   * Log events to the browser's developer console.\n   */\n  debug: false,\n  impressionThreshold: 1000,\n  captureContextMenu: true,\n  defaultActivationTracking: \"auto\",\n  tags: { default: [\"data-id\", \"data-name\"] },\n};\n","import {\n  CONTEXT_MENU_QUERY,\n  EVENT_HUB_QUERY,\n  VARIABLES_QUERY,\n} from \"@constants\";\nimport type { Nullish } from \"@tailjs/util\";\nimport { T, document, join, parseDomain, replace, split } from \".\";\n\nexport const ERR_BUFFER_OVERFLOW = \"buffer-overflow\";\nexport const ERR_POST_FAILED = \"post-failed\";\nexport const ERR_INVALID_COMMAND = \"invalid-command\";\nexport const ERR_INTERNAL_ERROR = \"internal-error\";\nexport const ERR_ARGUMENT_ERROR = \"invalid-argument\";\nexport const ERR_RESERVED = \"reserved\";\nexport const ERR_CONFIG_LOCKED = \"config-locked\";\nexport const ERR_DUPPLICATE_KEY = \"key\";\n\nconst src = split(\"\" + document.currentScript![\"src\"], \"#\");\nconst args = split(\"\" + (src[1] || \"\"), \";\");\n\nexport const SCRIPT_SRC = src[0];\nexport const TRACKER_DOMAIN =\n  args[1] || parseDomain(SCRIPT_SRC)?.domain?.domainName;\n\nexport const isInternalUrl = (url: string | Nullish) =>\n  !!(\n    TRACKER_DOMAIN &&\n    parseDomain(url)?.domain?.domainName.endsWith(TRACKER_DOMAIN) === T\n  );\n\nexport const mapUrl = (...urlParts: string[]) =>\n  replace(join(urlParts), /(^(?=\\?))|(^\\.(?=\\/))/, SCRIPT_SRC.split(\"?\")[0]);\n\nexport const VAR_URL = mapUrl(\"?\", EVENT_HUB_QUERY);\nexport const MNT_URL = mapUrl(\"?\", CONTEXT_MENU_QUERY);\nexport const USR_URL = mapUrl(\"?\", VARIABLES_QUERY);\n","import { del, forEach, hashSet, openPromise, set } from \".\";\n\ntype HandlerArgs<Args extends any[]> = [...params: Args, unbind: () => void];\nexport const eventSet = <Args extends any[] = []>(\n  once = false\n): [\n  add: (handler: (...args: HandlerArgs<Args>) => void) => () => void,\n  invoke: (...args: Args) => void\n] => {\n  const handlers = hashSet<(...args: HandlerArgs<Args>) => void>();\n  const unbinder = (handler: any) => () => del(handlers, handler);\n  let invokeArgs: Args | null = null;\n\n  return [\n    (handler: (...args: HandlerArgs<Args>) => void): (() => void) => (\n      // If the event has already fired call the handler with whatever args were used when it happened.\n      once && invokeArgs\n        ? handler(...invokeArgs, () => {})\n        : set(handlers, handler),\n      unbinder(handler)\n    ),\n    (...args: Args) =>\n      forEach(handlers, (handler) => {\n        handler(...(invokeArgs = args), unbinder(handler));\n      }),\n  ];\n};\n\nexport const startupLock = openPromise();\n\nexport const [registerStartupHandler, startupComplete] = eventSet(true);\n\nregisterStartupHandler(() => startupLock(true));\n","import { parseTagString, type Tag } from \"@tailjs/types\";\nimport type { Nullish } from \"@tailjs/util\";\nimport {\n  attr,\n  attrs,\n  bool,\n  concat2,\n  createElement,\n  cssProperty,\n  F,\n  filter,\n  flatMap,\n  forAncestorsOrSelf,\n  forEach,\n  fun,\n  get,\n  hashSet,\n  iterable,\n  map,\n  match,\n  matches,\n  nil,\n  NodeWithParentElement,\n  obj,\n  regex,\n  replace,\n  size,\n  str,\n  T,\n  test,\n  trackerConfig,\n  values,\n  weakMap,\n} from \".\";\nimport type { BoundaryData, TagMappings } from \"..\";\n\nexport const boundaryData = weakMap<Node, BoundaryData>();\nexport const getBoundaryData = (el: Node) => get(boundaryData, el);\n\nexport const trackerPropertyName = (name: string, css = F) =>\n  (css ? \"--track-\" : \"track-\") + name;\n\n// const trackerProperty = (\n//   el: Element,\n//   name: string,\n//   value = attr(el, trackerPropertyName(name)),\n//   css = cssProperty(el as Element, trackerPropertyName(name, T))\n// ) => (value ? (css ? value + \" \" + css : value) : css);\n\ntype MatchAttributeRule = readonly [\n  match: RegExp,\n  selector?: string,\n  baseRank?: string\n];\n\ntype CacheMatchRules = [\n  eligibleCache: { [name: string]: boolean },\n  rules: MatchAttributeRule[] | Nullish\n];\n\n/**\n * Extracts an element's tags given an attribute name, and a list of rules about how to match..\n * Since this function is external, its local variables are added as local parameters. Don't tamper.\n *\n * An optional `eligibleCache` can be passed along to speed up rejecting attribute names that definitely don't match anything.\n */\nconst matchAttributeNames = (\n  el: Element | Nullish,\n  cached: CacheMatchRules | Nullish,\n  tags: Set<string>,\n  prefix?: string | boolean,\n  value?: string,\n  eligible?: boolean\n) =>\n  cached?.[1] &&\n  forEach(\n    attrs(el),\n    (name) =>\n      (cached[0][name] ??=\n        ((eligible = F),\n        str(\n          (prefix =\n            // Grrr.. we did not. Let's loop through them then.\n            forEach(\n              cached[1],\n              ([match, selector, prefix], _, stop) =>\n                test(name, match) &&\n                // Sneakily we \"delete\" the eligible flag, so the skipNameCache's `??=` assignment will always be reevaluated.\n                // If this code branch is never hit, we return the initial value `false`, and this check will never be performed again.\n                // We do this check before the selector check, since this result is not generally cacheable.\n                ((eligible = undefined), !selector || matches(el, selector)) &&\n                stop(prefix ?? name)\n            ))\n        ) && // The empty string is also \"true\" since it means precense of the attribute without a value (as in `<div tag-yes />).\n          (!(value = el!.getAttribute(name)!) || bool(value, false)) &&\n          parseTagString(value, replace(prefix, /\\-/g, \":\"), tags),\n        eligible))\n  );\n\n// We cache the tracker configuration's rules for tag mappings.\nlet cachedTagMapper: (el: Element, tags: Set<string>) => void = () => {};\nlet cachedMappings: TagMappings | undefined;\nconst parseTagAttributes = (el: Element, tags: Set<string>) => {\n  if (cachedMappings === (cachedMappings = trackerConfig.tags)) {\n    return cachedTagMapper(el, tags);\n  }\n\n  const parse = (rule: TagMappings[string]): MatchAttributeRule[] =>\n      !rule\n        ? []\n        : regex(rule)\n        ? [[rule]]\n        : iterable(rule)\n        ? flatMap(rule, parse)\n        : [\n            obj(rule)\n              ? [regex(rule.match, false), rule.selector, rule.prefix]\n              : [regex(rule, false)],\n          ],\n    cache: CacheMatchRules = [\n      {},\n      // Start by checking whether we have any of the good ol', documented, \"tail.js official\" tag attributes.\n      [[/^(?:track\\-)?tags?(?:$|\\-)(.*)/], ...parse(values(cachedMappings))],\n    ];\n\n  (cachedTagMapper = (el: Element, tags: Set<string>) =>\n    matchAttributeNames(el, cache, tags))(el, tags);\n};\n\nconst cssPropertyWithBase = (el: Element, name: string) =>\n  concat2(\n    cssProperty(el, trackerPropertyName(name, T)),\n    cssProperty(el, trackerPropertyName(\"base-\" + name, T)),\n    \"\"\n  );\n\n// We cannot cache as broadly for CSS based rules, so we cache per selector instead.\nconst parsedCssRules: {\n  [rule: string]: CacheMatchRules;\n} = {};\n\nconst parseCssMappingRules = (\n  el: Element,\n  tags: Set<string>,\n  rulesString = cssPropertyWithBase(el, \"attributes\")\n) => {\n  matchAttributeNames(\n    el,\n    (parsedCssRules[rulesString] ??= [\n      {},\n      filter(\n        match(\n          rulesString,\n          /(?:(\\S+)\\:\\s*)?(?:\\((\\S+)\\)|([^\\s,:]+))\\s*(?!\\S*\\:)/g,\n          (_, prefix, rule1, rule2) =>\n            [regex(rule1 || rule2, false), , prefix] as const,\n          []\n        ),\n        T\n      ),\n    ]),\n    tags\n  );\n  parseTagString(cssPropertyWithBase(el, \"tags\"), undefined, tags);\n};\n\nlet currentBoundaryData: BoundaryData | Nullish;\nexport const trackerProperty = (\n  el: Element,\n  name: string,\n  inherit:\n    | boolean\n    | ((el: NodeWithParentElement, distance: number) => boolean) = F,\n  boundaryData?: (el: BoundaryData) => string | Nullish\n): string | null =>\n  (inherit\n    ? forAncestorsOrSelf(\n        el,\n        (el, r) => r(trackerProperty(el, name, F)),\n        fun(inherit, F)\n      )\n    : concat2(\n        attr(el, trackerPropertyName(name)),\n        cssProperty(el, trackerPropertyName(name, T))\n      )) ??\n  (boundaryData &&\n    (currentBoundaryData = getBoundaryData(el)) &&\n    boundaryData(currentBoundaryData)) ??\n  nil;\n\nlet propertyValue: string | Nullish;\nexport const trackerFlag = (\n  el: Element,\n  name: string,\n  inherit:\n    | boolean\n    | ((el: NodeWithParentElement, distance: number) => boolean) = F,\n  boundaryData?: (data: BoundaryData) => boolean | Nullish\n) =>\n  (propertyValue = trackerProperty(el, name, inherit, boundaryData as any)) ===\n    \"\" || (propertyValue == nil ? propertyValue : bool(propertyValue, T));\n\nexport type ParsedTags = { tags?: Tag[] };\n\nexport const parseTags = (\n  sourceEl: Element | Nullish,\n  stoppingCriterion?: (el: Element, distance: number) => boolean,\n  elementTagData?: (el: Element) => Iterable<Tag> | Nullish,\n  tags?: Set<string>\n): ParsedTags =>\n  !sourceEl\n    ? {}\n    : ((tags ??= hashSet<string>()),\n      parseCssMappingRules(sourceEl, tags),\n      forAncestorsOrSelf(\n        sourceEl,\n        (el) => {\n          parseTagAttributes(el, tags!);\n          parseTagString(map(elementTagData?.(el)), undefined, tags!);\n        },\n        stoppingCriterion\n      ),\n      size(tags) ? { tags: [...tags] } : {});\n\nlet styleElement: Node;\nexport const injectCssDefaults = (document: Document) => {\n  document.body.appendChild(\n    (((styleElement =\n      // --track-base-attributes and --track-base-tags are not set, since they are supposed to be inherited.\n      createElement(\"style\")).innerText = `* { ${trackerPropertyName(\n      \"tags\",\n      T\n    )}:; ${trackerPropertyName(\"attributes\", T)}:;}`),\n    styleElement)\n  );\n};\n","import { Encodable } from \"@tailjs/util/transport\";\nimport {\n  F,\n  T,\n  TAB_ID,\n  array,\n  decode,\n  encode,\n  filter,\n  fun,\n  httpDecode,\n  httpDecrypt,\n  httpEncode,\n  httpEncrypt,\n  map,\n  mapSharedId,\n  nil,\n  now,\n  push,\n  shift,\n  timeout,\n  undefined,\n} from \".\";\n\nexport interface SimpleStorage {\n  getItem: (key: string) => string | null;\n  setItem: (key: string, value: string, timeout?: number) => void;\n  removeItem: (key: string) => void;\n\n  /**\n   * A flag whether the storage natively supports expiry of stale value. In that case, the timestamp for expiry will not be serialized.\n   * This is the case for cookies, so no need to bloat the scarce data capacity more than necessary.\n   */\n  supportsExpiry?: boolean;\n}\n\nexport interface StorageAccess {\n  <T extends Encodable = Encodable>(key: string): T | null;\n  <T extends Encodable>(key: string, value: T, timeout?: number): T;\n\n  <T extends Encodable>(\n    key: string,\n    value: (current: T) => T,\n    timeout?: number\n  ): T;\n}\n\nexport interface MappedStorageAccess<T extends Encodable> {\n  (): T | null;\n  (value: T, timeout?: number): T;\n  (value: (current: T) => T, timeout?: number): T;\n}\n\nexport interface ObservableStorageAccess extends StorageAccess {\n  <T extends Encodable | null>(\n    handler: StorageItemListener<T>,\n    self: boolean\n  ): () => boolean | void;\n}\n\nexport type StorageItemListener<T extends Encodable = Encodable> = (\n  key: string,\n  value: T | null,\n  oldValue: T | null,\n  sourceId: string | null\n) => boolean | void;\n\nconst memoryStorage = (): SimpleStorage => {\n  const values: Record<string, string> = {};\n  return {\n    getItem: (key) => values[key] as any,\n    setItem: (key, value) => (values[key] = value),\n    removeItem: (key) => delete values[key],\n  };\n};\n\ntype StorageEntry<T extends Encodable = Encodable> = [\n  value: T,\n  expires?: number,\n  source?: string\n];\n\nconst serialize = <T extends Encodable = Encodable>(\n  value: T,\n  expires?: number,\n  sourceId?: string | null,\n  secure = false\n): T extends null ? null : string =>\n  value == nil\n    ? nil\n    : ((secure ? httpEncrypt : httpEncode)(\n        sourceId || expires\n          ? {\n              $: [\n                value as any,\n                expires, // If there is a source ID we need a value to keep the array length.\n                sourceId,\n              ],\n            }\n          : value\n      ) as any);\n\nlet decoded: any, expires: number;\nconst deserialize = <T extends Encodable = Encodable>(\n  value: string | null,\n  removeExpired?: () => void,\n  secure = false\n): StorageEntry<T> | null =>\n  !value /* including empty string */\n    ? nil\n    : ((decoded = (secure ? httpDecrypt : httpDecode)(value)),\n      decoded.$\n        ? (((expires = +((decoded = decoded.$)[1] ?? 0)),\n          expires > 0 && expires < now(F)\n            ? (removeExpired?.(), nil)\n            : [decoded[0], expires, decoded[2]]) as StorageEntry<any>)\n        : [decoded]);\n\ntype StorageDelta = {\n  key: string | null;\n  newValue: string | null;\n  oldValue: string | null;\n};\n\ntype DeltaEventMapper = (\n  listener: (delta: StorageDelta) => void,\n  remove?: boolean\n) => void;\n\nlet entry: StorageEntry<Encodable> | null;\nlet oldEntry: StorageEntry<Encodable> | null;\nconst storage: {\n  (storage: SimpleStorage): StorageAccess;\n  (\n    storage: SimpleStorage,\n    register?: DeltaEventMapper,\n    secure?: boolean\n  ): ObservableStorageAccess;\n} = (\n  storage: SimpleStorage,\n  register?: DeltaEventMapper,\n  secure?: boolean\n): ObservableStorageAccess => {\n  const sourceId = register ? TAB_ID : undefined;\n  const removeExpired = (key: string | null) => () =>\n    key && storage.removeItem(key);\n\n  const ownListeners = new Set<StorageItemListener>();\n  const accessor = Object.assign((arg0: any, arg1?: any, arg2?: any): any => {\n    if (fun(arg0)) {\n      if (!register) return;\n      // Listener.\n      const [innerHandler, triggerSelf = F] = [arg0, arg1] as [\n        StorageItemListener,\n        boolean\n      ];\n\n      const handler: StorageItemListener = (...args) => {\n        let res = innerHandler(...args);\n        return res === F && unlisten?.();\n      };\n\n      const listener = ({ key, newValue, oldValue }: StorageEvent): any => (\n        ((entry = deserialize(newValue, removeExpired(key), secure)),\n        (oldEntry = deserialize(oldValue, undefined, secure))),\n        key &&\n          handler(\n            key,\n            entry?.[0] ?? nil,\n            oldEntry?.[0] ?? nil,\n            entry?.[2] ?? nil\n          )\n      );\n\n      let unlisten = () => (\n        (unlisten = nil!), register(listener, T), ownListeners.delete(handler)\n      );\n\n      register(listener);\n\n      triggerSelf && ownListeners.add(handler);\n      return unlisten;\n    }\n    let [key, value, timeout = 0] = [arg0, arg1, arg2] as [\n      string,\n      Encodable | ((current: any) => any) | undefined,\n      number\n    ];\n\n    if (value === undefined) {\n      // get\n      return (\n        deserialize(storage.getItem(key), removeExpired(key), secure)?.[0] ??\n        nil\n      );\n    }\n\n    if (fun(value)) {\n      //update\n      return accessor(key, value(accessor(key)), timeout);\n    }\n\n    // set\n    const data =\n      value == nil || timeout < 0\n        ? nil\n        : serialize(\n            value,\n            timeout && !storage.supportsExpiry ? now(T) + timeout : undefined,\n            sourceId,\n            secure\n          );\n\n    data == nil\n      ? storage?.removeItem(key)\n      : storage?.setItem(key, data, timeout > 0 ? timeout : undefined);\n\n    ownListeners.size &&\n      (((entry = deserialize(data, undefined, secure)),\n      (oldEntry = deserialize(storage.getItem(key), undefined, secure))),\n      ownListeners.forEach((handler) =>\n        handler(key, entry?.[0] ?? nil, oldEntry?.[0] ?? nil, entry?.[2] ?? nil)\n      ));\n    return value;\n  });\n  return accessor;\n};\n\nexport const cookieStorage: SimpleStorage = {\n  getItem: (key) => (\n    (key = encode(key)),\n    decode(\n      document.cookie\n        .split(\";\")\n        .map((kv) => kv.split(\"=\"))\n        .find((kv) => kv[0].trim() === key)?.[1] || nil\n    )\n  ),\n  setItem: (key, value, maxAge) =>\n    (document.cookie = `${encode(key)}=${encode(\n      value ?? \"\"\n    )}; Path=/; SameSite=Lax${\n      !value || maxAge != nil\n        ? `; Max-Age=${Math.round((maxAge ?? 0) / 1000)}`\n        : \"\"\n    }`),\n\n  removeItem: (key) => cookieStorage.setItem(key, \"\", 0),\n\n  supportsExpiry: true,\n};\n\nexport const memory = storage(memoryStorage());\nexport const cookies = storage(cookieStorage);\nexport const secureCookies = storage(cookieStorage, undefined, true);\nexport const session = storage(sessionStorage);\nexport const shared = storage(\n  localStorage,\n  (listener, remove) =>\n    remove\n      ? window.removeEventListener(\"storage\", listener)\n      : window.addEventListener(\"storage\", listener),\n  true\n);\nexport const bind = <T extends Encodable = Encodable>(\n  storage: StorageAccess,\n  key: string,\n  useSharedId = T\n): MappedStorageAccess<T> => {\n  useSharedId && (key = mapSharedId(key));\n  return (...args: any[]) => (storage as any)(key, ...args);\n};\n\nexport type SharedQueue<T extends Encodable = Encodable> = {\n  (item: T, replace?: boolean): () => boolean;\n  (): T | null;\n};\nexport const sharedQueue = <T extends Encodable>(\n  key: string,\n  keyExpiry = 2000,\n  useSharedId = T\n): SharedQueue<T> => {\n  const queue = bind<[item: T, expires: number][]>(shared, key, useSharedId);\n  return (item?: T, replace = F): any => {\n    if (item === undefined) {\n      // Get\n      let match: T | null = nil;\n      queue((current) => {\n        current = filter(current, (item) => item[1] > now());\n        match = shift(current)?.[0] ?? nil;\n        return current;\n      });\n\n      return match;\n    }\n\n    let exists = T;\n\n    const updateQueue = (replace: boolean) =>\n      queue((current) =>\n        replace\n          ? map(current, (other) =>\n              other[0] === item\n                ? ((exists = T), [item, now() + keyExpiry])\n                : (other as any)\n            )\n          : push(current ?? [], [item, now() + keyExpiry])!\n      );\n\n    updateQueue(replace);\n    if (keyExpiry) {\n      let poll = timeout();\n      const refreshKey = () => (updateQueue(T), !exists && poll(), exists);\n\n      poll(refreshKey, -keyExpiry / 2);\n    }\n    return () => exists;\n  };\n};\n","import { TrackedEvent } from \"@tailjs/types\";\nimport type { Nullish } from \"@tailjs/util\";\nimport {\n  T,\n  any,\n  del,\n  filter,\n  get,\n  getOrSet,\n  hashMap,\n  hashSet,\n  map,\n  set,\n} from \".\";\n\nconst dependencies = Symbol();\n\nconst cleared = hashSet<TrackedEvent>();\n\n// If an event refers to another event it will not get posted before that is posted.\n// That also means that if the referred event is never posted, neither is the event.\n// TODO: Evaluate if this may cause a memory leak.\nconst pendingDependencies = hashMap<TrackedEvent, Set<TrackedEvent>>();\nconst areAllDependenciesPosted = (ev: TrackedEvent) =>\n  !any(ev[dependencies], (dep) => !get(cleared, dep));\n\nexport const hasDependencies = (event: TrackedEvent) =>\n  !areAllDependenciesPosted(event) &&\n  (map(event[dependencies], (dep) =>\n    set(\n      getOrSet(pendingDependencies, dep, () => hashSet()),\n      event\n    )\n  ),\n  T);\n\nlet stalled: Set<TrackedEvent> | Nullish;\nexport const completeDependency = (event: TrackedEvent) => (\n  set(cleared, event),\n  (stalled = pendingDependencies.get(event)) && // Free memory when all dependant events are cleared\n    (!stalled.size && del(pendingDependencies, event),\n    filter(\n      stalled,\n      (dep) => areAllDependenciesPosted(dep) && (del(stalled!, dep), T)\n    ))\n);\n\nexport const addDependency = (\n  event: TrackedEvent,\n  dependency: TrackedEvent\n) => (\n  event !== dependency &&\n    ((event[dependencies] ??= []).push(dependency) as any),\n  event\n);\n","import type { Nullish, Json } from \"@tailjs/util\";\nimport {\n  F,\n  T,\n  TAB_ID,\n  defer,\n  filter,\n  fun,\n  map,\n  mapSharedId,\n  nil,\n  shared,\n  shift,\n  size,\n} from \".\";\n\nexport interface MessageHandler<T extends Json = Json> {\n  (value: Exclude<T, null>, sourceId: string, direct: boolean): boolean | void;\n}\n\nexport type MessageSource = [sourceId: string, direct: boolean, self: string];\n\ntype HandlerArgs<F> = F extends (\n  source: MessageSource,\n  ...args: infer A\n) => void\n  ? A\n  : never;\n\ntype ExtractMessageTypes<T> = T extends {\n  [key in infer K]: (...args: any[]) => void;\n}\n  ? K extends string | number\n    ? [K, ...HandlerArgs<T[K]>]\n    : never\n  : never;\n\nexport interface Channel<Default extends Json = Json> {\n  <T extends Default>(handler: MessageHandler<T>, self?: boolean): () =>\n    | void\n    | boolean;\n  <T extends Default>(data: T, ...targetIds: (string | Nullish)[]): void;\n}\n\nexport const createChannel: {\n  <T extends Json = Json>(id: string): Channel<T>;\n  <\n    Handlers extends Record<\n      string | number,\n      (source: MessageSource, ...args: any[]) => void\n    >\n  >(\n    id: string,\n    handlers: Handlers,\n    self?: boolean\n  ): Channel<ExtractMessageTypes<Handlers>>;\n} = (id: any, handlers?: any, self?: any): any => {\n  id = mapSharedId(`c_${id}`);\n  const channelKey = id;\n\n  const getTargetKey = (targetId: string) => `${id}!${targetId}`;\n  const ownKey = getTargetKey(TAB_ID);\n\n  const channel = (arg0: any, ...rest: any[]): any => {\n    let cleared = T;\n    if (fun(arg0)) {\n      // Add listener.\n      return shared((key, value, _, sourceId) => {\n        if (\n          value != nil &&\n          sourceId &&\n          (key === channelKey || key === ownKey)\n        ) {\n          const result = (arg0 as MessageHandler)(\n            value,\n            sourceId,\n            key === ownKey\n          );\n\n          return result !== F;\n        }\n      }, (rest[0] ?? self) === T);\n    }\n    rest = filter(rest);\n\n    map(size(rest) ? map(rest, getTargetKey) : [id], (destinationKey) => {\n      cleared = F;\n      shared(destinationKey, arg0);\n      defer(() => cleared !== (cleared = T) && shared(destinationKey, nil));\n    });\n  };\n\n  if (handlers) {\n    channel((value: any, sourceId: string, direct: boolean) =>\n      handlers[shift(value) as any]?.(\n        [sourceId, direct, sourceId === TAB_ID],\n        ...value\n      )\n    );\n  }\n\n  return channel;\n};\n","import {\n  ERR_DUPPLICATE_KEY,\n  F,\n  T,\n  createChannel,\n  entries,\n  err,\n  eventSet,\n  fromEntries,\n  listen,\n  registerStartupHandler,\n  timeout,\n} from \".\";\n\nconst globalStateChannel = createChannel<1 | 2 | 3 | Record<string, any>>(\"ss\");\nconst globalStateResolvers: Record<string, [() => any, (value: any) => void]> =\n  {};\n\nconst [listeners, callListeners] = eventSet(true);\n\nexport { listeners as addGlobalStateResolvedListener };\n\nexport let globalStateResolved = F;\nconst resolveTimeout = timeout();\n\nexport const abortGlobalStateResolve = () => (resolveTimeout.finish(), T);\n\nexport const registerSharedState = <T>(\n  key: string,\n  resolve: () => T,\n  apply: (value: T | undefined) => void\n): ((updatedValue: T) => void) => (\n  globalStateResolvers[key]\n    ? err(ERR_DUPPLICATE_KEY, key)\n    : (globalStateResolvers[key] = [resolve, apply]),\n  (value) => globalStateChannel({ [key]: value })\n);\n\nregisterStartupHandler(() => {\n  resolveTimeout(() => ((globalStateResolved = T), callListeners()), 75);\n  let hasResponse = F;\n  globalStateChannel((payload, source) =>\n    payload === 1 // Ask out\n      ? globalStateChannel(2, source) // Offer state\n      : payload === 2\n      ? // Accept state once.\n        (hasResponse !== (hasResponse = T) && globalStateChannel(3, source), T)\n      : // We got picked for sharing the state\n      payload === 3\n      ? globalStateChannel(\n          fromEntries(\n            entries(globalStateResolvers, ([key, [resolve]]) => [\n              key,\n              resolve(),\n            ])\n          ),\n          source\n        )\n      : // Apply state\n        (entries(globalStateResolvers, ([key, [, apply]]) =>\n          apply(payload[key])\n        ),\n        resolveTimeout.finish())\n  );\n  // Ping on wakeup\n  globalStateChannel(1);\n\n  listen(window, \"pageshow\", () => !hasResponse && globalStateChannel(1));\n  listen(window, \"pagehide\", () => (hasResponse = F));\n});\n","import {\n  Expired,\n  F,\n  MAX_SAFE_INTEGER,\n  OpenPromise,\n  OpenPromiseWithTimeout,\n  Reset,\n  T,\n  TAB_ID,\n  TabId,\n  any,\n  clear,\n  createChannel,\n  debug,\n  defer,\n  del,\n  delay,\n  entries,\n  formatDuration,\n  getMinTabId,\n  keys,\n  listen,\n  nil,\n  now,\n  openPromise,\n  push,\n  registerStartupHandler,\n  size,\n  splice,\n  timeout,\n  trackerConfig,\n  tryAsync,\n  values,\n  window,\n} from \".\";\n\ntype Data = any;\ntype ActionId = string;\n\n// After this amount of ms it is assumed safe that all tabe have received a message sent from any other tab.\nconst MAX_MESSAGE_DELAY = 25;\nconst CLOSED_TAB_TIMEOUT = 500; // After this duration a closed tab is considered gone.\n\nexport type CommitAction<Data = any> = (\n  data: Data[],\n  critical: boolean\n) => Promise<boolean | void>;\n\nexport type ExitAction = (terminating: boolean) => void;\n\nconst enum MessageType {\n  /**\n   * Informs other tabs that a new tab loaded (either from bf cache or first load).\n   * The other tabs will reply with the same message to the new tab so it will know about all current tabs.\n   */\n  Loaded = 1,\n\n  /**\n   * Informs other tabs that a tab is unloading (either to bf cache or for good).\n   * When all tabs are unloading the last one will collect and commit their pending data.\n   *\n   */\n  Unloading = 2,\n\n  /**\n   * Broadcasts events that were collected in the tab.\n   */\n  Collect = 3,\n\n  /**\n   * Instructs a tab to coordinate a commit. It will do so if it has the smallest known tab ID, otherwise it will forward the request\n   * to the tab it thinks has the smallest ID.\n   */\n  Coordinate = 4,\n\n  /**\n   * Tabs will clear their collected data on this message. The tab that has the cooridnator ID will additionally commit it.\n   */\n  Commit = 5,\n\n  /**\n   * The tab received focus.\n   */\n  Activated = 6,\n\n  /**\n   * Tab lost focus.\n   */\n  Deactivated = 7,\n}\n\nexport type ActionHandler = [commit: CommitAction, exit?: ExitAction];\ntype ActionState = [\n  collected: Data[],\n  commitHandle: OpenPromiseWithTimeout<[success: boolean, items: number]>\n];\n\n// This is used to keep track of open and closing tabs so we can evaluate which tabs has the smalles ID (was opened first).\n// This tab must be the one comitting since it is the only one that is guaranteed to have seen all previous posts form other tabs.\n// This approach can also be thought of as an efficient algorithm for \"leader election\" to prevent multiple tabs making HTTP requests at the same time.\n// Interleaved HTTP requests must be avoided since it breaks the server state stored in the HTTP cookies.\n//\n// It cannot be prevented when all tabs are closing and an existing request has already been made to a slow server.\n// In this case the client flags the request to let the server know the the state should not be updated with the final request.\n// When this final race-condition occurs it is assumed _unlikely_ that the final request will contain other events than \"VIEW_END\" events (no \"VIEW\" events in particular),\n// so the book-keeping made for session duration, number of views,  previous session etc. is equally _unlikely_ to get out of sync.\nconst knownTabs: Record<\n  TabId,\n  number | null // If closed, at timestamp for when it happened.\n> = {};\n\nconst actionHandlers: Record<string, ActionHandler> = {};\n\nlet localData: Record<ActionId, Data[]> = {};\n\nconst flushLocalData = () => {\n  const currentData = localData;\n  localData = {};\n  return currentData;\n};\nexport const registerAction = <Data>(\n  id: ActionId,\n  ...actionHandler: ActionHandler\n): [\n  post: (...data: Data[]) => void,\n  commit: (critical?: boolean) => Promise<number>\n] => {\n  actionHandlers[id] = actionHandler;\n  return [\n    (...data) =>\n      size(data) &&\n      (push((localData[id] ??= []), ...data),\n      !closing &&\n        defer(\n          () =>\n            size(localData) && channel([MessageType.Collect, flushLocalData()])\n        )),\n    () => coordinateCommit(id),\n  ];\n};\n\nconst actionStates: Record<TabId, ActionState> = {};\nconst getActionState = (id: ActionId): ActionState =>\n  (actionStates[id] ??= [\n    [],\n    openPromise<[success: boolean, items: number]>(\n      trackerConfig.requestTimeout * 2\n    )([T, 0]),\n  ]);\n\nconst purgeClosedTabs = (timeout: number) =>\n  entries(\n    knownTabs,\n    ([key, value]) =>\n      value && Date.now() - value > timeout && del(knownTabs, key)\n  );\n\nconst getCoordinatorId = () => getMinTabId(TAB_ID, ...keys(knownTabs));\n\nconst isLastTab = () =>\n  !any(values(knownTabs), (closing) => !closing) &&\n  getCoordinatorId() === TAB_ID;\n\nconst channel = createChannel(\n  \"cs\",\n  {\n    [MessageType.Loaded]: ([sourceId, direct]) => {\n      knownTabs[sourceId] ??= nil;\n      !direct &&\n        sourceId !== TAB_ID &&\n        !closing &&\n        channel([MessageType.Loaded], sourceId);\n    },\n    [MessageType.Unloading](\n      [sourceId],\n      freezing: boolean,\n      data: Record<string, any>\n    ) {\n      knownTabs[sourceId] = Date.now();\n      entries(data, ([key, value]) => collect(key, value));\n      if (!freezing) {\n        keys(\n          actionHandlers,\n          (key) => isLastTab() && channel([MessageType.Commit, key, TAB_ID, T])\n        );\n      }\n    },\n\n    [MessageType.Collect](_, data: Record<ActionId, Data[]>) {\n      entries(data, ([key, value]) => collect(key, value));\n    },\n    [MessageType.Coordinate](_, actionId: ActionId) {\n      coordinateCommit(actionId);\n    },\n    [MessageType.Commit](\n      _,\n      actionId: ActionId,\n      coordinator: TabId,\n      critical: boolean\n    ) {\n      const [collected, handle] = getActionState(actionId);\n      const data = splice(collected, 0);\n      TAB_ID === coordinator &&\n        (async () => {\n          const n = size(data);\n          let success =\n            !n ||\n            ((await tryAsync(actionHandlers[actionId]?.[0](data, critical))) ??\n              T);\n\n          if (!success || n) {\n            debug(\n              `The action handler for '${actionId}' ${\n                success ? \"completed sucessfully\" : \"rejected\"\n              }.`\n            );\n          }\n\n          // The action did not succeed.\n          // It will only return false if it got cancelled or the server definitely failed in a way where the events will not get duplicated if posted again.\n          // Share the failed data with all tabs, instead of just keeping it locally, so it will get posted again even in the rare event where this tab got unloaded before the commit failed.\n          !success &&\n            (channel([MessageType.Collect, { [actionId]: data }]),\n            critical && debug(\"A critical request to commit got rejected.\"));\n\n          handle([success, n]);\n        })();\n    },\n    [MessageType.Activated]: ([sourceId]) => (\n      purgeClosedTabs(0), // At least one tab isn't closing. Purge the closed ones.\n      updatePollingTab(sourceId)\n    ),\n    [MessageType.Deactivated]: () => updatePollingTab(nil),\n  },\n  T\n);\n\nconst collect = (actionId: ActionId, data: Data[]) => {\n  return push(getActionState(actionId)[0], ...data);\n};\n\nlet closing = T;\nlet initPromise: OpenPromise | null = nil;\nconst init = async () => {\n  await initPromise;\n  if (closing === (closing = F)) {\n    return;\n  }\n  initPromise = openPromise();\n  try {\n    clear(knownTabs);\n    channel([MessageType.Loaded]);\n    // At this point we don't know how many tabs there are, if any. We need to wait a bit and see.\n    await delay(50);\n  } finally {\n    initPromise(T);\n  }\n};\n\nconst terminate = async (freeze: boolean) => {\n  if (closing === (closing = T)) {\n    return;\n  }\n  values(actionHandlers, (handler) => handler[1]?.(T));\n\n  channel([MessageType.Unloading, freeze, flushLocalData()]);\n  // We unloaded or froze. If we were the timeout leader (either coordinator or active) we need to tell the others that we deactivated.\n  toggleActive(F);\n};\n\nconst coordinateCommit = async (actionId: ActionId): Promise<number> => {\n  await initPromise;\n  if (closing) return 0; // Don't initiate commit when closing.\n\n  // If we are shutting down we will allow another tab shutting down to be elected as master. (Shutdown means all tabs are closed).\n  const coordinator = getCoordinatorId();\n  if (coordinator !== TAB_ID) {\n    channel([MessageType.Coordinate, actionId], coordinator);\n    return 0;\n  }\n\n  const handle = getActionState(actionId)[1];\n  const t0 = now(F);\n\n  let result = await handle;\n  handle(Reset);\n\n  channel([MessageType.Commit, actionId, TAB_ID, F]);\n  result = await handle;\n  debug(\n    result === Expired\n      ? `Commit timed out for '${actionId}.`\n      : !result[0] ||\n          (result[1] &&\n            `${result[0] ? \"Successfully comitted\" : \"Failed to commit\"} ${\n              result[1]\n            } items for '${actionId}' after ${formatDuration(now(F) - t0)}`)\n  );\n\n  return result[1];\n};\n\n// Timeout leader coordination\n\nlet safeTimeoutTimestamp: number = MAX_SAFE_INTEGER;\nlet selectedPollingTab: TabId | null = nil;\n\nconst updatePollingTab = (activeId: TabId | null) =>\n  (selectedPollingTab = activeId ??= getCoordinatorId()) === TAB_ID\n    ? (safeTimeoutTimestamp = Math.min(\n        safeTimeoutTimestamp,\n        now() + MAX_MESSAGE_DELAY\n      ))\n    : (safeTimeoutTimestamp = MAX_SAFE_INTEGER);\n\n// Polling for responses / regularly posting events etc.  must happen from intervals /timeouts in all tabs,\n// but only the one that is the \"timeout leader\" may execute the logic to avoid race conditions.\n// The coordinator can always be reached via messages (they are not throttled), but the tab in control of polling should preferably be the one that has focus\n// since background tabs are throttled.\nexport const isForegroundTab = () =>\n  initPromise?.() === T &&\n  (purgeClosedTabs(CLOSED_TAB_TIMEOUT), now() > safeTimeoutTimestamp);\n\nlet active = F;\nconst toggleActive = (toggle: boolean) =>\n  active !== (active = toggle) && toggle\n    ? channel([MessageType.Activated])\n    : !toggle &&\n      TAB_ID === selectedPollingTab &&\n      channel([MessageType.Deactivated]);\n\nregisterStartupHandler(() => {\n  listen(window, \"pageshow\", () => init());\n  listen(document, \"resume\" as any, () => init());\n  init();\n\n  listen(window, [\"beforeunload\", \"pagehide\"], () => terminate(F));\n  listen(document, \"freeze\" as any, () => terminate(T));\n\n  // Background flush event buffer.\n  timeout(\n    () =>\n      isForegroundTab() && keys(actionHandlers, (key) => coordinateCommit(key)),\n    -trackerConfig.postFrequency\n  );\n\n  listen(document, \"visibilitychange\", () =>\n    toggleActive(document.visibilityState === \"visible\")\n  );\n  listen(window, \"focus\", () => toggleActive(T));\n  listen(window, \"blur\", () => toggleActive(F));\n  toggleActive(document.visibilityState === \"visible\");\n});\n","import { MUTEX_REQUEST_COOKIE, MUTEX_RESPONSE_COOKIE } from \"@constants\";\nimport { EncodableObject } from \"@tailjs/util/transport\";\nimport {\n  F,\n  T,\n  createChannel,\n  debug,\n  decompose,\n  eventSet,\n  formatDuration,\n  isForegroundTab,\n  nil,\n  now,\n  promise,\n  registerStartupHandler,\n  // cookies,\n  secureCookies,\n  timeout,\n  trackerConfig,\n  tryCatch,\n} from \".\";\n\nconst cookies = secureCookies;\n\n// If a post has not completed within this threshold concurrent posting may happen.\nconst ACTIVE_REQUEST_POLL = 25;\nconst PASSIVE_REQUEST_POLL = 500;\n\nconst [addResponseListener, callResponseHandlers] =\n  eventSet<[affinity: string, variables: EncodableObject]>();\n\nexport { addResponseListener };\n\nconst responseChannel = createChannel<true | { error: any }>(\"req\");\n\nconst checkResponseCookie = () => {\n  return (\n    tryCatch(() =>\n      decompose(\n        cookies<\n          [string, [string, number], string | undefined, EncodableObject]\n        >(MUTEX_RESPONSE_COOKIE),\n        (affinity, source, error, variables) => (\n          cookies(MUTEX_RESPONSE_COOKIE, nil),\n          debug(\n            `Got response for ${source?.[0]} after ${\n              source?.[1] ? formatDuration(now() - source[1]) : \"(unknown)\"\n            }.`\n          ),\n          callResponseHandlers(affinity, variables),\n          error\n            ? (responseChannel({ error }), debug(`Response error: ${error}`))\n            : responseChannel(T),\n          T\n        )\n      )\n    ) || F\n  );\n};\n\nconst responseTimeout = timeout();\n\nconst pollResponseCookie = () => (\n  isForegroundTab() && checkResponseCookie(),\n  responseTimeout(\n    pollResponseCookie,\n    cookies(MUTEX_REQUEST_COOKIE) ? ACTIVE_REQUEST_POLL : PASSIVE_REQUEST_POLL\n  )\n);\n\nregisterStartupHandler(() => pollResponseCookie());\n\nexport const tryAcquireRequestLock = async (\n  force: boolean,\n  source: string,\n  action: (forced: boolean) => boolean | any\n): Promise<boolean> => {\n  const sourceLabel = `(${source ?? \"(unknown)\"})`;\n  checkResponseCookie();\n  let forced = !!cookies(MUTEX_REQUEST_COOKIE);\n  if (!force && forced) {\n    debug(`Another request is currently in progress - request cancelled.`);\n    return F;\n  }\n  let t0 = now();\n  const cookieValue = [sourceLabel, t0];\n  cookies(MUTEX_REQUEST_COOKIE, cookieValue, trackerConfig.requestTimeout);\n  cookies(MUTEX_RESPONSE_COOKIE, nil);\n  if (action(forced) === F) {\n    cookies(MUTEX_REQUEST_COOKIE, nil);\n    return T;\n  }\n\n  return await promise<boolean>((resolve) =>\n    responseChannel((response) => (resolve(response === T), F), T)\n  );\n};\n","import type { TrackedEvent } from \"@tailjs/types\";\nimport { httpEncode } from \"@tailjs/util/transport\";\nimport {\n  ERR_POST_FAILED,\n  F,\n  TAB_ID,\n  VAR_URL,\n  addResponseListener,\n  clean,\n  completeDependency,\n  debug,\n  err,\n  eventSet,\n  hasDependencies,\n  map,\n  navigator,\n  nil,\n  now,\n  push,\n  registerAction,\n  registerSharedState,\n  shift,\n  size,\n  splice,\n  startupLock,\n  tryAcquireRequestLock,\n} from \".\";\n\nconst [addPostListener, callPostListeners] =\n  eventSet<[events: TrackedEvent[]]>();\n\nconst [addShutdownListener, callShutdownListeners] = eventSet();\n\nexport {\n  addPostListener as addQueuePostListener,\n  addShutdownListener as addTerminationListener,\n};\nexport const enqueueEvent = (event: TrackedEvent) => {\n  const queue = [event];\n  const batch: TrackedEvent[] = [];\n  let ready: TrackedEvent[] | undefined;\n  while (queue.length) {\n    const event = shift(queue)!;\n    if (hasDependencies(event)) {\n      continue;\n    }\n    (ready = completeDependency(event)) && splice(queue, 1, 0, ...ready);\n\n    push(batch, event);\n  }\n  post(...batch);\n};\n\nconst [post, commit] = registerAction<TrackedEvent>(\n  \"events\",\n  async (events, force) => {\n    if (!size(events)) {\n      return F;\n    }\n    await startupLock;\n\n    if (force && !affinity) {\n      debug(\n        \"WARN: Force post downgraded to normal post because affinity has not been set.\"\n      );\n      force = F;\n    }\n    debug(\"Post started\");\n\n    callPostListeners(events);\n\n    return await tryAcquireRequestLock(force, TAB_ID, (discardCookies) => {\n      const t0 = now();\n      const postData = httpEncode([\n        map(\n          events,\n          (\n            ev,\n            _,\n            event = {\n              ...ev,\n              timestamp: Math.min(0, (ev.timestamp ??= t0) - t0),\n            }\n          ) => (clean(event), debug(event, nil, event.type), event)\n        ),\n        [affinity, discardCookies],\n      ]);\n      !navigator.sendBeacon(\n        VAR_URL,\n        new Blob([postData], {\n          // This content type avoids the overhead of the \"preflight\" request that is otherwise made by browsers in cross-domain scenarios.\n          // (application/x-www-form-urlencoded could also work).\n          type: \"text/plain\",\n        })\n      ) && err(ERR_POST_FAILED, events);\n    });\n  },\n  (terminating) => (terminating && callShutdownListeners(), undefined)\n);\n\nexport { commit };\n\n// Force posts will not happen before this is set.\nlet affinity: any | undefined;\nconst broadcastAffinity = registerSharedState(\n  \"affinity\",\n  () => affinity,\n  (value) => (affinity = value)\n);\nconst setAffinity = (value: any) => (\n  (affinity = value), broadcastAffinity(value)\n);\n\naddResponseListener(setAffinity);\n","import { F, T, addTerminationListener, del, hashSet, map } from \".\";\n\nexport type PendingActionHandle = (commit?: boolean) => void;\n\n// These will be flushed when / if the user leaves the page.\nconst activeHandles = hashSet<PendingActionHandle>();\n\nlet flushing = F;\n\nexport const noopAction: PendingActionHandle = () => {};\n\nexport const flushViewEndActions = () => {\n  flushing = T;\n  map(activeHandles, (item) => item(T));\n};\n\nexport const registerViewEndAction = (\n  action: (flushed: boolean) => void\n): PendingActionHandle => {\n  const handler = (commit = T) =>\n    del(activeHandles, handler) && commit && action(flushing);\n\n  activeHandles.add(handler);\n\n  return handler;\n};\n\naddTerminationListener(() => flushViewEndActions());\n","import type { UserAgentEvent } from \"@tailjs/types\";\nimport { window } from \"../lib\";\n\nexport const detectDeviceType = (): Pick<\n  UserAgentEvent,\n  \"deviceType\" | \"screen\"\n> => {\n  // Common thresholds based on https://yesviz.com/viewport/\n  const screen = window?.screen;\n  if (!screen) return {};\n\n  let { width: w, height: h, orientation: o } = screen; // Get's the resolution in logical (CSS) pixels.\n  const landscape = w < h;\n  const angle = o?.angle ?? window[\"orientation\"] ?? 0;\n  (angle === -90 || angle === 90) && ([w, h] = [h, w]);\n\n  return {\n    deviceType: w < 480 ? \"mobile\" : w <= 1024 ? \"tablet\" : \"desktop\",\n    screen: { dpr: window.devicePixelRatio, width: w, height: h, landscape },\n  };\n};\n","import { QUERY_DEVICE } from \"@constants\";\nimport {\n  HeartbeatEvent,\n  LocalID,\n  Timestamp,\n  UserAgentEvent,\n  UserInteractionEvent,\n  ViewEndedEvent,\n  ViewEvent,\n  ViewTimingEvent,\n  cast,\n  isViewEvent,\n} from \"@tailjs/types\";\nimport {\n  TrackerExtensionFactory,\n  detectDeviceType,\n  isChangeUserCommand,\n} from \"..\";\nimport {\n  F,\n  noopAction as NO_OP,\n  T,\n  addDependency,\n  assign,\n  debug,\n  del,\n  document,\n  eventSet,\n  forEach,\n  getViewportSize,\n  isForegroundTab,\n  isInternalUrl,\n  listen,\n  location,\n  map,\n  mark,\n  matchExHash,\n  navigator,\n  nextId,\n  nil,\n  now,\n  parseDomain,\n  parseParameters,\n  push,\n  registerSharedState,\n  registerViewEndAction,\n  replace,\n  session,\n  sharedQueue,\n  split,\n  timeout,\n  timer,\n  trackerConfig,\n  transpose,\n  undefined,\n  window,\n} from \"../lib\";\n\ntype TabInfo = [\n  id: LocalID,\n  created: Timestamp,\n  navigated: Timestamp,\n  views: number\n];\n\nlet currentViewEvent: ViewEvent | undefined;\n\nexport const getCurrentViewId = () => currentViewEvent?.clientId;\nconst [addViewChangedListener, viewChanged] = eventSet<[viewId: string]>();\nexport { addViewChangedListener };\n\nexport type ViewMessage = {\n  view?: { id: string; timing: UserInteractionEvent[\"timing\"] };\n  who?: LocalID;\n  vars?: [key: string, value: any, source: string][];\n};\n\nlet pushPopNavigation: ViewEvent[\"navigationType\"] | undefined;\n\nexport type ReferringViewData = [\n  viewId: LocalID,\n  relatedEventId: LocalID | undefined\n];\n\nconst referrers = sharedQueue<ReferringViewData>(\"ref\", 10000);\nexport const pushNavigationSource = (navigationEventId: LocalID) =>\n  referrers([currentViewEvent!.clientId, navigationEventId]);\n\nconst totalDuration = timer();\nconst visibleDuration = timer();\nconst interactiveDuration = timer();\n\nexport const getVisibleDuration = () => visibleDuration();\n\nconst [onFrame, callOnFrame] = eventSet<[frame: HTMLIFrameElement]>();\nexport { onFrame };\n\nconst knownFrames = new WeakSet<any>();\nconst frames = document.getElementsByTagName(\"iframe\");\n\nexport const context: TrackerExtensionFactory = {\n  id: \"context\",\n  setup(tracker) {\n    timeout(\n      () =>\n        forEach(\n          frames,\n          (frame) => mark(knownFrames, frame) && callOnFrame(frame)\n        ),\n      -1000\n    ).pulse();\n\n    let isNewTab = T;\n\n    let activations = 1;\n    let viewPosted = F; // Don't post heartbeats on hide before the view has been posted.\n\n    const tab = session<TabInfo>(\"t\", (current) => {\n      if ((isNewTab = !current)) {\n        return [nextId(), now(), now(), 0];\n      }\n      current[2] = now();\n      return current;\n    });\n    let firstTab = T;\n    registerSharedState(\n      \"first\",\n      () => F,\n      (first) => {\n        if (!first) {\n          firstTab = F;\n          currentViewEvent &&\n            del(currentViewEvent, [\"firstTab\", \"landingPage\"]);\n        }\n      }\n    );\n\n    let pendingViewEvent = NO_OP;\n    let pendingViewEndEvent = NO_OP;\n\n    let currentLocation: string | null = nil;\n    const postView = (force = F) => {\n      if (\n        matchExHash(\"\" + currentLocation, (currentLocation = location.href)) &&\n        !force\n      ) {\n        return;\n      }\n\n      pendingViewEvent();\n      pendingViewEndEvent();\n\n      totalDuration.reset();\n      visibleDuration.reset();\n      interactiveDuration.reset();\n\n      session<TabInfo>(\"t\", () => {\n        tab[2] = now();\n        ++tab[3];\n        return tab;\n      });\n\n      const { href, domain } = parseDomain(location.href) ?? {};\n      currentViewEvent = {\n        type: \"VIEW\",\n        timestamp: now(),\n        clientId: nextId(),\n        tab: tab[0],\n        href,\n        path: location.pathname,\n        hash: location.hash || undefined,\n        domain,\n        tabIndex: tab[3],\n        viewport: getViewportSize(),\n      };\n      viewChanged(currentViewEvent.clientId);\n\n      currentViewEvent.firstTab = firstTab;\n      firstTab && tab[3] === 1 && (currentViewEvent.landingPage = T);\n\n      // Query string\n      const trySplit = (s: string, sep: string, parts = split(s, sep)) =>\n        parts.length > 1 ? parts : nil;\n\n      const ps = parseParameters(replace(location.href, /^[^?]*\\??/, \"\"));\n      if (ps) {\n        const qs = (currentViewEvent!.queryString = transpose(ps, ([k, v]) => [\n          k.toLowerCase(),\n          v.length > 1\n            ? v\n            : trySplit(v[0], \"|\") ||\n              trySplit(v[0], \";\") ||\n              trySplit(v[0], \",\") ||\n              v,\n        ]));\n        map(\n          [\"source\", \"medium\", \"campaign\", \"term\", \"content\"],\n          (p, _) => ((currentViewEvent!.utm ??= {})[p] = qs[`utm_${p}`]?.[0])\n        );\n      }\n\n      !(currentViewEvent.navigationType = pushPopNavigation) &&\n        performance &&\n        map(\n          performance.getEntriesByType(\"navigation\"),\n          (entry: PerformanceNavigationTiming) => {\n            currentViewEvent!.redirects = entry.redirectCount;\n            currentViewEvent!.navigationType = replace(\n              entry.type,\n              /\\_/g,\n              \"-\"\n            ) as any;\n          }\n        );\n\n      pushPopNavigation = undefined;\n\n      if ((currentViewEvent.navigationType ??= \"navigate\") === \"navigate\") {\n        // Try find related event and parent tab context if any.\n        // And only if navigating (not back/forward/refresh)\n\n        if (isNewTab && isInternalUrl(document.referrer)) {\n          const referrer = referrers();\n\n          currentViewEvent.view = referrer?.[0];\n          currentViewEvent.relatedEventId = referrer?.[1];\n        }\n      }\n\n      // Referrer\n      const referrer = document.referrer || nil;\n      referrer &&\n        !isInternalUrl(referrer) &&\n        (currentViewEvent!.externalReferrer = {\n          href: referrer,\n          domain: parseDomain(referrer)?.domain,\n        });\n\n      viewPosted = F;\n      pendingViewEvent = registerViewEndAction(\n        () => (\n          (viewPosted = T),\n          push(tracker, currentViewEvent),\n          currentViewEvent?.firstTab && push(tracker, { flush: T })\n        )\n      );\n      pendingViewEndEvent = registerViewEndAction(() => {\n        push(\n          tracker,\n\n          { type: \"VIEW_ENDED\", timing: {} } as ViewEndedEvent,\n\n          {\n            set: { view: undefined },\n          }\n        );\n        isNewTab = F;\n      });\n\n      push(tracker, {\n        get: {\n          view: (view: any) => (currentViewEvent!.definition = view),\n          rendered: () => {\n            // Allow some extra time for gossiping to figure out if we are the only tab.\n            // This will also ensure that the view is set on the event if both `view` and `rendered` are set in the same `set` command.\n            timeout(pendingViewEvent, 100);\n          },\n        },\n      });\n\n      tracker.push({\n        get: {\n          [QUERY_DEVICE]: (value) => {\n            if (!value || !isForegroundTab()) return;\n            push(\n              tracker,\n              cast<UserAgentEvent>({\n                type: \"USER_AGENT\",\n                hasTouch: navigator.maxTouchPoints > 0,\n                userAgent: navigator.userAgent,\n                view: currentViewEvent?.clientId,\n                languages: map(\n                  navigator.languages,\n                  (id, i, parts = split(id, \"-\")) =>\n                    cast<UserAgentEvent[\"languages\"]>({\n                      id,\n                      language: parts[0],\n                      region: parts[1],\n                      primary: i === 0,\n                      preference: i + 1,\n                    })\n                ),\n                timezone: {\n                  iana: Intl.DateTimeFormat().resolvedOptions().timeZone,\n                  offset: new Date().getTimezoneOffset(),\n                },\n                ...detectDeviceType(),\n              })\n            );\n          },\n        },\n      });\n    };\n\n    const interactiveTimeout = timeout();\n    listen(\n      document,\n      [\"pointermove\", \"scroll\", \"pointerdown\", \"keydown\"],\n      () => {\n        interactiveDuration(T);\n        interactiveTimeout(() => interactiveDuration(F), 10000);\n      }\n    );\n\n    listen(document, \"visibilitychange\", () => {\n      if (document.visibilityState === \"hidden\") {\n        visibleDuration(F);\n        interactiveDuration(F);\n      } else {\n        visibleDuration(T);\n        ++activations;\n      }\n    });\n\n    listen(\n      window,\n      \"popstate\",\n      () => ((pushPopNavigation = \"back-forward\"), postView())\n    );\n    map([\"push\", \"replace\"], (name) => {\n      const inner = history[(name += \"State\")];\n      history[name] = (...args: any) => {\n        inner.apply(history, args);\n        pushPopNavigation = \"navigate\";\n        postView();\n      };\n    });\n\n    postView();\n\n    const heartbeat = timeout();\n    const resetHeartbeat = () =>\n      viewPosted &&\n      trackerConfig.heartbeatFrequency > 0 &&\n      heartbeat(\n        () =>\n          isForegroundTab() &&\n          tracker.push(cast<HeartbeatEvent>({ type: \"HEARTBEAT\", timing: {} })),\n        -trackerConfig.heartbeatFrequency\n      );\n\n    resetHeartbeat();\n\n    return {\n      processCommand(command) {\n        if (isChangeUserCommand(command)) {\n          tracker.push(\n            command.username\n              ? { type: \"LOGIN\", username: command.username }\n              : { type: \"LOGOUT\" }\n          );\n          return T;\n        }\n        return F;\n      },\n      decorate(event) {\n        resetHeartbeat();\n\n        if (!currentViewEvent || isViewEvent(event)) return;\n        const view = currentViewEvent?.clientId,\n          ctx = {\n            view,\n            timing: (event as ViewTimingEvent)?.timing && {\n              activations,\n              totalTime: totalDuration(),\n              visibleTime: visibleDuration(),\n              interactiveTime: interactiveDuration(),\n            },\n          };\n\n        ctx && (assign(event, ctx), addDependency(event, currentViewEvent));\n      },\n    };\n  },\n};\n","import {\n  AnchorNavigationEvent,\n  CartUpdatedEvent,\n  ComponentClickEvent,\n  ConfiguredComponent,\n  NavigationEvent,\n  UserInteractionEvent,\n  cast,\n  isViewEndedEvent,\n} from \"@tailjs/types\";\nimport {\n  TrackerExtensionFactory,\n  getComponentContext,\n  onFrame,\n  pushNavigationSource,\n  tryGetCartEventData,\n} from \"..\";\n\nimport { CONTEXT_MENU_COOKIE } from \"@constants\";\nimport type { Nullish } from \"@tailjs/util\";\nimport { parseActivationTags } from \"..\";\nimport {\n  F,\n  MNT_URL,\n  T,\n  any,\n  attr,\n  attrl,\n  clear,\n  cookies,\n  del,\n  document,\n  encode,\n  equals,\n  forAncestorsOrSelf,\n  getBoundaryData,\n  getScreenPos,\n  getViewport,\n  isInternalUrl,\n  keys,\n  listen,\n  location,\n  map,\n  mapUrl,\n  matchExHash,\n  navigator,\n  nextId,\n  nil,\n  noopAction,\n  obj,\n  parseDomain,\n  push,\n  registerViewEndAction,\n  tagName,\n  timeout,\n  trackerConfig,\n  trackerFlag,\n  tryCatch,\n  window,\n} from \"../lib\";\n\nconst isLinkElement = (\n  el: Element,\n  href: any = tagName(el) === \"A\" && attr(el, \"href\")\n): el is HTMLAnchorElement =>\n  href && href != \"#\" && !href.startsWith(\"javascript:\");\n\nconst isClickable = (\n  el: Element,\n  t = tagName(el),\n  attr = trackerFlag(el, \"button\")\n): el is HTMLElement =>\n  attr !== F &&\n  (equals(t, \"A\", \"BUTTON\") ||\n    (t === \"INPUT\" && equals(attrl(el, \"type\"), \"button\", \"submit\")) ||\n    attr === T);\n\nfunction getElementLabel(el: Element | EventTarget | null, container: Element) {\n  let info: Pick<UserInteractionEvent, \"element\"> | undefined;\n  forAncestorsOrSelf(el ?? container, (el) =>\n    equals(tagName(el), \"IMG\") || el === container\n      ? ((info = {\n          element: {\n            tagName: el.tagName,\n            text:\n              attr(el, \"title\") ||\n              attr(el, \"alt\") ||\n              (el as HTMLElement).innerText?.trim().substring(0, 100) ||\n              undefined,\n          },\n        }),\n        F)\n      : T\n  );\n  return info;\n}\nexport const userInteraction: TrackerExtensionFactory = {\n  id: \"navigation\",\n\n  setup(tracker) {\n    const pollContextCookie = timeout();\n\n    // There can be all kinds of fishy navigation logic happening, so it is not enough just to look at link (<A>) clicks.\n    // Hence, when navigation occurs (in the current tab), we do not send the event before we have an VIEW_END.\n    // We rely on that the logic for VIEW_END takes care all the different ways to navigate (history.push etc.) so this is where we know that navigation happened for sure.\n    let pendingNavigationEvent = noopAction;\n\n    const stripPositions = <T = any>(el: any, hitTest: boolean): T =>\n      hitTest\n        ? el\n        : (map(keys(el), (key) =>\n            key === \"rect\" ||\n            //key === \"pos\"  Changed so pos is always included.\n            key === \"viewport\"\n              ? del(el, key)\n              : obj(el[key]) &&\n                map(el[key], (item) => stripPositions(item, hitTest))\n          ),\n          el);\n    const trackDocument = (document: Document) => {\n      listen(\n        document,\n        [\"click\", \"contextmenu\", \"auxclick\"],\n        (ev: MouseEvent) => {\n          // Cancel whatever we might be waiting for.\n          pendingNavigationEvent?.(F);\n\n          let trackClicks: boolean | Nullish;\n          let trackRegion: boolean | Nullish;\n          let clickableElement: HTMLElement | null = nil! as HTMLElement; // Typescript insists this is never?\n\n          let nav = F;\n\n          forAncestorsOrSelf<boolean>(ev.target, (el) => {\n            clickableElement ??= isClickable(el) ? el : nil;\n            nav = nav || tagName(el) === \"NAV\";\n\n            let cmp: ConfiguredComponent | ConfiguredComponent[] | Nullish;\n\n            trackClicks ??=\n              trackerFlag(el, \"clicks\", T, (data) => data.track?.clicks) ??\n              ((cmp = getBoundaryData(el)?.component) &&\n                any(cmp, (cmp) => cmp.track?.clicks !== F));\n            trackRegion ??=\n              trackerFlag(el, \"region\", T, (data) => data.track?.region) ??\n              ((cmp = getBoundaryData(el)?.component) &&\n                any(cmp, (cmp) => cmp.track?.region));\n          });\n\n          if (!clickableElement) {\n            return;\n          }\n          const componentContext = getComponentContext(clickableElement);\n          const tags = parseActivationTags(clickableElement);\n          trackClicks ??= !nav;\n          trackRegion ??= T;\n\n          const sharedEventProperties = {\n            ...(trackRegion\n              ? {\n                  pos: getScreenPos(clickableElement, ev),\n                  viewport: getViewport(),\n                }\n              : nil),\n            ...getElementLabel(ev.target, clickableElement),\n            ...componentContext,\n            ...tags,\n            timing: {},\n          };\n\n          if (isLinkElement(clickableElement!)) {\n            const external = clickableElement.hostname !== location.hostname;\n            const { domain, href } = parseDomain(clickableElement.href);\n            if (\n              clickableElement.host === location.host &&\n              clickableElement.pathname === location.pathname &&\n              clickableElement.search === location.search\n            ) {\n              if (clickableElement.hash === \"#\") {\n                // Don't care about that one.\n                return;\n              }\n              if (clickableElement.hash !== location.hash) {\n                push(\n                  tracker,\n                  cast<AnchorNavigationEvent>({\n                    type: \"ANCHOR_NAVIGATION\",\n                    anchor: clickableElement.hash,\n                    ...sharedEventProperties,\n                  })\n                );\n              }\n              return;\n            }\n\n            const navigationEvent: NavigationEvent = cast<NavigationEvent>({\n              clientId: nextId(),\n              type: \"NAVIGATION\",\n              href: external ? clickableElement.href : href,\n              external,\n              domain,\n              self: T,\n              anchor: clickableElement.hash,\n              ...sharedEventProperties,\n            });\n\n            if (ev.type === \"contextmenu\") {\n              const referrerConsumed = pushNavigationSource(\n                navigationEvent.clientId\n              );\n\n              const currentUrl = clickableElement.href;\n              const internalUrl = isInternalUrl(currentUrl);\n\n              if (!internalUrl) {\n                if (!trackerConfig.captureContextMenu) return;\n                clickableElement.href = mapUrl(\n                  MNT_URL,\n                  \"=\",\n                  encode(currentUrl)\n                );\n                tryCatch(\n                  () =>\n                    navigator.userActivation?.isActive &&\n                    navigator.clipboard.writeText(currentUrl)\n                );\n              }\n\n              const flag = Date.now();\n              cookies(CONTEXT_MENU_COOKIE, flag, 11000);\n              pollContextCookie(() => {\n                (clickableElement as HTMLAnchorElement).href = currentUrl;\n                if (\n                  !referrerConsumed() ||\n                  +cookies(CONTEXT_MENU_COOKIE)! === flag + 1\n                ) {\n                  cookies(CONTEXT_MENU_COOKIE, nil);\n                  navigationEvent.self = F;\n                  push(tracker, navigationEvent);\n                  clear(pollContextCookie);\n                }\n              }, -100);\n\n              let unbindAll = listen(\n                document,\n                [\"keydown\", \"keyup\", \"visibilitychange\", \"pointermove\"],\n                () =>\n                  unbindAll() &&\n                  clear(pollContextCookie, 10000, () =>\n                    cookies(CONTEXT_MENU_COOKIE, \"\")\n                  )\n              );\n            } else if (ev.button <= 1) {\n              if (\n                ev.button === 1 || //Middle-click: new tab.\n                ev.ctrlKey || // New tab\n                ev.shiftKey || // New window\n                ev.altKey || // Download\n                attr(clickableElement, \"target\") !== window.name\n              ) {\n                pushNavigationSource(navigationEvent.clientId);\n                navigationEvent.self = F;\n                // Fire immediately, we are staying on the page.\n                push(tracker, navigationEvent);\n                return;\n              } else if (!matchExHash(location.href, clickableElement.href)) {\n                navigationEvent.exit = navigationEvent.external;\n                // No \"real\" navigation will happen if it is only the hash changing.\n                pushNavigationSource(navigationEvent.clientId);\n              }\n\n              // If it so happened that navigation happened we will send it on VIEW_END.\n              pendingNavigationEvent = registerViewEndAction(() =>\n                push(tracker, navigationEvent)\n              );\n            }\n            return;\n          }\n\n          const cart = tryGetCartEventData(ev.target as Element);\n          (cart || trackClicks) &&\n            push(\n              tracker,\n              cart\n                ? cast<CartUpdatedEvent>({\n                    type: \"CART_UPDATED\",\n                    ...sharedEventProperties,\n                    ...cart,\n                  })\n                : cast<ComponentClickEvent>({\n                    type: \"COMPONENT_CLICK\",\n                    ...sharedEventProperties,\n                  })\n            );\n          return;\n        }\n      );\n    };\n\n    trackDocument(document);\n    onFrame(\n      (frame) => frame.contentDocument && trackDocument(frame.contentDocument)\n    );\n\n    return {\n      decorate(eventData) {\n        if (isViewEndedEvent(eventData)) {\n          pendingNavigationEvent(T);\n        }\n      },\n    };\n  },\n};\n","import {\n  type CartAction,\n  type CartEventData,\n  type CartUpdatedEvent,\n  type OrderEvent,\n} from \"@tailjs/types\";\nimport type { Nullish } from \"@tailjs/util\";\nimport { TrackerExtensionFactory, isCartCommand, isOrderCommand } from \"..\";\nimport {\n  F,\n  T,\n  equals,\n  forAncestorsOrSelf,\n  getBoundaryData,\n  item,\n  nil,\n  obj,\n  push,\n  str,\n  trackerProperty,\n  undefined,\n} from \"../lib\";\n\nexport const parseCartEventData = (\n  data: boolean | string | CartEventData | Nullish\n): CartEventData | undefined => (\n  data == nil ? undefined : (data === T || data === \"\") && (data = \"add\"),\n  str(data) && equals(data, \"add\", \"remove\", \"update\", \"clear\")\n    ? { action: data as CartAction }\n    : obj(data)\n    ? data\n    : undefined\n);\n\nfunction normalizeCartEventData(data: CartEventData | Nullish) {\n  if (!data) return undefined;\n\n  if (data.units != nil && equals(data.action, nil, \"add\", \"remove\")) {\n    if (data.units === 0) return undefined;\n    data.action = data.units > 0 ? \"add\" : \"remove\";\n  }\n  return data;\n}\n\nexport function tryGetCartEventData(sourceElement: Element) {\n  // Find cart. Look for cart attributes and/or data until the first content is met.\n  let contextCart: CartEventData | Nullish;\n  forAncestorsOrSelf(\n    sourceElement,\n    (el, r) =>\n      !!(contextCart ??= parseCartEventData(\n        getBoundaryData(el)?.cart ?? trackerProperty(el, \"cart\")\n      )) &&\n      !contextCart.item &&\n      (contextCart.item = item(getBoundaryData(el)?.content, -1)) &&\n      r(contextCart)\n  );\n\n  return normalizeCartEventData(contextCart);\n}\n\nexport const commerce: TrackerExtensionFactory = {\n  id: \"cart\",\n  setup(tracker) {\n    return {\n      processCommand(command) {\n        if (isCartCommand(command)) {\n          let cart = command.cart;\n          cart === \"clear\"\n            ? push(tracker, {\n                type: \"CART_UPDATED\",\n                action: \"clear\",\n              } as CartUpdatedEvent)\n            : (cart = normalizeCartEventData(cart)!) &&\n              push(tracker, {\n                ...cart,\n                type: \"CART_UPDATED\",\n              } as CartUpdatedEvent);\n\n          return T;\n        }\n        if (isOrderCommand(command)) {\n          push(tracker, {\n            type: \"ORDER\",\n            ...command.order,\n          } as OrderEvent);\n\n          return T;\n        }\n        return F;\n      },\n    };\n  },\n};\n","import {\n  ImpressionEvent,\n  ImpressionSummaryEvent,\n  cast,\n  type ActivatedComponent,\n  type ActivatedContent,\n  type ConfiguredComponent,\n  type Rectangle,\n  type UserInteractionEvent,\n} from \"@tailjs/types\";\nimport {\n  BoundaryCommand,\n  BoundaryData,\n  TrackerExtensionFactory,\n  getVisibleDuration,\n  isDataBoundaryCommand,\n  isScanComponentsCommand,\n} from \"..\";\nimport {\n  F,\n  NodeWithParentElement,\n  PendingActionHandle,\n  T,\n  any,\n  boundaryData,\n  clear,\n  concat,\n  del,\n  filter,\n  flatMap,\n  forAncestorsOrSelf,\n  forEach,\n  get,\n  getRect,\n  getScreenPos,\n  getViewport,\n  join,\n  map,\n  max,\n  nil,\n  parseTags,\n  push,\n  registerViewEndAction,\n  scanAttributes,\n  set,\n  size,\n  str,\n  timeout,\n  timer,\n  trackerConfig,\n  trackerFlag,\n  trackerProperty,\n  undefined,\n  unshift,\n} from \"../lib\";\nexport type ActivatedDomComponent = ConfiguredComponent & ActivatedComponent;\n\nexport const componentDomConfiguration = Symbol(\"DOM configuration\");\n\nexport const parseActivationTags = (el: Element) =>\n  parseTags(el, undefined, (el) => map(get(boundaryData, el)?.tags));\n\nconst hasComponentOrContent = (boundary?: BoundaryData | null) =>\n  boundary?.component || boundary?.content;\n\nlet entry: BoundaryData | undefined;\nexport const parseBoundaryTags = (el: Element) =>\n  parseTags(\n    el,\n    (ancestor) =>\n      ancestor !== el && !!hasComponentOrContent(get(boundaryData, ancestor)),\n    (el) =>\n      (entry = get(boundaryData, el)) &&\n      concat(\n        flatMap([entry.component, entry.content], (item) =>\n          flatMap(item, (item) => map(item.tags, F))\n        ),\n        entry.tags\n      )\n  );\n\nlet content: ActivatedContent[] | undefined;\nconst stripRects = (\n  component: ActivatedDomComponent,\n  keep?: boolean\n): ActivatedDomComponent =>\n  keep\n    ? component\n    : {\n        ...component,\n        rect: undefined,\n        content:\n          (content = component.content) &&\n          map(content, (content) => ({ ...content, rect: undefined })),\n      };\n\nconst enum IncludeState {\n  Secondary = 0,\n  Primary = 1,\n  Promoted = 2,\n}\n\nconst setContext = timeout();\n\nexport const getComponentContext = (\n  el: NodeWithParentElement,\n  directOnly = F\n) => {\n  clear(setContext);\n\n  let collectedContent: ActivatedContent[] = [];\n\n  type Area = {} & string; // For clarity.\n  let collected: (ActivatedDomComponent | Area)[] = [];\n\n  let includeState = IncludeState.Secondary;\n  let rect: Rectangle | undefined;\n  forAncestorsOrSelf(el, (el) => {\n    const entry = get(boundaryData, el);\n    if (!entry) {\n      return;\n    }\n\n    if (hasComponentOrContent(entry)) {\n      const components = filter(\n        entry.component,\n        (entry) =>\n          includeState === IncludeState.Secondary ||\n          (!directOnly &&\n            ((includeState === IncludeState.Primary &&\n              entry.track?.secondary !== T) ||\n              entry.track?.promote))\n      );\n\n      rect =\n        (any(components, (item) => item.track?.region) && getRect(el)) ||\n        undefined;\n      const tags = parseBoundaryTags(el);\n      entry.content &&\n        unshift(\n          collectedContent,\n          ...map(entry.content, (item) => ({\n            ...item,\n            rect,\n            ...tags,\n          }))\n        );\n\n      components.length &&\n        (unshift(\n          collected,\n          ...map(\n            components,\n            (item) => (\n              (includeState = max(\n                includeState,\n                item.track?.secondary // INV: Secondary components are only included here if we did not have any components from a child element.\n                  ? IncludeState.Primary\n                  : IncludeState.Promoted\n              )),\n              stripRects(\n                {\n                  ...item,\n                  content: collectedContent,\n                  rect,\n                  ...tags,\n                },\n                !!rect\n              )\n            )\n          )\n        ),\n        (collectedContent = []));\n    }\n\n    const area = entry.area || trackerProperty(el, \"area\");\n    area && unshift(collected, ...map(area));\n  });\n\n  let areaPath: string[] | undefined;\n  let components: ActivatedComponent[] | undefined;\n\n  if (collectedContent.length) {\n    // Content without a contaning component is gathered in an ID-less component.\n    push(collected, stripRects({ id: \"\", rect, content: collectedContent }));\n  }\n\n  forEach(collected, (item) => {\n    if (str(item)) {\n      push((areaPath ??= []), item);\n    } else {\n      item.area ??= join(areaPath, \"/\");\n      unshift((components ??= []), item);\n    }\n  });\n\n  return components || areaPath\n    ? { components: components, area: join(areaPath, \"/\") }\n    : undefined;\n};\n\nconst intersectionHandler = Symbol();\nexport const components: TrackerExtensionFactory = {\n  id: \"components\",\n  setup(tracker) {\n    const observer = new IntersectionObserver(\n      (els) =>\n        forEach(\n          els,\n          ({ target, isIntersecting, boundingClientRect, intersectionRatio }) =>\n            target[intersectionHandler]?.(\n              isIntersecting,\n              boundingClientRect,\n              intersectionRatio\n            )\n        ),\n      // Low thresholds used to be able to handle components larger than viewports.\n      { threshold: [0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.75] }\n    );\n\n    function registerComponent({ boundary: el, ...command }: BoundaryCommand) {\n      let update =\n        \"add\" in command\n          ? (current: BoundaryData) =>\n              cast<BoundaryData>({\n                ...current,\n                component: concat(current?.component, command.component),\n                content: concat(current?.content, command.content),\n                area: command?.area ?? current?.area,\n                tags: concat(current?.tags, command.tags),\n                cart: command.cart ?? current?.cart,\n                track: command.track ?? current?.track,\n              })\n          : command[\"update\"];\n\n      set(boundaryData, el, update ?? command);\n\n      let components: ConfiguredComponent[] | undefined;\n      if (\n        (components = filter(\n          get(boundaryData, el)?.component,\n          (cmp) =>\n            // Impression settings from the DOM/CSS are ignorred for secondary and inferred components (performance thing)\n            cmp!.track?.impressions ||\n            (cmp.track?.secondary ?? cmp.inferred) !== T\n        ))\n      ) {\n        if (!size(components)) {\n          return;\n        }\n\n        let visible = F;\n        let impressions = 0;\n        let event: PendingActionHandle | null = nil;\n        let fold: number;\n        const captureState = timeout();\n        const t = timer(() => getVisibleDuration(), F);\n\n        el[intersectionHandler] = (\n          intersecting: boolean,\n          rect: DOMRectReadOnly,\n          ratio: number\n        ) => {\n          intersecting =\n            ratio >= 0.75 ||\n            (rect.top < (fold = window.innerHeight / 2) && rect.bottom > fold);\n\n          t(intersecting);\n          if (visible !== (visible = intersecting)) {\n            //el[\"style\"].border = visible ? \"2px solid blue\" : \"\";\n            if (visible) {\n              captureState(() => {\n                ++impressions;\n                if (!event) {\n                  const events = filter(\n                    map(\n                      components,\n                      (cmp) =>\n                        ((cmp!.track?.impressions ||\n                          trackerFlag(\n                            el,\n                            \"impressions\",\n                            T,\n                            (data) => data.track?.impressions\n                          )) &&\n                          cast<ImpressionEvent>({\n                            type: \"IMPRESSION\",\n                            pos: getScreenPos(el),\n                            viewport: getViewport(),\n                            ...getComponentContext(el, T),\n                          })) ||\n                        nil\n                    )\n                  );\n                  push(tracker, ...events);\n\n                  event = registerViewEndAction(() =>\n                    push(\n                      tracker,\n                      ...map(\n                        events,\n                        (ev) =>\n                          ({\n                            type: \"IMPRESSION_SUMMARY\",\n                            relatedEventId: ev.clientId,\n                            duration: t(),\n                            impressions: impressions - 1,\n                          } as ImpressionSummaryEvent)\n                      )\n                    )\n                  );\n                }\n              }, trackerConfig.impressionThreshold);\n            } else {\n              clear(captureState); // Not visible, clear timeout.\n            }\n          }\n          !el.isConnected && (event?.(), (event = nil));\n        };\n        observer.observe(el);\n      }\n    }\n\n    return {\n      decorate(eventData) {\n        // Strip tracking configuration.\n        forEach((eventData as UserInteractionEvent).components, (component) =>\n          del(component as any, \"track\")\n        );\n      },\n      processCommand(cmd) {\n        return isDataBoundaryCommand(cmd)\n          ? (registerComponent(cmd), T)\n          : isScanComponentsCommand(cmd)\n          ? (map(\n              scanAttributes(cmd.scan.attribute, cmd.scan.components),\n              registerComponent\n            ),\n            T)\n          : F;\n      },\n    };\n  },\n};\n","import { QUERY_DEVICE } from \"@constants\";\nimport { TrackedEvent, isTrackedEvent } from \"@tailjs/types\";\nimport type { Nullish } from \"@tailjs/util\";\nimport {\n  Listener,\n  Tracker,\n  TrackerCommand,\n  TrackerConfiguration,\n  TrackerExtension,\n  defaultExtensions,\n  isExtensionCommand,\n  isFlushCommand,\n  isGetCommand,\n  isListenerCommand,\n  isSetCommand,\n  isTagAttributesCommand,\n  isToggleCommand,\n  isTrackerAvailableCommand,\n} from \".\";\nimport {\n  ERR_INTERNAL_ERROR,\n  ERR_INVALID_COMMAND,\n  F,\n  T,\n  addGlobalStateResolvedListener,\n  addQueuePostListener,\n  addResponseListener,\n  array,\n  assign,\n  commit,\n  define,\n  del,\n  enqueueEvent,\n  entries,\n  err,\n  filter,\n  fun,\n  globalStateResolved,\n  httpDecode,\n  isTracker,\n  map,\n  mapUrl,\n  nextId,\n  nil,\n  now,\n  push,\n  registerSharedState,\n  setStorageKey,\n  size,\n  sort,\n  splice,\n  startupComplete,\n  str,\n  trackerConfig,\n  tryCatch,\n  variables,\n  window,\n} from \"./lib\";\n\nexport let tracker: Tracker;\nexport const initializeTracker = (config: TrackerConfiguration | string) => {\n  if (tracker) return tracker;\n\n  str(config) && (config = httpDecode(config)!);\n\n  // Make sure the configuration has all parameters set to valid values.\n  map(\n    [\"vars\", \"hub\"],\n    (p) => !fun(config[p]) && (config[p] = mapUrl(config[p]))\n  );\n\n  assign(trackerConfig, config);\n  setStorageKey(del(trackerConfig, \"clientKey\"));\n  const apiKey = del(trackerConfig, \"apiKey\");\n\n  const queuedCommands = window[trackerConfig.name] ?? [];\n  if (!array(queuedCommands)) {\n    err(\n      `The global variable for the tracker \"${trackerConfig.name}\" is used for something else than an array of queued commands.`\n    );\n    return;\n  }\n\n  // Extensions / listeners\n  const extensions: [number, TrackerExtension][] = [];\n  let listeners: Listener[] = [];\n  // Extensions may post commands when constructed and while the tracker is initializing\n\n  const callListeners = (event: string, ...args: any[]) => {\n    let keep = T;\n    listeners = filter(listeners, (listener) =>\n      tryCatch(\n        () => (\n          listener[event]?.(...args, {\n            tracker: tracker,\n            unsubscribe: () => (keep = F),\n          }),\n          keep // Will be set synchronously in the unsubscribe handler before this value is returned.\n        )\n      )\n    );\n  };\n  addQueuePostListener((events) => callListeners(\"post\", events));\n  const pendingStateCommands: TrackerCommand[] = [];\n  addGlobalStateResolvedListener(\n    () => pendingStateCommands.length && push(tracker, ...pendingStateCommands)\n  );\n\n  // Variables\n\n  const localVariables = Object.fromEntries(\n    map(\n      [\"view\", \"tags\", \"rendered\", \"loaded\", \"scripts\", QUERY_DEVICE, \"mufti\"],\n      (key) => [key, T]\n    )\n  );\n\n  let publicVariables: [string, string][];\n  const [getVars, setVars] = variables(\n    tracker,\n    (kvs) =>\n      size((publicVariables = filter(kvs, ([key]) => !localVariables[key]))) &&\n      updateVariables(publicVariables)\n  );\n  addResponseListener((_, variables) => setVars(variables));\n\n  const updateVariables = registerSharedState(\n    \"vars\",\n    () =>\n      map(\n        filter(entries(getVars()), ([key]) => !localVariables[key]),\n        ([key, value]) => [key, value] as const\n      ),\n    (vars) => vars && setVars(vars, T)\n  );\n\n  // Main\n\n  let mainArgs: TrackerCommand[] | null = nil;\n  let currentArg = 0;\n  let insertArgs = F;\n\n  define(window, {\n    [trackerConfig.name]: [\n      (tracker = define(\n        {},\n        {\n          id: [nextId()],\n          push: [\n            (...commands: TrackerCommand[]) => {\n              if (!mainArgs && apiKey) {\n                if (commands[0] !== apiKey) {\n                  throw new Error(\"Invalid API key.\");\n                }\n                commands.splice(0, 1);\n              }\n\n              if (!commands.length) {\n                return;\n              }\n\n              commands = commands.flatMap(\n                (command) => (\n                  !command\n                    ? command\n                    : typeof command === \"string\" &&\n                      (command = httpDecode<TrackerCommand>(command)),\n                  array(command) ? command : [command]\n                )\n              );\n\n              let flush = F; // // Flush after these commands, optionally without waiting for other requests to finish (because the page is unloading and we have no better option even though it may split sessions.)\n\n              commands = filter(commands, (command) => {\n                if (!command) return F;\n\n                if (isTagAttributesCommand(command)) {\n                  trackerConfig.tags = assign(\n                    {},\n                    trackerConfig.tags,\n                    command.tagAttributes\n                  );\n                } else if (isToggleCommand(command)) {\n                  trackerConfig.disabled = command.disable;\n                  return F;\n                } else if (isFlushCommand(command)) {\n                  flush = T;\n                  return F;\n                } else if (isTrackerAvailableCommand(command)) {\n                  command(tracker);\n                  return F;\n                }\n                if (\n                  !globalStateResolved &&\n                  !isListenerCommand(command) &&\n                  !isExtensionCommand(command)\n                ) {\n                  pendingStateCommands.push(command);\n                  return F;\n                }\n                // #endregion\n                return T;\n              });\n\n              if (!commands.length && !flush) {\n                return;\n              }\n\n              const getCommandRank = (cmd: TrackerCommand) =>\n                isExtensionCommand(cmd)\n                  ? -100\n                  : isListenerCommand(cmd)\n                  ? -50\n                  : isSetCommand(cmd)\n                  ? -10\n                  : isTrackedEvent(cmd)\n                  ? 90\n                  : 0;\n\n              // Put events last to allow listeners and interceptors from the same batch to work on them.\n              // Sets come before gets to avoid unnecessary waiting\n              // Extensions then listeners are first so they can evaluate the rest.\n              const expanded: TrackerCommand[] = sort(commands, getCommandRank);\n\n              // Allow nested calls to tracker.push from listerners and interceptors. Insert commands in the currently processed main batch.\n              if (\n                mainArgs &&\n                splice(\n                  mainArgs,\n                  insertArgs ? currentArg + 1 : mainArgs.length,\n                  0,\n                  ...expanded\n                )\n              )\n                return;\n\n              mainArgs = expanded;\n\n              for (currentArg = 0; currentArg < mainArgs.length; currentArg++) {\n                if (!mainArgs[currentArg]) continue;\n                tryCatch(\n                  () => {\n                    const command = mainArgs![currentArg];\n                    callListeners(\"command\", command);\n                    insertArgs = F;\n                    if (isTrackedEvent(command)) {\n                      command.timestamp ??= now();\n\n                      insertArgs = T;\n                      let skip = F;\n                      map(extensions, ([, extension], i) => {\n                        if (\n                          skip ||\n                          extension.decorate?.(command as TrackedEvent) === F\n                        ) {\n                          skip = T;\n                        }\n                      });\n\n                      if (skip) {\n                        return; // Skip event and process next command.\n                      }\n\n                      enqueueEvent(command);\n                    } else if (isGetCommand(command)) {\n                      getVars(command.get, command.timeout);\n                    } else if (isSetCommand(command)) {\n                      setVars(command.set);\n                      map(entries(command.set), ([key, value]) =>\n                        callListeners(\"set\", key, value)\n                      );\n                    } else if (isListenerCommand(command)) {\n                      push(listeners, command.listener);\n                    } else if (isExtensionCommand(command)) {\n                      let extension: TrackerExtension | Nullish;\n                      if (\n                        (extension = tryCatch(\n                          () => command.extension.setup(tracker),\n                          (e) => err(nil, command.extension, e)\n                        ))\n                      ) {\n                        push(extensions, [command.priority ?? 100, extension]);\n                        sort(extensions, ([priority]) => priority);\n                      }\n                    } else if (isTrackerAvailableCommand(command)) {\n                      command(tracker); // Variables have already been loaded once.\n                    } else {\n                      let success = F;\n                      for (const [, extension] of extensions) {\n                        if (\n                          (success = extension.processCommand?.(command) ?? F)\n                        ) {\n                          break;\n                        }\n                      }\n                      !success && err(ERR_INVALID_COMMAND, command);\n                    }\n                  },\n                  (e) => err(ERR_INTERNAL_ERROR, nil, e)\n                );\n              }\n\n              mainArgs = nil;\n              if (flush) {\n                commit();\n              }\n            },\n          ],\n          [isTracker]: [T],\n        }\n      ) as any),\n    ],\n  });\n\n  startupComplete();\n\n  push(\n    tracker,\n    { set: { loaded: T } },\n    ...map(defaultExtensions, (extension) => ({ extension })),\n    ...queuedCommands\n  );\n\n  return tracker;\n};\n","import type { Component, ExternalReference } from \"@tailjs/types\";\nimport {\n  F,\n  T,\n  attr,\n  document,\n  get,\n  hashSet,\n  map,\n  nil,\n  parseInt,\n  push,\n  set,\n  split,\n  str,\n} from \".\";\nimport type { BoundaryCommand } from \"..\";\n\ntype MappedComponent = [\n  command: {\n    component?: Component;\n    content?: ExternalReference;\n    area?: string;\n  },\n  elements: HTMLElement[]\n];\nexport function scanAttributes(\n  attributeName: string,\n  references: MappedComponent[0][]\n): BoundaryCommand[] {\n  if (!references) return [];\n  const commands: BoundaryCommand[] = [];\n\n  const seen = hashSet<any>();\n  document.querySelectorAll(`[${attributeName}]`).forEach((el) => {\n    if (get(seen, el)) {\n      return;\n    }\n\n    const stack: any[] = [];\n\n    while (attr(el, attributeName) != nil) {\n      set(seen, el);\n      const delta = split(attr(el, attributeName)!, \"|\");\n      attr(el, attributeName, nil);\n      for (let i = 0; i < delta.length; i++) {\n        let item: any = delta[i];\n        if (item === \"\") {\n          continue; // If the attribute starts with \"|\" it means \"keep stack\". Splitting the array on \"|\" will give an empty item.\n        }\n        const number = item === \"-\" ? -1 : parseInt(str(item, F) ?? \"\", 36);\n        if (number < 0) {\n          stack.length += number;\n          continue;\n        } else if (i === 0) {\n          stack.length = 0; // The first item has an value to replace the stack since not preceded by neither \"|\" nor an negative number (pop).\n        }\n\n        if (isNaN(number) && /^[\"\\[{]/.test(item)) {\n          // Poor man's parser. If the JSON contains '|'s keep going until it works.\n          let json = \"\";\n          for (; i < delta.length; i++) {\n            try {\n              item = JSON.parse((json += delta[i]));\n              break;\n            } catch (e) {}\n          }\n        }\n\n        if (number >= 0 && references[number]) {\n          item = references[number];\n        }\n        stack.push(item);\n      }\n      push(\n        commands,\n        ...map(stack, (data) => ({ add: T, ...data, boundary: el }))\n      );\n      const next = el.nextElementSibling!; // Ignore TS null error.\n      if (el.tagName === \"WBR\") {\n        el.parentNode?.removeChild(el);\n      }\n      el = next;\n    }\n  });\n\n  return commands;\n}\n","import { ScrollEvent, cast } from \"@tailjs/types\";\nimport { addViewChangedListener, type TrackerExtensionFactory } from \"..\";\nimport {\n  T,\n  defer,\n  listen,\n  map,\n  push,\n  relativeScrollPos,\n  scrollPos,\n  window,\n} from \"../lib\";\n\nexport const scroll: TrackerExtensionFactory = {\n  id: \"scroll\",\n  setup(tracker) {\n    let emitted: Partial<Record<Required<ScrollEvent>[\"scrollType\"], boolean>> =\n      {};\n    let initialScroll = scrollPos(T);\n\n    addViewChangedListener(() =>\n      defer(() => ((emitted = {}), (initialScroll = scrollPos(T))), 250)\n    );\n\n    listen(window, \"scroll\", () => {\n      const scroll = scrollPos();\n      const offset = relativeScrollPos();\n\n      if (scroll.y >= initialScroll.y) {\n        const types: (keyof typeof emitted)[] = [];\n\n        !emitted[\"fold\"] &&\n          scroll.y >= initialScroll.y + 200 &&\n          ((emitted[\"fold\"] = T), types.push(\"fold\"));\n\n        !emitted[\"page-middle\"] &&\n          offset.y >= 0.5 &&\n          ((emitted[\"page-middle\"] = T), types.push(\"page-middle\"));\n\n        !emitted[\"page-end\"] &&\n          offset.y >= 0.99 &&\n          ((emitted[\"page-end\"] = T), types.push(\"page-end\"));\n\n        const mapped = map(types, (scrollType) =>\n          cast<ScrollEvent>({\n            type: \"SCROLL\",\n            scrollType,\n            offset,\n          })\n        );\n\n        mapped.length && push(tracker, mapped);\n      }\n    });\n  },\n};\n","import { FormEvent, FormField, Timestamp, cast } from \"@tailjs/types\";\nimport type { Nullish } from \"@tailjs/util\";\nimport {\n  TrackerExtensionFactory,\n  addViewChangedListener,\n  getComponentContext,\n  getVisibleDuration,\n  onFrame,\n} from \"..\";\nimport {\n  NodeWithParentElement,\n  T,\n  addTerminationListener,\n  attr,\n  document,\n  entries,\n  get,\n  getOrSet,\n  getRect,\n  item,\n  listen,\n  map,\n  nil,\n  now,\n  push,\n  replace,\n  scopeAttr,\n  timeout,\n  trackerFlag,\n  trackerPropertyName,\n  undefined,\n  uuidv4,\n} from \"../lib\";\n\ntype FormElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\n\nconst enum FormFillState {\n  None = 0,\n  Submitted = 1,\n  Pending = 2,\n  Submitting = 3,\n}\n\ntype FormState = [\n  event: FormEvent,\n  fields: WeakMap<Element, FormFieldState>,\n  element: HTMLFormElement,\n  fillState: FormFillState,\n  started: Timestamp,\n  nextFillOrder: number\n];\n\nconst currentValue = Symbol();\ntype FormFieldState = FormField & {\n  [currentValue]: string;\n};\n\nexport const forms: TrackerExtensionFactory = {\n  id: \"forms\",\n  setup(tracker) {\n    const formEvents = new Map<HTMLFormElement, FormState>();\n\n    const getFormFieldValue = (element: any): string =>\n      element.selectedOptions\n        ? [...element.selectedOptions].map((option) => option.value).join(\",\")\n        : element.type === \"checkbox\"\n        ? element.checked\n          ? \"yes\"\n          : \"no\"\n        : element.value;\n\n    const getFormState = (\n      el: FormElement\n    ): [input: FormElement, state: FormState] | undefined => {\n      const formElement = el.form;\n      if (!formElement) return; // Don't care if we started with an element that didn't map to a field.\n\n      const refName =\n        scopeAttr(formElement, trackerPropertyName(\"ref\")) || \"track_ref\";\n\n      const parseElements = () => {\n        map(\n          formElement.querySelectorAll(\n            \"INPUT,SELECT,TEXTAREA\"\n          ) as NodeListOf<FormElement>,\n          (el, i) => {\n            if (!el.name || el.type === \"hidden\") {\n              if (\n                el.type === \"hidden\" &&\n                (el.name === refName || trackerFlag(el, \"ref\"))\n              ) {\n                !el.value && (el.value = uuidv4());\n                state[0].ref = el.value;\n              }\n              return;\n            }\n\n            const name = el.name;\n            const field = (state[0].fields![name] ??= {\n              id: el.id || name,\n              name,\n              label: replace(\n                item(el.labels, 0)?.innerText ?? el.name,\n                /^\\s*(.*?)\\s*\\*?\\s*$/g,\n                \"$1\"\n              ),\n              activeTime: 0,\n              type: el.type ?? \"unknown\",\n              [currentValue as any]: getFormFieldValue(el),\n            }) as FormFieldState;\n\n            state[0].fields![field.name] = field;\n            state[1].set(el, field);\n          }\n        );\n      };\n\n      let capturedContext: ReturnType<typeof getComponentContext>;\n\n      const isFormVisible = () =>\n        formElement.isConnected && getRect(formElement).width;\n\n      const state = getOrSet(formEvents, formElement, () => {\n        const fieldMap = new Map<Element, FormFieldState>();\n        const ev: FormEvent = {\n          type: \"FORM\",\n          name:\n            scopeAttr(formElement, trackerPropertyName(\"form-name\")) ||\n            attr(formElement, \"name\") ||\n            formElement.id ||\n            undefined,\n          activeTime: 0,\n          totalTime: 0,\n          fields: {},\n        };\n\n        let state: FormState;\n        const commitEvent = () => {\n          handleLostFocus(); // focusout or change events may not be called when the user leaves the page while a field has focus.\n\n          // If the form has disappeared it is heuristically assumed it was submitted successfully.\n          state[3] >= FormFillState.Pending &&\n            (ev.completed =\n              state[3] === FormFillState.Submitting || !isFormVisible());\n          push(\n            tracker,\n            cast<FormEvent>({\n              ...capturedContext,\n              ...ev,\n              totalTime: now(T) - state[4],\n            })\n          );\n          state[3] = FormFillState.Submitted;\n        };\n\n        addViewChangedListener(commitEvent);\n        addTerminationListener(commitEvent);\n\n        const commitTimeout = timeout();\n\n        listen(formElement, \"submit\", () => {\n          capturedContext = getComponentContext(formElement);\n          state[3] = FormFillState.Submitting;\n\n          commitTimeout(() => {\n            // If the form disappears within 750 ms but no navigation happens it is assumed that it was \"submitted\" somehow, e.g. via AJAX.\n            // This heurtistic may result in false positives if the user clicks submit, gets vaildation errors and then leaves the site instantly.\n            //\n            // If the server is aggressively slow to respond to a post and the for goes back into pending state,\n            // it is undefined whether the submit happened or not, if the user leaves the site before the server responds.\n            // In this case it will count as abandondment.\n\n            if (formElement.isConnected && getRect(formElement).width > 0) {\n              state[3] = FormFillState.Pending;\n              commitTimeout();\n            } else {\n              commitEvent();\n            }\n          }, 750);\n        });\n\n        return (state = [\n          ev,\n          fieldMap,\n          formElement,\n          FormFillState.None,\n          now(T),\n          1,\n        ]);\n      });\n      if (!get(state[1], el)) {\n        // This will also be the case if a new field was added to the DOM.\n        parseElements();\n      }\n      return [el!, state];\n    };\n\n    const getFieldInfo = (\n      el: NodeWithParentElement,\n      [formElement, state] = getFormState(el as any) ?? [],\n      field = state?.[1].get(formElement as Element)\n    ) => field && ([state![0], field, formElement!, state!] as const);\n\n    let currentField: ReturnType<typeof getFieldInfo> | null = nil;\n    const handleLostFocus = () => {\n      if (!currentField) return;\n\n      const [form, field, el, state] = currentField;\n      const active = -(tv0 - (tv0 = getVisibleDuration()));\n      const total = -(t0 - (t0 = now(T)));\n\n      const previousValue = field[currentValue];\n      const newValue = (field[currentValue] = getFormFieldValue(el));\n\n      if (newValue !== previousValue) {\n        field.fillOrder ??= state[5]++;\n        if (field.filled) {\n          field.corrections = (field.corrections ?? 0) + 1;\n        }\n        field.filled = T;\n\n        state[3] = FormFillState.Pending;\n        entries(\n          form.fields!,\n          ([name, value]) =>\n            (value.lastField = name === field.name || undefined)\n        );\n      }\n\n      field.activeTime! += active;\n      field.totalTime! += total;\n      form.activeTime! += active;\n      currentField = nil;\n    };\n\n    let tv0 = 0;\n    let t0 = 0;\n    const wireFormFields = (document: Document | Nullish) => {\n      document &&\n        listen(\n          document,\n          [\"focusin\", \"focusout\", \"change\"],\n          (ev, _, current = getFieldInfo(ev.target)) => {\n            current &&\n              ((currentField = current),\n              ev.type === \"focusin\"\n                ? ((t0 = now(T)), (tv0 = getVisibleDuration()))\n                : handleLostFocus());\n          }\n        );\n    };\n\n    wireFormFields(document);\n    onFrame((frame) => frame.contentDocument && wireFormFields);\n  },\n};\n","import {\n  TrackerExtensionFactory,\n  commerce,\n  components,\n  context,\n  forms,\n  scroll,\n  userInteraction,\n} from \"..\";\n\nexport const defaultExtensions: TrackerExtensionFactory[] = [\n  context,\n  components,\n  userInteraction,\n  scroll,\n  commerce,\n  forms,\n];\n","export const commandTest =\n  <T = any>(...name: any[]) =>\n  (command: any): command is T =>\n    command === name[0] ||\n    name.some(\n      (name) => typeof name === \"string\" && command?.[name] !== undefined\n    );\n","import { CartEventData } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Triggers events related to a shopping cart.\n */\nexport interface CartCommand {\n  cart: \"clear\" | CartEventData;\n}\n\nexport const isCartCommand = commandTest<CartCommand>(\"cart\");\n","import type { Nullish } from \"@tailjs/util\";\nimport { commandTest } from \"./shared\";\n\nexport interface ChangeUserCommand {\n  username: string | Nullish;\n}\n\nexport const isChangeUserCommand = commandTest<ChangeUserCommand>(\"username\");\n","import type { TagMappings } from \"..\";\nimport { commandTest } from \"./shared\";\n\nexport type TagAttributesCommand = {\n  tagAttributes: TagMappings;\n};\nexport const isTagAttributesCommand =\n  commandTest<TagAttributesCommand>(\"tagAttributes\");\n","import { commandTest } from \"./shared\";\n\n/**\n * Enables or disables tracking.\n */\nexport type ToggleCommand = {\n  disable: boolean;\n};\nexport const isToggleCommand = commandTest<ToggleCommand>(\"disable\");\n","import type {\n  CartAction,\n  CartEventData,\n  ConfiguredComponent,\n  Content,\n  Tag,\n  TrackingSettings,\n} from \"@tailjs/types\";\n\nimport { commandTest } from \"./shared\";\n\nexport interface BoundaryData {\n  /**\n   * The component definition(s) associated with the boundary element.\n   */\n  component?: ConfiguredComponent | ConfiguredComponent[] | null;\n\n  /**\n   * The content definition(s) associated with the boundary element.\n   */\n  content?: Content | Content[] | null;\n\n  /**\n   * The name of the content area associated with the boundary element.\n   *\n   * A content area is used to indicate where activated components are used.\n   */\n  area?: string | null;\n\n  /**\n   *  These tags will be added to the components and content in user activations with the boundary element or any of its descendants.\n   */\n  tags?: Tag | Tag[] | null;\n\n  /**\n   * The element will include cart data when activated.\n   */\n  cart?: CartAction | CartEventData;\n\n  /**\n   * Settings that will apply to components contained by the boundary element including itself, similar to specifying \"track-*\" HMTL attributes on the element.\n   */\n  track?: TrackingSettings;\n}\n\n/**\n * Registers an element as the boundary for a component or similar tracking data. All events triggered from the element or its descendants will have this information attached.\n * In case of nested boundaries the closest one is used.\n */\nexport type BoundaryCommand = {\n  boundary: Element;\n} & (\n  | (BoundaryData & {\n      /**\n       * The content, tags and components will be added to the existing, if any.\n       */\n      add?: boolean;\n    })\n  | { update: (current?: BoundaryData) => BoundaryData | null }\n);\n\n// {\n//   /**\n//    * The component definition(s) associated with the boundary element.\n//    */\n//   component?: ConfiguredComponent | ConfiguredComponent[] | null;\n\n//   /**\n//    * The content definition(s) associated with the boundary element.\n//    */\n//   content?: Content | Content[] | null;\n\n//   /**\n//    * The name of the content area associated with the boundary element.\n//    *\n//    * A content area is used to indicate where activated components are used.\n//    */\n//   area?: string | string[] | null;\n\n//   /**\n//    *  These tags will be added to the components and content in user activations with the boundary element or any of its descendants.\n//    */\n//   tags?: Tag | Tag[] | null;\n\n//   /**\n//    * The element will include cart data when activated.\n//    */\n//   cart?: CartAction | CartEventData;\n\n//   /**\n//    * The element's component will be included in the stack even when the activation tracking level is `direct`.\n//    */\n//   promote?: boolean;\n\n//   /**\n//    * Specifies how the this command modifies the data associated with the boundary element.\n//    *\n//    * Only properties present in this command are affected (e.g. `component` or `content`) unless the action is `clear`.\n//    *\n//    * @default \"add\"\n//    */\n//   action?: \"add\" | \"remove\" | \"clear\";\n\n//   /**\n//    * The DOM element that gets this command's data associated.\n//    */\n//   boundary: Element;\n// }\n\nexport const isDataBoundaryCommand = commandTest<BoundaryCommand>(\"boundary\");\n","import type { TrackerExtensionFactory } from \"..\";\nimport { commandTest } from \"./shared\";\n\nexport interface ExtensionCommand {\n  extension: TrackerExtensionFactory;\n  priority?: number;\n}\nexport const isExtensionCommand = commandTest<ExtensionCommand>(\"extension\");\n","import { T } from \"../lib/alias\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Causes all queued events to be posted to the server immediately.\n */\nexport type FlushCommand = { flush: boolean; force?: boolean; defer?: boolean };\nexport const isFlushCommand = commandTest<FlushCommand>(T, \"flush\");\n","import type { ReservedVariables, Tracker } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/** Used to get a context variable from the tracker. This is async, so if a key is anticipated to eventually be set, the callback will wait for it if does not already have a value.\n * This command can also be used for polling by returning `true` from the callback in which case it will be called everytime the value is set (not necessarily with a changed value).\n *\n */\nexport interface GetCommand {\n  /**\n   * If the functions returns true it will be triggered again if the value changes.\n   */\n  get: Record<string, GetCallback> & {\n    [key in keyof ReservedVariables]?: GetCallback<ReservedVariables[key]>;\n  };\n  /**\n   * If no one has set the value after this amount of ms, the callback will be triggered with `undefined` as the value and a flag indicating that the request timed out.\n   * If set to zero the callback will always be called synchronously with either the value or undefined if it is not defined.\n   * Negative values means \"no timeout\".\n   */\n  timeout?: number;\n}\n\n/**\n * The callback that is called for {@link GetCommand}s when a tracker variable is set or changed.\n * To enable/simplify polling the callback gets triggered again next time the variable changes if it returns `true`.\n */\nexport type GetCallback<T = any> = (\n  /** The current value of the variable in the tracker. */\n  value: T | undefined,\n\n  /** The key for which the callback is registered.  */\n  key: string,\n\n  /** Whether the callback is called with an undefined value because the timeout elapsed. */\n  timeout: boolean,\n\n  /** The tracker where the variable was set. */\n  tracker: Tracker\n) => any | true;\n\nexport const isGetCommand = commandTest<GetCommand>(\"get\");\n","import type { Listener } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Registers a listener that will be invoked before and after events are flushed.\n * Useful for debugging or client-side integration with other tracker libraries (if one absolutely must).\n */\nexport interface ListenerCommand {\n  listener: Listener;\n}\nexport const isListenerCommand = commandTest<ListenerCommand>(\"listener\");\n","import { Order, OrderEvent } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Shorthand command to trigger an {@link OrderEvent} event.\n */\nexport interface OrderCommand {\n  /**\n   * The order that was completed or cancelled.\n   */\n  order: Order;\n}\n\nexport const isOrderCommand = commandTest<OrderCommand>(\"order\");\n","import type { Component, ExternalReference } from \"@tailjs/types\";\nimport { commandTest } from \"./shared\";\n\nexport type ComponentOrContent =\n  | { component: Component }\n  | { content: ExternalReference };\n\n/**\n * Registers an element as the boundary for a component. All events triggered from the element or its descendants will have this information attached.\n * In case of nested boundaries the closest one is used.\n */\nexport interface ScanComponentsCommand {\n  scan: {\n    attribute: string;\n    components: ComponentOrContent[];\n  };\n}\n\nexport const isScanComponentsCommand =\n  commandTest<ScanComponentsCommand>(\"scan\");\n","import type { ReservedVariables } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/**\n * Set the specified properties in the tracker's variables\n */\nexport interface SetCommand {\n  /** An object where the names of the properties correspond to the variables set in the tracker. */\n  set: Record<string, any> & Partial<ReservedVariables>;\n}\n\nexport const isSetCommand = commandTest<SetCommand>(\"set\");\n","import type { Tracker, TrackerCommand } from \"..\";\n\nexport type TrackerAvailableCommand = (tracker: Tracker) => void;\nexport const isTrackerAvailableCommand = (\n  command: TrackerCommand\n): command is (tracker: Tracker) => void => typeof command === \"function\";\n","import {\n  array,\n  entries,\n  err,\n  ERR_ARGUMENT_ERROR,\n  F,\n  item,\n  map,\n  obj,\n  push,\n  T,\n  tryCatch,\n  undefined,\n} from \".\";\nimport { GetCallback, Tracker } from \"..\";\n\nexport type Variables = [\n  get: {\n    (): Record<string, any>;\n    (values: Record<string, GetCallback>, timeout?: number): void;\n  },\n  set: {\n    (key: string, value: any, passive?: boolean): void;\n    (values: Record<string, any>, passive?: boolean): void;\n    (values: [string, any][], passive: boolean): void;\n  }\n];\n\nexport const variables = (\n  tracker: Tracker,\n  listen?: (values: [key: string, value: any][]) => void\n): Variables => {\n  const data: Record<string, any> = {};\n\n  const callbacks: Record<string, GetCallback[]> = {};\n\n  const getCallbacks = (\n    key: string,\n    reset: boolean\n  ): [previous: GetCallback[], current: GetCallback[]] => [\n    (callbacks[key] ??= []),\n    reset ? (callbacks[key] = []) : callbacks[key],\n  ];\n\n  const set = (...args: any[]) => {\n    const passive = item(args, -1) === T;\n    const kvs = array(args[0])\n      ? args[0]\n      : obj(args[0])\n      ? entries(args[0])\n      : [[args[0], args[1]]];\n    map(kvs, ([key, value]) => {\n      key = \"\" + key;\n      data[key] = value;\n      const [callbacks, next] = getCallbacks(key, T);\n      map(\n        callbacks,\n        (callback) =>\n          callback(value, key, F, tracker) === T && push(next, callback)\n      );\n    });\n\n    !passive && listen?.(kvs);\n  };\n\n  const get: Variables[0] = (\n    values?: Record<string, GetCallback>,\n    timeout?: number\n  ): any => {\n    if (!values) return data;\n\n    map(entries(values), ([key, callback]) => {\n      if (!callback) return err(ERR_ARGUMENT_ERROR, key);\n      let inner = callback;\n\n      const [queue] = getCallbacks(key, F);\n\n      let triggered = F;\n      callback = (value, key, current) => {\n        triggered = T;\n        return tryCatch(() => inner(value, key, current, tracker));\n      };\n\n      if (data[key] === undefined && timeout !== 0) {\n        push(queue, callback);\n\n        timeout &&\n          timeout > 0 &&\n          setTimeout(\n            () =>\n              !triggered && // The callback has not yet been triggered, timeout happened.\n              callback(undefined, key, T, tracker) !== T &&\n              (inner = () => {}), // Neutralize the inner callback so it is not invoked again if a value arrives after the timeout.\n            timeout\n          );\n      } else {\n        callback(data[key], key, T, tracker) === T && push(queue, callback);\n      }\n    });\n  };\n  return [get, set];\n};\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\nimport { initializeTracker } from \"./initializeTracker\";\nimport { F, T, define, window } from \"./lib\";\nimport { attach } from \"./pusher\";\n\n// This assumes the script is loaded from the RequestHandler's ?cfg route.\n\n// To prevent external scripts from eaves-dropping and get a hold of the storage key, this is how initialization works:\n// 1: The configuration scripts appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overriden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nwindow[INITIALIZE_TRACKER_FUNCTION] = (callback: any) => {\n  callback(initializeTracker);\n};\n\n// let loaded = F;\n// define(window, {\n//   [INITIALIZE_TRACKER_FUNCTION]: [\n//     (callback: (init: typeof initializeTracker) => void) => {\n//       if (loaded === (loaded = T)) return;\n//       callback(initializeTracker);\n//     },\n//   ],\n// });\n"],"names":["MUTEX_RESPONSE_COOKIE","undefined","MAX_SAFE_INTEGER","Number","symbolIterator","Symbol","iterator","isUndefined","value","isDefined","ifDefined","result","hasValue","isNumber","isString","isArray","Array","isObject","acceptIterables","isSymbol","isFunction","isIterable","acceptStrings","stopInvoked","sliceAction","action","start","end","index","createIterator","source","projection","item","i","key","step","maxIterations","length","offset","map","mapped","push","project","unwrap","then","conjunct","values","conjunction","slice","join","returnValue","createEnumAccessor","sourceEnum","flags","enumName","pureFlags","originalValue","names","Object","fromEntries","entries","filter","toLowerCase","any","reduce","flag","nameLookup","none","valueLookup","parseValue","validateNumbers","tryParse","lookup","format","name","parse","error","transform","message","TypeError","JSON","stringify","pure","target","args","add","arg","defaults","properties","splice","forEach","items","defineProperty","configurable","enumerable","writable","get","logFormat","c","DataClassification","Anonymous","Indirect","Direct","Sensitive","DataPurposeFlags","None","Necessary","Functionality","Performance","Targeting","Security","Infrastructure","Any","freeze","level","purposes","VariableScope","Global","Session","Device","User","Entity","VariableResultStatus","VariablePatchType","currentValue","matchSelected","typeTest","types","ev","type","some","isTrackedEvent","isViewEvent","isViewEndedEvent","splitRanks","ranks","replace","split","rank","parseTagString","input","baseRank","test","decodeURIComponent","_","sep","parsedTag","tags","baseRanks","_0","tag","quote1","quote2","unquoted","pop","concat","nil","T","F","assign","st","setTimeout","pi","parseInt","SSR","window","win","doc","document","nav","navigator","body","loc","location","perf","performance","err","code","console","round","x","decimals","bool","Math","pow","decode","encode","encodeURIComponent","parameters","equals","lowerCase","s","concat2","value1","value2","defaultValue","typePrefixes","is","exec","testOrConvertFunction","convert","str","toString","fun","obj","array","iterable","sort","sortKey","lhs","rhs","deleteCount","unshift","shift","sources","size","keys","mapOrRecord","initialValue","breakSignal","cloneOrProject","flatMap","predicate","emptyIsNull","stop","hashSet","Set","clear","clearable","del","has","delete","set","getOrSet","transpose","additionalEntries","promise","Promise","resolve","Reset","Expired","openPromise","timeout","currentResolve","currentPromise","resolved","reset","capturedResolve","delay","p","match","regex","selector","escapeRegEx","REGEX_NEVER","unionOrNever","parts","joined","distinct","RegExp","stringRuleCache","separators","part","text","separator","replaceValue","codes","chars","charCode","charCodeAt","FNVs","32","64","128","entropy","max","random","serialize","data","options","multiple","Error","floatBuffer","floatView","pow32","Uint8Array","append","subarray","isReplacement","appendNull","appendByte","appendBoolean","lo","isFinite","isSafeInteger","appendBytes","hi","appendInt64","ArrayBuffer","DataView","setFloat64","bytes","ascii","ci","c2","appendString","Date","ns","sec","getTime","getMilliseconds","appendArray","Uint8ClampedArray","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","appendObject","invalidTypeReplacement","byte","newLength","newArray","abs","deserialize","pos","read","readMap","readArray","readStr","readBin","readExt","readFloat","readUInt","readInt","debug","first","view","buffer","byteOffset","getFloat32","getFloat64","lengthSize","String","fromCharCode","decodeUtf8","msgpack","module","exports","msgpackJsName","screenPos","y","rect","REF_PROP","patchSerialize","cleaners","refs","refIndex","patchProperty","val","patched","inner","addCleaner","cleaner","toJSON","Map","k","serialized","createTransport","json","encrypt","decrypt","hash","n","j","pad","bits","prime","mixer","mixer255","iw","mixer0","window0","resetMixer","updateMixer","ENTROPY","cipher","numericOrBits","BigInt","asUintN","MIN_SAFE_INTEGER","lfsr","fastStringHash","bitsOrNumeric","encoded","expression","e","chunk","base64","from64u","matchedRef","v","httpEncode","httpDecode","httpEncrypt","httpDecrypt","now","_tmp","timeOrigin","trunc","ms","callback","id","currentCallback","capturedCallback","clearInterval","clearTimeout","setInterval","cleanup","currentId","wait","pulse","isActive","finish","timer","time","started","elapsed","origin","defer","f","queueMicrotask","randomValues","crypto","getRandomValues","randomSafeInt","arr","localIdBuffer","nextId","compareTabIds","other","localeCompare","TAB_ID","trackerConfig","src","disabled","postEvents","postFrequency","requestTimeout","heartbeatFrequency","clientKey","apiKey","impressionThreshold","captureContextMenu","defaultActivationTracking","default","MAX_ANCESTOR_DISTANCE","forAncestorsOrSelf","el","stoppingCriterion","distance","nodeType","prev","parentElement","ownerDocument","defaultView","frameElement","scopeAttr","node","attr","getAttribute","removeAttribute","setAttribute","cssProperty","getComputedStyle","getPropertyValue","define","props","defineProperties","tagName","scrollPos","int","scrollX","scrollY","matchExHash","href1","href2","getScreenPos","mouseEvent","includeFold","getPos","xpx","ypx","offsetWidth","offsetHeight","pageFolds","innerHeight","pointerType","pageY","pageX","getRect","getBoundingClientRect","left","top","width","height","listen","cb","capture","passive","unbinders","removeEventListener","addEventListener","unbind","parseDomain","href","all","protocol","domainName","substring","domain","getViewport","innerWidth","totalWidth","totalHeight","tryCatch","finallyCallback","stopImmediatePropagation","currentScript","SCRIPT_SRC","TRACKER_DOMAIN","isInternalUrl","url","endsWith","mapUrl","urlParts","VAR_URL","MNT_URL","eventSet","once","handlers","unbinder","handler","invokeArgs","startupLock","registerStartupHandler","startupComplete","cachedMappings","currentBoundaryData","propertyValue","decoded","expires","entry","oldEntry","boundaryData","WeakMap","getBoundaryData","trackerPropertyName","css","matchAttributeNames","cached","prefix","eligible","getAttributeNames","matches","cachedTagMapper","cssPropertyWithBase","parsedCssRules","trackerProperty","inherit","r","trackerFlag","parseTags","sourceEl","elementTagData","rulesString","rule1","rule2","cache","rule","removeExpired","secure","$","storage","register","sourceId","removeItem","ownListeners","accessor","arg0","arg1","arg2","innerHandler","listener","unlisten","triggerSelf","newValue","oldValue","getItem","supportsExpiry","setItem","cookieStorage","cookie","kv","find","trim","maxAge","memoryStorage","stalled","cookies","secureCookies","session","sessionStorage","shared","localStorage","remove","createChannel","self","channelKey","getTargetKey","targetId","ownKey","channel","rest","cleared","destinationKey","direct","dependencies","pendingDependencies","areAllDependenciesPosted","dep","globalStateChannel","globalStateResolvers","listeners","callListeners","globalStateResolved","resolveTimeout","registerSharedState","apply","knownTabs","hasResponse","payload","actionHandlers","localData","flushLocalData","currentData","actionStates","getActionState","purgeClosedTabs","getCoordinatorId","reducer","min","previous","current","1","closing","2","freezing","collect","3","4","actionId","coordinateCommit","5","coordinator","critical","collected","handle","success","async","always","6","updatePollingTab","7","initPromise","init","await","terminate","toggleActive","safeTimeoutTimestamp","selectedPollingTab","activeId","isForegroundTab","active","toggle","visibilityState","addResponseListener","callResponseHandlers","responseChannel","checkResponseCookie","decompose","affinity","variables","tuple","responseTimeout","pollResponseCookie","MUTEX_REQUEST_COOKIE","addPostListener","callPostListeners","addShutdownListener","callShutdownListeners","post","commit","actionHandler","events","force","sourceLabel","forced","t0","discardCookies","postData","event","timestamp","o","sendBeacon","Blob","response","tryAcquireRequestLock","terminating","broadcastAffinity","activeHandles","flushing","noopAction","registerViewEndAction","addTerminationListener","currentViewEvent","pushPopNavigation","userInteraction","setup","tracker","pollContextCookie","pendingNavigationEvent","trackDocument","trackClicks","trackRegion","clickableElement","cmp","t","track","clicks","component","region","componentContext","getComponentContext","parseActivationTags","container","info","sharedEventProperties","viewport","element","innerText","timing","startsWith","isLinkElement","external","hostname","host","pathname","search","anchor","navigationEvent","clientId","referrerConsumed","pushNavigationSource","currentUrl","userActivation","clipboard","writeText","unbindAll","button","ctrlKey","shiftKey","altKey","exit","sourceElement","contextCart","parseCartEventData","cart","content","normalizeCartEventData","onFrame","frame","contentDocument","decorate","eventData","addViewChangedListener","viewChanged","referrers","useSharedId","queue","bind","exists","updateQueue","poll","sharedQueue","navigationEventId","totalDuration","visibleDuration","interactiveDuration","getVisibleDuration","callOnFrame","knownFrames","WeakSet","frames","getElementsByTagName","context","isNewTab","activations","viewPosted","tab","firstTab","pendingViewEvent","NO_OP","pendingViewEndEvent","currentLocation","postView","trySplit","ps","qs","referrer","path","tabIndex","landingPage","query","queryString","utm","navigationType","getEntriesByType","redirects","redirectCount","relatedEventId","externalReferrer","flush","definition","rendered","qd","hasTouch","maxTouchPoints","userAgent","languages","language","primary","preference","timezone","iana","Intl","DateTimeFormat","resolvedOptions","timeZone","getTimezoneOffset","h","landscape","angle","screen","w","orientation","deviceType","dpr","devicePixelRatio","a","interactiveTimeout","heartbeat","history","resetHeartbeat","processCommand","command","isChangeUserCommand","username","ctx","totalTime","visibleTime","interactiveTime","dependency","units","commerce","isCartCommand","isOrderCommand","order","hasComponentOrContent","boundary","stripRects","keep","setContext","directOnly","areaPath","components","collectedContent","includeState","area","secondary","promote","ancestor","intersectionHandler","observer","IntersectionObserver","els","isIntersecting","boundingClientRect","intersectionRatio","threshold","registerComponent","fold","visible","impressions","captureState","update","inferred","intersecting","ratio","bottom","duration","isConnected","observe","cmd","isDataBoundaryCommand","isScanComponentsCommand","attributeName","references","commands","seen","querySelectorAll","stack","delta","number","isNaN","next","nextElementSibling","parentNode","removeChild","scan","attribute","scroll","emitted","initialScroll","scrollType","defaultExtensions","formEvents","getFormFieldValue","selectedOptions","option","checked","currentField","handleLostFocus","form","field","state","total","previousValue","tv0","fillOrder","filled","corrections","fields","lastField","activeTime","wireFormFields","formElement","capturedContext","refName","fieldMap","commitEvent","completed","commitTimeout","label","labels","ref","getFormState","commandTest","isTagAttributesCommand","isToggleCommand","isExtensionCommand","isFlushCommand","isGetCommand","isListenerCommand","isSetCommand","isTrackerAvailableCommand","initializeTracker","config","queuedCommands","extensions","pendingStateCommands","publicVariables","localVariables","getVars","setVars","updateVariables","mainArgs","currentArg","insertArgs","unsubscribe","addQueuePostListener","addGlobalStateResolvedListener","callbacks","getCallbacks","triggered","kvs","vars","tagAttributes","disable","expanded","skip","extension","ready","batch","priority","isTracker","loaded"],"mappings":"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","x_google_ignoreList":[27]}