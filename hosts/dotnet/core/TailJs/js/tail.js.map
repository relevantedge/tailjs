{"version":3,"file":"tail.js","sources":["../../../../../npm/packages/@tailjs/util/src/types.ts","../../../../../npm/constants/constants.ts","../../../../../npm/packages/@tailjs/util/src/base64.ts","../../../../../npm/packages/@tailjs/util/src/lfsr.ts","../../../../../npm/packages/@tailjs/util/src/transport.ts","../../../../../npm/node_modules/.pnpm/@ygoe+msgpack@1.0.3/node_modules/@ygoe/msgpack/msgpack.js","../../../../../npm/packages/@tailjs/client/src/lib2/ids.ts","../../../../../npm/packages/@tailjs/client/src/lib2/storage.ts","../../../../../npm/packages/@tailjs/client/src/lib2/dom.ts","../../../../../npm/packages/@tailjs/client/src/lib2/channel.ts","../../../../../npm/packages/@tailjs/client/src/pusher.ts","../../../../../npm/packages/@tailjs/client/src/index.browser.ts"],"sourcesContent":["export type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\ntype IsNever<T> = [T] extends [never] ? true : false;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the constract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properies that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Shorthand for a value that is optionally awaitable.\n */\nexport type MaybePromise<T> = PromiseLike<T> | T;\n\nexport type ValueOrDefault<T, R, D = undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? D\n  : R;\n\n/** Shorter than writing all this out, and slightly easier to read. */\nexport type Nullish = null | undefined;\n\n/**\n * Removes null'ish values from a union.\n */\nexport type OmitNullish<T> = T extends Nullish ? never : T;\n\n/**\n * Common function type used for projection of [key,value] entries.\n */\nexport type KeyValueProjection<K, V, R> = (\n  entry: [key: K, value: V],\n  index: number\n) => R;\n\n/**\n * Shorthand for a type that is inferred from a parameter and can either be the item in an iterable, or just the type itself.\n */\nexport type IterableOrSelf<T> = IterableOrArrayLike<T> | T;\n\n/**\n * Tests if a type is `any`. The test used is technically impossable to succeed unless the type is in fact `any`.\n */\nexport type IsAny<T> = ((unlikely: { d7d52e56b9c14b2b99c207f89f839630: T }) => {\n  bd88181902d54401bb37e71194dd8b7d: T;\n}) extends T\n  ? true\n  : false;\n\n/**\n * Utility type to allow `as const` to be used on tuples returned from functions without actually making them `readonly` (which is annoying).\n * Normally TypeScript considers the return value of a function like `x=>[10,\"four\"]` to be `(string|number)[]` (which is also annoying).\n */\nexport type ConstToTuples<T> = T extends readonly any[]\n  ? { -readonly [P in keyof T]: T[P] }\n  : Voidefined<T>;\n\n/**\n * Goes with {@link Nulls} to simplify the expression.\n */\nexport type ArgNulls<T, Arg> = (T | Nullish) & Arg;\n\n/**\n * Trick for having a function that returns a non-null value, if a formal paramter always has a non-null value.\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\n/**\n * Typescript has the distinction between `void` and `undefined`.\n * I'm sure there is a theorically sound explanation. Both that and the distinction are annoying so this little utility type maps `void` to `undefined`.\n *\n * The ampersand union trick makes TypeScript relax instead of the \"The type T could be instantiated etc...\" error.\n */\nexport type Voidefined<T> = T extends void ? T & undefined : T;\n\n/**\n * An extension to T[] and Iterable<T> that also correctly captures weird things like NodeListOf<T>\n */\nexport type IterableOrArrayLike<T> =\n  | Iterable<T>\n  | { [item: number]: T; length: number };\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = (value: any, parse?: boolean) => T | undefined;\n\nexport const undefined = void 0;\nexport const nil = null;\n\nconst createConverter =\n  <T>(typeTester: TypeTester<T>, parser?: (value: any) => T | undefined) =>\n  (value: any, parse = true) =>\n    typeTester(value)\n      ? value\n      : parser && parse && isDefined((value = parser(value)))\n      ? value\n      : undefined;\n\nexport const tryCatch = <T, C = undefined>(\n  expression: () => T,\n  errorHandler?: (error: any) => C,\n  clean?: () => void\n): T | C => {\n  try {\n    return expression();\n  } catch (e) {\n    return errorHandler?.(e) as any;\n  } finally {\n    clean?.();\n  }\n};\n\nexport const tryCatchAsync = async <T, C = undefined>(\n  expression: () => Promise<T> | T,\n  errorHandler?: (error: any) => Promise<C> | C,\n  always?: () => void\n): Promise<T | C> => {\n  try {\n    return await expression();\n  } catch (e) {\n    return (await errorHandler?.(e)) as any;\n  } finally {\n    always?.();\n  }\n};\n\nexport const isNull = (value: any): value is null => value === nil;\nexport const isUndefined = (value: any): value is undefined | void =>\n  value === undefined;\nexport const isDefined = <T>(value: T): value is Exclude<T, undefined | void> =>\n  !isUndefined(value);\n\nexport const hasValue = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value != nil;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\nexport const parseBoolean = createConverter(isBoolean, (value) => !!value);\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\nexport const parseNumber = createConverter(isNumber, (value) =>\n  parseFloat(value)\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\nexport const parseBigInt = createConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createConverter(isString, (value) =>\n  hasValue(value) ? \"\" + value : value\n);\n\nexport const isArray = Array.isArray;\nexport const toArray = <T>(value: T | Iterable<T>): T[] =>\n  value == null\n    ? []\n    : isArray(value)\n    ? value\n    : isIterable(value)\n    ? [...value]\n    : ([value] as any);\n\nexport const isObject = (value: any): value is object =>\n  value && typeof value === \"object\";\n\n/** Tests whether a value is an object but not an array. */\nexport const isPureObject = (\n  value: any\n): value is object & { [Symbol.iterator]?: never } =>\n  isObject(value) && !isIterable(value);\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\n\nexport const isIterable = (value: any): value is Iterable<any> =>\n  value?.[Symbol.iterator] && !isString(value);\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == nil\n    ? value === nil\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\nexport const identity = <T = any>(value: T) => value;\n\nexport const clone = <T>(value: T): T =>\n  isArray(value)\n    ? [...value]\n    : isPureObject(value)\n    ? { ...value }\n    : (value as any);\n","// MUST MATCH packages\\@tailjs\\engine\\src\\RequestHandler.ts\nexport const MUTEX_REQUEST_COOKIE = \".tail.rq\";\nexport const MUTEX_RESPONSE_COOKIE = \".tail.rs\";\nexport const CONTEXT_MENU_COOKIE = \".tail.cm\";\n\nexport const QUERY_DEVICE = \"qd\";\nexport const INITIALIZE_TRACKER_FUNCTION = \".tail.js.init\";\n\nexport const EVENT_HUB_QUERY = \"var\";\nexport const VARIABLES_QUERY = \"usr\";\nexport const CONTEXT_MENU_QUERY = \"mnt\";\n","const codes: number[] = [];\nconst chars: number[] = [];\nexport const charCode = (s: string, index = 0) => s.charCodeAt(index);\nexport const fromCharCodes = (chars: number[]) => String.fromCharCode(...chars);\n\n[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"].forEach(\n  (p, i) => (codes[(chars[i] = p.charCodeAt(0))] = i)\n);\n\n/**\n * Encodes an array of bytes to Base64URL without padding (URL safe Base64 using `-` and `_` instead of `+` and `/`).\n *\n * (thanks to Jon Leighton at https://gist.github.com/jonleighton/958841).\n */\nexport const to64u = (bytes: Uint8Array) => {\n  let i = 0;\n  let chunk: number;\n  const n = bytes.length;\n\n  const base64: number[] = [];\n  while (i < n) {\n    chunk = (bytes[i++] << 16) | (bytes[i++] << 8) | bytes[i++];\n    base64.push(\n      chars[(chunk & 16515072) >> 18],\n      chars[(chunk & 258048) >> 12],\n      chars[(chunk & 4032) >> 6],\n      chars[chunk & 63]\n    );\n  }\n  base64.length += n - i;\n\n  return fromCharCodes(base64);\n};\n\n/**\n * Decodes a BaseURL encoded string (without padding).\n */\nexport const from64u = (encoded: string) => {\n  let i = 0;\n  let j = 0;\n  let p: number;\n  const n = encoded.length;\n  const bytes = new Uint8Array(3 * ((n / 4) | 0) + (((n + 3) & 3) % 3));\n  while (i < n) {\n    bytes[j++] =\n      (codes[charCode(encoded, i++)] << 2) |\n      ((p = codes[charCode(encoded, i++)]) >> 4);\n    if (i < n) {\n      bytes[j++] = ((p & 15) << 4) | ((p = codes[charCode(encoded, i++)]) >> 2);\n      if (i < n) {\n        bytes[j++] = ((p & 3) << 6) | codes[charCode(encoded, i++)];\n      }\n    }\n  }\n  return bytes;\n};\n","import { charCode, hasValue, isBoolean } from \".\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  <B extends boolean>(source: T, numeric: B): B extends true ? number : string;\n  (source: T, bits?: 32 | 64 | 128): string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key = \"\"): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (iw = 0; iw < key.length; mixer0 += window0[iw] = charCode(key, iw++));\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero it all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: any, numericOrBits: any = 64) => {\n      if (!hasValue(source)) return null;\n      let bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n","import { deserialize, serialize } from \"@ygoe/msgpack\";\n\n// Use below when ad-hoc testing with nodmon. It doesn't like the import above (probabaly because of mangling).\n//import msgpack from \"@ygoe/msgpack\";\n//const { serialize, deserialize } = msgpack;\n\nimport {\n  Encodable,\n  EncodableContract,\n  HashFunction,\n  Nullish,\n  from64u,\n  hasValue,\n  isArray,\n  isDefined,\n  isFunction,\n  isIterable,\n  isNull,\n  isNumber,\n  isObject,\n  isPureObject,\n  isSymbol,\n  isUndefined,\n  lfsr,\n  nil,\n  to64u,\n  tryCatch,\n} from \".\";\nimport { isFloat64Array } from \"util/types\";\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param validate This property has no effect other than letting TypeScript validate whether the value can be deserialized back to its original form without losing properties.\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  (value: any, validate?: false): string;\n  <T = Encodable>(value: T & EncodableContract<T>, validate: true): string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(encoded: string | Nullish) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\nconst floatBuffer = new ArrayBuffer(8);\nconst floatView = new DataView(floatBuffer);\n\n/**\n * Misc. fixes to the msgpack library. For example, it does not handle exponential numbers well.\n */\nconst patchSerialize = (value: any) => {\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number;\n  const patchProperty = (\n    value: any,\n    key: any,\n    val = value[key],\n    patched = inner(val)\n  ) => (\n    (val !== patched || isSymbol(key)) &&\n      ((value[key] = patched), addCleaner(() => (value[key] = val))),\n    val\n  );\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (isNull(value)) return nil;\n    if (isUndefined(value) || isFunction(value) || isSymbol(value)) {\n      return null;\n    }\n\n    if (Number.isFinite(value) && !Number.isSafeInteger(value)) {\n      floatView.setFloat64(0, value, true);\n\n      return { \"\": [...new Uint32Array(floatBuffer)] };\n    }\n\n    if (!isObject(value)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if (isDefined((refIndex = (refs ??= new Map()).get(value)))) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isPureObject(value)) {\n      refs.set(value, refs.size + 1);\n      Object.keys(value).forEach(\n        (k) =>\n          (isUndefined(patchProperty(value, k)) || isSymbol(k)) &&\n          delete value[k]\n      );\n    } else if (isIterable(value)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  const serialized = serialize(inner(value));\n  cleaners?.forEach((cleaner) => cleaner());\n  return serialized;\n};\n\nconst patchDeserialize = (value: Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value)) return value;\n\n    if (isArray(value[\"\"]) && (value = value[\"\"]).length === 2) {\n      return new DataView(new Uint32Array(value).buffer).getFloat64(0, true);\n    }\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return hasValue(value)\n    ? tryCatch(\n        () => inner(deserialize(value)),\n        () => undefined\n      )\n    : value;\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<string>\n];\n\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lsfr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (key?: null | string): Transport => {\n  const [encrypt, decrypt, hash] = lfsr(key ?? \"\");\n\n  return [\n    (data: any) => to64u(encrypt(patchSerialize(data))),\n    (encoded: any) =>\n      hasValue(encoded) ? patchDeserialize(decrypt(from64u(encoded))) : null,\n    (data: any, numericOrBits?: any) =>\n      hash(serialize(data), numericOrBits) as any,\n  ];\n};\n\nexport const defaultTransport = createTransport();\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\n","﻿(function () {\r\n\t\"use strict\";\r\n\r\n\t// Serializes a value to a MessagePack byte array.\r\n\t//\r\n\t// data: The value to serialize. This can be a scalar, array or object.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple values in data are concatenated to multiple MessagePack arrays.\r\n\t// - invalidTypeReplacement: The value that is used to replace values of unsupported types, or a function that returns such a value, given the original value as parameter.\r\n\tfunction serialize(data, options) {\r\n\t\tif (options && options.multiple && !Array.isArray(data)) {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\r\n\t\t}\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet floatBuffer, floatView;\r\n\t\tlet array = new Uint8Array(128);\r\n\t\tlet length = 0;\r\n\t\tif (options && options.multiple) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tappend(data[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tappend(data);\r\n\t\t}\r\n\t\treturn array.subarray(0, length);\r\n\r\n\t\tfunction append(data, isReplacement) {\r\n\t\t\tswitch (typeof data) {\r\n\t\t\t\tcase \"undefined\":\r\n\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\tappendBoolean(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tappendNumber(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tappendString(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif (data === null)\r\n\t\t\t\t\t\tappendNull(data);\r\n\t\t\t\t\telse if (data instanceof Date)\r\n\t\t\t\t\t\tappendDate(data);\r\n\t\t\t\t\telse if (Array.isArray(data))\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\r\n\t\t\t\t\t\tappendBinArray(data);\r\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\r\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\r\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\r\n\t\t\t\t\t\tappendArray(data);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tappendObject(data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\r\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendNull(data) {\r\n\t\t\tappendByte(0xc0);\r\n\t\t}\r\n\r\n\t\tfunction appendBoolean(data) {\r\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\r\n\t\t}\r\n\r\n\t\tfunction appendNumber(data) {\r\n\t\t\tif (isFinite(data) && Math.floor(data) === data) {\r\n\t\t\t\t// Integer\r\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0 && data >= -0x20) {\r\n\t\t\t\t\tappendByte(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\r\n\t\t\t\t\tappendBytes([0xcc, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\r\n\t\t\t\t\tappendBytes([0xd0, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\r\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\r\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\r\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\r\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\r\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\r\n\t\t\t\t\t// 32 bits for bitwise operations.\r\n\t\t\t\t\tlet hi = data / pow32;\r\n\t\t\t\t\tlet lo = data % pow32;\r\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\r\n\t\t\t\t\tappendByte(0xd3);\r\n\t\t\t\t\tappendInt64(data);\r\n\t\t\t\t}\r\n\t\t\t\telse if (data < 0) {   // below int64\r\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t\telse {   // above uint64\r\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Float\r\n\t\t\t\tif (!floatView) {\r\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\r\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\r\n\t\t\t\t}\r\n\t\t\t\tfloatView.setFloat64(0, data);\r\n\t\t\t\tappendByte(0xcb);\r\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendString(data) {\r\n\t\t\tlet bytes = encodeUtf8(data);\r\n\t\t\tlet length = bytes.length;\r\n\r\n\t\t\tif (length <= 0x1f)\r\n\t\t\t\tappendByte(0xa0 + length);\r\n\t\t\telse if (length <= 0xff)\r\n\t\t\t\tappendBytes([0xd9, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(bytes);\r\n\t\t}\r\n\r\n\t\tfunction appendArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x90 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let index = 0; index < length; index++) {\r\n\t\t\t\tappend(data[index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendBinArray(data) {\r\n\t\t\tlet length = data.length;\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendBytes([0xc4, length]);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tappendBytes(data);\r\n\t\t}\r\n\r\n\t\tfunction appendObject(data) {\r\n\t\t\tlet length = 0;\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tif (data[key] !== undefined) {\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (length <= 0xf)\r\n\t\t\t\tappendByte(0x80 + length);\r\n\t\t\telse if (length <= 0xffff)\r\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\r\n\t\t\telse\r\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\r\n\r\n\t\t\tfor (let key in data) {\r\n\t\t\t\tlet value = data[key];\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tappend(key);\r\n\t\t\t\t\tappend(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendDate(data) {\r\n\t\t\tlet sec = data.getTime() / 1000;\r\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\r\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\r\n\t\t\t}\r\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\r\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\r\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\r\n\t\t\t\tappendInt64(sec);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction appendByte(byte) {\r\n\t\t\tif (array.length < length + 1) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + 1)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray[length] = byte;\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\tfunction appendBytes(bytes) {\r\n\t\t\tif (array.length < length + bytes.length) {\r\n\t\t\t\tlet newLength = array.length * 2;\r\n\t\t\t\twhile (newLength < length + bytes.length)\r\n\t\t\t\t\tnewLength *= 2;\r\n\t\t\t\tlet newArray = new Uint8Array(newLength);\r\n\t\t\t\tnewArray.set(array);\r\n\t\t\t\tarray = newArray;\r\n\t\t\t}\r\n\t\t\tarray.set(bytes, length);\r\n\t\t\tlength += bytes.length;\r\n\t\t}\r\n\r\n\t\tfunction appendInt64(value) {\r\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\r\n\t\t\t// bitwise operations.\r\n\t\t\tlet hi, lo;\r\n\t\t\tif (value >= 0) {\r\n\t\t\t\t// Same as uint64\r\n\t\t\t\thi = value / pow32;\r\n\t\t\t\tlo = value % pow32;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\r\n\t\t\t\tvalue++;\r\n\t\t\t\thi = Math.abs(value) / pow32;\r\n\t\t\t\tlo = Math.abs(value) % pow32;\r\n\t\t\t\thi = ~hi;\r\n\t\t\t\tlo = ~lo;\r\n\t\t\t}\r\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deserializes a MessagePack byte array to a value.\r\n\t//\r\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\r\n\t// options: An object that defined additional options.\r\n\t// - multiple: Indicates whether multiple concatenated MessagePack arrays are returned as an array.\r\n\tfunction deserialize(array, options) {\r\n\t\tconst pow32 = 0x100000000;   // 2^32\r\n\t\tlet pos = 0;\r\n\t\tif (array instanceof ArrayBuffer) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\r\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\r\n\t\t}\r\n\t\tif (!array.length) {\r\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\r\n\t\t}\r\n\t\tif (!(array instanceof Uint8Array)) {\r\n\t\t\tarray = new Uint8Array(array);\r\n\t\t}\r\n\t\tlet data;\r\n\t\tif (options && options.multiple) {\r\n\t\t\t// Read as many messages as are available\r\n\t\t\tdata = [];\r\n\t\t\twhile (pos < array.length) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Read only one message and ignore additional data\r\n\t\t\tdata = read();\r\n\t\t}\r\n\t\treturn data;\r\n\r\n\t\tfunction read() {\r\n\t\t\tconst byte = array[pos++];\r\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\r\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\r\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\r\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\r\n\t\t\tif (byte === 0xc0) return null;   // nil\r\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\r\n\t\t\tif (byte === 0xc2) return false;   // false\r\n\t\t\tif (byte === 0xc3) return true;   // true\r\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\r\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\r\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\r\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\r\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\r\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\r\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\r\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\r\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\r\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\r\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\r\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\r\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\r\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\r\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\r\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\r\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\r\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\r\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\r\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\r\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\r\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\r\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\r\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\r\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\r\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\r\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\r\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\r\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\r\n\t\t\tconsole.debug(\"msgpack array:\", array);\r\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\r\n\t\t}\r\n\r\n\t\tfunction readInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\tlet first = true;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tlet byte = array[pos++];\r\n\t\t\t\t\tvalue += byte & 0x7f;\r\n\t\t\t\t\tif (byte & 0x80) {\r\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvalue *= 256;\r\n\t\t\t\t\tvalue += array[pos++];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readUInt(size) {\r\n\t\t\tlet value = 0;\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tvalue *= 256;\r\n\t\t\t\tvalue += array[pos++];\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tfunction readFloat(size) {\r\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\r\n\t\t\tpos += size;\r\n\t\t\tif (size === 4)\r\n\t\t\t\treturn view.getFloat32(0, false);\r\n\t\t\tif (size === 8)\r\n\t\t\t\treturn view.getFloat64(0, false);\r\n\t\t}\r\n\r\n\t\tfunction readBin(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = array.subarray(pos, pos + size);\r\n\t\t\tpos += size;\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readMap(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = {};\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tlet key = read();\r\n\t\t\t\tdata[key] = read();\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readArray(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet data = [];\r\n\t\t\twhile (size-- > 0) {\r\n\t\t\t\tdata.push(read());\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction readStr(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet start = pos;\r\n\t\t\tpos += size;\r\n\t\t\treturn decodeUtf8(array, start, size);\r\n\t\t}\r\n\r\n\t\tfunction readExt(size, lengthSize) {\r\n\t\t\tif (size < 0) size = readUInt(lengthSize);\r\n\t\t\tlet type = readUInt(1);\r\n\t\t\tlet data = readBin(size);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 255:\r\n\t\t\t\t\treturn readExtDate(data);\r\n\t\t\t}\r\n\t\t\treturn { type: type, data: data };\r\n\t\t}\r\n\r\n\t\tfunction readExtDate(data) {\r\n\t\t\tif (data.length === 4) {\r\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\treturn new Date(sec * 1000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 8) {\r\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\r\n\t\t\t\t\t((data[1] << 14) >>> 0) +\r\n\t\t\t\t\t((data[2] << 6) >>> 0) +\r\n\t\t\t\t\t(data[3] >>> 2);\r\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\r\n\t\t\t\t\t((data[4] << 24) >>> 0) +\r\n\t\t\t\t\t((data[5] << 16) >>> 0) +\r\n\t\t\t\t\t((data[6] << 8) >>> 0) +\r\n\t\t\t\t\tdata[7];\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tif (data.length === 12) {\r\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\r\n\t\t\t\t\t((data[1] << 16) >>> 0) +\r\n\t\t\t\t\t((data[2] << 8) >>> 0) +\r\n\t\t\t\t\tdata[3];\r\n\t\t\t\tpos -= 8;\r\n\t\t\t\tlet sec = readInt(8);\r\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Encodes a string to UTF-8 bytes.\r\n\tfunction encodeUtf8(str) {\r\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\r\n\t\tlet ascii = true, length = str.length;\r\n\t\tfor (let x = 0; x < length; x++) {\r\n\t\t\tif (str.charCodeAt(x) > 127) {\r\n\t\t\t\tascii = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\r\n\t\tfor (let ci = 0; ci !== length; ci++) {\r\n\t\t\tlet c = str.charCodeAt(ci);\r\n\t\t\tif (c < 128) {\r\n\t\t\t\tbytes[i++] = c;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c < 2048) {\r\n\t\t\t\tbytes[i++] = c >> 6 | 192;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\r\n\t\t\t\t\tif (++ci >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\r\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\r\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\r\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\r\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\r\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\r\n\t\t\t\t}\r\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\r\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\r\n\t\t\t}\r\n\t\t\tbytes[i++] = c & 63 | 128;\r\n\t\t}\r\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\r\n\t}\r\n\r\n\t// Decodes a string from UTF-8 bytes.\r\n\tfunction decodeUtf8(bytes, start, length) {\r\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\r\n\t\tlet i = start, str = \"\";\r\n\t\tlength += start;\r\n\t\twhile (i < length) {\r\n\t\t\tlet c = bytes[i++];\r\n\t\t\tif (c > 127) {\r\n\t\t\t\tif (c > 191 && c < 224) {\r\n\t\t\t\t\tif (i >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\r\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 223 && c < 240) {\r\n\t\t\t\t\tif (i + 1 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\r\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c > 239 && c < 248) {\r\n\t\t\t\t\tif (i + 2 >= length)\r\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\r\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\r\n\t\t\t\t}\r\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\r\n\t\t\t}\r\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\r\n\t\t\telse if (c <= 0x10ffff) {\r\n\t\t\t\tc -= 0x10000;\r\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\r\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\r\n\t\t\t}\r\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\r\n\t\t}\r\n\t\treturn str;\r\n\t}\r\n\r\n\t// The exported functions\r\n\tlet msgpack = {\r\n\t\tserialize: serialize,\r\n\t\tdeserialize: deserialize,\r\n\r\n\t\t// Compatibility with other libraries\r\n\t\tencode: serialize,\r\n\t\tdecode: deserialize\r\n\t};\r\n\r\n\t// Environment detection\r\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\r\n\t\t// Node.js\r\n\t\tmodule.exports = msgpack;\r\n\t}\r\n\telse {\r\n\t\t// Global object\r\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\r\n\t}\r\n\r\n})();\r\n","export type UUID = string;\r\n\r\nexport const now = () => Math.trunc(performance.timeOrigin + performance.now());\r\n\r\nexport const TAB_ID =\r\n  now().toString(36) +\r\n  Math.trunc(1296 * Math.random())\r\n    .toString(36)\r\n    .padStart(2, \"0\");\r\n\r\nlet localId = 0;\r\nexport const nextId = () => TAB_ID + \"_\" + (++localId).toString(36);\r\n","import { Binders, TAB_ID, error, listen } from \".\";\r\n\r\ntype Observer<T = any> = (\r\n  newValue: T | null,\r\n  oldValue: T | null,\r\n  key: string | null\r\n) => void;\r\n\r\nexport type Metadata<T = any> = [value: T, source?: string, expires?: number];\r\n\r\nexport interface StorageProvider {\r\n  getItem<T = any>(key: string): Metadata<T> | null;\r\n  setItem<T>(key: string, value: Metadata<T>): void;\r\n  removeItem(key: string): void;\r\n  observe?<T>(key: string, observer: Observer<T>): Binders;\r\n}\r\n\r\nexport const tryCatch = <T, C = undefined>(\r\n  expression: () => T,\r\n  errorHandler?: (error: any) => C,\r\n  clean?: () => void\r\n): T | C => {\r\n  try {\r\n    return expression();\r\n  } catch (e) {\r\n    return errorHandler?.(e) as any;\r\n  } finally {\r\n    clean?.();\r\n  }\r\n};\r\n\r\nexport interface TypedStorage {\r\n  get<T = any>(key: string): T | null;\r\n  set<T>(key: string, value: T, timeout?: number): T;\r\n  delete(key: string): void;\r\n  update<T = any>(\r\n    key: string,\r\n    newValue: (current: T | null) => T,\r\n    timeout?: number\r\n  ): T;\r\n  observe?<T = any>(key: string, observer: Observer<T>): Binders;\r\n}\r\n\r\nexport interface BoundStorage<T = any> {\r\n  get(): T | null;\r\n  set<Nulls extends null | undefined = never>(\r\n    value: T | Nulls,\r\n    timeout?: number\r\n  ): T | Nulls;\r\n  delete(): void;\r\n  update<Nulls extends null | undefined = never>(\r\n    newValue: (current: T | null) => T | Nulls,\r\n    timeout?: number\r\n  ): T | Nulls;\r\n  observe?(observer: Observer<T>): Binders;\r\n}\r\n\r\nconst serialize = JSON.stringify;\r\n\r\nconst deserialize: {\r\n  <T = any>(payload: string | null | undefined): T | null;\r\n} = (payload: string | null) =>\r\n  payload == null\r\n    ? null\r\n    : tryCatch(\r\n        () => JSON.parse(payload),\r\n        () => null\r\n      );\r\n\r\nexport const mapStorage = <P extends StorageProvider>(\r\n  provider: P\r\n): P[\"observe\"] extends undefined ? TypedStorage : Required<TypedStorage> => {\r\n  const set = <T>(key: string, value: T | null, timeout?: number) => {\r\n    if (value == null) {\r\n      provider.removeItem(key);\r\n    } else {\r\n      provider.setItem(key, [value, TAB_ID, timeout]);\r\n    }\r\n    return value as any;\r\n  };\r\n\r\n  let retries = 0;\r\n  const update = <T>(\r\n    key: string,\r\n    newValue: (current: T | null) => T | null,\r\n    timeout: number\r\n  ) => {\r\n    if (retries++ > 3) {\r\n      error(`Lost race ('${key}').`, true);\r\n    }\r\n    const value = set(key, newValue(provider.getItem<T>(key)?.[0] ?? null));\r\n    const writtenValue = provider.getItem(key);\r\n    if (writtenValue?.[1] && writtenValue?.[1] !== TAB_ID) {\r\n      return update(key, newValue, timeout);\r\n    }\r\n    retries = 0;\r\n    return value;\r\n  };\r\n\r\n  return {\r\n    get: (key) => provider.getItem(key)?.[0] ?? null,\r\n    set,\r\n    delete: (key) => set(key, null),\r\n    update,\r\n    observe: provider.observe ? provider.observe.bind(provider) : undefined,\r\n  };\r\n};\r\n\r\nexport const sharedStorage = mapStorage({\r\n  getItem: (key) => deserialize(localStorage.getItem(key)),\r\n  setItem: (key, value) =>\r\n    localStorage.setItem(\r\n      key,\r\n      serialize(value.filter((value) => value != null))\r\n    ),\r\n  removeItem: (key) => localStorage.removeItem(key),\r\n  observe: (key, observer) => {\r\n    const [unbind, bind] = listen(\r\n      window,\r\n      \"storage\",\r\n      ({ key: changedKey, newValue, oldValue }) =>\r\n        key == changedKey &&\r\n        observer(deserialize(newValue), deserialize(oldValue), key)\r\n    );\r\n\r\n    const [unbindShow, bindShow] = listen(window, \"pageshow\", bind);\r\n    const [unbindHide, bindHide] = listen(window, \"pagehide\", unbind);\r\n\r\n    return [\r\n      () => {\r\n        unbindHide();\r\n        unbindShow();\r\n        return unbind();\r\n      },\r\n      () => {\r\n        bindHide();\r\n        bindShow();\r\n        return bind();\r\n      },\r\n    ];\r\n  },\r\n});\r\n\r\nexport const bindStorage: {\r\n  <T>(key: string, storage?: Required<TypedStorage>): Required<BoundStorage<T>>;\r\n  <T>(key: string, storage: TypedStorage): BoundStorage<T>;\r\n} = <T>(\r\n  key: string,\r\n  storage: TypedStorage = sharedStorage\r\n): Required<BoundStorage<T>> => ({\r\n  get: () => storage.get<T>(key),\r\n  set: (value, timeout) => storage.set(key, value, timeout),\r\n  delete: () => storage.delete(key),\r\n  update: (updater, timeout) => storage.update(key, updater as any, timeout),\r\n  observe: storage.observe\r\n    ? (observer) => storage.observe!(key, observer)\r\n    : undefined!,\r\n});\r\n\r\nexport const bindStickyStorage = <T>(\r\n  key: string,\r\n  storage: Required<TypedStorage> = sharedStorage\r\n): Required<BoundStorage<T>> => {\r\n  if (!storage.observe) {\r\n    throw new TypeError(\"Storage must be observable.\");\r\n  }\r\n\r\n  type V = [value: T | null, version: number];\r\n\r\n  const inner = bindStorage<V>(key, storage);\r\n  let current: V = inner.get() ?? [null, 0];\r\n  let stored: V | null;\r\n\r\n  const isValid = (stored: any | null) =>\r\n    stored === null || (stored.length === 2 && typeof stored[1] === \"number\");\r\n  const isStale = (stored: V | null) => !((stored?.[1] as any) >= current[1]);\r\n\r\n  const ensureValue = () => {\r\n    stored = inner.get();\r\n    if (isStale(stored)) {\r\n      inner.set(current);\r\n      return current;\r\n    }\r\n    return (current = stored!);\r\n  };\r\n\r\n  inner.observe((value) => {\r\n    if (isStale(value)) {\r\n      ensureValue();\r\n    } else {\r\n      current = value!;\r\n    }\r\n  });\r\n\r\n  return {\r\n    get: () => ensureValue()[0],\r\n    set: (value, timeout) =>\r\n      inner.set(\r\n        value === null ? null : ([value, ensureValue()[1] + 1] as any),\r\n        timeout\r\n      )?.[0],\r\n    delete: () => inner.delete(),\r\n    update: (updater, timeout) =>\r\n      inner.update(() => {\r\n        const current = ensureValue();\r\n        return [updater(current[0]), current[1] + 1] as any;\r\n      }, timeout),\r\n    observe: (observer) =>\r\n      inner.observe!((newValue, previousValue, key) => {\r\n        if (!isValid(newValue)) return;\r\n        if (!isStale(newValue)) {\r\n          observer(\r\n            newValue![0],\r\n            (isValid(previousValue) && previousValue?.[0]) || null,\r\n            key\r\n          );\r\n        }\r\n      }),\r\n  };\r\n};\r\n","type AllMaps = WindowEventMap &\r\n  GlobalEventHandlersEventMap &\r\n  DocumentEventMap &\r\n  HTMLElementEventMap;\r\n\r\nexport type Rebinder = () => boolean;\r\nexport type Unbinder = () => boolean;\r\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\r\n\r\nexport const combine = <T extends (...args: any) => any>(\r\n  ...functions: T[]\r\n): T extends (...args: infer A) => infer R\r\n  ? (...args: A) => R extends void ? void : R[]\r\n  : never => ((...args: any[]) => functions.map((f) => f(...args))) as any;\r\n\r\nexport type Listener<Arg> = (arg: Arg, unbind: Unbinder) => void;\r\nexport const createBinders = <Arg>(\r\n  listener: Listener<Arg>,\r\n  attach: (listener: (arg: Arg) => void) => void,\r\n  detach: (listener: (arg: Arg) => void) => void\r\n): Binders => {\r\n  let bound = false;\r\n  const unbind = () =>\r\n    bound !== (bound = false) && (detach(outerListener), true);\r\n  const rebind = () =>\r\n    bound !== (bound = true) && (attach(outerListener), true);\r\n\r\n  const outerListener = (arg: Arg) => listener(arg, unbind);\r\n  rebind();\r\n  return [unbind, rebind];\r\n};\r\n\r\nexport const listen = <K extends keyof AllMaps>(\r\n  target: {\r\n    addEventListener(\r\n      type: string,\r\n      listener: EventListenerOrEventListenerObject,\r\n      options?: boolean | AddEventListenerOptions\r\n    ): void;\r\n    removeEventListener(\r\n      type: string,\r\n      listener: EventListenerOrEventListenerObject,\r\n      options?: boolean | EventListenerOptions\r\n    ): void;\r\n  },\r\n  name: K,\r\n  listener: (ev: AllMaps[K], unbind?: Unbinder) => any,\r\n  options: AddEventListenerOptions = { capture: true, passive: true }\r\n) =>\r\n  createBinders(\r\n    listener,\r\n    (listener) => target.addEventListener(name, listener, options),\r\n    (listener) => target.addEventListener(name, listener, options)\r\n  );\r\n\r\n// export const listen = <K extends keyof AllMaps>(\r\n//   el: any,\r\n//   names: K[] | K,\r\n//   cb: (ev: AllMaps[K], unbind: () => void) => void,\r\n//   capture = true,\r\n//   passive = true\r\n// ) => {\r\n//   let unbinders: any[] = [];\r\n\r\n//   return (\r\n//     toArray(names).map((name, i) => {\r\n//       const mapped = (ev: any) => {\r\n//         cb(ev, unbinders[i]);\r\n//       };\r\n//       push(unbinders, () => el.removeEventListener(name, mapped, capture));\r\n//       return el.addEventListener(name, mapped, { capture, passive });\r\n//     }),\r\n//     () =>\r\n//       unbinders.length > 0 && map(unbinders, (unbind) => unbind())\r\n//         ? ((unbinders = []), T)\r\n//         : F\r\n//   );\r\n// };\r\n","import { TAB_ID, bindStorage, sharedStorage } from \".\";\r\n\r\nexport type Channel<T> = {\r\n  post(sender: string, payload: T): void;\r\n  unsubscribe: () => void;\r\n};\r\n\r\nexport type SynchronizedStorage<T> = {\r\n  get(): T | null;\r\n  update<V extends T | null>(update: (oldValue: T | null) => V): V;\r\n};\r\n\r\ntype ChannelPayload<T> = {\r\n  sender: string;\r\n  payload: T;\r\n  target?: string;\r\n};\r\n\r\nexport const createChannel = <T>(\r\n  id: string,\r\n  handler: (sender: string, payload: T) => void\r\n): Channel<T> => {\r\n  const storage = bindStorage<ChannelPayload<T>>(id, sharedStorage);\r\n\r\n  return {\r\n    post: (sender, payload) => {\r\n      storage.set({ sender, payload });\r\n      storage.delete();\r\n    },\r\n    unsubscribe: storage.observe((value) => {\r\n      if (value && (!value.target || value.target === TAB_ID)) {\r\n        handler(value.sender, value.payload);\r\n      }\r\n    })[0],\r\n  };\r\n};\r\n\r\nlet chatChannel: Channel<string> | undefined;\r\nexport const error: {\r\n  (message: string, fatal: boolean): void;\r\n  (message: string, cause?: any, fatal?: boolean);\r\n} = (message: string, error?: any, throwError = false) => {\r\n  if (typeof error === \"boolean\") {\r\n    throwError = error;\r\n    error = null;\r\n  }\r\n  if (error?.message) {\r\n    message += \"(\" + error.message;\r\n    error.stack && (message += \"\\n\\n\" + error.stack);\r\n    message += \")\";\r\n  }\r\n  console.error(message);\r\n  if (throwError) {\r\n    throw new Error(message);\r\n  }\r\n};\r\nexport const log = (message: any) => {\r\n  typeof message === \"object\" && (message = JSON.stringify(message));\r\n\r\n  (chatChannel ??= createChannel<string>(\"chat\", (sender, message) => {\r\n    console.log(`Other tab (${sender}): ${message}`);\r\n  })).post(TAB_ID, message);\r\n  console.log(`This tab: ${message}`);\r\n};\r\n\r\n// export const createSynchronizedStorage = <T>(id: string) => {\r\n//   type V = { serial: number; value: null };\r\n\r\n//   let currentValue: V = { serial: 0, value: null };\r\n\r\n//   const refresh = () => {\r\n//     const storedValue = deserialize<V>(localStorage.getItem(id));\r\n//     if (storedValue && storedValue.serial > currentValue.serial) {\r\n//       log(\"Value updated.\");\r\n//       currentValue = storedValue;\r\n//     } else if (\r\n//       !storedValue?.serial ||\r\n//       storedValue.serial < currentValue.serial\r\n//     ) {\r\n//       log(\"Restored the value.\");\r\n//       // Someone deleted the key, or the current value is not compatible with us.\r\n//       localStorage.setItem(id, serialize(currentValue));\r\n//     }\r\n//     return currentValue;\r\n//   };\r\n\r\n//   const storageHandler = ({ key }: StorageEvent) => {\r\n//     if (key === id) {\r\n//       refresh();\r\n//     }\r\n//   };\r\n\r\n//   const recover = () => {\r\n//     const storedValue = deserialize<V>(localStorage.getItem(id));\r\n//     if (!storedValue?.serial || storedValue.serial < currentValue.serial) {\r\n//       //localStorage.setItem\r\n//     }\r\n//   };\r\n//   const wire = () => {\r\n//     refresh();\r\n//     window.addEventListener(\"storage\", storageHandler);\r\n//   };\r\n\r\n//   const unwire = () => window.removeEventListener(\"storage\", storageHandler);\r\n\r\n//   window.addEventListener(\"pageshow\", wire);\r\n//   window.addEventListener(\"pagehide\", unwire);\r\n\r\n//   wire();\r\n\r\n//   let storage: SynchronizedStorage<T> = {\r\n//     get: () => refresh().value,\r\n//     update: (update) => {\r\n//       const updated = update(refresh().value);\r\n//       localStorage.setItem(\r\n//         id,\r\n//         serialize(\r\n//           (currentValue = {\r\n//             serial: currentValue.serial + 1,\r\n//             value: updated as any,\r\n//           })\r\n//         )\r\n//       );\r\n//       return updated;\r\n//     },\r\n//   };\r\n//   return storage;\r\n// };\r\n","import { isPureObject } from \"@tailjs/util\";\r\nimport { TAB_ID, bindStorage, listen, now } from \"./lib2\";\r\n\r\nconst enum TabState {\r\n  Open = 1,\r\n  Active = 2,\r\n  Closed = 3,\r\n}\r\n\r\ntype ChatMessage = {\r\n  message?: string;\r\n  tab?: TabState;\r\n};\r\n\r\ntype TabData = {};\r\n\r\ntype State = {\r\n  openTabs: Record<string, TabData>;\r\n};\r\n\r\nconst state: State = {\r\n  openTabs: { [TAB_ID]: {} },\r\n};\r\n\r\nconst activeTabs = bindStorage<Record<string, number>>(\"active2\");\r\n\r\nexport const attach = async () => {\r\n  listen(\r\n    window,\r\n    \"pageshow\",\r\n    () =>\r\n      activeTabs.update(\r\n        (current) => (\r\n          ((current = isPureObject(current) ? current : {})[TAB_ID] = now()),\r\n          current\r\n        )\r\n      )\r\n    //activeStorage.update((current) => (current ?? 0) + 1)\r\n  );\r\n  listen(\r\n    window,\r\n    \"pagehide\",\r\n    () =>\r\n      activeTabs.update(\r\n        (current) => (isPureObject(current) && delete current[TAB_ID], current)\r\n      )\r\n    // activeStorage.update((current: any) =>\r\n    //   current > 0 ? current - 1 : current\r\n    // )\r\n  );\r\n};\r\n","import { INITIALIZE_TRACKER_FUNCTION } from \"@constants\";\n//import { initializeTracker } from \"./initializeTracker\";\n//import { F, T, define, window } from \"./lib\";\nimport { attach } from \"./pusher\";\n\n// This assumes the script is loaded from the RequestHandler's ?cfg route.\n\n// To prevent external scripts from eaves-dropping and get a hold of the storage key, this is how initialization works:\n// 1: The configuration scripts appends a <script> element with this script, and adds a \"loaded\" handler.\n// 2: This script defines a non-configurable method on the window. This prevents it from being overriden if something intercepts the \"loaded\" handler before the configuration script.\n// 3: The configuration script calls this function with a callback that initializes the tracker with the configuration including the storage key.\n\nwindow[INITIALIZE_TRACKER_FUNCTION] = (callback: any) => {\n  callback(attach);\n};\n\n// let loaded = F;\n// define(window, {\n//   [INITIALIZE_TRACKER_FUNCTION]: [\n//     (callback: (init: typeof initializeTracker) => void) => {\n//       if (loaded === (loaded = T)) return;\n//       callback(initializeTracker);\n//     },\n//   ],\n// });\n"],"names":["Array","isArray","isObject","value","isPureObject","isIterable","Symbol","iterator","forEach","p","i","charCodeAt","FNVs","32","64","128","entropy","floatBuffer","serialize","data","options","multiple","Error","floatView","pow32","array","Uint8Array","length","append","subarray","isReplacement","appendNull","appendByte","lo","isFinite","Math","floor","appendBytes","hi","appendInt64","ArrayBuffer","DataView","setFloat64","appendNumber","bytes","str","ascii","x","ci","c","c2","toString","encodeUtf8","appendString","Date","ns","sec","getTime","getMilliseconds","appendDate","appendArray","Uint8ClampedArray","appendBinArray","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","key","appendObject","invalidTypeReplacement","index","byte","newLength","newArray","set","abs","deserialize","pos","push","read","readMap","readArray","readStr","readBin","readExt","readFloat","readUInt","readInt","console","debug","size","first","view","buffer","byteOffset","getFloat32","getFloat64","lengthSize","start","String","fromCharCode","decodeUtf8","type","msgpack","encode","decode","module","exports","window","msgpackJsName","hash","prime","mixer","mixer255","iw","s","resetMixer","updateMixer","source","cipher","numericOrBits","bits","BigInt","asUintN","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","lfsr","createTransport","provider","retries","update","now","trunc","performance","timeOrigin","TAB_ID","random","padStart","listen","target","name","listener","capture","passive","bound","unbind","addEventListener","outerListener","rebind","arg","createBinders","JSON","stringify","payload","parse","e","sharedStorage","get","getItem","timeout","removeItem","setItem","delete","newValue","error","writtenValue","observe","localStorage","filter","observer","bind","changedKey","oldValue","unbindShow","bindShow","unbindHide","bindHide","message","throwError","stack","activeTabs","storage","updater","bindStorage","attach","async","current","callback"],"mappings":"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","x_google_ignoreList":[5]}