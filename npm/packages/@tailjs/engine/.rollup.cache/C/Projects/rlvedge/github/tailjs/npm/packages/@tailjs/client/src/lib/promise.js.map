{"version":3,"file":"promise.js","sourceRoot":"","sources":["promise.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,SAAS,EAAE,MAAM,GAAG,CAAC;AAE3D,MAAM,CAAC,MAAM,OAAO,GAGhB,CAAC,GAAG,IAAW,EAAE,EAAE,CACrB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,CAAE,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAS,CAAC;AAEnE;;GAEG;AACH,MAAM,CAAC,MAAM,KAAK,GAAG,MAAM,EAAE,CAAC;AAmB9B;;GAEG;AACH,MAAM,CAAC,MAAM,OAAO,GAAG,MAAM,EAAE,CAAC;AAKhC;;GAEG;AACH,MAAM,CAAC,MAAM,WAAW,GAGpB,CAAC,OAAgB,EAAoB,EAAE;IACzC,IAAI,cAAc,GAAyB,GAAI,CAAC;IAChD,IAAI,cAAc,GAAiB,GAAI,CAAC;IACxC,IAAI,QAAQ,GAAQ,SAAS,CAAC;IAE9B,MAAM,KAAK,GAAG,GAAG,EAAE;QACjB,QAAQ,GAAG,SAAS,CAAC;QACrB,IAAI,eAAe,GAAkC,GAAG,CAAC;QAEzD,cAAc,GAAG,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YACnC,cAAc,GAAG,eAAe,GAAG,CAAC,KAAK,EAAE,EAAE,CAC3C,eAAe;gBACf,CAAC,CAAC,eAAe,GAAG,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAC3D,CAAC,CAAC,CAAC;QAEH,IAAI,OAAO,EAAE,CAAC;YACZ,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,eAAe,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;QACxD,CAAC;IACH,CAAC,CAAC;IACF,KAAK,EAAE,CAAC;IACR,MAAM,CAAC,GAAG,MAAM,CACd,CAAC,GAAG,IAAW,EAAO,EAAE,CACtB,CAAC,IAAI,CAAC,IAAI,CAAC;QACT,CAAC,CAAC,QAAQ;QACV,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,KAAK;YAChB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,QAAQ,KAAK,SAAS,CAAC,IAAI,KAAK,EAAE;YACtD,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC3B,CAAC,CAAC,EACR;QACE,IAAI,EAAE,CAAC,GAAG,IAAS,EAAE,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;KACrD,CACF,CAAC;IAEF,OAAO,CAAC,CAAC;AACX,CAAC,CAAC","sourcesContent":["import { T, assign, delay, nil, size, undefined } from \".\";\n\nexport const promise: {\n  <T>(): Promise<void>;\n  <T>(...args: ConstructorParameters<typeof Promise<T>>): Promise<T>;\n} = (...args: any[]) =>\n  !args.length ? Promise.resolve() : (new Promise(args[0]) as any);\n\n/**\n * Magic value to reset an  {@link OpenPromise}.\n */\nexport const Reset = Symbol();\n\nexport type OpenPromise<T = boolean> = PromiseLike<T> & {\n  /**\n   * Resolves the promise with the specified value.\n   */\n  (value: T): OpenPromise<T>;\n\n  /**\n   * Resets the promise, optionally only if completed\n   */\n  (reset: typeof Reset, ifCompleted?: boolean): OpenPromise<T>;\n\n  /**\n   * Tests whether the promise is resolved, optionally timed out.\n   */\n  (): T | undefined;\n};\n\n/**\n * Indicates that an {@link OpenPromiseWithTimeout} has timed out.\n */\nexport const Expired = Symbol();\nexport type OpenPromiseWithTimeout<T = boolean> = OpenPromise<\n  T | typeof Expired\n>;\n\n/**\n * Creates a new {@link OpenPromise} or {@link OpenPromiseWithTimeout} if a timeout is specified.\n */\nexport const openPromise: {\n  <T = boolean>(): OpenPromise<T>;\n  <T = boolean>(timeout: number): OpenPromiseWithTimeout<T>;\n} = (timeout?: number): OpenPromise<any> => {\n  let currentResolve: (value: any) => void = nil!;\n  let currentPromise: Promise<any> = nil!;\n  let resolved: any = undefined;\n\n  const reset = () => {\n    resolved = undefined;\n    let capturedResolve: ((value: any) => void) | null = nil;\n\n    currentPromise = promise((resolve) => {\n      currentResolve = capturedResolve = (value) =>\n        capturedResolve &&\n        ((capturedResolve = nil), resolve((resolved = value)));\n    });\n\n    if (timeout) {\n      delay(timeout).then(() => capturedResolve?.(Expired));\n    }\n  };\n  reset();\n  const p = assign(\n    (...args: any[]): any =>\n      !size(args)\n        ? resolved\n        : (args[0] === Reset\n            ? (args[1] !== T || resolved !== undefined) && reset()\n            : currentResolve(args[0]),\n          p),\n    {\n      then: (...args: any) => currentPromise.then(...args),\n    }\n  );\n\n  return p;\n};\n"]}