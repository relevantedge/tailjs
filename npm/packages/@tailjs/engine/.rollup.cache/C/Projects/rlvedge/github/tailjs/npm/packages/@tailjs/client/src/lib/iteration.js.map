{"version":3,"file":"iteration.js","sourceRoot":"","sources":["iteration.ts"],"names":[],"mappings":"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","sourcesContent":["// Utility functions for arrays and iterables.\n\nimport {\n  isObject,\n  type ArgNulls,\n  type ConstToNormal,\n  type IterableOrArrayLike,\n  type IterableOrSelf,\n  type KeyValueProjection,\n  type Nullish,\n  type Nulls,\n} from \"@tailjs/util\";\nimport { F, T, array, bool, fun, hashSet, iterable, nil, num, obj } from \".\";\n\n/**\n * Array's `sort` function that offers a single function that is applied on each element instead of having to do it twice (`[...].sort(x,y)=>f(x)-f(y)`).\n * Default is to use the value directly.\n */\nexport const sort = <T = number, Arg = any>(\n  items: ArgNulls<T[], Arg>,\n  sortKey: (item: T) => number = (item) => item as any\n): Nulls<Arg> =>\n  (items?.sort((lhs, rhs) => sortKey(lhs) - sortKey(rhs)), items) as any;\n\n/**\n * Array's `splice` method for efficient minifying.\n */\nexport const splice = <T, Arg>(\n  value: ArgNulls<T[], Arg>,\n  start: number,\n  deleteCount?: number,\n  ...values: T[]\n): T[] | Nulls<Arg> =>\n  value &&\n  (deleteCount != nil\n    ? (value.splice as any)(start, deleteCount, ...values)\n    : (value.splice as any)(start));\n\n/**\n * Array's `unshift` method for efficient minifying that also returns the array itself for fluent convenience.\n */\nexport const unshift = <T extends { unshift(...args: any): any }, Arg>(\n  target: ArgNulls<T, Arg>,\n  ...values: T[\"unshift\"] extends (...args: infer A) => any ? A : never\n): T | Nulls<Arg, undefined> => (target?.unshift(...values), target) as any;\n\n/**\n * Array's `shift` method for efficient minifying.\n */\nexport const shift = <T>(array: { shift(): T } | Nullish) => array?.shift();\n\n/**\n * Array's `push` method for efficient minifying that also returns the array itself for fluent convenience.\n */\nexport const push = <T extends { push(...args: any): any }, Arg>(\n  target: ArgNulls<T, Arg>,\n  ...values: T[\"push\"] extends (...args: infer A) => any ? A : never\n): T | Nulls<Arg, undefined> => (target?.push(...values), target) as any;\n\n/**\n * Array's `pop` method for efficient minifying.\n */\nexport const pop = <T>(array: { pop(): T } | Nullish) => array?.pop();\n\n/**\n * Like Array's `concat` but supports iterables.\n */\nexport const concat = <T>(...sources: (IterableOrSelf<T> | Nullish)[]): T[] =>\n  size((sources = filter(sources))) < 2\n    ? map(sources[0])\n    : ([].concat(...(map(sources as any, map as any) as any)) as any);\n\n/**\n * Gives the distinct elements of the specified values. If a value is iterable it is expanded.\n */\nexport const distinct = <T>(\n  ...values: (IterableOrSelf<T | Nullish> | Nullish)[]\n): T[] => map(hashSet<T>(filter(concat(...values)))) as any;\n\n/**\n * Constructs a range (or empty array) with the given attributes.\n */\nexport const range: {\n  (length: number, empty?: false): number[];\n  (length: number, empty: true): undefined[];\n  <T = number>(length: number, project: (n: number) => T): T[];\n  (start: number, end: number): number[];\n} = (arg0: any, arg1: any) =>\n  arg1 === T\n    ? [...Array(arg0)]\n    : num(arg1)\n    ? range(arg1 - arg0, (n) => arg0 + n)\n    : (fun(arg1) || (arg1 = ((n: number) => n) as any),\n      map(range(arg0, T), (_, i) => (arg1 as any)(i)));\n\n/**\n * The length of an array and strings, size of sets and maps and the number of keys in an object.\n *\n * If the value is a primitive type (not string) the size is defined as 0.\n */\nexport const size = (\n  item:\n    | Iterable<any>\n    | Record<keyof any, any>\n    | { size: number }\n    | { length: number }\n    | Nullish\n) =>\n  item == nil\n    ? 0\n    : item[\"length\"] ?? item[\"size\"] ?? (obj(item) ? keys(item).length : 0);\n\n/**\n * An extended version of Object.entries that also supports maps, sets and arrays.\n */\nexport const entries: {\n  <K, V, P = [K, V]>(\n    map:\n      | {\n          entries(): Iterable<[K, V]>;\n        }\n      | Nullish,\n    project?: KeyValueProjection<K, V, P>\n  ): ConstToNormal<P>[];\n  <V, P = [number, V]>(\n    array: V[],\n    project?: KeyValueProjection<number, V, P>\n  ): ConstToNormal<P>[];\n  <K extends keyof any = keyof any, V = any, P = [K, V]>(\n    record: { [key in K]?: V },\n    project?: KeyValueProjection<K, V, P>\n  ): ConstToNormal<P>[];\n} = (mapOrRecord: any, project?: any) =>\n  !mapOrRecord\n    ? []\n    : array(mapOrRecord)\n    ? map(mapOrRecord, (value, index) =>\n        project ? project(index, value) : [index, value]\n      )\n    : map(mapOrRecord.entries?.() ?? Object.entries(mapOrRecord), project);\n\n/**\n * An extended version of Object.keys that also supports maps and sets.\n */\nexport const keys: {\n  <K = keyof any, P = K>(\n    map:\n      | {\n          keys(): Iterable<K>;\n        }\n      | Nullish,\n    project?: (key: K, index: number) => P\n  ): ConstToNormal<P>[];\n  <K extends keyof any = keyof any, P = K>(\n    record: { [key in K]?: any },\n    project?: (key: K, index: number) => P\n  ): ConstToNormal<P>[];\n} = (mapOrRecord: any, project?: any) =>\n  !mapOrRecord\n    ? []\n    : map(mapOrRecord.keys?.() ?? Object.keys(mapOrRecord), project);\n\n/**\n * An extended version of Object.values that also supports arrays and sets.\n */\nexport const values: {\n  <V, P = V>(\n    map:\n      | {\n          values(): Iterable<V>;\n        }\n      | Nullish,\n    project?: (value: V, index: number) => P\n  ): ConstToNormal<P>[];\n  <V = any, P = V>(\n    record: { [key in keyof any]?: V },\n    project?: (value: V, index: number) => P\n  ): ConstToNormal<P>[];\n} = (mapOrRecord: any, project?: any) =>\n  !mapOrRecord\n    ? []\n    : map(mapOrRecord.values?.() ?? Object.values(mapOrRecord), project);\n\n/**\n * Generalized version of Array's `forEach` method that enables breaking and a return value.\n * Non iterables are intepreted as an array with themselves as the only item.\n *\n * If the `breakSignal` is called, iteration will stop.\n * For convenience the break function can be called with a value that will then be passed through to combine breaking and returning a value.\n * This does not change the return value by itself.\n *\n * `const hasPositive = forEach(numbers, (x,_,stop)=>x > 0 && stop(true))`\n *\n * @returns The last returned value from the action.\n */\nexport const forEach = <T, R = void, InitialValue = undefined>(\n  items: IterableOrSelf<T> | Nullish,\n  action: (\n    item: T,\n    index: number,\n    breakSignal: <T>(passThroughValue?: T) => T,\n    currentValue: R | InitialValue\n  ) => R,\n  initialValue?: InitialValue\n): InitialValue | R => {\n  if (item == nil || !size(iterable(items) ? items : (items = [items] as any)))\n    return initialValue as any;\n\n  const breakSignal = (...args: any) => (\n    (index = 0), size(args) ? args[0] : initialValue\n  );\n\n  let index = 0;\n  for (const item of items as any)\n    if (\n      ((initialValue = action(\n        item,\n        index++,\n        breakSignal,\n        initialValue as any\n      ) as any),\n      !index) // Index is set to zero from the breakSignal\n    )\n      break;\n\n  return initialValue as any;\n};\n\n/**\n * Generalized version of Array's `map` method that also supports iterables and node lists.\n *\n * If called without a projection, it converts whatever is passed to it to an array.\n * When the value is already an array, the `clone` parameter decides whether the array itself or a clone should be returned.\n */\nexport const map: {\n  <T, P = T extends IterableOrArrayLike<infer T> ? T : T>(\n    value: IterableOrSelf<T> | Nullish,\n    projection: (item: T, index: number) => P\n  ): ConstToNormal<P>[];\n  <T, P = T extends IterableOrArrayLike<infer T> ? T : T>(\n    value: IterableOrSelf<T> | Nullish,\n    clone?: boolean\n  ): ConstToNormal<P>[];\n} = (value: any, cloneOrProject?: any): any[] =>\n  value == nil\n    ? []\n    : fun(cloneOrProject)\n    ? (map(value, F).map((value, index) => cloneOrProject(value, index)) as any)\n    : array(value) && !cloneOrProject\n    ? value\n    : (iterable(value) && [...value]) || [value];\n\n/**\n * A generalized version of Array's `flatMap` that also supports iterables and node lists.\n */\nexport const flatMap: {\n  <T, P = T extends Iterable<infer T> ? T : T>(\n    value: IterableOrArrayLike<T> | T | Nullish,\n    project: (item: T, index: number) => P | P[]\n  ): ConstToNormal<P>[];\n} = <T, P = T>(\n  value: T | Iterable<T | Nullish> | Nullish,\n  projection: (item: T, index: number) => P | P[] = (item) => item as any\n): ConstToNormal<P>[] =>\n  value == nil\n    ? []\n    : (filter(map(value, F)).flatMap((item, index) =>\n        projection(item as any, index)\n      ) as any);\n\n/**\n * A convenience method for returning the n'th item from an iterable or the n'th character from a string.\n *\n * If the source is not alrady an array (or indexable by an item method), it will be converted to one first.\n * The latter feature should be used with caution since it adds a terrible performance overhead if used from within a loop.\n */\nexport const item: {\n  <T>(\n    array:\n      | Iterable<T>\n      | T\n      | { [index: number]: T; length: number }\n      | string\n      | null\n      | undefined,\n    index?: number\n  ): T | undefined;\n  (text: string, index?: number): string | undefined;\n} = <T>(source: any, index = 0): T | undefined =>\n  source == nil\n    ? undefined\n    : (source.length == null && (source = map(source)),\n      source.item,\n      source[index < 0 ? (source as T[]).length + index : index]);\n\n/**\n * A generalized version of Array's `filter` that works on all the types supported by {@link map}.\n *\n * In addition it allows an empty result to be returned as `null`\n */\nexport const filter: {\n  <T, R extends T = T, B extends boolean = false>(\n    value: IterableOrSelf<T> | Nullish,\n    predicate: (item: R, index: number) => any,\n    emptyIsNull?: B\n  ): T[] | (B extends true ? null : never);\n  <T, B extends boolean = false>(\n    value: IterableOrSelf<T | Nullish> | Nullish,\n    emptyIsNull?: B\n  ): T[] | (B extends true ? null : never);\n} = <T>(\n  value: IterableOrSelf<T> | Nullish,\n  predicate?: boolean | ((item: T, index: number) => any),\n  emptyIsNull = bool(predicate) || F\n): T[] =>\n  ((value = (map(value) as any).filter((item: any, index: any) =>\n    (fun(predicate, true) ?? ((item: any) => item != nil))(item, index)\n  )),\n  emptyIsNull && !size(value!) ? nil : value) as any;\n\n/**\n * A convenience method to test whether an iterable has any element matching the predicate specified.\n *\n * If the parameter is not iterable is in interpreted as an array with itself as the only element.\n */\nexport const any = <T>(\n  value: IterableOrSelf<T>,\n  predicate: (item: T, index: number) => any = (item) =>\n    item != (nil as any) && item !== F\n): boolean => {\n  return (\n    value != nil &&\n    (iterable(value) || isObject(value)) &&\n    (!predicate\n      ? !!size(value as any)\n      : forEach(value, (item, i, stop) => predicate(item, i) && stop(T), F))\n  );\n};\n\n/**\n * Array's `reduce` method that also works for iterables.\n */\nexport const reduce = <T, V>(\n  items: IterableOrArrayLike<T>,\n  reducer: (previous: V, item: T) => V,\n  initialValue: V\n) =>\n  map(items).reduce(\n    (previous, current) => reducer(previous, current as any),\n    initialValue\n  );\n\n/**\n * Takes the sum of the items in an iterable.\n */\nexport const sum = <T, Arg>(\n  items: ArgNulls<IterableOrArrayLike<T>, Arg>,\n  selector?: (item: T) => number\n): number | Nulls<Arg> =>\n  items &&\n  (reduce(\n    items,\n    (sum, item) => (selector?.(item) ?? (item as number)) + sum,\n    0\n  ) as any);\n\n/**\n * Returns the highest value in a series of numbers.\n */\nexport const max: (typeof Math)[\"max\"] = (...values) => Math.max(...values);\n"]}