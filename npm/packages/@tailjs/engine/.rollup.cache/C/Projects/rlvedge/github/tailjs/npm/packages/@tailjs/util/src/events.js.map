{"version":3,"file":"events.js","sourceRoot":"","sources":["events.ts"],"names":[],"mappings":"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","sourcesContent":["import { filter, isUndefined, reduce } from \".\";\n\nexport type Rebinder = () => boolean;\nexport type Unbinder = () => boolean;\nexport type Binders = [unbind: Unbinder, rebind: Rebinder];\n\nexport type SourceListener<Args extends any[]> = (...args: Args) => void;\nexport type Listener<Args extends any[]> = (\n  ...args: [...args: Args, unbind: Unbinder]\n) => void;\n\nexport const createEventBinders = <Args extends any[]>(\n  listener: Listener<Args>,\n  attach: (listener: SourceListener<Args>) => void,\n  detach: (listener: SourceListener<Args>) => void\n): Binders => {\n  let bound = false;\n\n  const outerListener = (...args: Args) => listener(...args, unbind);\n\n  const unbind = () =>\n    bound !== (bound = false) && (detach(outerListener), true);\n\n  const rebind = () =>\n    bound !== (bound = true) && (attach(outerListener), true);\n\n  rebind();\n  return [unbind, rebind];\n};\n\nexport const joinEventBinders = (\n  ...binders: (Binders | undefined)[]\n): Binders => (\n  (binders = filter(binders)),\n  [\n    () => reduce(binders, (changed, binder) => binder![0]() || changed, false),\n    () => reduce(binders, (changed, binder) => binder![1]() || changed, false),\n  ]\n);\n\nexport type EventHandler<Args extends any[]> = (...payload: Args) => void;\n\nexport const createEvent = <Args extends any[]>(): [\n  listen: (listener: Listener<Args>, triggerCurrent?: boolean) => Binders,\n  dispatch: (...payload: Args) => void\n] => {\n  const listeners = new Set<SourceListener<Args>>();\n  let dispatchedArgs: Args | undefined;\n  return [\n    (handler, trigger) => {\n      const binders = createEventBinders(\n        handler,\n        (handler) => listeners.add(handler),\n        (handler) => listeners.delete(handler)\n      );\n      trigger && dispatchedArgs && handler(...dispatchedArgs, binders[0]);\n      return binders;\n    },\n    (...payload) => (\n      (dispatchedArgs = payload),\n      listeners.forEach((handler) => handler(...payload))\n    ),\n  ];\n};\n\nexport type ChainedEventHandler<Args extends any[], T> = (\n  ...args: [\n    ...args: Args,\n    next: {\n      (): T;\n      (...args: Args): T;\n    },\n    unbind: Unbinder\n  ]\n) => T;\n\ntype LinkedNode<T> = [\n  prev: LinkedNode<T> | undefined,\n  item: T,\n  next: LinkedNode<T> | undefined\n];\n\nexport const createChainedEvent = <T = void, Args extends any[] = []>(): [\n  register: (\n    handler: ChainedEventHandler<Args, T>,\n    priority?: number\n  ) => Binders,\n  invoke: (...args: Args) => T | undefined\n] => {\n  type Item = [\n    handler: ChainedEventHandler<Args, T>,\n    priority: number,\n    binders: Binders\n  ];\n  type Node = LinkedNode<Item>;\n  let head: Node | undefined;\n  let tail: Node | undefined;\n  let next: Node | undefined;\n\n  const register = (\n    handler: ChainedEventHandler<Args, T>,\n    // Make sure that handler gets rebound at their previous priority without jumping discrete increments.\n    // (It is deseriable to be able to specfiy priority 0 or  10 without having to think about how many 0s there are)\n    priority = (tail?.[1][1] ?? 0) + 0.000001\n  ) => {\n    const registerNode = (node?: Node) => {\n      let bound = true;\n      node ??= [\n        undefined,\n        [\n          handler,\n          priority,\n          [\n            () => {\n              if (!bound) return false;\n              node![0] ? (node![0][2] = node![2]) : (head = node![2]);\n              node![2] ? (node![2][0] = node![0]) : (tail = node![0]);\n              node![0] = node![2] = undefined;\n              return !(bound = false);\n            },\n            () => (bound ? false : (registerNode(node), (bound = true))),\n          ],\n        ],\n        undefined,\n      ];\n      next = head;\n      if (!next) {\n        head = tail = node;\n      } else if (priority >= tail![1][1]) {\n        node[0] = tail;\n        tail = tail![2] = node;\n      } else {\n        // INV: priority < tail.priority, so next will be non-null after loop;\n        while (next![1][1]! <= priority) {\n          next = next[2]!;\n        }\n\n        (node[0] = (node[2] = next)[0]) ? (node[0][2] = node) : (head = node);\n        next[0] = node;\n      }\n\n      return node[1][2];\n    };\n    return registerNode();\n  };\n\n  const invoke = (node: Node | undefined, args: Args) => (\n    (next = node?.[2]),\n    node\n      ? node[1][0](\n          ...args,\n          (...nextArgs: Args) =>\n            invoke(next!, nextArgs.length ? nextArgs : args),\n          node[1][2][0]\n        )\n      : undefined\n  );\n\n  return [register, (...args) => invoke(head, args)];\n};\n"]}