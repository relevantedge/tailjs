{"version":3,"file":"EventParser.js","sourceRoot":"","sources":["EventParser.ts"],"names":[],"mappings":"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","sourcesContent":["import { TrackedEvent } from \"@tailjs/types\";\nimport { Schema, Validator } from \"jsonschema\";\nimport { ReadOnlyRecord } from \"./lib\";\nimport { JsonString } from \"./shared\";\n\nexport function getErrorMessage(validationResult: any) {\n  return !validationResult[\"type\"] ? validationResult[\"error\"] : null;\n}\n\nexport type ValidationError = { error: string; source: any };\nexport const isValidationError = (item: any): item is ValidationError =>\n  item && item[\"type\"] == null && item[\"error\"] != null;\n\nexport type ParseResult = TrackedEvent | ValidationError;\n\nexport type SchemaDefinition = { name: string; json: string | Schema };\n\nfunction tryGetEventTypeIds(typeDefinition: Schema) {\n  let typeIds: string[] = [];\n  if (typeDefinition.type === \"object\") {\n    const typeProp = typeDefinition.properties?.type;\n    if (typeof typeProp?.const === \"string\") {\n      typeIds.push(typeProp.const);\n    }\n    typeProp?.enum?.forEach((value) => {\n      if (typeof value === \"string\" && value !== typeIds[0]) {\n        typeIds.push(value);\n      }\n    });\n  }\n  typeDefinition.allOf?.forEach((definition) =>\n    typeIds.push(...tryGetEventTypeIds(definition))\n  );\n  return typeIds;\n}\n\nexport interface SchemaWithBaseTypes extends Schema {\n  /**\n   * The base an object type implements.\n   */\n  implements?: string[];\n}\n\nexport interface ModelMetadata {\n  hasProperty(\n    event: TrackedEvent | null | undefined,\n    property: string\n  ): boolean;\n\n  is<T = TrackedEvent>(\n    event: TrackedEvent | T | null | undefined,\n    typeName: string | null | undefined,\n    includeSelf?: boolean\n  ): event is T;\n}\n\nconst getSchemaReference = (typeName: string) => `#/definitions/${typeName}`;\nconst getSchemaTypeName = (ref: string) => ref.replace(\"#/definitions/\", \"\");\n\nconst isValidated = Symbol(\"validated\");\n\nexport class EventParser implements ModelMetadata {\n  private readonly _types: {\n    [key: string]: {\n      name: string;\n      schemaId?: string;\n      schema: Schema;\n    };\n  } = {};\n  private readonly _validator: Validator = new Validator();\n\n  public readonly events: ReadOnlyRecord<string, SchemaWithBaseTypes>;\n\n  constructor(schema: Record<string, JsonString<Schema> | Schema>) {\n    const events = {};\n\n    const mergeAllOf = (\n      schema: SchemaWithBaseTypes,\n      type = schema,\n      typeName?: string\n    ): SchemaWithBaseTypes => {\n      if (type.allOf || type.type === \"object\") {\n        if (\n          type.additionalProperties == null ||\n          type.additionalProperties === true\n        ) {\n          type.additionalProperties = false;\n        }\n      }\n      if (type.definitions) {\n        type = {\n          ...type,\n          definitions: Object.fromEntries(\n            Object.entries(type.definitions).map(([key, value]) => [\n              key,\n              mergeAllOf(schema, value, key),\n            ])\n          ),\n        };\n      }\n      if (!typeName) {\n        return type;\n      }\n\n      if (type.allOf) {\n        let merged = { type: \"object\", ...type };\n        merged.implements = [];\n        delete merged[\"allOf\"];\n        for (const part of type.allOf) {\n          let properties = part.properties;\n          let required = part.required;\n\n          if (!properties && part.$ref) {\n            merged.implements!.push(part.$ref);\n\n            const refTypeName = getSchemaTypeName(part.$ref);\n            const reffed = schema.definitions?.[refTypeName];\n            if (!reffed) {\n              throw new Error(\n                `Invalid type definition. The referenced type ${part.$ref} could not be resolved.`\n              );\n            }\n            const mergedRef = mergeAllOf(schema, reffed, refTypeName);\n            properties = mergedRef?.properties;\n            required = mergedRef?.required;\n            properties &&\n              (properties = Object.fromEntries(\n                Object.entries(properties).map(([key, value]) => [\n                  key,\n                  { $baseType: part.$ref, ...value } as any,\n                ])\n              ));\n\n            mergedRef.implements?.forEach((value) =>\n              merged.implements!.push(value)\n            );\n          }\n\n          if (properties) {\n            merged = {\n              ...merged,\n              properties: part.$ref\n                ? { ...properties, ...merged.properties } // Don't overwrite from base type.\n                : { ...merged.properties, ...properties },\n            };\n            if (Array.isArray(required)) {\n              (merged.required = Array.isArray(merged.required)\n                ? merged.required\n                : []).push(...required);\n            }\n          }\n        }\n\n        if (Array.isArray(merged.required)) {\n          // One include required properties once.\n          merged.required = [...new Set(merged.required)];\n        }\n        merged.implements &&\n          (merged.implements = [...new Set<string>(merged.implements)]);\n        return merged;\n      }\n\n      return type;\n    };\n\n    const appendSubtypes = (\n      schema: SchemaWithBaseTypes,\n      type = schema,\n      typeName?: string\n    ): SchemaWithBaseTypes => {\n      if (type.definitions) {\n        Object.entries(type.definitions).forEach(([key, value]) =>\n          appendSubtypes(schema, value, key)\n        );\n      }\n\n      typeName &&\n        type.properties &&\n        type.implements?.forEach((baseTypeName) => {\n          const baseType =\n            schema.definitions?.[getSchemaTypeName(baseTypeName)];\n          if (!baseType || baseType.type !== \"object\" || !baseType.properties) {\n            return;\n          }\n          Object.entries(type.properties!).forEach(\n            ([key, value]) =>\n              (baseType!.properties![key] ??= {\n                ...value,\n                const: undefined,\n                $subtype: getSchemaReference(typeName),\n              } as any)\n          );\n        });\n\n      return type;\n    };\n\n    const registerEvent = (\n      eventSchema: Schema,\n      schemaId: string | undefined,\n      ids: string[]\n    ) => {\n      if (!ids.length) {\n        throw new Error(\n          `An event cannot be registered without a constant value for its type name ({\"type\": \"string\", \"const\": \"[Type name]' or \"enum\":[\"[Type name]\",...]}).`\n        );\n      }\n      const reg = {\n        name: ids[0],\n        schema: eventSchema,\n        schemaId,\n      };\n\n      const add = (alias: string, registration: typeof reg) => {\n        const current = this._types[alias];\n        if (current && current !== registration) {\n          throw new Error(\n            `Cannot add the type '${registration.name}' with the alias '${alias}' since that is already in use by '${current.name}'.`\n          );\n        }\n        this._types[alias] = registration;\n      };\n\n      for (const alias of ids) {\n        add(alias, reg);\n      }\n\n      events[reg.name] = reg.schema;\n\n      return reg;\n    };\n\n    const rewriteRefs = (parent: any, rewrite: (current: string) => string) => {\n      if (typeof parent !== \"object\") return;\n      if (Array.isArray(parent)) {\n        parent.forEach((item) => rewriteRefs(item, rewrite));\n      } else {\n        for (const prop in parent) {\n          const value = parent[prop];\n          if (prop === \"$ref\" && value.startsWith(\"#\")) {\n            parent[prop] = rewrite(value as string);\n          } else {\n            rewriteRefs(value, rewrite);\n          }\n        }\n      }\n    };\n\n    for (const [_, source] of Object.entries(schema)) {\n      const schema: Schema = appendSubtypes(\n        mergeAllOf(typeof source === \"string\" ? JSON.parse(source) : source)\n      );\n\n      const schemaDefs: Record<string, Schema> = {};\n      const schemaEvents: Schema[] = [];\n\n      if (schema.type) {\n        const ids = tryGetEventTypeIds(schema);\n\n        if (!ids.length) {\n          throw new Error(\"A schema with a root type must be an event.\");\n        }\n\n        registerEvent(schema, schema.$id, ids);\n        continue;\n      } else if (!schema.definitions) {\n        // Empty schema.\n        continue;\n      }\n\n      for (const [name, def] of Object.entries(schema.definitions)) {\n        const ids = tryGetEventTypeIds(def);\n\n        if (!ids.length) {\n          schemaDefs[name] = def;\n          continue;\n        }\n\n        schemaEvents.push(registerEvent(def, schema.$id, ids).schema);\n      }\n\n      for (const event of schemaEvents) {\n        function patch(schema: Schema) {\n          rewriteRefs(schema, (current) => {\n            event.definitions ??= {};\n            const name = current.replace(/^.*?([^\\/]+)$/, \"$1\");\n            if (!event.definitions[name]) {\n              const def = schemaDefs[name];\n              if (!def) {\n                throw new Error(\n                  `The reference ${name} could not be resolved. Mind that an event cannot reference other events.`\n                );\n              }\n              event.definitions[name] = def;\n              patch(def);\n            }\n            return current;\n          });\n        }\n        patch(event);\n\n        this._validator.addSchema(event);\n      }\n    }\n\n    this.events = events;\n  }\n\n  hasProperty(\n    event: TrackedEvent | null | undefined,\n    property: string\n  ): boolean {\n    return (\n      event != null && this.events[event.type]?.properties?.[property] != null\n    );\n  }\n\n  is<T = TrackedEvent>(\n    event: T | TrackedEvent | null | undefined,\n    baseType: string | null | undefined,\n    includeSelf = true\n  ): event is T {\n    const type = (event as any)?.type;\n    if (!type) return false;\n    return (\n      type != null &&\n      baseType != null &&\n      ((includeSelf && type === baseType) ||\n        this.events[(event as any).type]?.implements?.includes(\n          getSchemaReference(baseType)\n        ) === true)\n    );\n  }\n\n  public parseAndValidate(data: string | {}, knownOnly = false): ParseResult[] {\n    const parsed = this.parse(data);\n    return this.validate(parsed, knownOnly);\n  }\n\n  public parse(data: string | {}): ParseResult[] {\n    let events = typeof data === \"string\" ? JSON.parse(data) : data;\n    if (!Array.isArray(events)) {\n      events = [events];\n    }\n    const results: ParseResult[] = [];\n\n    for (const instance of events) {\n      if (typeof instance !== \"object\" || Array.isArray(instance)) {\n        results.push({ error: \"Object expected\", source: instance });\n        continue;\n      }\n\n      if (!instance.type) {\n        results.push({\n          error: \"A type property was expected.\",\n          source: instance,\n        });\n      }\n\n      const reg = this._types[instance.type];\n      if (reg) {\n        instance.type = reg.name;\n        instance.schema = reg.schemaId;\n      }\n      results.push(instance);\n    }\n    return results;\n  }\n\n  public validate(events: ParseResult[], knownOnly = false): ParseResult[] {\n    const validated: ParseResult[] = [];\n    for (const instance of events) {\n      if (isValidationError(instance) || instance[isValidated]) {\n        validated.push(instance);\n        continue;\n      }\n      const reg = this._types[instance.type];\n      if (!reg) {\n        if (!knownOnly) {\n          validated.push(instance);\n          continue;\n        }\n        validated.push({\n          error: `No such type: '${instance.type}'.`,\n          source: instance,\n        });\n        continue;\n      }\n\n      if (!instance.type) {\n        validated.push({\n          error: \"A type property was expected.\",\n          source: instance,\n        });\n        continue;\n      }\n\n      const result = this._validator.validate(instance, reg.schema, {\n        nestedErrors: true,\n        throwError: false,\n      });\n      if (!result.valid) {\n        validated.push({\n          error: result.errors\n            .map(\n              (error) =>\n                `${error.path.length ? error.path.join(\".\") : \"instance\"} ${\n                  error.message\n                }`\n            )\n            .join(\"\\n\"),\n          source: instance,\n        });\n        continue;\n      }\n      instance.type = reg.name;\n      instance[isValidated] = true;\n      validated.push(instance);\n    }\n\n    return validated;\n  }\n}\n"]}