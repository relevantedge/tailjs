{"version":3,"file":"Tracker.js","sourceRoot":"","sources":["Tracker.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DataClassification,\n  DataPurposes,\n  PostResponse,\n  Timestamp,\n  TrackedEvent,\n  Variable,\n  VariableClassification,\n  VariableFilter,\n  VariableGetter,\n  VariableHeader,\n  VariableKey,\n  VariableQueryOptions,\n  VariableQueryResult,\n  VariableScope,\n  VariableSetResult,\n  VariableSetStatus,\n  VariableSetter,\n  dataClassification,\n  dataPurposes,\n  isSuccessResult,\n  Session,\n  variableScope,\n} from \"@tailjs/types\";\nimport { Transport, createTransport } from \"@tailjs/util/transport\";\nimport { ReadOnlyRecord, map, params, unparam } from \"./lib\";\nimport {\n  Cookie,\n  HttpRequest,\n  HttpResponse,\n  RequestHandler,\n  RequestHandlerConfiguration,\n  TrackedEventBatch,\n  TrackerEnvironment,\n  VariableStorageContext,\n  VariableGetResults,\n  VariableSetError,\n  VariableSetResults,\n  VariableStorage,\n} from \"./shared\";\nimport {\n  MaybePromise,\n  filter,\n  forEach,\n  isDefined,\n  isNumber,\n  now,\n  obj,\n  update,\n} from \"@tailjs/util\";\n\nexport type TrackerSettings = Pick<\n  RequestHandlerConfiguration,\n  \"sessionTimeout\" | \"includeIp\" | \"clientKeySeed\"\n> & {\n  disabled?: boolean;\n  clientIp?: string | null;\n  headers?: Record<string, string>;\n  host: string;\n  path: string;\n  url: string;\n  queryString: Record<string, string[]>;\n  cookies?: Record<string, Cookie>;\n  requestHandler: RequestHandler;\n};\n\nconst enum ExtensionState {\n  Pending = 0,\n  Applying = 1,\n  Done = 2,\n}\n\nexport type TrackerPostOptions = {\n  routeToClient?: boolean;\n  deviceSessionId?: string;\n  deviceId?: string;\n  userId?: string;\n};\n\nconst SCOPE_DATA_KEY = \"_data\";\n\nexport interface ScopeData {\n  id: string;\n  firstSeen: Timestamp;\n  lastSeen: Timestamp;\n  views: number;\n  isNew?: boolean;\n}\n\nconst createInitialScopeData = <T extends ScopeData>(\n  id: string,\n  timestamp: Timestamp,\n  additionalData: Omit<T, \"id\" | \"consent\" | \"firstSeen\" | \"lastSeen\" | \"views\">\n): T =>\n  ({\n    id,\n    firstSeen: timestamp,\n    lastSeen: timestamp,\n    views: 0,\n    isNew: true,\n    ...additionalData,\n  } as T);\n\nexport interface SessionData extends ScopeData {\n  deviceSessionId?: string;\n  deviceId?: string;\n  userId?: string;\n  previousSession?: Timestamp;\n}\n\nexport interface InternalSessionData extends SessionData {\n  hasUserAgent?: boolean;\n}\n\nexport interface DeviceData extends ScopeData {\n  sessions: number;\n}\n\ninterface DeviceVariableCache {\n  /** Parsed variables from cookie. */\n  variables?: Record<string, Variable> | undefined;\n\n  /** Only refresh device variables stored at client if changed.  */\n  touched?: boolean;\n}\n\ntype ClientDeviceDataBlob = ClientDeviceVariable[];\n\ntype ClientDeviceVariable = [\n  key: string,\n  classification: DataClassification,\n  version: string | undefined,\n  value: any\n];\n\nexport class Tracker {\n  /**\n   * Used for queueing up events so they do not get posted before all extensions have been applied to the request.\n   *\n   * Without this queue this might happen if one of the first extensions posted an event in the apply method.\n   * It would then pass through the post pipeline in a nested call and see `_extensionsApplied` to be `true` even though they were not, hence miss their logic.\n   */\n  private _eventQueue: [\n    events: TrackedEventBatch,\n    options: TrackerPostOptions\n  ][] = [];\n  private _extensionState = ExtensionState.Pending;\n  private _initialized: boolean;\n  private _requestId: string | undefined;\n\n  /** @internal  */\n  public readonly _clientEvents: TrackedEvent[] = [];\n\n  /** @internal */\n  public readonly _requestHandler: RequestHandler;\n  public readonly clientIp: string | null;\n\n  public readonly cookies: Record<string, Cookie>;\n  public readonly disabled: boolean;\n  public readonly env: TrackerEnvironment;\n  public readonly headers: ReadOnlyRecord<string, string>;\n  public readonly queryString: ReadOnlyRecord<string, string[]>;\n  public readonly referrer: string | null;\n  public readonly requestItems: Map<any, any>;\n  /** Transient variables that can be used by extensions whilst processing a request. */\n  public readonly transient: Record<string, any>;\n\n  private readonly _clientCipher: Transport;\n  public readonly clientKey: string;\n\n  public host: string;\n  public path: string;\n  public url: string;\n\n  public constructor({\n    disabled = false,\n    clientIp = null,\n    headers,\n    host,\n    path,\n    url,\n    queryString,\n    cookies,\n    requestHandler,\n    clientKeySeed,\n  }: TrackerSettings) {\n    this.disabled = disabled;\n    this._requestHandler = requestHandler;\n    this.env = requestHandler.environment;\n    this.host = host;\n    this.path = path;\n    this.url = url;\n\n    this.queryString = queryString ?? {};\n\n    this.headers = headers ?? {};\n    this.cookies = (cookies as Record<string, any>) ?? {};\n    this.transient = {};\n    this.requestItems = new Map<any, any>();\n\n    this.clientIp =\n      clientIp ??\n      this.headers[\"x-forwarded-for\"]?.[0] ??\n      Object.fromEntries(params(this.headers[\"forwarded\"]))[\"for\"] ??\n      null;\n\n    this.referrer = this.headers[\"referer\"] ?? null;\n    let clientKey = `${this.clientIp}_${headers?.[\"user-agent\"] ?? \"\"}`;\n    clientKey = `${clientKey.substring(\n      0,\n      clientKey.length / 2\n    )}${clientKeySeed}${clientKey.substring(clientKey.length / 2 + 1)}`;\n    this._clientCipher = createTransport(\n      (this.clientKey = this.env.hash(clientKey, 64))\n    );\n  }\n\n  public get clientEvents() {\n    return this._clientEvents;\n  }\n\n  /** A unique ID used to look up session data. This is a pointer to the session data that includes the actual session ID.\n   *\n   * In this way the session ID for a pseudonomized cookie-less identifier may be truly anonymized.\n   * It also protects against race conditions. If one concurrent request changes the session (e.g. resets it), the other(s) will see it.\n   *\n   */\n  public _sessionReferenceId: string;\n\n  /** @internal */\n  public _session: Variable<InternalSessionData>;\n\n  /** @internal */\n  public _device?: Variable<DeviceData>;\n\n  /**\n   * See {@link Session.expiredDeviceSessionId}.\n   * @internal\n   */\n  public _expiredDeviceSessionId?: string;\n\n  /**\n   * Device variables are only persisted in the device.\n   * However, when used they are temporarily stored in memory like session variables to avoid race conditions.\n   */\n  private _clientDeviceCache?: DeviceVariableCache;\n\n  private _consent: {\n    level: DataClassification;\n    purposes: DataPurposes;\n  } = { level: DataClassification.Anonymous, purposes: DataPurposes.Necessary };\n\n  public get consent() {\n    return this._consent;\n  }\n\n  public get requestId() {\n    return `${this._requestId}`;\n  }\n\n  public get session(): Readonly<SessionData> {\n    return this._session.value!;\n  }\n\n  public get sessionId(): string {\n    return this.session.id;\n  }\n\n  public get deviceSessionId() {\n    return this._session.value?.deviceSessionId;\n  }\n\n  public get device(): Readonly<DeviceData> | undefined {\n    return this._device?.value;\n  }\n\n  public get deviceId() {\n    return this._session.value?.deviceId;\n  }\n\n  public get authenticatedUserId() {\n    return this._session.value?.userId;\n  }\n\n  public async updateConsent(\n    level?: DataClassification,\n    purposes?: DataPurposes\n  ): Promise<void> {\n    level ??= this.consent.level;\n    purposes ??= this.consent.purposes;\n    if (level < this.consent.level || ~purposes & this.consent.purposes) {\n      // If the user downgraded the level of consent or removed purposes we need to delete existing data that does not match.\n\n      await this.env.storage.purge([\n        {\n          keys: [\"*\"],\n          scopes: [\n            VariableScope.Session,\n            VariableScope.Device,\n            VariableScope.User,\n          ],\n          purposes: ~purposes,\n          classification: {\n            min: level + 1,\n          },\n        },\n      ]);\n    }\n\n    if (\n      (level === DataClassification.Anonymous) !==\n      (this.consent.level === DataClassification.Anonymous)\n    ) {\n      // We need to transition to or from cookie-less tracking which means the key used to refer to the session data changes.\n      // (Non-cookieless uses a unique session ID, cookie-less uses a hash of request headers which is not guaranteed to be unique).\n    }\n    // if (consentLevel === this._consentLevel) return;\n    // this._consentLevel = consentLevel;\n    // if (consentLevel === DataClassification.None) {\n    //   this._requestHandler._sessionStore.purge(this);\n    // } else {\n    //   // Copy current values from cookie-less store.\n    //   await this._requestHandler._sessionStore.set(\n    //     this,\n    //     ...(await this._requestHandler._globalStorage.get(\n    //       this,\n    //       { scope: \"session\" },\n    //       { scope: \"device-session\" },\n    //       { scope: \"device\" },\n    //       { scope: \"user\" }\n    //     ))\n    //   );\n    //   await this._requestHandler._sessionStore.set(this, {\n    //     scope: \"session\",\n    //     key: \"consent\",\n    //     value: consentLevel,\n    //   });\n    // }\n  }\n\n  public httpClientEncrypt(value: any): string {\n    return this._clientCipher[0](value);\n  }\n\n  public httpClientDecrypt(encoded: string | null | undefined): any {\n    return this._clientCipher[1](encoded);\n  }\n\n  /** @internal */\n  public async _applyExtensions(deviceSessionId?: string, deviceId?: string) {\n    await this._initialize(deviceSessionId, deviceId);\n    if (this._extensionState === ExtensionState.Pending) {\n      this._extensionState = ExtensionState.Applying;\n      try {\n        await this._requestHandler.applyExtensions(this);\n      } finally {\n        this._extensionState = ExtensionState.Done;\n        if (this._eventQueue.length) {\n          for (const [events, options] of this._eventQueue.splice(0)) {\n            await this.post(events, options);\n          }\n        }\n      }\n    }\n  }\n\n  public async forwardRequest(request: HttpRequest): Promise<HttpResponse> {\n    const finalRequest = {\n      url: request.url,\n      binary: request.binary,\n      method: request.method,\n      headers: { ...this.headers },\n    };\n\n    if (request.headers) {\n      Object.assign(finalRequest.headers, request.headers);\n    }\n\n    finalRequest.headers[\"cookie\"] = unparam(\n      Object.fromEntries(\n        map(this.cookies, ([key, value]) => [key, value?.value])\n          .filter((kv) => kv[1] != null)\n          .concat(params(finalRequest.headers[\"cookie\"]))\n      )\n    );\n\n    const response = await this._requestHandler.environment.request(\n      finalRequest\n    );\n\n    return response;\n  }\n\n  public getClientScripts() {\n    return this._requestHandler.getClientScripts(this);\n  }\n\n  public async post(\n    events: TrackedEventBatch,\n    options: TrackerPostOptions = {}\n  ): Promise<PostResponse> {\n    if (this._extensionState === ExtensionState.Applying) {\n      this._eventQueue.push([events, options]);\n      return {};\n    }\n    return await this._requestHandler.post(this, events, options);\n  }\n\n  // #region DeviceData\n\n  /**\n   *\n   * Called by {@link TrackerVariableStorage} after successful set operations, to give the tracker a chance to update its state.\n   * (Session and device data)\n   *\n   * @internal\n   */\n  public async _maybeUpdate(\n    key: VariableKey<boolean>,\n    current: Variable | undefined\n  ) {\n    const scope = variableScope(key.scope);\n    if (key.key === SCOPE_DATA_KEY) {\n      if (scope === VariableScope.Session) {\n        // TODO: Reset session if purged.\n        current && (this._session = current);\n      } else if (\n        scope === VariableScope.Device &&\n        this._consent.level > DataClassification.Anonymous\n      ) {\n        this._device = current;\n      }\n    }\n  }\n\n  /**\n   * Used by the {@link TrackerVariableStorage} to maintain deviec data stored in the device and only briefly cached on the server.\n   * @internal\n   */\n  public _getClientDeviceVariables() {\n    if (!this._clientDeviceCache) {\n      const deviceCache = (this._clientDeviceCache = {} as DeviceVariableCache);\n\n      dataPurposes.entries.map(([purpose, flag]) => {\n        // Device variables are stored with a cookie for each purpose.\n\n        forEach(\n          this.httpClientDecrypt(\n            this.cookies[this._requestHandler._cookieNames.device[purpose]]\n              ?.value\n          ) as ClientDeviceDataBlob,\n          (value) => {\n            update((deviceCache!.variables ??= {}), purpose, (current) => {\n              current ??= {\n                scope: VariableScope.Device,\n                key: value[0],\n                classification: value[1],\n                version: value[2],\n                value: value[3],\n              };\n              current.purposes = (current.purposes ?? 0) | flag;\n              return current;\n            });\n          }\n        );\n      });\n      return this._clientDeviceCache.variables;\n    }\n  }\n\n  /**\n   * Used by the {@link TrackerVariableStorage} to maintain device data stored in the device and only briefly cached on the server.\n   * @internal\n   */\n  public _touchClientDeviceData() {\n    if (this._clientDeviceCache) {\n      this._clientDeviceCache.touched = true;\n    }\n  }\n\n  // #endregion\n\n  /**\n   *\n   * Initializes the tracker with session and device data.\n   * The deviceId ans deviceSesssionId parameters are only used if no session already exists.\n   * After that they will stick. This means if a device starts a new server session, its device session will remain.\n   * Simlarily if an old frozen tab suddenly wakes up it will get the new device session.\n   * (so yes, they can hypothetically be split across the same tab even though that goes against the definition).\n   *\n   * @internal */\n  public async _initialize(deviceId?: string, deviceSessionId?: string) {\n    if (this._initialized === (this._initialized = true)) {\n      return false;\n    }\n    this._requestId = await this.env.nextId(\"request\");\n\n    const timestamp = now();\n    const consentData = (\n      this.cookies[\"consent\"]?.value ??\n      `${dataClassification.anonymous}:${dataPurposes.necessary}`\n    ).split(\":\");\n\n    this._consent = {\n      level:\n        dataClassification.tryParse(consentData[0]) ??\n        DataClassification.Anonymous,\n      purposes:\n        dataPurposes.tryParse(consentData[1].split(\",\")) ??\n        DataPurposes.Necessary,\n    };\n    await this._ensureSession(timestamp, deviceId, deviceSessionId);\n  }\n\n  public async reset(\n    session: boolean,\n    device = false,\n    consent = false,\n    referenceTimestamp?: Timestamp,\n    deviceId?: string,\n    deviceSessionId?: string\n  ) {\n    if (consent) {\n      await this.updateConsent(\n        DataClassification.Anonymous,\n        DataPurposes.Necessary\n      );\n    }\n    await this._ensureSession(\n      referenceTimestamp ?? now(),\n      deviceId,\n      deviceSessionId,\n      session,\n      device\n    );\n  }\n\n  private async _ensureSession(\n    timestamp: number,\n    deviceId?: string,\n    deviceSessionId?: string,\n    resetSession?: boolean,\n    resetDevice?: boolean\n  ) {\n    const previousDeviceSessionId = this.deviceSessionId;\n\n    if ((resetSession || resetDevice) && this._sessionReferenceId) {\n      // Purge old data. No point in storing this since it will no longer be used.\n      await this.env.storage.purge([\n        {\n          keys: [\"*\"],\n          scopes: filter(\n            [\n              resetSession && VariableScope.Session,\n              resetDevice && VariableScope.Device,\n            ],\n            isNumber\n          ),\n        },\n      ]);\n    }\n\n    if (this._consent.level > DataClassification.Anonymous) {\n      // CAVEAT: There is a minimal chance that multiple sessions may be generated for the same device if requests are made concurrently.\n      // This means clients must make sure the initial request to endpoint completes before more or send (or at least do a fair effort).\n      this._sessionReferenceId =\n        (resetSession\n          ? undefined\n          : this.httpClientDecrypt(this.cookies[\"session\"]?.value)?.id) ??\n        (await this.env.nextId(\"session\"));\n\n      this.cookies[\"session\"] = {\n        httpOnly: true,\n        sameSitePolicy: \"None\",\n        essential: true,\n        value: this.httpClientEncrypt({ id: this._sessionReferenceId }),\n      };\n    } else {\n      this._sessionReferenceId =\n        await this._requestHandler._sessionReferenceMapper.mapSessionId(this);\n    }\n\n    this._session =\n      // We bypass the TrackerVariableStorage here and uses the environment\n      // becaues we use a different target ID than the unique session ID when doing cookie-less tracking.\n      (\n        await this.env.storage.get([\n          {\n            scope: VariableScope.Session,\n            key: SCOPE_DATA_KEY,\n            targetId: this._sessionReferenceId,\n            initializer: async () => {\n              let cachedDeviceData: DeviceData | undefined;\n              if (this.consent.level > DataClassification.Anonymous) {\n                cachedDeviceData = resetDevice\n                  ? undefined\n                  : (this._getClientDeviceVariables()?.[SCOPE_DATA_KEY]\n                      ?.value as DeviceData);\n              }\n\n              return {\n                classification: DataClassification.Anonymous,\n                purpose: DataPurposes.Necessary,\n                value: createInitialScopeData<InternalSessionData>(\n                  await this.env.nextId(),\n                  timestamp,\n                  {\n                    deviceId:\n                      this._consent.level > DataClassification.Anonymous\n                        ? deviceId ??\n                          (resetDevice ? undefined : cachedDeviceData?.id) ??\n                          (await this.env.nextId(\"device\"))\n                        : undefined,\n                    deviceSessionId:\n                      deviceSessionId ??\n                      (await this.env.nextId(\"device-session\")),\n                    previousSession: cachedDeviceData?.lastSeen,\n                    hasUserAgent: false,\n                  }\n                ),\n              };\n            },\n          },\n        ])\n      )[0]!;\n\n    if (this._session.value!.deviceId) {\n      const device = (\n        await this.get([\n          {\n            scope: VariableScope.Device,\n            key: SCOPE_DATA_KEY,\n            purpose: DataPurposes.Necessary,\n            initializer: async () => ({\n              classification: this.consent.level,\n              value: createInitialScopeData<DeviceData>(\n                this._session.value?.deviceId!,\n                timestamp,\n                {\n                  sessions: 1,\n                }\n              ),\n            }),\n          },\n        ])\n      )[0];\n\n      if (!device.initialized && this.session.isNew) {\n        await this.set([\n          {\n            ...device,\n            patch: (current) =>\n              current?.value\n                ? {\n                    value: {\n                      ...current.value,\n                      sessions: current.value.sessions + 1,\n                    } as DeviceData,\n                  }\n                : undefined,\n          },\n        ]);\n      }\n\n      if (previousDeviceSessionId && isDefined(this.deviceId)) {\n        this._expiredDeviceSessionId = previousDeviceSessionId;\n      }\n    }\n  }\n\n  /**\n   *  Must be called last by the request handler just before a response is sent.\n   *  The tracker must not be used afterwards.\n   *  @internal\n   * */\n  public async _persist() {\n    this.cookies[this._requestHandler._cookieNames.consent] = {\n      httpOnly: true,\n      maxAge: Number.MAX_SAFE_INTEGER,\n      essential: true,\n      sameSitePolicy: \"None\",\n      value: this.consent.purposes + \"@\" + this.consent.level,\n    };\n\n    const splits: Record<string, ClientDeviceDataBlob> = {};\n\n    if (this._clientDeviceCache?.touched) {\n      // We have updated device data and need to refresh to get whatever other processes may have written (if any).s\n\n      const deviceValues = (\n        await this.query(\n          [\n            {\n              scopes: [VariableScope.Device],\n              keys: [\":*\"],\n            },\n          ],\n          {\n            top: 1000,\n            ifNoneMatch: map(\n              this._clientDeviceCache?.variables,\n              ([, variable]) => variable\n            ),\n          }\n        )\n      ).results;\n\n      forEach(deviceValues, (variable) => {\n        dataPurposes.map(variable.purposes, ([purpose]) =>\n          (splits[purpose] ??= []).push([\n            variable.key,\n            variable.classification,\n            variable.version,\n            variable.value,\n          ])\n        );\n      });\n    }\n\n    dataPurposes.entries.map(([purpose, flag]) => {\n      const remove =\n        this.consent.level === DataClassification.Anonymous || !splits[purpose];\n      const cookieName = this._requestHandler._cookieNames.device[purpose];\n\n      if (remove) {\n        if (this.cookies[cookieName]) {\n          this.cookies[cookieName].value = undefined;\n        }\n      } else if (splits[purpose]) {\n        if (!this._clientDeviceCache?.touched) {\n          // Device data has not been touched. Don't send the cookies.\n          delete this.cookies[cookieName];\n        } else {\n          this.cookies[cookieName] = {\n            httpOnly: true,\n            maxAge: Number.MAX_SAFE_INTEGER,\n            sameSitePolicy: \"None\",\n            essential: flag === DataPurposes.Necessary,\n            value: this.httpClientEncrypt(splits[purpose]),\n          };\n        }\n      }\n    });\n  }\n\n  // #region Storage\n  private _getStorageContext(): VariableStorageContext {\n    return { tracker: this };\n  }\n\n  async renew(): Promise<void> {\n    for (const scope of [VariableScope.Device, VariableScope.Session]) {\n      await this.env.storage.renew(\n        scope,\n        /* TrackerVariableStorage will fill this out */ [\"(auto)\"],\n        this._getStorageContext()\n      );\n    }\n  }\n\n  get<K extends (VariableGetter<any> | null | undefined)[]>(\n    keys: K & (VariableGetter<any> | null | undefined)[]\n  ): MaybePromise<VariableGetResults<K>> {\n    return this.env.storage.get(\n      keys as VariableGetter<any>[],\n      this._getStorageContext()\n    ) as VariableGetResults<K>; // This conversion is okay because of the TrackerVariableStorage\n  }\n  head(\n    filters: VariableFilter[],\n    options?: VariableQueryOptions | undefined\n  ): MaybePromise<VariableQueryResult<VariableHeader<true>>> {\n    return this.env.storage.head(filters, options, this._getStorageContext());\n  }\n  query(\n    filters: VariableFilter[],\n    options?: VariableQueryOptions | undefined\n  ): MaybePromise<VariableQueryResult<Variable<any>>> {\n    return this.env.storage.query(filters, options, this._getStorageContext());\n  }\n\n  async set<V extends (VariableSetter<any> | null | undefined)[]>(\n    variables: V & (VariableSetter<any> | null | undefined)[]\n  ): Promise<VariableSetResults<V>> {\n    const results = await this.env.storage.set(\n      variables,\n      this._getStorageContext()\n    );\n\n    for (const result of results) {\n      if (isSuccessResult(result)) {\n        if (result.source.key === SCOPE_DATA_KEY) {\n          result.source.scope === VariableScope.Session &&\n            (this._session = result.current!);\n          result.source.scope === VariableScope.Device &&\n            (this._device = result.current);\n        }\n      }\n    }\n\n    if (!this._session) {\n      // Being without session data violates an invariant, so if someone deleted the data, we create a new session. Ha!\n      await this._ensureSession(\n        now(),\n        this.deviceId,\n        this.deviceSessionId,\n        true,\n        false\n      );\n    }\n\n    return results;\n  }\n  purge(alsoUserData = false): MaybePromise<void> {\n    return this.env.storage.purge(\n      [\n        {\n          scopes: [VariableScope.Device, VariableScope.Session].concat(\n            alsoUserData ? [VariableScope.User] : []\n          ),\n          keys: [\"*\"],\n        },\n      ],\n      this._getStorageContext()\n    );\n  }\n\n  // #endregion\n}\n"]}