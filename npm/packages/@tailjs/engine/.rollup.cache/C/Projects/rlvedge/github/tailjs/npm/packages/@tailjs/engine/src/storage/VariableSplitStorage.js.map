{"version":3,"file":"VariableSplitStorage.js","sourceRoot":"","sources":["VariableSplitStorage.ts"],"names":[],"mappings":"AAAA,OAAO,EAYL,QAAQ,EACR,aAAa,GACd,MAAM,eAAe,CAAC;AACvB,OAAO,EAEL,GAAG,EACH,SAAS,EACT,UAAU,EACV,GAAG,EACH,OAAO,GACR,MAAM,cAAc,CAAC;AACtB,OAAO,EAA6B,SAAS,EAAE,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAExE,OAAO,EAML,UAAU,GACX,MAAM,IAAI,CAAC;AAKZ,MAAM,OAAO,oBAAoB;IACd,SAAS,CAAiB;IACnC,eAAe,GAGZ,IAAI,CAAC;IAEhB,YAAY,QAAiD;QAC3D,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC;IAChE,CAAC;IAES,WAAW,CAAC,OAAgC;QACpD,OAAO,OAAO,YAAY,oBAAoB,CAAC;IACjD,CAAC;IAEO,OAAO,CACb,MAAS;QAOT,IAAI,CAAC,MAAM;YAAE,OAAO,SAAgB,CAAC;QAErC,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACpC,IAAI,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAE/D,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,OAAO,SAAU,CAAC;QACpB,CAAC;QAED,OAAO;YACL,GAAG,MAAM;YACT,OAAO;YACP,MAAM;SACA,CAAC;IACX,CAAC;IAED,IAAY,cAAc;QACxB,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;YAC1B,IAAI,CAAC,eAAe,GAAG,IAAI,GAAG,EAAE,CAAC;YACjC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,KAAoB,EAAE,EAAE,CACxD,QAAQ,EAAE,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAC5B,GAAG,CAAC,IAAI,CAAC,eAAgB,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAChE,CACF,CAAC;QACJ,CAAC;QACD,OAAO,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;IAED,uBAAuB,CACrB,SAA6D,EAC7D,OAAgC;QAEhC,IAAI,CAAC,cAAc,CAAC,OAAO,CACzB,CAAC,CAAC,EAAE,OAAO,EAAE,EAAE,CACb,UAAU,CAAC,OAAO,CAAC;YACnB,OAAO,CAAC,uBAAuB,CAAC,SAAS,EAAE,OAAO,CAAC,CACtD,CAAC;IACJ,CAAC;IAEM,KAAK,CAAC,KAAK,CAChB,KAAoB,EACpB,QAAkB,EAClB,OAAgC;QAEhC,MAAM,OAAO,CACX,GAAG,CACD,IAAI,CAAC,cAAc,EACnB,CAAC,CAAC,OAAO,EAAE,YAAY,CAAC,EAAE,EAAE,CAC1B,UAAU,CAAC,OAAO,CAAC;YACnB,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC;YACvB,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC,CAC1C,CACF,CAAC;IACJ,CAAC;IAEO,UAAU,CAChB,IAAO;QAEP,MAAM,UAAU,GAAG,IAAI,GAAG,EAA8C,CAAC;QAEzE,IAAI,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,WAAW,EAAE,EAAE;YACtC,IAAI,CAAC,SAAS;gBAAE,OAAO;YAEvB,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;YACjD,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YAC5C,GAAG,CAAC,UAAU,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,EAAS,CAAS,CAAC,IAAI,CAAC;gBACtD,WAAW;gBACX,CAAC,UAAU,IAAI,GAAG,KAAK,SAAS,CAAC,GAAG;oBAClC,CAAC,CAAC,EAAE,GAAG,SAAS,EAAE,GAAG,EAAE,GAAG,EAAE;oBAC5B,CAAC,CAAC,SAAS;aACd,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,OAAO,UAAU,CAAC;IACpB,CAAC;IAEO,aAAa,CAAC,OAAyB;QAC7C,MAAM,UAAU,GAAG,IAAI,GAAG,EAA6C,CAAC;QACxE,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;YAC7B,MAAM,SAAS,GAAG,IAAI,GAAG,EAAwC,CAAC;YAClE,MAAM,MAAM,GAAG,CACb,OAA4C,EAC5C,GAAc,EACd,EAAE,CACF,OAAO;gBACP,GAAG,CAAC,SAAS,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC,GAAG,CAC1C,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CACpD,CAAC;YAEJ,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,aAAa,CAAC,IAAI,aAAa,CAAC,MAAM,CAAC;YACzE,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;gBAC3B,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gBAC5C,IAAI,CAAC,aAAa;oBAAE,SAAS;gBAE7B,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,EAAE,CAAC;oBAC9B,MAAM,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;oBAC7B,IAAI,GAAG,KAAK,GAAG,IAAI,MAAM,CAAC,MAAM,KAAK,GAAG,EAAE,CAAC;wBACzC,aAAa,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC;oBAC9D,CAAC;yBAAM,CAAC;wBACN,MAAM,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,CAAC;oBACnD,CAAC;gBACH,CAAC;YACH,CAAC;YAED,KAAK,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,SAAS,EAAE,CAAC;gBACxC,MAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;gBACvD,IAAI,CAAC,aAAa;oBAAE,SAAS;gBAE7B,GAAG,CAAC,UAAU,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC;oBACtC,GAAG,MAAM;oBACT,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC;oBACf,MAAM,EAAE,MAAM,CAAC,MAAM;wBACnB,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAC7B,aAAa,CAAC,GAAG,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CACxC;wBACH,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC;iBACvB,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QACD,OAAO,CAAC,GAAG,UAAU,CAAC,CAAC;IACzB,CAAC;IAES,KAAK,CAAC,gBAAgB,CAC9B,OAAgC,EAChC,OAA8B,EAC9B,OAAiC;QAEjC,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,KAAK,CAAC,GAAG,CACP,IAAO,EACP,OAAgC;QAEhC,MAAM,OAAO,GAA0B,EAAS,CAAC;QACjD,MAAM,OAAO,CACX,GAAG,CACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,EACnC,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE,EAAE,CACnB,UAAU,CAAC,OAAO,CAAC;YACnB,SAAS,CACP,OAAO,EACP,KAAK,EACL,KAAK,EAAE,SAAS,EAAE,EAAE,CAClB,MAAM,IAAI,CAAC,gBAAgB,CACzB,OAAO,EACP,SAAkC,EAClC,MAAM,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CACtC,CACJ,CACJ,CACF,CAAC;QAEF,OAAO,OAAO,CAAC;IACjB,CAAC;IAEO,KAAK,CAAC,YAAY,CACxB,MAAwB,EACxB,OAAyB,EACzB,OAA0C,EAC1C,OAAgC;QAEhC,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAC/C,MAAM,OAAO,GAAwB;YACnC,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS;YACrC,OAAO,EAAE,EAAE;SACZ,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;YACvB,OAAO,OAAO,CAAC;QACjB,CAAC;QACD,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC5B,OAAO,MAAM,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;QACnE,CAAC;QAID,MAAM,aAAa,GACjB,OAAO,EAAE,MAAM,EAAE,OAAO,IAAI,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,QAAQ,CAAC;QAE1D,IAAI,MAAM,GAAG,OAAO,EAAE,MAAM,EAAE,QAAQ;YACpC,CAAC,CAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAY;YACjD,CAAC,CAAC,SAAS,CAAC;QAEd,IAAI,GAAG,GAAG,OAAO,EAAE,GAAG,IAAI,GAAG,CAAC;QAC9B,IAAI,SAAS,GAAG,KAAK,CAAC;QAEtB,KACE,IAAI,CAAC,GAAG,CAAC;QACT,uGAAuG;QACvG,oIAAoI;QACpI,mFAAmF;QACnF,CAAC,GAAG,UAAU,CAAC,MAAM,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,EAC9D,CAAC,EAAE,EACH,CAAC;YACD,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YACvC,MAAM,YAAY,GAAG,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;YAEjC,IAAI,KAAyB,CAAC;YAC9B,IAAI,YAAY,IAAI,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;gBAC1D,6EAA6E;gBAC7E,sEAAsE;gBACtE,uHAAuH;gBACvH,KAAK,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;YAC1B,CAAC;iBAAM,CAAC;gBACN,MAAM,EACJ,KAAK,EAAE,YAAY,EACnB,OAAO,EAAE,cAAc,EACvB,MAAM,EAAE,aAAa,GACtB,GAAG,MAAM,OAAO,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE;oBAC/B,GAAG,OAAO;oBACV,GAAG;oBACH,MAAM,EAAE;wBACN,OAAO,EAAE,aAAa;wBACtB,QAAQ,EAAE,YAAY,EAAE,CAAC,CAAC,CAAC;qBAC5B;iBACF,CAAC,CAAC;gBAEH,KAAK,GAAG,YAAY,CAAC;gBACrB,IAAI,aAAa,EAAE,CAAC;oBAClB,SAAS,KAAK,CAAC,CAAC,aAAa,CAAC;oBAC9B,CAAC,MAAM,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;gBAC9C,CAAC;qBAAM,IAAI,cAAc,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC;oBACvC,gGAAgG;oBAChG,cAAc,CAAC,MAAM,GAAG,GAAG,CAAC;gBAC9B,CAAC;gBACD,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,GAAI,cAA6B,CAAC,CAAC,CAAC,sDAAsD;gBAC/G,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;YACjD,CAAC;YAED,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC;gBACtB,CAAC,OAAO,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QACvE,CAAC;QAED,IAAI,SAAS,EAAE,CAAC;YACd,iFAAiF;YACjF,yEAAyE;YACzE,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;QAC1C,CAAC;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,IAAI,CACF,OAAyB,EACzB,OAA0C,EAC1C,OAAgC;QAEhC,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;IAC9D,CAAC;IAED,KAAK,CACH,OAAyB,EACzB,OAA0C,EAC1C,OAAgC;QAEhC,OAAO,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;IAC/D,CAAC;IAES,KAAK,CAAC,gBAAgB,CAC9B,OAAwB,EACxB,OAA8B,EAC9B,OAA0C;QAE1C,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,KAAK,CAAC,GAAG,CACP,SAAY,EACZ,OAAgC;QAEhC,MAAM,OAAO,GAA0B,EAAS,CAAC;QACjD,MAAM,OAAO,CACX,GAAG,CACD,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,EACxC,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE,EAAE,CACnB,UAAU,CAAC,OAAO,CAAC;YACnB,SAAS,CACP,OAAO,EACP,KAAK,EACL,KAAK,EAAE,SAAS,EAAE,EAAE,CAClB,MAAM,IAAI,CAAC,gBAAgB,CACzB,OAAO,EACP,SAA2C,EAC3C,MAAM,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CACtC,CACJ,CACJ,CACF,CAAC;QAEF,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,KAAK,CAAC,KAAK,CACT,OAAyB,EACzB,OAAgC;QAEhC,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAC/C,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;YACvB,OAAO;QACT,CAAC;QACD,MAAM,OAAO,CACX,UAAU,CAAC,GAAG,CACZ,CAAC,CAAC,OAAO,EAAE,OAAO,CAAC,EAAE,EAAE,CACrB,UAAU,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC,CACzD,CACF,CAAC;IACJ,CAAC;CACF","sourcesContent":["import {\r\n  Variable,\r\n  VariableFilter,\r\n  VariableGetter,\r\n  VariableHeader,\r\n  VariableKey,\r\n  VariableQueryOptions,\r\n  VariableQueryResult,\r\n  VariableScope,\r\n  VariableScopeValue,\r\n  VariableSetResult,\r\n  VariableSetter,\r\n  toStrict,\r\n  variableScope,\r\n} from \"@tailjs/types\";\r\nimport {\r\n  MaybePromise,\r\n  get,\r\n  isDefined,\r\n  isFunction,\r\n  map,\r\n  waitAll,\r\n} from \"@tailjs/util\";\r\nimport { ParsedKey, PartitionItems, mergeKeys, parseKey } from \"../lib\";\r\n\r\nimport {\r\n  ReadOnlyVariableStorage,\r\n  VariableGetResults,\r\n  VariableSetResults,\r\n  VariableStorage,\r\n  VariableStorageContext,\r\n  isWritable,\r\n} from \"..\";\r\n\r\nexport type PrefixMapping = Map<string, ReadOnlyVariableStorage>;\r\nexport type PrefixMappings = (PrefixMapping | undefined)[];\r\n\r\nexport class VariableSplitStorage implements VariableStorage {\r\n  private readonly _mappings: PrefixMappings;\r\n  private _cachedStorages: Map<\r\n    ReadOnlyVariableStorage,\r\n    Set<VariableScope>\r\n  > | null = null;\r\n\r\n  constructor(mappings: (() => PrefixMappings) | PrefixMappings) {\r\n    this._mappings = isFunction(mappings) ? mappings() : mappings;\r\n  }\r\n\r\n  protected _keepPrefix(storage: ReadOnlyVariableStorage) {\r\n    return storage instanceof VariableSplitStorage;\r\n  }\r\n\r\n  private _mapKey<K extends VariableKey | undefined>(\r\n    source: K\r\n  ): K extends undefined\r\n    ? undefined\r\n    : ParsedKey & {\r\n        storage: ReadOnlyVariableStorage;\r\n        source: K;\r\n      } {\r\n    if (!source) return undefined as any;\r\n\r\n    const parsed = parseKey(source.key);\r\n    let storage = this._mappings[source.scope]?.get(parsed.prefix);\r\n\r\n    if (!storage) {\r\n      return undefined!;\r\n    }\r\n\r\n    return {\r\n      ...parsed,\r\n      storage,\r\n      source,\r\n    } as any;\r\n  }\r\n\r\n  private get _storageScopes() {\r\n    if (!this._cachedStorages) {\r\n      this._cachedStorages = new Map();\r\n      this._mappings.forEach((prefixes, scope: VariableScope) =>\r\n        prefixes?.forEach((storage) =>\r\n          get(this._cachedStorages!, storage, () => new Set()).add(scope)\r\n        )\r\n      );\r\n    }\r\n    return this._cachedStorages;\r\n  }\r\n\r\n  configureScopeDurations(\r\n    durations: Partial<Record<VariableScopeValue<false>, number>>,\r\n    context?: VariableStorageContext\r\n  ): void {\r\n    this._storageScopes.forEach(\r\n      (_, storage) =>\r\n        isWritable(storage) &&\r\n        storage.configureScopeDurations(durations, context)\r\n    );\r\n  }\r\n\r\n  public async renew(\r\n    scope: VariableScope,\r\n    scopeIds: string[],\r\n    context?: VariableStorageContext\r\n  ): Promise<void> {\r\n    await waitAll(\r\n      map(\r\n        this._storageScopes,\r\n        ([storage, mappedScopes]) =>\r\n          isWritable(storage) &&\r\n          mappedScopes.has(scope) &&\r\n          storage.renew(scope, scopeIds, context)\r\n      )\r\n    );\r\n  }\r\n\r\n  private _splitKeys<K extends (VariableKey | undefined | null)[]>(\r\n    keys: K\r\n  ): Map<ReadOnlyVariableStorage, PartitionItems<K>> {\r\n    const partitions = new Map<ReadOnlyVariableStorage, PartitionItems<K>>();\r\n\r\n    keys.forEach((sourceKey, sourceIndex) => {\r\n      if (!sourceKey) return;\r\n\r\n      const { storage, key } = this._mapKey(sourceKey);\r\n      const keepPrefix = this._keepPrefix(storage);\r\n      (get(partitions, storage, () => [] as any) as any).push([\r\n        sourceIndex,\r\n        !keepPrefix && key !== sourceKey.key\r\n          ? { ...sourceKey, key: key }\r\n          : sourceKey,\r\n      ]);\r\n    });\r\n\r\n    return partitions;\r\n  }\r\n\r\n  private _splitFilters(filters: VariableFilter[]) {\r\n    const partitions = new Map<ReadOnlyVariableStorage, VariableFilter[]>();\r\n    for (const filter of filters) {\r\n      const keySplits = new Map<ReadOnlyVariableStorage, Set<string>>();\r\n      const addKey = (\r\n        storage: ReadOnlyVariableStorage | undefined,\r\n        key: ParsedKey\r\n      ) =>\r\n        storage &&\r\n        get(keySplits, storage, () => new Set()).add(\r\n          this._keepPrefix(storage) ? key.sourceKey : key.key\r\n        );\r\n\r\n      const scopes = map(filter.scopes, variableScope) ?? variableScope.values;\r\n      for (const scope of scopes) {\r\n        const scopePrefixes = this._mappings[scope];\r\n        if (!scopePrefixes) continue;\r\n\r\n        for (const key of filter.keys) {\r\n          const parsed = parseKey(key);\r\n          if (key === \"*\" || parsed.prefix === \"*\") {\r\n            scopePrefixes.forEach((storage) => addKey(storage, parsed));\r\n          } else {\r\n            addKey(scopePrefixes.get(parsed.prefix), parsed);\r\n          }\r\n        }\r\n      }\r\n\r\n      for (const [storage, keys] of keySplits) {\r\n        const storageScopes = this._storageScopes.get(storage);\r\n        if (!storageScopes) continue;\r\n\r\n        get(partitions, storage, () => []).push({\r\n          ...filter,\r\n          keys: [...keys],\r\n          scopes: filter.scopes\r\n            ? filter.scopes.filter((scope) =>\r\n                storageScopes.has(variableScope(scope))\r\n              )\r\n            : [...storageScopes],\r\n        });\r\n      }\r\n    }\r\n    return [...partitions];\r\n  }\r\n\r\n  protected async _patchGetResults(\r\n    storage: ReadOnlyVariableStorage,\r\n    getters: VariableGetter<any>[],\r\n    results: (Variable | undefined)[]\r\n  ) {\r\n    return results;\r\n  }\r\n\r\n  async get<K extends (VariableGetter<any> | null | undefined)[]>(\r\n    keys: K,\r\n    context?: VariableStorageContext\r\n  ): Promise<VariableGetResults<K>> {\r\n    const results: VariableGetResults<K> = [] as any;\r\n    await waitAll(\r\n      map(\r\n        this._splitKeys(keys.map(toStrict)),\r\n        ([storage, split]) =>\r\n          isWritable(storage) &&\r\n          mergeKeys(\r\n            results,\r\n            split,\r\n            async (variables) =>\r\n              await this._patchGetResults(\r\n                storage,\r\n                variables as VariableGetter<any>[],\r\n                await storage.get(variables, context)\r\n              )\r\n          )\r\n      )\r\n    );\r\n\r\n    return results;\r\n  }\r\n\r\n  private async _queryOrHead(\r\n    method: \"query\" | \"head\",\r\n    filters: VariableFilter[],\r\n    options?: VariableQueryOptions | undefined,\r\n    context?: VariableStorageContext\r\n  ): Promise<VariableQueryResult<any>> {\r\n    const partitions = this._splitFilters(filters);\r\n    const results: VariableQueryResult = {\r\n      count: options?.count ? 0 : undefined,\r\n      results: [],\r\n    };\r\n    if (!partitions.length) {\r\n      return results;\r\n    }\r\n    if (partitions.length === 1) {\r\n      return await partitions[0][0][method](partitions[0][1], options);\r\n    }\r\n\r\n    type Cursor = [count: number | undefined, cursor: string | undefined][];\r\n\r\n    const includeCursor =\r\n      options?.cursor?.include || !!options?.cursor?.previous;\r\n\r\n    let cursor = options?.cursor?.previous\r\n      ? (JSON.parse(options.cursor.previous) as Cursor)\r\n      : undefined;\r\n\r\n    let top = options?.top ?? 100;\r\n    let anyCursor = false;\r\n\r\n    for (\r\n      let i = 0;\r\n      // Keep going as long as we need the total count, or have not sufficient results to meet top (or done).\r\n      // If one of the storages returns an undefined count even though requested, we will also blank out the count in the combined results\r\n      // and stop reading from additional storages since total count is no longer needed.\r\n      i < partitions.length && (top > 0 || isDefined(results.count));\r\n      i++\r\n    ) {\r\n      const [storage, query] = partitions[0];\r\n      const storageState = cursor?.[i];\r\n\r\n      let count: number | undefined;\r\n      if (storageState && (!isDefined(storageState[1]) || !top)) {\r\n        // We have persisted the total count from the storage in the combined cursor.\r\n        // If the cursor is empty it means that we have exhausted the storage.\r\n        // If there is a cursor but `top` is zero (we don't need more results), we use the count cached from the initial query.\r\n        count = storageState[0];\r\n      } else {\r\n        const {\r\n          count: storageCount,\r\n          results: storageResults,\r\n          cursor: storageCursor,\r\n        } = await storage[method](query, {\r\n          ...options,\r\n          top,\r\n          cursor: {\r\n            include: includeCursor,\r\n            previous: storageState?.[1],\r\n          },\r\n        });\r\n\r\n        count = storageCount;\r\n        if (includeCursor) {\r\n          anyCursor ||= !!storageCursor;\r\n          (cursor ??= [])[i] = [count, storageCursor];\r\n        } else if (storageResults.length > top) {\r\n          // No cursor needed. Cut off results to avoid returning excessive amounts of data to the client.\r\n          storageResults.length = top;\r\n        }\r\n        results.results.push(...(storageResults as Variable[])); // This is actually only the header for head requests.\r\n        top = Math.max(0, top - storageResults.length);\r\n      }\r\n\r\n      isDefined(results.count) &&\r\n        (results.count = isDefined(count) ? results.count + 1 : undefined);\r\n    }\r\n\r\n    if (anyCursor) {\r\n      // Only if any of the storages returned a cursor for further results, we do this.\r\n      // Otherwise, we return an undefined cursor to indicate that we are done.\r\n      results.cursor = JSON.stringify(cursor);\r\n    }\r\n    return results;\r\n  }\r\n\r\n  head(\r\n    filters: VariableFilter[],\r\n    options?: VariableQueryOptions | undefined,\r\n    context?: VariableStorageContext\r\n  ): MaybePromise<VariableQueryResult<VariableHeader>> {\r\n    return this._queryOrHead(\"head\", filters, options, context);\r\n  }\r\n\r\n  query(\r\n    filters: VariableFilter[],\r\n    options?: VariableQueryOptions | undefined,\r\n    context?: VariableStorageContext\r\n  ): Promise<VariableQueryResult> {\r\n    return this._queryOrHead(\"query\", filters, options, context);\r\n  }\r\n\r\n  protected async _patchSetResults(\r\n    storage: VariableStorage,\r\n    setters: VariableSetter<any>[],\r\n    results: (VariableSetResult | undefined)[]\r\n  ) {\r\n    return results;\r\n  }\r\n\r\n  async set<K extends (VariableSetter<any> | null | undefined)[]>(\r\n    variables: K,\r\n    context?: VariableStorageContext\r\n  ): Promise<VariableSetResults<K>> {\r\n    const results: VariableSetResults<K> = [] as any;\r\n    await waitAll(\r\n      map(\r\n        this._splitKeys(variables.map(toStrict)),\r\n        ([storage, split]) =>\r\n          isWritable(storage) &&\r\n          mergeKeys(\r\n            results,\r\n            split,\r\n            async (variables) =>\r\n              await this._patchSetResults(\r\n                storage,\r\n                variables as VariableSetter<any, boolean>[],\r\n                await storage.set(variables, context)\r\n              )\r\n          )\r\n      )\r\n    );\r\n\r\n    return results;\r\n  }\r\n\r\n  async purge(\r\n    filters: VariableFilter[],\r\n    context?: VariableStorageContext\r\n  ): Promise<void> {\r\n    const partitions = this._splitFilters(filters);\r\n    if (!partitions.length) {\r\n      return;\r\n    }\r\n    await waitAll(\r\n      partitions.map(\r\n        ([storage, filters]) =>\r\n          isWritable(storage) && storage.purge(filters, context)\r\n      )\r\n    );\r\n  }\r\n}\r\n"]}