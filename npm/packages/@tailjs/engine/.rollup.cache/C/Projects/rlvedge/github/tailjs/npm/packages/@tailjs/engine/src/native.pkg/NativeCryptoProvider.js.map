{"version":3,"file":"NativeCryptoProvider.js","sourceRoot":"","sources":["NativeCryptoProvider.ts"],"names":[],"mappings":"AAAA,WAAW;AACX,gBAAgB;AAChB,eAAe;AACf,oBAAoB;AACpB,sBAAsB;AACtB,gBAAgB;AAChB,mBAAmB;AACnB,mBAAmB;AACnB,WAAW;AACX,oBAAoB;AACpB,2BAA2B;AAC3B,sBAAsB;AACtB,sBAAsB;AAEtB,iDAAiD;AACjD,2CAA2C;AAE3C,2BAA2B;AAC3B,uBAAuB;AACvB,oBAAoB;AACpB,0BAA0B;AAC1B,KAAK;AAEL,gEAAgE;AAChE,qFAAqF;AACrF,qGAAqG;AACrG,uEAAuE;AACvE,2BAA2B;AAC3B,+CAA+C;AAC/C,MAAM;AAEN,4CAA4C;AAC5C,2BAA2B;AAC3B,2CAA2C;AAC3C,0DAA0D;AAC1D,iFAAiF;AACjF,gDAAgD;AAChD,+DAA+D;AAC/D,sDAAsD;AACtD,0EAA0E;AAC1E,2BAA2B;AAC3B,qBAAqB;AACrB,kBAAkB;AAClB,gBAAgB;AAChB,2BAA2B;AAC3B,8CAA8C;AAC9C,mFAAmF;AACnF,2BAA2B;AAC3B,wBAAwB;AACxB,mBAAmB;AACnB,iEAAiE;AACjE,0BAA0B;AAC1B,YAAY;AACZ,WAAW;AACX,0BAA0B;AAC1B,wCAAwC;AACxC,mDAAmD;AACnD,MAAM;AAEN,sCAAsC;AACtC,uCAAuC;AACvC,wCAAwC;AACxC,oCAAoC;AACpC,MAAM;AAEN,yCAAyC;AACzC,kCAAkC;AAClC,mCAAmC;AACnC,qBAAqB;AACrB,QAAQ;AACR,gCAAgC;AAChC,wDAAwD;AACxD,yBAAyB;AACzB,+CAA+C;AAC/C,QAAQ;AACR,8CAA8C;AAC9C,6BAA6B;AAC7B,oCAAoC;AACpC,mBAAmB;AACnB,QAAQ;AAER,2CAA2C;AAE3C,6DAA6D;AAC7D,iCAAiC;AACjC,iDAAiD;AACjD,kEAAkE;AAClE,WAAW;AACX,kBAAkB;AAClB,eAAe;AACf,oCAAoC;AACpC,MAAM;AAEN,mCAAmC;AACnC,kCAAkC;AAClC,kCAAkC;AAClC,qBAAqB;AACrB,QAAQ;AAER,sDAAsD;AACtD,2BAA2B;AAC3B,2BAA2B;AAC3B,QAAQ;AACR,iDAAiD;AACjD,yDAAyD;AACzD,4EAA4E;AAC5E,iBAAiB;AACjB,sCAAsC;AACtC,gEAAgE;AAChE,SAAS;AACT,MAAM;AACN,IAAI","sourcesContent":["// import {\n//   BinaryLike,\n//   CipherKey,\n//   createCipheriv,\n//   createDecipheriv,\n//   createHash,\n//   getCipherInfo,\n// } from \"crypto\";\n// import {\n//   CryptoProvider,\n//   DefaultCryptoProvider,\n//   KeyConfiguration,\n// } from \"../shared\";\n\n// // It is fast and small, as Alice said to Bob.\n// const DEFAULT_ALGORITHM = \"des-ede-cbc\";\n\n// type Cipher = readonly [\n//   algorithm: string,\n//   key: CipherKey,\n//   iv: BinaryLike | null\n// ];\n\n// export class NativeCryptoProvider implements CryptoProvider {\n//   // The first one is the active one. The other ones can be used for key rotation.\n//   private readonly _ciphers: Record<string, Cipher | null>; //[algorithm,key,iv,success indicator]\n//   private readonly _currentCipher: readonly [string, Cipher | null];\n//   public get enabled() {\n//     return this._currentCipher?.[1] != null;\n//   }\n\n//   constructor(keys: KeyConfiguration[]) {\n//     const ciphers = keys\n//       .map(({ id, algorithm, key }) => {\n//         id = DefaultCryptoProvider.hash(this.hash(id));\n//         if (!key) return [id, null] as const; // No key (encryption disabled).\n//         const keyHash = createHash(\"sha256\");\n//         const bytes = keyHash.update(key, \"utf-8\").digest();\n//         algorithm = algorithm || DEFAULT_ALGORITHM;\n//         const { ivLength, keyLength } = getCipherInfo(algorithm) ?? {};\n//         if (keyLength) {\n//           return [\n//             id,\n//             [\n//               algorithm,\n//               bytes.subarray(0, keyLength),\n//               ivLength ? bytes.subarray(keyLength, keyLength + ivLength) : null,\n//             ] as Cipher,\n//           ] as const;\n//         } else {\n//           console.error(`Unsupported algorithm ${algorithm}`);\n//           return null!;\n//         }\n//       })\n//       .filter(Boolean);\n//     this._currentCipher = ciphers[0];\n//     this._ciphers = Object.fromEntries(ciphers);\n//   }\n\n//   public hash(cipherText: string) {\n//     const hash = createHash(\"sha1\");\n//     hash.update(cipherText, \"utf-8\");\n//     return hash.digest(\"base64\");\n//   }\n\n//   public decrypt(cipherText: string) {\n//     if (!this._currentCipher) {\n//       // Encryption is disabled.\n//       return null;\n//     }\n//     // Cipher ID? ')' payload\n//     const parts = cipherText.match(/^([^)]*)\\)(.*)/);\n//     if (!parts?.[1]) {\n//       return !parts ? cipherText : parts[2];\n//     }\n//     const cipher = this._ciphers[parts[1]];\n//     cipherText = parts[2];\n//     if (!cipher || !cipherText) {\n//       return \"\";\n//     }\n\n//     const [algorithm, key, iv] = cipher;\n\n//     const decipher = createDecipheriv(algorithm, key, iv);\n//     return `${decipher.update(\n//       `${cipherText}`.replace(/[\\-_]/g, (m) =>\n//         m === \"-\" ? \"+\" : m === \"_\" ? \"/\" : m === \".\" ? \"=\" : m\n//       ),\n//       \"base64\",\n//       \"utf8\"\n//     )}${decipher.final(\"utf8\")}`;\n//   }\n\n//   public encrypt(text: string) {\n//     if (!this._currentCipher) {\n//       // Encryption is disabled\n//       return null;\n//     }\n\n//     const [id, cipherConfig] = this._currentCipher;\n//     if (!cipherConfig) {\n//       return `)${text}`;\n//     }\n//     const [algorithm, key, iv] = cipherConfig;\n//     const cipher = createCipheriv(algorithm, key, iv);\n//     return `${id})${cipher.update(text, \"utf8\", \"base64\")}${cipher.final(\n//       \"base64\"\n//     )}`.replace(/[\\+\\/\\=]/g, (m) =>\n//       m === \"+\" ? \"-\" : m === \"/\" ? \"_\" : m === \"=\" ? \".\" : m\n//     );\n//   }\n// }\n"]}