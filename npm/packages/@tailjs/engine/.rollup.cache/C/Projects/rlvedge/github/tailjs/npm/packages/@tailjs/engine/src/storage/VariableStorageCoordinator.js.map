{"version":3,"file":"VariableStorageCoordinator.js","sourceRoot":"","sources":["VariableStorageCoordinator.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n  Variable,\r\n  VariableGetter,\r\n  VariablePatch,\r\n  VariableSetResult,\r\n  VariableSetStatus,\r\n  VariableSetter,\r\n  isConflictResult,\r\n  isErrorResult,\r\n  isVariablePatch,\r\n} from \"@tailjs/types\";\r\nimport { delay, isDefined } from \"@tailjs/util\";\r\nimport {\r\n  PartitionItem,\r\n  applyPatchOffline,\r\n  partitionItems,\r\n  withSourceIndex,\r\n} from \"../lib\";\r\n\r\nimport {\r\n  PrefixMappings,\r\n  ReadOnlyVariableStorage,\r\n  VariableStorageContext,\r\n  VariableSplitStorage,\r\n  VariableStorage,\r\n  isWritable,\r\n} from \"..\";\r\n\r\nexport interface VariableStorageCoordinatorSettings {\r\n  mappings: PrefixMappings;\r\n  retries?: number;\r\n  transientRetryDelay?: number;\r\n  errorRetryDelay?: number;\r\n}\r\n\r\nexport class VariableStorageCoordinator extends VariableSplitStorage {\r\n  private _settings: Required<VariableStorageCoordinatorSettings>;\r\n\r\n  constructor({\r\n    mappings,\r\n    retries = 3,\r\n    transientRetryDelay = 50,\r\n    errorRetryDelay = 250,\r\n  }: VariableStorageCoordinatorSettings) {\r\n    super(mappings);\r\n    this._settings = {\r\n      mappings,\r\n      retries,\r\n      transientRetryDelay,\r\n      errorRetryDelay,\r\n    };\r\n  }\r\n\r\n  private async _setWithRetry(\r\n    setters: (VariableSetter<any> | null | undefined)[],\r\n    targetStorage?: VariableStorage,\r\n    context?: VariableStorageContext,\r\n    patch?: (\r\n      sourceIndex: number,\r\n      result: VariableSetResult\r\n    ) => VariableSetter<any> | undefined\r\n  ): Promise<(VariableSetResult | undefined)[]> {\r\n    const finalResults: (VariableSetResult | undefined)[] = [];\r\n    let pending = withSourceIndex(setters);\r\n\r\n    const retries = this._settings.retries;\r\n    for (let i = 0; pending.length && i <= retries; i++) {\r\n      const current = pending;\r\n      let retryDelay = this._settings.transientRetryDelay;\r\n      pending = [];\r\n      try {\r\n        const results = await (targetStorage ? targetStorage.set : super.set)(\r\n          partitionItems(current),\r\n          context\r\n        );\r\n\r\n        results.forEach((result, j) => {\r\n          finalResults[j] = result;\r\n\r\n          if (isErrorResult(result) && result.transient) {\r\n            pending.push(current[j]);\r\n          } else if (isConflictResult(result) && patch) {\r\n            const patched = patch(j, result);\r\n            patched && pending.push([j, patched]);\r\n          }\r\n        });\r\n      } catch (e) {\r\n        retryDelay = this._settings.errorRetryDelay;\r\n        current.map(\r\n          ([index, source]) =>\r\n            source &&\r\n            (finalResults[index] = {\r\n              status: VariableSetStatus.Error as const,\r\n              error: `Operation did not complete after ${retries} attempts. ${e}`,\r\n              source: source,\r\n            })\r\n        );\r\n        pending = current;\r\n      }\r\n\r\n      if (pending.length) {\r\n        await delay((0.8 + 0.2 * Math.random()) * retryDelay * (i + 1));\r\n      }\r\n    }\r\n\r\n    // Map original sources (lest something was patched).\r\n    finalResults.forEach(\r\n      (result, i) => result && (result.source = setters[i]!)\r\n    );\r\n    return finalResults;\r\n  }\r\n\r\n  protected async _patchGetResults(\r\n    storage: ReadOnlyVariableStorage,\r\n    getters: VariableGetter<any>[],\r\n    results: (Variable<any> | undefined)[]\r\n  ): Promise<(Variable<any> | undefined)[]> {\r\n    const initializerSetters: VariableSetter<any>[] = [];\r\n\r\n    for (let i = 0; i < getters.length; i++) {\r\n      const getter = getters[i];\r\n      if (!getter.initializer || results[i]) {\r\n        continue;\r\n      }\r\n      if (!isWritable(storage)) {\r\n        throw new Error(\r\n          `A getter with an initializer was specified for a non-writable storage.`\r\n        );\r\n      }\r\n\r\n      const initialValue = await getter.initializer();\r\n      if (!isDefined(initialValue)) {\r\n        continue;\r\n      }\r\n      initializerSetters.push({ ...getter, ...initialValue });\r\n    }\r\n\r\n    if (isWritable(storage) && initializerSetters.length > 0) {\r\n      await this._setWithRetry(initializerSetters, storage);\r\n    }\r\n    return results;\r\n  }\r\n\r\n  protected async _patchSetResults(\r\n    storage: VariableStorage,\r\n    setters: VariableSetter<any, true>[],\r\n    results: (VariableSetResult | undefined)[],\r\n    context?: VariableStorageContext\r\n  ): Promise<(VariableSetResult | undefined)[]> {\r\n    const patches: PartitionItem<VariablePatch<any, true>>[] = [];\r\n\r\n    let setter: VariableSetter<any, true>;\r\n    results.forEach(\r\n      (result, i) =>\r\n        result?.status === VariableSetStatus.Unsupported &&\r\n        isVariablePatch((setter = setters[i])) &&\r\n        patches.push([i, setter])\r\n    );\r\n\r\n    if (patches.length) {\r\n      const applyPatch = (\r\n        patchIndex: number,\r\n        current: Variable | undefined\r\n      ) => {\r\n        const [sourceIndex, patch] = patches[patchIndex];\r\n        //const current = currentValues[i];\r\n        const patched = applyPatchOffline(current, patch);\r\n        if (!patched) {\r\n          results[sourceIndex] = {\r\n            status: VariableSetStatus.Unchanged,\r\n            current,\r\n            source: setters[sourceIndex],\r\n          };\r\n        }\r\n        return patched ? { ...setters[sourceIndex], ...patched } : undefined;\r\n      };\r\n\r\n      const patchSetters: PartitionItem<VariableSetter<any>>[] = [];\r\n      const currentValues = storage.get(partitionItems(patches), context);\r\n\r\n      for (let i = 0; i < patches.length; i++) {\r\n        const patched = applyPatch(i, currentValues[i]);\r\n        if (patched) {\r\n          patchSetters.push([i, patched]);\r\n        }\r\n      }\r\n\r\n      if (patchSetters.length > 0) {\r\n        (\r\n          await this._setWithRetry(\r\n            partitionItems(patchSetters),\r\n            storage,\r\n            context,\r\n            (sourceIndex, result) =>\r\n              isConflictResult(result)\r\n                ? applyPatch(patchSetters[sourceIndex][0], result.current)\r\n                : undefined\r\n          )\r\n        ).forEach((result, i) => {\r\n          // Map setter to patch to source.\r\n          const sourceIndex = patches[patchSetters[i][0]][0];\r\n          result && (result.source = setters[sourceIndex]);\r\n          results[sourceIndex] = result;\r\n        });\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n}\r\n"]}