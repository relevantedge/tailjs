{"version":3,"file":"TrackerVariableStorage.js","sourceRoot":"","sources":["TrackerVariableStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n  DataClassification,\r\n  Variable,\r\n  VariableFilter,\r\n  VariableGetter,\r\n  VariableHeader,\r\n  VariableQueryOptions,\r\n  VariableQueryResult,\r\n  VariableScope,\r\n  VariableScopeValue,\r\n  VariableSetResult,\r\n  VariableSetStatus,\r\n  VariableSetter,\r\n  VariableValidationBasis,\r\n  dataClassification,\r\n  dataPurposes,\r\n  isSuccessResult,\r\n  isVariablePatch,\r\n  toStrict,\r\n  variableScope,\r\n} from \"@tailjs/types\";\r\nimport { MaybePromise, isDefined, isFunction } from \"@tailjs/util\";\r\nimport {\r\n  Tracker,\r\n  VariableGetResults,\r\n  VariableSetResults,\r\n  VariableStorage,\r\n  VariableStorageContext,\r\n} from \"..\";\r\n\r\nimport { PartitionItem, extractKey, parseKey } from \".\";\r\n\r\nconst trackerScopes = new Set([\r\n  VariableScope.User,\r\n  VariableScope.Device,\r\n  VariableScope.Session,\r\n]);\r\nconst nonTrackerScopes = new Set([VariableScope.Global, VariableScope.Entity]);\r\n\r\nexport class TrackerVariableStorage implements VariableStorage {\r\n  private _storage: VariableStorage;\r\n\r\n  constructor(storage: VariableStorage) {\r\n    this._storage = storage;\r\n  }\r\n\r\n  public configureScopeDurations(\r\n    durations: Partial<Record<VariableScopeValue<false>, number>>,\r\n    context?: VariableStorageContext\r\n  ): void {\r\n    this._storage.configureScopeDurations(durations, context);\r\n  }\r\n\r\n  public renew(\r\n    scope: VariableScope,\r\n    scopeIds: string[],\r\n    context?: VariableStorageContext\r\n  ): MaybePromise<void> {\r\n    if (context?.tracker && this._isRestrictedScope(scope)) {\r\n      const scopeId = this._getScopeTargetId(scope, context.tracker);\r\n      if (!scopeId) {\r\n        return;\r\n      }\r\n      scopeIds = [scopeId];\r\n    }\r\n    return this._storage.renew(scope, scopeIds, context);\r\n  }\r\n\r\n  private _isRestrictedScope(scope: VariableScope) {\r\n    return (\r\n      scope === VariableScope.Session ||\r\n      scope === VariableScope.Device ||\r\n      scope === VariableScope.User\r\n    );\r\n  }\r\n\r\n  private _getScopeTargetId(scope: VariableScope, tracker: Tracker) {\r\n    return scope === VariableScope.Session\r\n      ? tracker.session.id\r\n      : scope === VariableScope.Device\r\n      ? tracker.session.deviceId\r\n      : scope === VariableScope.User\r\n      ? tracker.session.userId\r\n      : undefined;\r\n  }\r\n\r\n  private _getMaxConsentLevel(scope: VariableScope, tracker: Tracker) {\r\n    // If a user is authenticated, it is assumed that there is consent for storing direct personal data,\r\n    // (right? The user must have provided a user name somehow...).\r\n\r\n    // This also means that a user may have consented to having their profile data such as name stored,\r\n    // but still do not want to be tracked.\r\n    return scope === VariableScope.User\r\n      ? DataClassification.Direct\r\n      : tracker.consent.level;\r\n  }\r\n\r\n  private _validate<T extends VariableValidationBasis<true>>(\r\n    variable: T | null | undefined,\r\n    tracker: Tracker\r\n  ) {\r\n    if (!variable) return undefined;\r\n\r\n    if (this._isRestrictedScope(variable.scope)) {\r\n      const originalTargetId = variable.targetId;\r\n      variable.targetId = this._getScopeTargetId(variable.scope, tracker);\r\n\r\n      if (originalTargetId && variable.targetId !== originalTargetId) {\r\n        throw new TypeError(\r\n          `Target ID must either match the tracker or be unspecified.`\r\n        );\r\n      }\r\n\r\n      if (!variable.targetId) {\r\n        // There is not consented ID for the scope in the tracker, or an ID unrelated to the current tracker was used.\r\n        return undefined;\r\n      }\r\n\r\n      if (isDefined(variable.classification)) {\r\n        if (\r\n          this._getMaxConsentLevel(variable.scope, tracker) <\r\n            variable.classification ||\r\n          (variable.purposes &&\r\n            tracker.consent.purposes && // This check ignores Necessary (which is 0)\r\n            !(tracker.consent.purposes & variable.purposes))\r\n        ) {\r\n          return undefined;\r\n        }\r\n      }\r\n    }\r\n\r\n    return variable;\r\n  }\r\n\r\n  public async set<K extends (VariableSetter<any> | null | undefined)[]>(\r\n    variables: K,\r\n    context?: VariableStorageContext\r\n  ): Promise<VariableSetResults<K>> {\r\n    const tracker = context?.tracker;\r\n\r\n    if (!tracker) {\r\n      return await this._storage.set(variables, context);\r\n    }\r\n\r\n    const validated = variables.map((variable) =>\r\n      this._validate(toStrict(variable), tracker)\r\n    );\r\n\r\n    validated.forEach(\r\n      (setter) =>\r\n        // Any attempt to change a device variable (even if it fails) must trigger the tracker to refresh all device variables and send them to the the client,\r\n        // to avoid race conditions (requests may complete out of request order, hence send stale cookies otherwise).\r\n        setter &&\r\n        setter.scope === VariableScope.Device &&\r\n        tracker._touchClientDeviceData()\r\n    );\r\n\r\n    const denied: PartitionItem<VariableSetResult<any>>[] = [];\r\n    validated.forEach((source, sourceIndex) => {\r\n      if (!source) return;\r\n\r\n      if (isVariablePatch(source) && isFunction(source.patch)) {\r\n        const captured = source.patch;\r\n        source.patch = (current) => {\r\n          // If the patch returns something that does not match the current consent,\r\n          // we need to 1) return undefined to avoid the storage to save anything, 2) patch the results with a \"denied\" status.\r\n          const inner = captured(current);\r\n          if (\r\n            inner &&\r\n            !this._validate({ ...extractKey(source), ...current }, tracker)\r\n          ) {\r\n            denied.push([\r\n              sourceIndex,\r\n              { status: VariableSetStatus.Denied, source },\r\n            ]);\r\n            return undefined;\r\n          }\r\n          return inner;\r\n        };\r\n      }\r\n    });\r\n    const results = (await this._storage.set(\r\n      validated,\r\n      context\r\n    )) as VariableSetResult<any>[];\r\n\r\n    denied.forEach(([sourceIndex, status]) => (results[sourceIndex] = status));\r\n    for (const result of results) {\r\n      isSuccessResult(result) &&\r\n        (await tracker._maybeUpdate(result.source, result.current));\r\n    }\r\n\r\n    return results as VariableSetResults<K>;\r\n  }\r\n\r\n  private _validateFilters(filters: VariableFilter[], tracker: Tracker) {\r\n    let validatedFilters: VariableFilter[] = [];\r\n\r\n    const consent = tracker.consent;\r\n    for (let filter of filters) {\r\n      // For each scope that intersects the tracker scopes, add a separate filter restricted to the target ID\r\n      // that matches the current tracker.\r\n      const scopes =\r\n        filter.scopes?.map((item) => variableScope(item)) ??\r\n        variableScope.values;\r\n\r\n      const safe = scopes.filter((scope) => nonTrackerScopes.has(scope));\r\n      safe.length && validatedFilters.push({ ...filter, scopes: safe });\r\n      validatedFilters.push(\r\n        ...scopes\r\n          .filter((scope) => trackerScopes.has(scope))\r\n          .map((scope) => {\r\n            const targetId = this._getScopeTargetId(scope, tracker);\r\n            const consentLevel = this._getMaxConsentLevel(scope, tracker);\r\n            return targetId\r\n              ? {\r\n                  ...(consent.purposes ||\r\n                  consentLevel < DataClassification.Sensitive\r\n                    ? {\r\n                        ...filter,\r\n                        // Remove purposes without consent (if purposes are undefined in consent, it means \"I am good with all\").\r\n                        purposes: filter.purposes\r\n                          ? dataPurposes(filter.purposes) & consent.purposes\r\n                          : undefined,\r\n\r\n                        classification: filter.classification && {\r\n                          // Cap classification filter so no criteria exceeds the consent's level.\r\n                          min:\r\n                            dataClassification(filter.classification.min)! >\r\n                            consentLevel\r\n                              ? consentLevel\r\n                              : filter.classification.min,\r\n                          // If no explicit levels are set, limit the max value to the consent's level.\r\n                          max:\r\n                            dataClassification(filter.classification.max)! >\r\n                              consentLevel || !filter.classification.levels\r\n                              ? consentLevel\r\n                              : filter.classification.max,\r\n                          levels: filter.classification.levels?.filter(\r\n                            (level) => dataClassification(level) <= consentLevel\r\n                          ),\r\n                        },\r\n                      }\r\n                    : filter),\r\n                  scopes: [scope],\r\n                  targetIds: [targetId],\r\n                }\r\n              : undefined;\r\n          })\r\n          .filter(isDefined)\r\n      );\r\n    }\r\n    return validatedFilters;\r\n  }\r\n\r\n  async purge(\r\n    filters: VariableFilter[],\r\n    context?: VariableStorageContext\r\n  ): Promise<void> {\r\n    if (!context?.tracker) {\r\n      return this._storage.purge(filters, context);\r\n    }\r\n\r\n    await this._storage.purge(\r\n      this._validateFilters(filters, context.tracker),\r\n      context\r\n    );\r\n  }\r\n\r\n  private _trackDeviceData(\r\n    getter: VariableGetter<any> | undefined,\r\n    tracker: Tracker\r\n  ) {\r\n    if (\r\n      getter &&\r\n      variableScope.tryParse(getter.scope) === VariableScope.Device &&\r\n      !parseKey(getter.key).prefix\r\n    ) {\r\n      if (!getter.initializer) {\r\n        // Try read the value from the device if it is not cached.\r\n        getter.initializer = () =>\r\n          tracker._getClientDeviceVariables()?.variables?.[getter.key];\r\n      }\r\n\r\n      // Only load new if changed since persisted version.\r\n      getter.version ??=\r\n        tracker._getClientDeviceVariables()?.[getter.key]?.version;\r\n    }\r\n    return getter;\r\n  }\r\n\r\n  async get<K extends (VariableGetter<any> | null | undefined)[]>(\r\n    keys: K,\r\n    context?: VariableStorageContext\r\n  ): Promise<VariableGetResults<K>> {\r\n    if (!context?.tracker) {\r\n      return this._storage.get(keys, context);\r\n    }\r\n    const results = await this._storage.get(\r\n      keys.map((key) => {\r\n        const ged = this._validate(toStrict(key), context.tracker!);\r\n        return this._trackDeviceData(ged, context.tracker!);\r\n      }),\r\n      context\r\n    );\r\n\r\n    return results.map((result) =>\r\n      this._validate(result, context.tracker!)\r\n    ) as VariableGetResults<K>;\r\n  }\r\n\r\n  private _queryOrHead(\r\n    method: \"head\" | \"query\",\r\n    filters: VariableFilter[],\r\n    options?: VariableQueryOptions | undefined,\r\n    context?: VariableStorageContext\r\n  ) {\r\n    // Queries always go straight to the storage (not looking at cached device variables).\r\n    if (!context?.tracker) {\r\n      return this._storage[method](filters, options, context);\r\n    }\r\n\r\n    return this._storage[method](\r\n      this._validateFilters(filters, context.tracker),\r\n      options,\r\n      context\r\n    ) as VariableQueryResult;\r\n  }\r\n\r\n  head(\r\n    filters: VariableFilter[],\r\n    options?: VariableQueryOptions | undefined,\r\n    context?: VariableStorageContext\r\n  ): MaybePromise<VariableQueryResult<VariableHeader<true>>> {\r\n    return this._queryOrHead(\"head\", filters, options, context);\r\n  }\r\n  query(\r\n    filters: VariableFilter[],\r\n    options?: VariableQueryOptions | undefined,\r\n    context?: VariableStorageContext\r\n  ): MaybePromise<VariableQueryResult<Variable<any>>> {\r\n    return this._queryOrHead(\r\n      \"query\",\r\n      filters,\r\n      options,\r\n      context\r\n    ) as MaybePromise<VariableQueryResult<Variable<any>>>;\r\n  }\r\n}\r\n"]}