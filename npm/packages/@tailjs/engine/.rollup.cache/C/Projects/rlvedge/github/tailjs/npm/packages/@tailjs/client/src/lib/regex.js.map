{"version":3,"file":"regex.js","sourceRoot":"","sources":["regex.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ConstToNormal,\n  IterableOrSelf,\n  Nullish,\n  Nulls,\n} from \"@tailjs/util\";\nimport {\n  REGEX,\n  TestOrConvertFunction,\n  array,\n  bool,\n  filter,\n  map,\n  str,\n  testOrConvertFunction,\n  undefined,\n  distinct,\n  size,\n  nil,\n  push,\n} from \".\";\n\n/**\n * Common definition of expresions that are used for string matching.\n *\n * If not already a regular expression, a string that starst with `/` and optionally ends with `/` is parsed as regular expressions with flags `gu` applied (global and Unicode).\n * This enables defining regular expression in text based configuration files that do not have native regular expressions.\n *\n * For convenience an asterisk (`*`) can be used to match any number of characters in strings, and  `,` and white-space ` ` are intepreted as list separators.\n * `\\` is used as the escape character so the string `\\/escaped\\*,and\\ this` will only match the strings, literally, `\\/escaped\\*` and `and this`.\n * This also means that intentional backslashes, commas and spaces must be escaped as `\\\\`, `\\,` and `\\ ` respectively.\n *\n * Arrays of strings and/or regular expressions are evaluated as unions (_string 1_ \"or\" _string 2_ \"or\" ...).\n *\n * The special values `null`, `undefined`, the empty string,  and `false` are interpreted as \"never\", and `true` is \"always\".\n *\n * Regarding separators, they may be different in specific contexts. If so, it will be mentioned there.\n */\nexport type ParsableRegExp =\n  | IterableOrSelf<null | undefined | boolean | string | RegExp>\n  | Iterable<ParsableRegExp>;\n\n/**\n * `Regex.test` optimized for minifying.\n */\nexport const test = (s: string | Nullish, match: RegExp | Nullish) =>\n  !!(s && match) && match.test(s);\n\nlet matchSelected: any;\n/**\n * Matches a regular expression against a string and projects the matched parts, if any.\n */\nexport const match: {\n  <R>(\n    s: string | Nullish,\n    match: RegExp | Nullish,\n    selector: (...args: string[]) => R | Nullish,\n    defaultValue: R[]\n  ): ConstToNormal<R>[];\n  <R>(\n    s: string | Nullish,\n    match: RegExp | Nullish,\n    selector: (...args: string[]) => R,\n    defaultValue?: R\n  ): ConstToNormal<R> | undefined;\n  (s: string | Nullish, match: RegExp | Nullish): RegExpMatchArray | null;\n} = <R>(\n  s: string,\n  regex: RegExp,\n  selector?: (...args: string[]) => R,\n  defaultValue?: R\n) =>\n  s &&\n  regex &&\n  (selector\n    ? (array(defaultValue)\n        ? match(\n            s,\n            regex,\n            (...args) =>\n              (matchSelected = selector(...args)) != nil &&\n              push(defaultValue as any, matchSelected)\n          )\n        : s.replace(\n            regex,\n            (...args) => ((defaultValue = selector(...args)), \"\")\n          ),\n      defaultValue)\n    : s.match(regex));\n\n/**\n * Replaces reserved characters to get a regular expression that matches the string.\n */\nexport const escapeRegEx = (input: string) =>\n  input.replace(/[\\^$\\\\.*+?()[\\]{}|]/g, \"\\\\$&\");\n\nconst REGEX_NEVER = /\\z./g;\nconst unionOrNever = (parts: (string | Nullish)[], joined?: string) =>\n  (joined = join(distinct(filter(parts, size)), \"|\"))\n    ? new RegExp(joined, \"gu\")\n    : REGEX_NEVER;\n\nconst stringRuleCache: { [pattern: string]: RegExp } = {};\n/**\n * Tests or parses a regular expression accepting the {@link ParsableRegExp} format.\n *\n * Strings are cached, so there is no need to do additional caching outside this function (as far as the caching would only concern strings).\n */\nexport const regex: TestOrConvertFunction<\n  RegExp,\n  ParsableRegExp,\n  [separators?: string[]]\n> = testOrConvertFunction(\n  REGEX,\n  (input: string | boolean | any[] | Nullish, separators = [\",\", \" \"]) =>\n    regex(input)\n      ? input\n      : array(input) // Parse individual specifiers, and join them into one long regex. An empty array is interpreted as \"never\".\n      ? unionOrNever(\n          map(input, (part) => regex(part, false, separators)?.source)\n        )\n      : bool(input)\n      ? input // `true` is \"always\", `false` is \"never\"\n        ? /./g\n        : REGEX_NEVER // Matches nothing. End of string followed by something is never the case.\n      : str(input)\n      ? (stringRuleCache[input] ??= match(\n          input || \"\",\n          /^(?:\\/(.+?)\\/?|(.*))$/gu,\n          (_, regex, text) =>\n            regex\n              ? new RegExp(regex, \"gu\")\n              : unionOrNever(\n                  map(\n                    split(\n                      text,\n                      new RegExp(\n                        `?<!(?<!\\\\)\\\\)[${join(map(separators, escapeRegEx))}]/`\n                      )\n                    ),\n                    (text) =>\n                      text &&\n                      `^${join(\n                        map(\n                          // Split on non-escaped asterisk (Characterized by a leading backslash that is not itself an escaped backslash).\n                          split(text, /(?<!(?<!\\\\)\\\\)\\*/),\n                          (part) =>\n                            escapeRegEx(\n                              // Remove backslashes used for escaping.\n                              replace(part, /\\\\(.)/g, \"$1\")\n                            )\n                        ),\n                        // Join the parts separated by non-escaped asterisks with the regex wildcard equivalent.\n                        \".*\"\n                      )}$`\n                  )\n                )\n        )!)\n      : undefined\n);\n\n/**\n * Better minifyable version of `String`'s `split` method that allows a null'ish parameter.\n */\nexport const split = <T extends string | Nullish>(\n  s: T,\n  separator: RegExp | string\n): T extends string ? string[] : string[] | Nulls<T> =>\n  s?.split(separator) ?? (s as any);\n\n/**\n * Better minifyable version of `String`'s `replace` method that allows a null'ish parameter.\n */\nexport const replace = <T extends string | Nullish>(\n  s: T,\n  match: RegExp,\n  replaceValue: string | ((...args: string[]) => string)\n): T => s?.replace(match, replaceValue as any) ?? (s as any);\n\n/**\n *  Better minifyable version of `String`'s `join` method that allows a null'ish parameter and removes empty.\n */\nexport const join = <T extends (string | Nullish)[] | Nullish>(\n  s: T,\n  separator = \"\"\n): string | Nulls<T> => (s?.join(separator) ?? s) as any;\n"]}