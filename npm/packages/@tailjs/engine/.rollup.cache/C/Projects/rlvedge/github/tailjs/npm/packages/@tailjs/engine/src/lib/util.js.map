{"version":3,"file":"util.js","sourceRoot":"","sources":["util.ts"],"names":[],"mappings":"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","sourcesContent":["import { Expand } from \".\";\nimport { Encodable, EncodableObject } from \"@tailjs/util/transport\";\n\nexport function any<T>(\n  value: T\n): value is T extends null | undefined ? never : T {\n  if (typeof value !== \"object\") {\n    return Array.isArray(value) ? value.length > 0 : value != null;\n  }\n\n  for (const _ in value) {\n    return true;\n  }\n  return false;\n}\n\nexport function stringVal(\n  value: string | string[] | undefined | null,\n  sep = \";\"\n) {\n  return value == null ? value : Array.isArray(value) ? value.join(sep) : value;\n}\n\nfunction* countYields<T>(items: Iterable<T>) {\n  let n = 0;\n  for (const item of items) {\n    yield item;\n    ++n;\n  }\n  return n;\n}\n\nfunction* iterateObject<K extends keyof any, V, T extends Record<K, V>, R>(\n  source: T,\n  projection: (src: T, key: K) => R\n): Iterable<R> {\n  let i = 0;\n  for (const p in source) {\n    yield projection(source, p as any);\n    ++i;\n  }\n  return i;\n}\n\ntype CleanPartitions<T> = {\n  [P in keyof T]: T[P] extends infer T & never[] ? T : T;\n};\n\nexport function keys<K extends keyof any, V>(\n  source: Record<K, V>\n): Iterable<K> {\n  return iterateObject(source, (src, key) => key) as any;\n}\n\nexport function values<K extends keyof any, V>(\n  source: Record<K, V>\n): Iterable<V> {\n  return iterateObject(source, (src, key) => src[key]);\n}\n\nexport function entries<K extends keyof any, V>(\n  source?: Record<K, V>\n): Iterable<[K, V]> {\n  return source == null\n    ? []\n    : (iterateObject(source, (src, key) => [key, src[key]]) as any);\n}\n\nexport const isIterable = (value: any): value is Iterable<any> =>\n  value[Symbol.iterator] !== void 0;\n\nexport type GroupFunction = {\n  <K, V>(\n    ...values: (Iterable<[K, Iterable<V | undefined>]> | undefined)[]\n  ): Map<K, V[]>;\n  <K, V>(...values: (Iterable<[K, V]> | undefined)[]): Map<K, V[]>;\n};\nexport const group = (<K, V>(...values: Iterable<[K, V]>[]): Map<K, any> => {\n  const groups = new Map<K, V[]>();\n  for (const src of values) {\n    if (src === undefined) continue;\n\n    for (const [key, value] of src) {\n      let current = groups.get(key);\n      if (current === undefined) {\n        groups.set(key, (current = []));\n      }\n      if (isIterable(value)) {\n        current.push(...value);\n      } else {\n        current.push(value);\n      }\n    }\n  }\n  return groups;\n}) as GroupFunction;\n\ntype FlatItem<T> = T extends (infer T)[] ? T : T;\n\ntype ReturnType<RT extends number, Flat extends boolean, T> = Flat extends true\n  ? ReturnType<RT, false, FlatItem<T>>\n  : RT extends 0\n  ? T[]\n  : RT extends 1\n  ? Iterable<T> & { flat(): T extends (infer T)[] ? T : T }\n  : void;\n\nexport type MapFunction<RT extends 0 | 1 | 2, Flat extends boolean = false> = {\n  <T, P = T>(\n    values: Iterable<T> | null | undefined,\n    projection?: ((value: T, index: number) => undefined | P) | null\n  ): ReturnType<RT, Flat, P>;\n  <T extends string | number | boolean, P = T>(\n    values: Iterable<T> | T | null | undefined,\n    projection?: ((value: T, index: number) => undefined | P) | null\n  ): ReturnType<RT, Flat, P>;\n  <K extends keyof any, V, P = [K, V]>(\n    values: Iterable<[K, V]> | Record<K, V> | null | undefined,\n    projection?: ((value: [K, V], index: number) => undefined | P) | null\n  ): ReturnType<RT, Flat, P>;\n  <T, P = T>(\n    values: Iterable<T> | T | null | undefined,\n    projection?: ((value: T, index: number) => undefined | P) | null\n  ): ReturnType<RT, Flat, P>;\n};\n\nexport const flat: MapFunction<0, true> & { it: MapFunction<1, true> } =\n  Object.assign((...args: any[]) => [...(flat.it as any)(...args)], {\n    *it(...args: any) {\n      for (const item in (map as any).it(...args)) {\n        if (Array.isArray(item)) {\n          yield* item;\n        } else {\n          yield item;\n        }\n      }\n    },\n  }) as any;\n\nexport const map: MapFunction<0> & {\n  it: MapFunction<1>;\n} = Object.assign((...args: any[]) => [...(map.it as any)(...args)], {\n  *it(values: Iterable<any>, projection?: (value: any, index: number) => any) {\n    if (!values) return 0;\n    const length = values[\"length\"] ?? values[\"count\"] ?? values[\"Count\"];\n    if (typeof length === \"number\") {\n      const newValues: any[] = [];\n      for (let i = 0; i < length; i++) {\n        newValues[i] = values[i];\n      }\n      values = newValues;\n    }\n\n    const iterable = (\n      values[Symbol.iterator]\n        ? values\n        : typeof values === \"object\"\n        ? Object.entries(values)\n        : [values]\n    ) as Iterable<any>;\n\n    if (!projection) {\n      return yield* countYields<any>(iterable);\n    }\n\n    let i = 0;\n    let n = 0;\n\n    for (const value of iterable) {\n      const projected = projection(value, i++);\n      if (projected === void 0) continue;\n      if (Array.isArray(projected[\"flat\"])) {\n        for (const value of projected[\"flat\"]) {\n          yield value;\n        }\n      }\n\n      yield projected;\n      ++n;\n    }\n    return n;\n  },\n}) as any;\n\nexport const filter = merge(\n  <T>(\n    values: Iterable<T> | null | undefined,\n    evaluate: ((value: T, index: number) => boolean) | null | undefined\n  ) => [...filter.it(values, evaluate)],\n  {\n    *it<T>(\n      values: Iterable<T> | null | undefined,\n      evaluate: ((value: T, index: number) => boolean) | null | undefined\n    ) {\n      if (!values) {\n        return 0;\n      }\n      if (!evaluate) {\n        return yield* countYields(values);\n      }\n\n      let i = 0;\n      let n = 0;\n      for (const value of values) {\n        if (evaluate(value, i++)) {\n          ++n;\n          yield value;\n        }\n      }\n      return n;\n    },\n  }\n);\n\nexport const forEach: MapFunction<2> = (values: any, action: any) => {\n  let i = 0;\n  for (const v of map.it(values)) {\n    action(v, i++);\n  }\n};\n\ntype Join<T extends any[]> = T extends [infer T]\n  ? T\n  : T extends [...infer Tail, infer T]\n  ? T & Join<Tail>\n  : never;\n\nexport function merge<T extends any[]>(...args: T): Expand<Join<T>> {\n  let target = args[0];\n  for (const source of args.slice(1)) {\n    for (const [key, value] of Object.entries(source)) {\n      if (value === void 0) {\n        // delete target[key];\n      } else if (typeof target[key] === \"object\" && typeof value === \"object\") {\n        if (Object.getPrototypeOf(value) === Object.prototype) {\n          merge(target[key], value);\n        } else {\n          target[key] = value;\n        }\n      } else {\n        target[key] = value;\n      }\n    }\n  }\n  return target;\n}\n\nexport const params = (\n  value: string | string[] | null | undefined,\n  decode = true\n): [string, string][] => {\n  if (!value) return [];\n\n  return Array.isArray(value) ? value.map(split) : [split(value)];\n\n  function split(value: string) {\n    const parts = value\n      .split(\"=\")\n      .map((v) => (decode ? decodeURIComponent(v.trim()) : v.trim()));\n    parts[1] ??= \"\";\n    return parts as [string, string];\n  }\n};\n\nexport const unparam = (\n  value: Record<string, string | null | undefined> | null | undefined,\n  encode = true\n) => {\n  if (!value) return \"\";\n  return map(value, ([key, value]) =>\n    value\n      ? `${encode ? encodeURIComponent(key) : key}=${\n          encode ? encodeURIComponent(value) : value\n        }`\n      : key\n  ).join(\"; \");\n};\n\nexport const tryParse = <T>(\n  value: string | undefined,\n  update: (value: T | null) => T\n) => (value ? update(JSON.parse(value)) : update(null));\n\nexport const expandPaths = (obj: Record<string, any>): Record<string, any> => {\n  const result: Record<string, any> = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const path = key.split(\".\");\n    let target = result;\n    for (let i = 0; i < path.length; i++) {\n      if (i < path.length - 1) {\n        target = target[path[i]] ??= {};\n      } else {\n        target[path[i]] = value;\n      }\n    }\n  }\n  return result;\n};\n\nexport const replace = <T extends string | null>(\n  s: T,\n  replacements: [from: string, to: string][],\n  encode: boolean\n): T extends null ? T : string =>\n  s == null\n    ? (null as any)\n    : replacements.reduce(\n        (s, [from, to]) => s.replaceAll(encode ? from : to, encode ? to : from),\n        s\n      );\n\nexport const formatError = (error: any) =>\n  error == null\n    ? \"(Unspecified error)\"\n    : [error?.message ?? error, error?.stack].filter((s) => s).join(\"\\n\\n\");\n\nexport const clone = <T extends Encodable>(value: T): T =>\n  value == null\n    ? value\n    : Array.isArray(value)\n    ? value.map(clone)\n    : typeof value === \"object\"\n    ? Object.fromEntries(\n        Object.entries(value).map(([key, value]) => [key, clone(value)])\n      )\n    : (value as any);\n\nexport const equals = (lhs: Encodable, rhs: Encodable) =>\n  lhs === rhs ||\n  (Array.isArray(lhs) || Array.isArray(rhs)\n    ? Array.isArray(lhs) &&\n      Array.isArray(rhs) &&\n      lhs.length === rhs.length &&\n      lhs.every((value, index) => equals(value, rhs[index]))\n    : typeof lhs === \"object\" && typeof rhs === \"object\"\n    ? objectsEqual(lhs, rhs)\n    : false);\n\nexport const objectsEqual = (\n  lhs: EncodableObject | null,\n  rhs: EncodableObject | null\n) => {\n  if (lhs === rhs || lhs == null || rhs == null) return lhs === rhs;\n  const leftEntries = Object.entries(lhs);\n  const rightEntries = Object.entries(rhs);\n  return (\n    leftEntries.length === rightEntries.length &&\n    leftEntries.every(\n      ([key, value], index) =>\n        rightEntries[index][0] === key && equals(value, rightEntries[index][1])\n    )\n  );\n};\n\nexport interface Timer {\n  start(): this;\n  stop(): this;\n  reset(): this;\n\n  print(milestone?: string): this;\n}\n\nexport const timer = (name: string): Timer => {\n  let elapsed = 0;\n\n  let t0: number | null = null;\n\n  const timer = {\n    start() {\n      t0 ??= Date.now();\n      return timer;\n    },\n    stop() {\n      t0 != null && ((elapsed += Date.now() - t0), (t0 = null));\n      return timer;\n    },\n    reset() {\n      elapsed = 0;\n      t0 !== null && (t0 = Date.now());\n      return this;\n    },\n    print(milestone?: string) {\n      t0 !== null && ((elapsed += Date.now() - t0), (t0 = Date.now()));\n      console.log(\n        `${name}${milestone ? ` (${milestone})` : \"\"}: ${elapsed} ms.`\n      );\n      return timer;\n    },\n  };\n  return timer;\n};\n"]}