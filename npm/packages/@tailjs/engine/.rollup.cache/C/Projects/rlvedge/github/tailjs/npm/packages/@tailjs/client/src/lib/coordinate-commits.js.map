{"version":3,"file":"coordinate-commits.js","sourceRoot":"","sources":["coordinate-commits.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Expired,\n  F,\n  MAX_SAFE_INTEGER,\n  OpenPromise,\n  OpenPromiseWithTimeout,\n  Reset,\n  T,\n  TAB_ID,\n  TabId,\n  any,\n  clear,\n  createChannel,\n  debug,\n  defer,\n  del,\n  delay,\n  entries,\n  formatDuration,\n  getMinTabId,\n  keys,\n  listen,\n  nil,\n  now,\n  openPromise,\n  push,\n  registerStartupHandler,\n  size,\n  splice,\n  timeout,\n  trackerConfig,\n  tryAsync,\n  values,\n  window,\n} from \".\";\n\ntype Data = any;\ntype ActionId = string;\n\n// After this amount of ms it is assumed safe that all tabe have received a message sent from any other tab.\nconst MAX_MESSAGE_DELAY = 25;\nconst CLOSED_TAB_TIMEOUT = 500; // After this duration a closed tab is considered gone.\n\nexport type CommitAction<Data = any> = (\n  data: Data[],\n  critical: boolean\n) => Promise<boolean | void>;\n\nexport type ExitAction = (terminating: boolean) => void;\n\nconst enum MessageType {\n  /**\n   * Informs other tabs that a new tab loaded (either from bf cache or first load).\n   * The other tabs will reply with the same message to the new tab so it will know about all current tabs.\n   */\n  Loaded = 1,\n\n  /**\n   * Informs other tabs that a tab is unloading (either to bf cache or for good).\n   * When all tabs are unloading the last one will collect and commit their pending data.\n   *\n   */\n  Unloading = 2,\n\n  /**\n   * Broadcasts events that were collected in the tab.\n   */\n  Collect = 3,\n\n  /**\n   * Instructs a tab to coordinate a commit. It will do so if it has the smallest known tab ID, otherwise it will forward the request\n   * to the tab it thinks has the smallest ID.\n   */\n  Coordinate = 4,\n\n  /**\n   * Tabs will clear their collected data on this message. The tab that has the cooridnator ID will additionally commit it.\n   */\n  Commit = 5,\n\n  /**\n   * The tab received focus.\n   */\n  Activated = 6,\n\n  /**\n   * Tab lost focus.\n   */\n  Deactivated = 7,\n}\n\nexport type ActionHandler = [commit: CommitAction, exit?: ExitAction];\ntype ActionState = [\n  collected: Data[],\n  commitHandle: OpenPromiseWithTimeout<[success: boolean, items: number]>\n];\n\n// This is used to keep track of open and closing tabs so we can evaluate which tabs has the smalles ID (was opened first).\n// This tab must be the one comitting since it is the only one that is guaranteed to have seen all previous posts form other tabs.\n// This approach can also be thought of as an efficient algorithm for \"leader election\" to prevent multiple tabs making HTTP requests at the same time.\n// Interleaved HTTP requests must be avoided since it breaks the server state stored in the HTTP cookies.\n//\n// It cannot be prevented when all tabs are closing and an existing request has already been made to a slow server.\n// In this case the client flags the request to let the server know the the state should not be updated with the final request.\n// When this final race-condition occurs it is assumed _unlikely_ that the final request will contain other events than \"VIEW_END\" events (no \"VIEW\" events in particular),\n// so the book-keeping made for session duration, number of views,  previous session etc. is equally _unlikely_ to get out of sync.\nconst knownTabs: Record<\n  TabId,\n  number | null // If closed, at timestamp for when it happened.\n> = {};\n\nconst actionHandlers: Record<string, ActionHandler> = {};\n\nlet localData: Record<ActionId, Data[]> = {};\n\nconst flushLocalData = () => {\n  const currentData = localData;\n  localData = {};\n  return currentData;\n};\nexport const registerAction = <Data>(\n  id: ActionId,\n  ...actionHandler: ActionHandler\n): [\n  post: (...data: Data[]) => void,\n  commit: (critical?: boolean) => Promise<number>\n] => {\n  actionHandlers[id] = actionHandler;\n  return [\n    (...data) =>\n      size(data) &&\n      (push((localData[id] ??= []), ...data),\n      !closing &&\n        defer(\n          () =>\n            size(localData) && channel([MessageType.Collect, flushLocalData()])\n        )),\n    () => coordinateCommit(id),\n  ];\n};\n\nconst actionStates: Record<TabId, ActionState> = {};\nconst getActionState = (id: ActionId): ActionState =>\n  (actionStates[id] ??= [\n    [],\n    openPromise<[success: boolean, items: number]>(\n      trackerConfig.requestTimeout * 2\n    )([T, 0]),\n  ]);\n\nconst purgeClosedTabs = (timeout: number) =>\n  entries(\n    knownTabs,\n    ([key, value]) =>\n      value && Date.now() - value > timeout && del(knownTabs, key)\n  );\n\nconst getCoordinatorId = () => getMinTabId(TAB_ID, ...keys(knownTabs));\n\nconst isLastTab = () =>\n  !any(values(knownTabs), (closing) => !closing) &&\n  getCoordinatorId() === TAB_ID;\n\nconst channel = createChannel(\n  \"cs\",\n  {\n    [MessageType.Loaded]: ([sourceId, direct]) => {\n      knownTabs[sourceId] ??= nil;\n      !direct &&\n        sourceId !== TAB_ID &&\n        !closing &&\n        channel([MessageType.Loaded], sourceId);\n    },\n    [MessageType.Unloading](\n      [sourceId],\n      freezing: boolean,\n      data: Record<string, any>\n    ) {\n      knownTabs[sourceId] = Date.now();\n      entries(data, ([key, value]) => collect(key, value));\n      if (!freezing) {\n        keys(\n          actionHandlers,\n          (key) => isLastTab() && channel([MessageType.Commit, key, TAB_ID, T])\n        );\n      }\n    },\n\n    [MessageType.Collect](_, data: Record<ActionId, Data[]>) {\n      entries(data, ([key, value]) => collect(key, value));\n    },\n    [MessageType.Coordinate](_, actionId: ActionId) {\n      coordinateCommit(actionId);\n    },\n    [MessageType.Commit](\n      _,\n      actionId: ActionId,\n      coordinator: TabId,\n      critical: boolean\n    ) {\n      const [collected, handle] = getActionState(actionId);\n      const data = splice(collected, 0);\n      TAB_ID === coordinator &&\n        (async () => {\n          const n = size(data);\n          let success =\n            !n ||\n            ((await tryAsync(actionHandlers[actionId]?.[0](data, critical))) ??\n              T);\n\n          if (!success || n) {\n            debug(\n              `The action handler for '${actionId}' ${\n                success ? \"completed sucessfully\" : \"rejected\"\n              }.`\n            );\n          }\n\n          // The action did not succeed.\n          // It will only return false if it got cancelled or the server definitely failed in a way where the events will not get duplicated if posted again.\n          // Share the failed data with all tabs, instead of just keeping it locally, so it will get posted again even in the rare event where this tab got unloaded before the commit failed.\n          !success &&\n            (channel([MessageType.Collect, { [actionId]: data }]),\n            critical && debug(\"A critical request to commit got rejected.\"));\n\n          handle([success, n]);\n        })();\n    },\n    [MessageType.Activated]: ([sourceId]) => (\n      purgeClosedTabs(0), // At least one tab isn't closing. Purge the closed ones.\n      updatePollingTab(sourceId)\n    ),\n    [MessageType.Deactivated]: () => updatePollingTab(nil),\n  },\n  T\n);\n\nconst collect = (actionId: ActionId, data: Data[]) => {\n  return push(getActionState(actionId)[0], ...data);\n};\n\nlet closing = T;\nlet initPromise: OpenPromise | null = nil;\nconst init = async () => {\n  await initPromise;\n  if (closing === (closing = F)) {\n    return;\n  }\n  initPromise = openPromise();\n  try {\n    clear(knownTabs);\n    channel([MessageType.Loaded]);\n    // At this point we don't know how many tabs there are, if any. We need to wait a bit and see.\n    await delay(50);\n  } finally {\n    initPromise(T);\n  }\n};\n\nconst terminate = async (freeze: boolean) => {\n  if (closing === (closing = T)) {\n    return;\n  }\n  values(actionHandlers, (handler) => handler[1]?.(T));\n\n  channel([MessageType.Unloading, freeze, flushLocalData()]);\n  // We unloaded or froze. If we were the timeout leader (either coordinator or active) we need to tell the others that we deactivated.\n  toggleActive(F);\n};\n\nconst coordinateCommit = async (actionId: ActionId): Promise<number> => {\n  await initPromise;\n  if (closing) return 0; // Don't initiate commit when closing.\n\n  // If we are shutting down we will allow another tab shutting down to be elected as master. (Shutdown means all tabs are closed).\n  const coordinator = getCoordinatorId();\n  if (coordinator !== TAB_ID) {\n    channel([MessageType.Coordinate, actionId], coordinator);\n    return 0;\n  }\n\n  const handle = getActionState(actionId)[1];\n  const t0 = now(F);\n\n  let result = await handle;\n  handle(Reset);\n\n  channel([MessageType.Commit, actionId, TAB_ID, F]);\n  result = await handle;\n  debug(\n    result === Expired\n      ? `Commit timed out for '${actionId}.`\n      : !result[0] ||\n          (result[1] &&\n            `${result[0] ? \"Successfully comitted\" : \"Failed to commit\"} ${\n              result[1]\n            } items for '${actionId}' after ${formatDuration(now(F) - t0)}`)\n  );\n\n  return result[1];\n};\n\n// Timeout leader coordination\n\nlet safeTimeoutTimestamp: number = MAX_SAFE_INTEGER;\nlet selectedPollingTab: TabId | null = nil;\n\nconst updatePollingTab = (activeId: TabId | null) =>\n  (selectedPollingTab = activeId ??= getCoordinatorId()) === TAB_ID\n    ? (safeTimeoutTimestamp = Math.min(\n        safeTimeoutTimestamp,\n        now() + MAX_MESSAGE_DELAY\n      ))\n    : (safeTimeoutTimestamp = MAX_SAFE_INTEGER);\n\n// Polling for responses / regularly posting events etc.  must happen from intervals /timeouts in all tabs,\n// but only the one that is the \"timeout leader\" may execute the logic to avoid race conditions.\n// The coordinator can always be reached via messages (they are not throttled), but the tab in control of polling should preferably be the one that has focus\n// since background tabs are throttled.\nexport const isForegroundTab = () =>\n  initPromise?.() === T &&\n  (purgeClosedTabs(CLOSED_TAB_TIMEOUT), now() > safeTimeoutTimestamp);\n\nlet active = F;\nconst toggleActive = (toggle: boolean) =>\n  active !== (active = toggle) && toggle\n    ? channel([MessageType.Activated])\n    : !toggle &&\n      TAB_ID === selectedPollingTab &&\n      channel([MessageType.Deactivated]);\n\nregisterStartupHandler(() => {\n  listen(window, \"pageshow\", () => init());\n  listen(document, \"resume\" as any, () => init());\n  init();\n\n  listen(window, [\"beforeunload\", \"pagehide\"], () => terminate(F));\n  listen(document, \"freeze\" as any, () => terminate(T));\n\n  // Background flush event buffer.\n  timeout(\n    () =>\n      isForegroundTab() && keys(actionHandlers, (key) => coordinateCommit(key)),\n    -trackerConfig.postFrequency\n  );\n\n  listen(document, \"visibilitychange\", () =>\n    toggleActive(document.visibilityState === \"visible\")\n  );\n  listen(window, \"focus\", () => toggleActive(T));\n  listen(window, \"blur\", () => toggleActive(F));\n  toggleActive(document.visibilityState === \"visible\");\n});\n"]}