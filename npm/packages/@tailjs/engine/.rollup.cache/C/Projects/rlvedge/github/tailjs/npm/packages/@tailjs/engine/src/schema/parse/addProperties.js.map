{"version":3,"file":"addProperties.js","sourceRoot":"","sources":["addProperties.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,cAAc,CAAC;AACtE,OAAO,EAIL,UAAU,EACV,oBAAoB,EACpB,gBAAgB,EAChB,cAAc,EACd,SAAS,EACT,yBAAyB,EACzB,aAAa,GACd,MAAM,GAAG,CAAC;AACX,OAAO,EAAE,qBAAqB,EAAE,MAAM,OAAO,CAAC;AAE9C,MAAM,CAAC,MAAM,aAAa,GAAG,CAC3B,IAAgB,EAChB,WAA8B,EAC9B,EAAE;IACF,MAAM,IAAI,GAAG,WAAW,CAAC,IAAI,CAAC;IAC9B,MAAM,QAAQ,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC;IAE9C,IAAI,WAAW,CAAC,OAAO,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;QAC3C,MAAM,iBAAiB,GAAG,aAAa,CAAC,WAAW,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;QAC3E,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC,GAAG,EAAE,UAAU,CAAC,EAAE,EAAE;YAC7C,MAAM,OAAO,GAAG,aAAa,CAAC,iBAAiB,EAAE,GAAG,CAAC,CAAC;YACtD,MAAM,CAAC,WAAW,EAAE,SAAS,CAAC,GAAG,cAAc,CAAC,OAAO,CAAC,CAAC;YAEzD,IAAI,UAAU,GAAG,WAAW,CAAC,IAAI,CAAC,IAAI;gBACpC,CAAC,CAAC,UAAU,CAAC,OAAO,EAAE,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC;gBAC5C,CAAC,CAAC,SAAS,CAAC;YAEd,MAAM,iBAAiB,GAAG,oBAAoB,CAAC,OAAO,CAAC,CAAC;YACxD,8CAA8C;YAC9C,8EAA8E;YAC9E,MAAM,QAAQ,GAAmB;gBAC/B,EAAE,EAAE,IAAI,CAAC,EAAE,GAAG,GAAG,GAAG,GAAG;gBACvB,IAAI,EAAE,GAAG;gBACT,GAAG,gBAAgB,CAAC,UAAU,CAAC;gBAC/B,OAAO;gBACP,aAAa,EAAE,IAAI;gBACnB,QAAQ,EAAE,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC;gBAC3B,SAAS;gBACT,gGAAgG;gBAChG,YAAY,EAAE,iBAAiB,CAAC,YAAY;gBAC5C,cAAc,EAAE,iBAAiB,CAAC,cAAe;gBACjD,QAAQ,EAAE,iBAAiB,CAAC,QAAS;gBAErC,WAAW;aACZ,CAAC;YAEF,IACE,WAAW,CAAC,IAAI,CAAC,UAAU;gBAC3B,yBAAyB,CAAC,WAAW,CAAC,IAAI,EAAE,WAAW,CAAC,EACxD,CAAC;gBACD,UAAU,GAAG,SAAS,CAAC,WAAW,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,CAAE,CAAC;YACnE,CAAC;YACD,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,UAAU,CAAC,EAAE,CAAC;gBACvC,CAAC,UAAU,CAAC,YAAY,KAAK,IAAI,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YACxD,CAAC;iBAAM,CAAC;gBACN,QAAQ,CAAC,aAAa,GAAG,qBAAqB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC/D,CAAC;YAED,IACE,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,EAAE,CAAC,OAAO,EAAE,EAAE,CACvC,SAAS,CAAC,OAAO,CAAC;gBAClB,CAAC,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,aAAa,CAAC,EAAE,EAAE;oBAC/C,CAAC,QAAQ,CAAC,UAAU,IAAI,QAAQ,CAAC,aAAa,CAAC,EAAE,EAAE;gBACnD,CAAC,CAAC,UAAU,CACR,2DAA2D,CAC5D;gBACH,CAAC,CAAC,QAAQ,CACb,EACD,CAAC;YACH,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,OAAO,CAAC,WAAW,CAAC,YAAY,EAAE,CAAC,WAAW,EAAE,EAAE,CAChD,aAAa,CAAC,IAAI,EAAE,WAAW,CAAC,CACjC,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import { forEach, isDefined, throwError, update } from \"@tailjs/util\";\r\nimport {\r\n  ParsedComposition,\r\n  ParsedProperty,\r\n  ParsedType,\r\n  getRefType,\r\n  parseClassifications,\r\n  parseDescription,\r\n  parseStructure,\r\n  parseType,\r\n  tryParseObjectComposition,\r\n  updateContext,\r\n} from \".\";\r\nimport { tryParsePrimitiveType } from \"../..\";\r\n\r\nexport const addProperties = (\r\n  type: ParsedType,\r\n  composition: ParsedComposition\r\n) => {\r\n  const node = composition.node;\r\n  const required = new Set(node.required ?? []);\r\n\r\n  if (composition.context && node.properties) {\r\n    const propertiesContext = updateContext(composition.context, \"properties\");\r\n    forEach(node.properties, ([key, definition]) => {\r\n      const context = updateContext(propertiesContext, key);\r\n      const [typeContext, structure] = parseStructure(context);\r\n\r\n      let objectType = typeContext.node.$ref\r\n        ? getRefType(context, typeContext.node.$ref)\r\n        : undefined;\r\n\r\n      const ownClassification = parseClassifications(context);\r\n      // TODO: Handle obsolete properties (renames).\r\n      // Should be in the form \"oldName\": {$ref: \"#new-property\", deprecated: true}.\r\n      const property: ParsedProperty = {\r\n        id: type.id + \".\" + key,\r\n        name: key,\r\n        ...parseDescription(definition),\r\n        context,\r\n        declaringType: type,\r\n        required: required.has(key),\r\n        structure,\r\n        // Allow classifications to be undefined for now. We will try to derive them from context later.\r\n        censorIgnore: ownClassification.censorIgnore,\r\n        classification: ownClassification.classification!,\r\n        purposes: ownClassification.purposes!,\r\n\r\n        typeContext,\r\n      };\r\n\r\n      if (\r\n        typeContext.node.properties &&\r\n        tryParseObjectComposition(typeContext.node, typeContext)\r\n      ) {\r\n        objectType = parseType(typeContext.node, typeContext, property)!;\r\n      }\r\n      if ((property.objectType = objectType)) {\r\n        (objectType.referencedBy ??= new Set()).add(property);\r\n      } else {\r\n        property.primitiveType = tryParsePrimitiveType(context.node);\r\n      }\r\n\r\n      if (\r\n        update(type.properties, key, (current) =>\r\n          isDefined(current) &&\r\n          (current.objectType ?? current.primitiveType)?.id !==\r\n            (property.objectType ?? property.primitiveType)?.id\r\n            ? throwError(\r\n                \"Properties in composed types must all have the same time.\"\r\n              )\r\n            : property\r\n        )\r\n      ) {\r\n      }\r\n    });\r\n  }\r\n\r\n  forEach(composition.compositions, (composition) =>\r\n    addProperties(type, composition)\r\n  );\r\n};\r\n"]}