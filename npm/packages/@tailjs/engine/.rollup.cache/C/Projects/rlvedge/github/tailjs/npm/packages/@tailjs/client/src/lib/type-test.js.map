{"version":3,"file":"type-test.js","sourceRoot":"","sources":["type-test.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IsAny, IterableOrArrayLike, Nullish } from \"@tailjs/util\";\nimport { F, T, nil } from \".\";\n\n/**\n * Converts various types' common representation of `true` and `false` to actual `true` and `false`.\n */\nexport const parseBoolean = (\n  value: string | boolean | null | number | undefined\n) =>\n  bool(value)\n    ? value\n    : value === 0\n    ? F\n    : value === 1\n    ? T\n    : value === \"false\"\n    ? F\n    : value === \"true\"\n    ? T\n    : undefined;\n\n/** Constants for type testing. */\nexport const STRING = 0,\n  BOOLEAN = 1,\n  NUMBER = 2,\n  FUNCTION = 3,\n  OBJECT = 4,\n  ARRAY = 5,\n  REGEX = 6;\n\n/**\n * When checking the string from `typeof blah`, no more than this is required for type tests.\n */\nconst typePrefixes = [\"s\", \"b\", \"n\", \"f\", \"o\"];\n\n/**\n * Tests whether a given value is of the desired type.\n */\nexport const is = <T extends number>(\n  type: T,\n  value: any\n): value is T extends typeof STRING\n  ? string\n  : T extends typeof BOOLEAN\n  ? boolean\n  : T extends typeof NUMBER\n  ? number\n  : T extends typeof FUNCTION\n  ? (...args: any) => any\n  : T extends typeof OBJECT\n  ? { [P in keyof any]: any }\n  : T extends typeof ARRAY\n  ? any[]\n  : T extends typeof REGEX\n  ? RegExp\n  : never =>\n  type === ARRAY\n    ? Array.isArray(value)\n    : (value != nil && typePrefixes[type] === (typeof value)[0]) ||\n      (type === REGEX && value.exec);\n\ntype UnwrapArray<T, V = any> = IsAny<V> extends true\n  ? T\n  : T extends IterableOrArrayLike<any>\n  ? V extends IterableOrArrayLike<infer V> & { toLowerCase?(): never }\n    ? V[]\n    : T\n  : T;\n\n/**\n * A general pattern used to type test or parse values of various types.\n */\nexport type TestOrConvertFunction<\n  T,\n  AllowParse = never,\n  ConvertArgs extends any[] = []\n> = {\n  <V>(value: V, parseStrict: false, ...args: ConvertArgs): V extends T\n    ? T extends V\n      ? UnwrapArray<T, V>\n      : V\n    : V extends AllowParse\n    ? UnwrapArray<T, V>\n    : T | undefined;\n  <V>(value: V, parseStrict: true): V extends T ? V : T;\n  <V extends T = T>(value: any): value is Exclude<V, Nullish>;\n};\n\n/**\n * Factory creating {@link TestOrConvertFunction}s.\n */\nexport const testOrConvertFunction: {\n  <T, AllowParse = never, ConvertArgs extends any[] = []>(\n    type: number,\n    convert: (value: any, ...args: ConvertArgs) => T | undefined\n  ): TestOrConvertFunction<T, AllowParse, ConvertArgs>;\n  <T>(type: number): <V extends T = T>(\n    value: any\n  ) => value is Exclude<V, Nullish>;\n} =\n  (\n    type: number,\n    convert?: (value: any, parse?: boolean, ...args: any[]) => any\n  ) =>\n  (value: any, parse?: boolean, ...args: any): value is any =>\n    parse === undefined\n      ? is(type, value)\n      : is(type, value)\n      ? value\n      : !parse\n      ? undefined\n      : convert?.(value, parse, ...args);\n\n/**\n * Tests or parses Boolean values.\n */\nexport const bool = testOrConvertFunction<boolean, any>(\n  BOOLEAN,\n  (value) => value !== \"0\" && value !== \"false\" && value !== \"no\" && !!value\n);\n\n/**\n * Tests or parses numerical values.\n */\nexport const num = testOrConvertFunction<number>(\n  NUMBER,\n  (value) => ((value = parseFloat(value)), isNaN(value) ? undefined : value)\n);\n\n/**\n * Tests if a value is a string, and if not, makes one by calling the value's `toString()` method.\n */\nexport const str = testOrConvertFunction<string>(STRING, (value) =>\n  value?.toString()\n);\n\n/**\n * Tests if a value can be invoked as a function.\n */\nexport const fun = testOrConvertFunction<(...args: any[]) => any>(\n  FUNCTION,\n  (_) => undefined\n);\n\n/**\n * Tests if a value is strictly an object (object but not array).\n */\nexport const obj = testOrConvertFunction<object>(OBJECT);\n\n/**\n * Tests if a value is an ECMAScript array (not TypedArray, those are too fancy).\n */\nexport const array = (() =>\n  // Needs wrapped in function, otherwise the multi-line type screws syntax highlighting.\n  testOrConvertFunction<\n    any[],\n    IterableOrArrayLike<any> & { toLowerCase?(): never }\n  >(ARRAY, (value) => (iterable(value) ? [...value] : undefined)))();\n\n/**\n * Utility type for {@link iterable} to help TypeScript know strings are not iterables.\n */\ntype IterableNotString<T> = T extends string\n  ? never\n  : T extends IterableOrArrayLike<any>\n  ? T\n  : never;\n\n/**\n * Tests if a value is an iterable collection of values (Iterable but not string).\n */\nexport const iterable = <T>(value: T): value is IterableNotString<T> =>\n  value && !str(value) && !!value[Symbol.iterator];\n"]}