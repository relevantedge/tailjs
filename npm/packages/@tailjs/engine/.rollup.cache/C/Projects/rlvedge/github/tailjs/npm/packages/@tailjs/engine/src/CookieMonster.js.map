{"version":3,"file":"CookieMonster.js","sourceRoot":"","sources":["CookieMonster.ts"],"names":[],"mappings":"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","sourcesContent":["import { isDefined } from \"@tailjs/util\";\nimport { forEach } from \"./lib\";\nimport { ClientResponseCookie, Cookie, CookieConfiguration } from \"./shared\";\n\nconst getCookieChunkName = (key: string, chunk?: number) =>\n  chunk === 0 ? key : `${key}-${chunk}`;\nexport const sourceCookieChunks = Symbol(\"Chunks\");\nexport type ParsedCookieHeaders = Record<string, Cookie> & {\n  // We keep the original number of chunks in the request so we can clear them if we return a shorter value (with fewer chunks) in the response\n  [sourceCookieChunks]: Record<string, number>;\n};\n\nexport class CookieMonster {\n  private readonly _secure: boolean;\n\n  public constructor(config: CookieConfiguration) {\n    this._secure = config.secure !== false;\n  }\n\n  public mapResponseCookies(\n    cookies: ParsedCookieHeaders\n  ): ClientResponseCookie[] {\n    const responseCookies: ClientResponseCookie[] = [];\n\n    forEach(cookies, ([key, cookie]: [string, Cookie]) => {\n      // These are the chunks\n      if (typeof key !== \"string\") return;\n\n      // These cookies should not be sent back, since nothing have updated them and we don't want to mess with Max-Age etc..\n      if (cookie.fromRequest && cookie._originalValue === cookie.value) return;\n\n      responseCookies.push(\n        ...this._mapClientResponseCookies(\n          key,\n          cookie,\n          cookies[sourceCookieChunks]?.[key] ?? -1\n        )\n      );\n    });\n\n    return responseCookies;\n  }\n\n  public parseCookieHeader(\n    value: string | null | undefined\n  ): ParsedCookieHeaders {\n    const cookies: ParsedCookieHeaders = { [sourceCookieChunks]: {} };\n    if (!value) return cookies;\n    const sourceCookies = Object.fromEntries(\n      value\n        .split(\";\")\n        .map((part) => part.trim())\n        .flatMap((part) => {\n          try {\n            const parts = part.split(\"=\").map(decodeURIComponent);\n            return (parts[1] ? [parts] : []) as [string, string][];\n          } catch (e) {\n            console.error(e);\n            return [];\n          }\n        })\n    );\n    for (const key in sourceCookies) {\n      const chunks: string[] = [];\n      for (let i = 0; ; i++) {\n        const chunkKey = getCookieChunkName(key, i);\n        const chunkValue = sourceCookies[chunkKey];\n        if (chunkValue === undefined) {\n          break;\n        }\n        chunks.push(chunkValue);\n        cookies[sourceCookieChunks][key] = i;\n      }\n      const value = chunks.join(\"\");\n      cookies[key] = {\n        fromRequest: true,\n        value: value,\n        _originalValue: value,\n      } as Cookie;\n    }\n\n    return cookies;\n  }\n\n  private _getHeaderValue(\n    name: string,\n    cookie: Cookie\n  ): [header: string, overflow: string] {\n    const clear = !isDefined(cookie.value) || cookie.maxAge! <= 0;\n\n    const parts = [\"Path=/\"];\n    if (this._secure) {\n      parts.push(\"Secure\");\n    }\n    if (cookie.httpOnly) {\n      parts.push(\"HttpOnly\");\n    }\n    if (cookie.maxAge != null || clear) {\n      parts.push(`Max-Age=${clear ? 0 : Math.min(34560000, cookie.maxAge!)}`);\n    }\n    parts.push(\n      `SameSite=${\n        cookie.sameSitePolicy === \"None\" && !this._secure\n          ? \"Lax\"\n          : cookie.sameSitePolicy ?? \"Lax\"\n      }`\n    );\n    let attributeLength = parts.join().length;\n    if (attributeLength > 0) {\n      attributeLength += 2; // + 2 because additional `; ` between key/value and attributes.\n    }\n    const cutoff = 4093 - attributeLength;\n\n    const encodedName = encodeURIComponent(name);\n    const value = cookie.value ?? \"\";\n    let encodedValue = encodeURIComponent(value);\n\n    // Find maximum unencoded cookie value length\n    const maxValueLength = cutoff - encodedName.length - 1; // -1 because `=`.\n\n    let overflow = \"\"; // The part of the value that did not fit in the cookie.\n    if (encodedValue.length > maxValueLength) {\n      let sourceChars = 0;\n      let encodedChars = 0;\n      for (const char in encodedValue.match(/[^%]|%../g)) {\n        if (encodedChars + char.length >= maxValueLength) {\n          break;\n        }\n        ++sourceChars;\n        encodedChars += char.length;\n      }\n\n      if (sourceChars === 0) {\n        throw new Error(\n          `Invalid cookie name: The length of the encoded cookie name (without value) together with the cookie's attributes will make the header value exceed ${cutoff} bytes.`\n        );\n      }\n\n      overflow = value.substring(sourceChars);\n      encodedValue = encodedValue.substring(0, encodedChars - 1);\n    }\n\n    const keyValue = `${encodedName}=${encodedValue}`;\n    parts.unshift(keyValue.substring(0, cutoff));\n    return [parts.join(\"; \"), overflow];\n  }\n\n  private _mapClientResponseCookies(\n    name: string,\n    cookie: Cookie,\n    originalChunks: number\n  ): ClientResponseCookie[] {\n    const responseCookies: ClientResponseCookie[] = [];\n\n    for (let i = 0; ; i++) {\n      const [headerString, overflow] = cookie.value\n        ? this._getHeaderValue(name, cookie)\n        : [\"\", \"\"];\n\n      if (!headerString) {\n        // Clear previous chunk.\n        cookie = { ...cookie, maxAge: 0, value: \"\" };\n      }\n\n      if (i < originalChunks || cookie.value) {\n        const chunkCookieName = getCookieChunkName(name, i);\n        responseCookies.push({\n          name: chunkCookieName,\n          value: cookie.value,\n          maxAge: cookie.maxAge,\n          httpOnly: cookie.httpOnly ?? true,\n          sameSitePolicy:\n            cookie.sameSitePolicy === \"None\" && !this._secure\n              ? \"Lax\"\n              : cookie.sameSitePolicy ?? \"Lax\",\n          essential: cookie.essential ?? false,\n          secure: this._secure,\n          headerString: this._getHeaderValue(chunkCookieName, cookie)[0],\n        });\n      }\n      cookie = { ...cookie, value: overflow };\n\n      if (!overflow && i >= originalChunks) {\n        break;\n      }\n    }\n\n    return responseCookies;\n  }\n}\n"]}