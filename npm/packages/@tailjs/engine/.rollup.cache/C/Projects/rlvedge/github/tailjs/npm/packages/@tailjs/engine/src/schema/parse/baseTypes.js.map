{"version":3,"file":"baseTypes.js","sourceRoot":"","sources":["baseTypes.ts"],"names":[],"mappings":"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","sourcesContent":["import { expand, forEach, get, join, map, some } from \"@tailjs/util\";\r\nimport {\r\n  ParsedComposition,\r\n  ParsedType,\r\n  TraverseContext,\r\n  getRefType,\r\n  mergeBaseProperties,\r\n  parseError,\r\n  updateTypeClassifications,\r\n} from \".\";\r\nimport { tryParsePrimitiveType } from \"..\";\r\n\r\nexport const updateBaseTypes = (context: TraverseContext) => {\r\n  const baseTypes = new Set<ParsedType>();\r\n  const properties = new Set<ParsedType>();\r\n  const typeNodes = context.parseContext.typeNodes;\r\n  typeNodes.forEach((type) => {\r\n    const addBaseTypes = (composition: ParsedComposition) => {\r\n      if (composition.context) {\r\n        const baseType = getRefType(composition.context, composition.ref?.id);\r\n        if (baseType) {\r\n          (type.extends ??= new Set()).add(baseType);\r\n        }\r\n        join(composition.compositions, composition.ref?.composition).forEach(\r\n          addBaseTypes\r\n        );\r\n      }\r\n    };\r\n\r\n    addBaseTypes(type.composition);\r\n\r\n    mergeBaseProperties(type, baseTypes);\r\n    updateTypeClassifications(type, properties);\r\n  });\r\n\r\n  // Seal concrete types.\r\n  typeNodes.forEach((type) => {\r\n    type.context.node.type = \"object\";\r\n    if (type.subtypes?.size) {\r\n      delete type.context.node.unevaluatedProperties;\r\n      type.abstract = true;\r\n    } else {\r\n      // unevaluatedProperties does not have an effect if there are no allOfs\r\n      type.context.node.unevaluatedProperties = false;\r\n    }\r\n  });\r\n\r\n  // Update all references to abstract types with a oneOf construct referencing each of its concrete types.\r\n  // Fail if they don't all have required const property with the same name to discriminate against.\r\n  typeNodes.forEach((type) => {\r\n    if (type.abstract && type.referencedBy?.size) {\r\n      const concreateSubTypes = expand(type, (type) => type.subtypes).filter(\r\n        (type) => !type.abstract\r\n      );\r\n      // Collect all required const properties and their values here.\r\n      // There must be at least one where all the types have different values;\r\n      const discriminators = new Map<string, Set<string>>();\r\n\r\n      forEach(concreateSubTypes, (subtype) =>\r\n        forEach(subtype.properties, ([, property]) => {\r\n          const allowedValues = tryParsePrimitiveType(\r\n            property.context.node\r\n          )?.allowedValues;\r\n          if (\r\n            (!property.required &&\r\n              !type.properties.get(property.name)?.required) ||\r\n            allowedValues?.length !== 1\r\n          )\r\n            return;\r\n\r\n          get(discriminators, property.name, () => new Set()).add(\r\n            allowedValues[0]\r\n          );\r\n        })\r\n      );\r\n\r\n      if (\r\n        some(\r\n          discriminators,\r\n          ([, value]) => value.size === concreateSubTypes.length\r\n        )\r\n      ) {\r\n        forEach(type.referencedBy, (property) => {\r\n          delete property.context.node.$ref;\r\n          property.context.node.oneOf = map(concreateSubTypes, (type) => ({\r\n            $ref: type.context.$ref,\r\n          }));\r\n          // property.context.node.type = \"object\";\r\n          // property.context.node.properties = {};\r\n          // property.context.node.unevaluatedProperties = false;\r\n        });\r\n      } else {\r\n        throw parseError(\r\n          type.context,\r\n          () =>\r\n            \"If an abstract type (that is, type extended by other types) is used as a property type, \" +\r\n            \"all its subtypes must have a common property with a const value to discriminate between them.\\n\" +\r\n            `${type.id} is extended by ${map(\r\n              type.subtypes,\r\n              (type) => type.id\r\n            )?.join(\", \")}, and referenced by ${map(\r\n              type.referencedBy,\r\n              (type) => type.id\r\n            )?.join(\", \")}`\r\n        );\r\n      }\r\n    }\r\n  });\r\n};\r\n"]}