{"version":3,"file":"transport.js","sourceRoot":"","sources":["transport.ts"],"names":[],"mappings":"AAAA,OAAO,OAAO,MAAM,eAAe,CAAC;AACpC,MAAM,EAAE,WAAW,EAAE,SAAS,EAAE,GAAG,OAAO,CAAC;AAE3C,OAAO,EAAgB,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,GAAG,CAAC;AACvD,OAAO,EAGL,QAAQ,EACR,OAAO,EACP,SAAS,EACT,UAAU,EACV,UAAU,EACV,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,WAAW,EACX,GAAG,EACH,QAAQ,GACT,MAAM,IAAI,CAAC;AAqHZ,MAAM,QAAQ,GAAG,MAAM,CAAC;AAExB,MAAM,WAAW,GAAG,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC;AACvC,MAAM,SAAS,GAAG,IAAI,QAAQ,CAAC,WAAW,CAAC,CAAC;AAE5C;;GAEG;AACH,MAAM,cAAc,GAAG,CAAC,KAAU,EAAE,EAAE;IACpC,IAAI,QAAoC,CAAC;IACzC,IAAI,IAAkC,CAAC;IACvC,IAAI,QAAgB,CAAC;IACrB,MAAM,aAAa,GAAG,CACpB,KAAU,EACV,GAAQ,EACR,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC,EAChB,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,EACpB,EAAE,CAAC,CACH,CAAC,GAAG,KAAK,OAAO,IAAI,QAAQ,CAAC,GAAG,CAAC,CAAC;QAChC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,EAAE,UAAU,CAAC,GAAG,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;QAChE,GAAG,CACJ,CAAC;IACF,MAAM,UAAU,GAAG,CAAC,OAAmB,EAAE,EAAE,CAAC,CAAC,QAAQ,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAE5E,MAAM,KAAK,GAAG,CAAC,KAAU,EAAE,EAAE;QAC3B,IAAI,KAAK,IAAI,IAAI,IAAI,UAAU,CAAC,KAAK,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC;YAC1D,OAAO,IAAI,CAAC;QACd,CAAC;QAED,IAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,CAAC;YAC3D,qGAAqG;YACrG,oFAAoF;YACpF,kFAAkF;YAClF,SAAS,CAAC,UAAU,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YACrC,OAAO,EAAE,EAAE,EAAE,CAAC,GAAG,IAAI,WAAW,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC;QACnD,CAAC;QAED,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,CAAC;YAC3B,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAK,KAAa,CAAC,MAAM,IAAI,KAAK,KAAK,CAAC,KAAK,GAAI,KAAa,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC;YACzE,OAAO,KAAK,CAAC,KAAK,CAAC,CAAC;QACtB,CAAC;QAED,IAAI,SAAS,CAAC,CAAC,QAAQ,GAAG,CAAC,IAAI,KAAK,IAAI,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;YAC5D,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC;gBACrB,oCAAoC;gBACpC,KAAK,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC;gBAC3B,UAAU,CAAC,GAAG,EAAE,CAAC,OAAO,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;YAC3C,CAAC;YACD,OAAO,EAAE,CAAC,QAAQ,CAAC,EAAE,QAAQ,EAAE,CAAC;QAClC,CAAC;QAED,IAAI,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC;YACpB,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;YAE/B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CACxB,CAAC,CAAC,EAAE,EAAE,CACJ,CAAC,WAAW,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACrD,OAAO,KAAK,CAAC,CAAC,CAAC,CAClB,CAAC;QACJ,CAAC;aAAM,IAAI,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;YAC7B,mHAAmH;YACnH,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM;gBAC1D,CAAC,CAAC,CAAC,GAAI,KAAa,CAAC;gBACrB,CAAC,CAAC,KAAK,CACR,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CACjB,CAAC,IAAI,KAAK;gBACR,CAAC,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC;gBACzB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,EAAE,UAAU,CAAC,GAAG,EAAE,CAAC,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAC3D,CAAC;QACJ,CAAC;QAED,OAAO,KAAK,CAAC;IACf,CAAC,CAAC;IAEF,MAAM,UAAU,GAAG,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;IAC3C,QAAQ,EAAE,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC;IAC1C,OAAO,UAAU,CAAC;AACpB,CAAC,CAAC;AAEF,MAAM,gBAAgB,GAAG,CAAC,KAAiB,EAAE,EAAE;IAC7C,IAAI,IAAuB,CAAC;IAC5B,IAAI,UAAe,CAAC;IAEpB,MAAM,KAAK,GAAG,CAAC,KAAU,EAAE,EAAE;QAC3B,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC;YAAE,OAAO,KAAK,CAAC;QAEzC,IAAI,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC3D,OAAO,IAAI,QAAQ,CAAC,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;QACzE,CAAC;QAED,IAAI,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,IAAI,KAAK,EAAE,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;YACrE,OAAO,UAAU,CAAC;QACpB,CAAC;QAED,IAAI,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC;YACpB,IAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,GAAG,KAAK,CAAC;YAC/B,OAAO,KAAK,CAAC,QAAQ,CAAC,CAAC;QACzB,CAAC;QAED,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,OAAO,CAC3B,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CACnD,CAAC;QAEF,OAAO,KAAK,CAAC;IACf,CAAC,CAAC;IAEF,OAAO,QAAQ,CAAC,KAAK,CAAC;QACpB,CAAC,CAAC,QAAQ,CACN,GAAG,EAAE,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,EAC/B,GAAG,EAAE,CAAC,SAAS,CAChB;QACH,CAAC,CAAC,SAAS,CAAC;AAChB,CAAC,CAAC;AAQF;;;GAGG;AACH,MAAM,CAAC,MAAM,eAAe,GAAG,CAC7B,GAAmB,EACnB,IAAI,GAAG,KAAK,EACD,EAAE;IACb,MAAM,CAAC,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC;IACjD,MAAM,cAAc,GAAG,CAAC,KAAU,EAAE,aAAkB,EAAE,EAAE;QACxD,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,aAAa,KAAK,IAAI;YAAE,OAAO,KAAK,CAAC;QAE5D,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC;YACrB,CAAC,CAAC,IAAI,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;YACrE,CAAC,CAAC,IAAI;gBACN,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC;gBACvB,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;QAC1B,OAAO,IAAI,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;IACpC,CAAC,CAAC;IACF,OAAO,IAAI;QACT,CAAC,CAAC;YACE,CAAC,IAAS,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;YACnC,CAAC,OAAO,EAAE,EAAE,CACV,OAAO,IAAI,IAAI;gBACb,CAAC,CAAC,SAAS;gBACX,CAAC,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;YACpD,CAAC,KAAU,EAAE,aAAmB,EAAE,EAAE,CAClC,cAAc,CAAC,KAAK,EAAE,aAAa,CAAQ;SAC9C;QACH,CAAC,CAAC;YACE,CAAC,IAAS,EAAE,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;YACnD,CAAC,OAAY,EAAE,EAAE,CACf,QAAQ,CAAC,OAAO,CAAC;gBACf,CAAC,CAAC,gBAAgB,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;gBAC7C,CAAC,CAAC,IAAI;YACV,CAAC,KAAU,EAAE,aAAmB,EAAE,EAAE,CAClC,cAAc,CAAC,KAAK,EAAE,aAAa,CAAQ;SAC9C,CAAC;AACR,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,gBAAgB,GAAG,eAAe,EAAE,CAAC;AAClD,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,UAAU,EAAE,IAAI,CAAC,GAAG,gBAAgB,CAAC","sourcesContent":["import msgpack from \"@ygoe/msgpack\";\nconst { deserialize, serialize } = msgpack;\n\nimport { HashFunction, from64u, lfsr, to64u } from \".\";\nimport {\n  IsNever,\n  Nullish,\n  hasValue,\n  isArray,\n  isDefined,\n  isFunction,\n  isIterable,\n  isNumber,\n  isObject,\n  isString,\n  isSymbol,\n  isUndefined,\n  map,\n  tryCatch,\n} from \"..\";\n\ntype ConverterFunctionValue<T> = T extends { toJSON(): infer V }\n  ? V\n  : T extends { valueOf(): infer V }\n  ? V\n  : T;\n\ntype ConverterValue<T> = T extends ConverterFunctionValue<T>\n  ? never\n  : ConverterFunctionValue<T>;\n\nexport type EncodableArray = Encodable[];\n\nexport type EncodableTuple = [...Items: Encodable[]];\n\nexport type EncodableObject = Partial<{\n  [K in string | number]?: Encodable;\n}>;\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Encodable =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | EncodableArray\n  | EncodableTuple\n  | EncodableObject;\n\n/**\n * The shape of the data that will come back when decoding the encoded value of a type.\n *\n * This assumes that only the shapes permitted by {@link Encodable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type Decoded<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reason, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? Decoded<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: Decoded<T[index]> }\n  : T extends Iterable<infer T>\n  ? Decoded<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string | number\n        ? Decoded<T[P]> extends undefined\n          ? never\n          : P\n        : never]: Decoded<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of well-known symbol properties. Those are ignored.\n *\n * Not violating the constract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properies that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\nexport type EncodableContract<T = Encodable> = Encodable extends T\n  ? Encodable\n  : T extends void\n  ? undefined // For annoying reasons, TypeScript differentiates between `undefined` and `void`. We want `void`.\n  : T extends string | number | boolean | null | undefined | void\n  ? T\n  : IsNever<ConverterValue<T>> extends false\n  ? EncodableContract<ConverterValue<T>>\n  : T extends any[]\n  ? { [index in keyof T]: EncodableContract<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      // Fun fact: TypeScript keeps optional properties if we iterate keyof P and then exclude symbols with the `extends` construct.\n      //  `(keyof T & symbol)` or `Exclude <keyof T, symbol>` makes all properties required. (`{ a?: undefined}` becomes `{a:undefined}`)\n      // Keeping optional `undefined` properties means that the property name is still allowed in a type like `{a()?: boolean}`, even though functions are not allowed.\n      [P in keyof T as P extends symbol ? never : P]: EncodableContract<T[P]>;\n    }\n  : never;\n\n/**\n * Encodes the specified value to an HTTP querystring/header safe string, that is, does not need to be URI escaped.\n * The function is analogous to `JSON.stringify`, except this one also supports references.\n * @param value The value to encode.\n * @param validate This property has no effect other than letting TypeScript validate whether the value can be deserialized back to its original form without losing properties.\n *\n * @returns The HTTP encoded representation of the value.\n */\nexport type Encoder = {\n  (value: any, validate?: false): string;\n  <T = Encodable>(value: T & EncodableContract<T>, validate: true): string;\n};\n\n/**\n * Decodes a value encoded with an {@link Encoder}.\n */\nexport type Decoder = <T = any>(encoded: string | Nullish) => T | undefined;\n\nconst REF_PROP = \"$ref\";\n\nconst floatBuffer = new ArrayBuffer(8);\nconst floatView = new DataView(floatBuffer);\n\n/**\n * Misc. fixes to the msgpack library. For example, it does not handle exponential numbers well.\n */\nconst patchSerialize = (value: any) => {\n  let cleaners: (() => void)[] | undefined;\n  let refs: Map<any, number> | undefined;\n  let refIndex: number;\n  const patchProperty = (\n    value: any,\n    key: any,\n    val = value[key],\n    patched = inner(val)\n  ) => (\n    (val !== patched || isSymbol(key)) &&\n      ((value[key] = patched), addCleaner(() => (value[key] = val))),\n    val\n  );\n  const addCleaner = (cleaner: () => void) => (cleaners ??= []).push(cleaner);\n\n  const inner = (value: any) => {\n    if (value == null || isFunction(value) || isSymbol(value)) {\n      return null;\n    }\n\n    if (Number.isFinite(value) && !Number.isSafeInteger(value)) {\n      // A bug in @ygoe/msgpack means floats do not get encoded. We need to encode them in a different way.\n      // This is how it landed, since data structure is highly unlikely to be encountered,\n      // yet it is probably not the best way to do this (apart from fixing the bug ofc.)\n      floatView.setFloat64(0, value, true);\n      return { \"\": [...new Uint32Array(floatBuffer)] };\n    }\n\n    if (!isObject(value, true)) {\n      return value;\n    }\n\n    if ((value as any).toJSON && value !== (value = (value as any).toJSON())) {\n      return inner(value);\n    }\n\n    if (isDefined((refIndex = (refs ??= new Map()).get(value)))) {\n      if (!value[REF_PROP]) {\n        // Only assign ID parameter if used.\n        value[REF_PROP] = refIndex;\n        addCleaner(() => delete value[REF_PROP]);\n      }\n      return { [REF_PROP]: refIndex };\n    }\n\n    if (isObject(value)) {\n      refs.set(value, refs.size + 1);\n\n      Object.keys(value).forEach(\n        (k) =>\n          (isUndefined(patchProperty(value, k)) || isSymbol(k)) &&\n          delete value[k]\n      );\n    } else if (isIterable(value)) {\n      // Array with undefined values or iterable (which is made into array.). ([,1,2,3] does not reveal its first entry).\n      (!isArray(value) || Object.keys(value).length < value.length\n        ? [...(value as any)]\n        : value\n      ).forEach((_, i) =>\n        i in value\n          ? patchProperty(value, i)\n          : ((value[i] = null), addCleaner(() => delete value[i]))\n      );\n    }\n\n    return value;\n  };\n\n  const serialized = serialize(inner(value));\n  cleaners?.forEach((cleaner) => cleaner());\n  return serialized;\n};\n\nconst patchDeserialize = (value: Uint8Array) => {\n  let refs: any[] | undefined;\n  let matchedRef: any;\n\n  const inner = (value: any) => {\n    if (!isObject(value, true)) return value;\n\n    if (isArray(value[\"\"]) && (value = value[\"\"]).length === 2) {\n      return new DataView(new Uint32Array(value).buffer).getFloat64(0, true);\n    }\n\n    if (value[REF_PROP] && (matchedRef = (refs ??= [])[value[REF_PROP]])) {\n      return matchedRef;\n    }\n\n    if (value[REF_PROP]) {\n      refs![value[REF_PROP]] = value;\n      delete value[REF_PROP];\n    }\n\n    Object.entries(value).forEach(\n      ([k, v]) => v !== (v = inner(v)) && (value[k] = v)\n    );\n\n    return value;\n  };\n\n  return hasValue(value)\n    ? tryCatch(\n        () => inner(deserialize(value)),\n        () => undefined\n      )\n    : undefined;\n};\n\nexport type Transport = [\n  encode: Encoder,\n  decode: Decoder,\n  hash: HashFunction<any>\n];\n\n/**\n * Creates a pair of {@link Encoder} and {@link Decoder}s as well as a {@link HashFunction<string>}.\n * MessagePack is used for serialization, {@link lsfr} encryption is optionally used if a key is specified, and the input and outputs are Base64URL encoded.\n */\nexport const createTransport = (\n  key?: null | string,\n  json = false\n): Transport => {\n  const [encrypt, decrypt, hash] = lfsr(key ?? \"\");\n  const fastStringHash = (value: any, bitsOrNumeric: any) => {\n    if (isNumber(value) && bitsOrNumeric === true) return value;\n\n    value = isString(value)\n      ? new Uint8Array(map(value.length, (i) => value.charCodeAt(i) & 255))\n      : json\n      ? JSON.stringify(value)\n      : patchSerialize(value);\n    return hash(value, bitsOrNumeric);\n  };\n  return json\n    ? [\n        (data: any) => JSON.stringify(data),\n        (encoded) =>\n          encoded == null\n            ? undefined\n            : tryCatch(() => JSON.parse(encoded, undefined)),\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ]\n    : [\n        (data: any) => to64u(encrypt(patchSerialize(data))),\n        (encoded: any) =>\n          hasValue(encoded)\n            ? patchDeserialize(decrypt(from64u(encoded)))\n            : null,\n        (value: any, numericOrBits?: any) =>\n          fastStringHash(value, numericOrBits) as any,\n      ];\n};\n\nexport const defaultTransport = createTransport();\nexport const [httpEncode, httpDecode, hash] = defaultTransport;\n"]}