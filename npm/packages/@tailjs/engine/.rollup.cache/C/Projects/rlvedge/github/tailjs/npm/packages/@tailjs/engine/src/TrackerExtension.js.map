{"version":3,"file":"TrackerExtension.js","sourceRoot":"","sources":["TrackerExtension.ts"],"names":[],"mappings":"","sourcesContent":["import type { TrackedEvent } from \"@tailjs/types\";\nimport { MaybePromise } from \"@tailjs/util\";\nimport type {\n  ParseResult,\n  Tracker,\n  TrackerEnvironment,\n  VariableStorage,\n} from \"./shared\";\n\nexport type NextPatchExtension = (\n  events: ParseResult[]\n) => Promise<TrackedEvent[]>;\n\nexport type TrackedEventBatch = {\n  add: TrackedEvent[];\n  patch: Partial<TrackedEvent>[];\n};\n\n/**\n * Tracker extensions enable the engine to interface with external systems, typically to store the collected events somewhere.\n * It may also be to extend the events collected from the client with additional data with Geo IP information being the canonical example.\n *\n * Without any extensions, nothing happens after events have been collected from clients.\n *\n * Since that is not very useful by iteself, a common use case for extensions is to store the collected events in a database or forwarding them to a CDP.\n * You may also have some legacy analytics solutions, or even run more than one side-by-side. In such case tail.js\n * Since any number of extensions can be loaded with the engine, this concept allows the collected events to \"fan out\", that is, store them in different systems for different purposes.\n * For the latter use case you can think of tail.js as a \"reverse proxy on steroids\".\n *\n * Typically you should want to store all the raw event data in some kind of cheap storage, so they can later be used for reporting.\n * You may also want to send certain significant events/conversions to a CRM or CDP because they are used for personalization or some business process like a customer changing lead status after filling out a form.\n **\n *\n * Extensions may do anything from altering, updating and/or adding events before they are processed by other extensions.\n *\n * An extension\n */\nexport interface TrackerExtension {\n  readonly id: string;\n\n  initialize?(environment: TrackerEnvironment): MaybePromise<void>;\n\n  apply?(tracker: Tracker): MaybePromise<void>;\n\n  patch?(\n    events: TrackedEvent[],\n    next: NextPatchExtension,\n    tracker: Tracker\n  ): MaybePromise<ParseResult[]>;\n\n  post?(events: TrackedEventBatch, tracker: Tracker): MaybePromise<void>;\n\n  getClientScripts?(tracker: Tracker): ClientScript[] | undefined | null;\n}\n\n/**\n * Definition of a additional client-side scripts that will get loaded with the tracker.\n */\nexport type ClientScript =\n  | {\n      /** An external source for the script. */\n      src: string;\n      /** Whether the script can be loaded asynchronously. */\n      defer?: boolean;\n    }\n  | {\n      /** A script expression that will get evaluated directly. */\n      inline: string;\n      /** Whether there are dependencies between this script expression and others. If not, inline scripts can be merged more efficiently.  */\n      allowReorder?: boolean;\n    };\n"]}