{"version":3,"file":"Variable.js","sourceRoot":"","sources":["Variable.ts"],"names":[],"mappings":"AAAA,OAAO,EAAqB,kBAAkB,EAAE,MAAM,cAAc,CAAC;AAiBrE,MAAM,MAAM,GAAG;IACb,MAAM,8BAAsB;IAC5B,OAAO,+BAAuB;IAC9B,MAAM,8BAAsB;IAC5B,IAAI,4BAAoB;IACxB,MAAM,8BAAsB;CACpB,CAAC;AACX,MAAM,CAAC,MAAM,aAAa,GAAG,kBAAkB,CAC7C,MAAM,EACN,KAAK,EACL,gBAAgB,CACjB,CAAC","sourcesContent":["import { ParsableEnumValue, createEnumAccessor } from \"@tailjs/util\";\nimport {\n  DataClassification,\n  DataPurposes,\n  DataClassificationValue,\n  DataPurposeValue,\n  Timestamp,\n} from \"..\";\n\nexport const enum VariableScope {\n  Global = 0,\n  Session = 1,\n  Device = 2,\n  User = 3,\n  Entity = 4,\n}\n\nconst scopes = {\n  global: VariableScope.Global,\n  session: VariableScope.Session,\n  device: VariableScope.Device,\n  user: VariableScope.User,\n  entity: VariableScope.Entity,\n} as const;\nexport const variableScope = createEnumAccessor(\n  scopes,\n  false,\n  \"variable scope\"\n);\n\nexport type VariableScopeValue<Numeric extends boolean | undefined = boolean> =\n  ParsableEnumValue<typeof scopes, Numeric, false>;\n\ntype UndefinedIfUndefined<Src, T> = Src extends undefined | null\n  ? T | undefined\n  : T;\n\n/** Transforms properties with known enum types to their parsable counterparts. */\nexport type Parsable<T, Numeric extends boolean | undefined = boolean> = {\n  [P in keyof T]: T[P] extends DataClassification | undefined | null\n    ? DataClassificationValue<UndefinedIfUndefined<T[P], Numeric>>\n    : T[P] extends DataPurposes | undefined | null\n    ? DataPurposeValue<UndefinedIfUndefined<T[P], Numeric>>\n    : T[P] extends VariableScope | undefined | null\n    ? VariableScopeValue<UndefinedIfUndefined<T[P], Numeric>>\n    : Parsable<T[P], Numeric>;\n};\n\n/**\n * Uniquely addresses a variable by scope, target and key name.\n */\nexport interface VariableKey<NumericEnums extends boolean = boolean> {\n  /** The scope the variable belongs to. */\n  scope: VariableScopeValue<NumericEnums>;\n\n  /**\n   * The name of the variable.\n   *\n   * A key may have a prefix that decides which variable storage it is routed to.\n   * The prefix and the key are separated by colon (`prefix:key`). Additional colons will be considered part of the variable name.\n   * To address a variable with a colon in its name without prefix use `:key`, for example `:colon:in:my:name`.\n   */\n  key: string;\n\n  /**\n   * The ID of the entity in the scope the variable belongs to.\n   * This is ignored for global variables, and can be set to `\"\"`.\n   */\n  targetId?: string;\n}\n\n/**\n * A {@link VariableKey} that optionally includes the expected version of a variable value.\n * This is used for \"if none match\" queries to invalidate caches efficiently.\n */\nexport interface VersionedVariableKey<NumericEnums extends boolean = boolean>\n  extends VariableKey<NumericEnums> {\n  version?: string;\n}\n\n/**\n * Defines how the value of variable is classified and for which purposes it can be used.\n */\nexport interface VariableClassification<\n  NumericEnums extends boolean = boolean\n> {\n  /**\n   * The legal classification of the kind of data a variable holds.\n   * This limits which data will be stored based on a user's consent.\n   */\n  classification: DataClassificationValue<NumericEnums>;\n\n  /**\n   * Optionally defines the possible uses of the data a variables holds (they are binary flags).\n   * When a variable is requested by some logic, it may be stated what the data is used for.\n   * If the user has not consented to data being used for this purpose the variable will not be avaiable.\n   */\n  purposes?: DataPurposeValue<NumericEnums>;\n\n  /**\n   * Optionally categorizes variables.\n   *\n   * For example, the tag `address` could be used for all variables related to a user's address,\n   * or `newsletter` for everything related to newsletter subscriptions.\n   */\n  tags?: string[];\n}\n\n/**\n * Information about when a variable's value was modified and a unqiue version (ETag) used for conflict resolution\n * in case multiple processes try to update it at the same time (optimistic concurrency).\n *\n * Only the version, and not the modified timestamp must be relied on during conflict resolution.\n */\nexport interface VariableVersion {\n  /**\n   * Timestamp for when the variable was created.\n   */\n  created?: Timestamp;\n\n  /**\n   * Timestamp for when the variable was created or modified.\n   */\n  modified?: Timestamp;\n\n  /**\n   * A unique token that changes everytime a variable is changed.\n   * It follows the semantics of a \"weak\" ETag in the HTTP protocol.\n   * How the value is generated is an internal implementation detail specific to the storage that manages the variable.\n   *\n   * The value is only undefined if it is not assumed to exist before a set operation.\n   */\n  version?: string | undefined;\n}\n\n/**\n * All data related to a variable except its value.\n */\nexport interface VariableHeader<NumericEnums extends boolean = true>\n  extends VariableKey<NumericEnums>,\n    VariableClassification<NumericEnums>,\n    VariableVersion {}\n\n/**\n * A variable is a specific piece of information that can be classified and changed independently.\n * A variable can either be global or related to a specific entity or tracker scope.\n */\nexport interface Variable<T = any, NumericEnums extends boolean = true>\n  extends VariableHeader<NumericEnums> {\n  /**\n   * The value of the variable is read-only. Trying to update its value in its storage will result in an error.\n   */\n  readonly?: boolean;\n\n  /**\n   * The value of the variable. It must only be undefined in a set operation in which case it means \"delete\".\n   */\n  value: T;\n}\n\n/**\n * The information needed about a variable to validate whether it complies with a user's consents,\n * or meets other authorization based requirements.\n */\nexport type VariableValidationBasis<NumericEnums extends boolean = boolean> =\n  VariableKey<NumericEnums> & Partial<VariableClassification<NumericEnums>>;\n"]}