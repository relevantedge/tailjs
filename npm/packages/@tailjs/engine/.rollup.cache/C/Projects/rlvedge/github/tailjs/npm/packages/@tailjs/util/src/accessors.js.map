{"version":3,"file":"accessors.js","sourceRoot":"","sources":["accessors.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  And,\n  Extends,\n  GeneralizeContstants,\n  If,\n  IsAny,\n  Minus,\n  NO_ARG,\n  NotFunction,\n  PrettifyIntersection,\n  Primitives,\n  RecordType,\n  UnionToIntersection,\n  count,\n  forEach,\n  hasMethod,\n  isArray,\n  isAwaitable,\n  isDefined,\n  isFunction,\n  isObject,\n  isUndefined,\n  map,\n  throwError,\n} from \".\";\n\ntype ReadonlyMapLike<K = any, V = any> = {\n  has?(key: K): boolean;\n  get(key: K): V | undefined;\n};\n\n// #region Shared types\ntype MapLike<K = any, V = any> = ReadonlyMapLike<K, V> & {\n  set(key: K, value: V): any;\n  delete(key: K): any;\n};\n\ntype ReadonlySetLike<K = any> = {\n  has(key: K): boolean;\n};\ntype SetLike<K = any> = ReadonlySetLike<K> & {\n  add(key: K): any;\n  delete(key: K): any;\n};\n\ntype ReadonlyPropertyContainer<K extends any = any, V extends any = any> =\n  | {\n      [P in keyof K]: V;\n    }\n  | ReadonlyMapLike<K, V>\n  | ReadonlySetLike<K>;\n\ntype PropertyContainer<K extends any = any, V extends any = any> =\n  | ReadonlyPropertyContainer<K, V>\n  | MapLike<K, V>\n  | SetLike<K>;\n\nexport type TupleIndices<T extends readonly any[]> = T extends readonly []\n  ? never\n  : number extends T[\"length\"]\n  ? number\n  : T extends readonly [any, ...infer Rest]\n  ? TupleIndices<Rest> | Rest[\"length\"]\n  : never;\n\nexport type KeyType<T extends ReadonlyPropertyContainer | null | undefined> =\n  T extends Primitives\n    ? never\n    : T extends ReadonlyMapLike<infer K, any> | ReadonlySetLike<infer K>\n    ? K\n    : T extends readonly any[]\n    ? TupleIndices<T>\n    : keyof T;\n\nexport type ValueType<\n  T extends ReadonlyPropertyContainer | null | undefined,\n  K = KeyType<T>,\n  Context extends undefined | \"get\" | \"set\" = undefined\n> = IsAny<T> extends true\n  ? any\n  : T extends null | undefined | void\n  ? never\n  : K extends KeyType<T>\n  ? T extends ReadonlyMapLike<K, infer V>\n    ? V | If<Extends<Context, \"get\" | \"set\">, undefined>\n    : T extends ReadonlySetLike<K>\n    ? boolean\n    : T[K] | If<And<Extends<T, RecordType>, Extends<Context, \"set\">>, undefined>\n  : never;\n\ntype AcceptUnknownContainers<\n  T extends ReadonlyPropertyContainer | null | undefined\n> = IsAny<T> extends true\n  ? T\n  : T extends null | undefined | void\n  ? never\n  : T extends MapLike\n  ? MapLike<unknown, unknown> | T\n  : T extends SetLike\n  ? SetLike<unknown> | T\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? readonly unknown[] | [] | T\n    : T\n  : T;\n\n// #endregion\n\n// #region get\n\nconst updateSingle = (target: any, key: any, value: any) =>\n  setSingle(target, key, isFunction(value) ? value(get(target, key)) : value);\n\nconst setSingle = (target: any, key: any, value: any) => {\n  value === undefined\n    ? target.delete\n      ? target.delete(key)\n      : delete target[key]\n    : target.set\n    ? target.set(key, value)\n    : target.add\n    ? value\n      ? target.add(key)\n      : target.delete(key)\n    : (target[key] = value);\n\n  return value;\n};\n\nexport const setSingleIfNotDefined = (\n  target: any,\n  key: any,\n  value: any,\n  error: (\n    key: string,\n    currentValue: any,\n    newValue: any,\n    target: any\n  ) => string | Error\n) => {\n  const currentValue = get(target, key);\n  if (isDefined(currentValue)) {\n    throwError(error(key, currentValue, value, target));\n  }\n  return setSingle(target, key, value);\n};\n\nexport const get: {\n  <\n    T extends ReadonlyPropertyContainer | null | undefined,\n    K extends KeyType<T>\n  >(\n    target: T,\n    key: K\n  ): ValueType<T, K, \"get\">;\n  <\n    T extends ReadonlyPropertyContainer | null | undefined,\n    K extends KeyType<T>,\n    R extends\n      | ValueType<T, K>\n      | (() => ValueType<T, K>)\n      | undefined\n      | (() => ValueType<T, K> | undefined)\n  >(\n    target: T,\n    key: K,\n    initializer: R\n  ): ValueType<\n    T,\n    K,\n    R extends ValueType<T, K> | (() => ValueType<T, K>) ? undefined : \"get\"\n  >;\n} = <\n  T extends ReadonlyPropertyContainer | null | undefined,\n  K extends KeyType<T>,\n  R extends ValueType<T, K> | undefined = undefined\n>(\n  target: T,\n  key: K | undefined,\n  initializer?: (() => R) | R\n) => {\n  if (!target) return undefined as any;\n\n  let value = (target as any).get\n    ? (target as any).get(key)\n    : (target as any).has\n    ? (target as any).has(key)\n    : target[key as any];\n\n  if (isUndefined(value) && isDefined(initializer)) {\n    isDefined(\n      (value = isFunction(initializer) ? (initializer as any)() : initializer)\n    ) && setSingle(target, key, value);\n  }\n  return value;\n};\n\n// #endregion\n\n// #region set and update\n\ntype UpdateFunction<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current,\n  Factory\n> = Factory extends false\n  ? (\n      current: Current,\n      key: Key,\n      target: T\n    ) => GeneralizeContstants<ValueType<T, Key>> | undefined\n  : (key: Key, target: T) => GeneralizeContstants<ValueType<T, Key>>;\n\ntype Updater<\n  T extends ReadonlyPropertyContainer,\n  Key,\n  Current = ValueType<T, Key>,\n  SettersOnly = false,\n  Factory = false\n> = SettersOnly extends true\n  ? ValueType<T, Key> | (Factory extends true ? never : undefined)\n  : IsAny<T> extends true\n  ? NotFunction | UpdateFunction<any, any, any, Factory>\n  :\n      | (ValueType<T, Key> extends Function\n          ? never\n          : ValueType<T, Key> | (Factory extends true ? never : undefined))\n      | UpdateFunction<T, Key, Current, Factory>;\n\ntype UpdaterType<T, SettersOnly = false> = SettersOnly extends true\n  ? T\n  : T extends (...args: any) => infer T\n  ? T\n  : T;\n\ntype BulkUpdateObject<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> = T extends MapLike | SetLike | any[]\n  ? {\n      [P in KeyType<T>]: Updater<T, P, ValueType<T, P>, SettersOnly, Factory>;\n    }\n  : { [P in keyof T & KeyType<T>]?: Updater<T, P, T[P], SettersOnly, Factory> };\n\ntype BulkUpdateKeyValue<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false,\n  K extends keyof T = keyof T\n> = IsAny<T> extends true\n  ? [any, Updater<T, any, any, SettersOnly, Factory>]\n  : T extends MapLike | SetLike | any[]\n  ? [\n      KeyType<T>,\n      Updater<T, KeyType<T>, ValueType<T, KeyType<T>>, SettersOnly, Factory>\n    ]\n  : K extends any\n  ? [K, Updater<T, KeyType<T>, any, SettersOnly, Factory>]\n  : never;\n\ntype BulkUpdates<\n  T extends ReadonlyPropertyContainer,\n  SettersOnly = false,\n  Factory = false\n> =\n  | BulkUpdateObject<T, SettersOnly, Factory>\n  | Iterable<\n      | BulkUpdateKeyValue<T, SettersOnly, Factory>\n      | BulkUpdateObject<T, SettersOnly, Factory>\n    >;\n\ntype SetErrorHandler<T extends ReadonlyPropertyContainer | null | undefined> = (\n  key: KeyType<T>,\n  currentValue: ValueType<T>,\n  newValue: ValueType<T>,\n  target: T\n) => string | Error;\n\ntype SettableKeyType<T extends PropertyContainer> = T extends readonly any[]\n  ? // `KeyType<T>` won't do.\n    // If this `keyof` constraint is not set TypeScript will only constrain values for readonly tuple items to T[number] and not T[K].\n    keyof T\n  : T extends RecordType\n  ? keyof any\n  : KeyType<T>;\n\ntype SettableValueType<T extends PropertyContainer, K> = K extends KeyType<T>\n  ?\n      | ValueType<T, K>\n      // `undefined` removes elements from maps and sets so also allowed.\n      | (T extends MapLike | SetLike ? undefined : never)\n  : T extends RecordType\n  ? any\n  : never;\n\ntype SettableValueFunctionType<T extends PropertyContainer, K, V> = (\n  current: SettableValueType<T, K>\n) => V;\n\ntype IsGeneralKey<T, S = keyof any> = S extends T ? true : false;\n\n/** List of keys in T that has undefined values. If Template does not allow undefined values for a key it is excluded from the reuslts. */\ntype UndefinedKeys<\n  T,\n  Template = {},\n  K extends keyof T = keyof T\n> = K extends keyof T\n  ? T[K] extends undefined\n    ? K extends keyof Template\n      ? undefined extends Template[K]\n        ? K\n        : never\n      : K\n    : never\n  : never;\n\ntype SetSingleResultType<\n  T extends PropertyContainer,\n  K,\n  V\n> = T extends RecordType\n  ? AssignRecord<T, { [P in K & keyof any]: V }>\n  : K extends KeyType<T>\n  ? V extends ValueType<T, K> | (T extends readonly any[] ? never : undefined)\n    ? T\n    : never\n  : never;\n\ntype SettableKeyValueTuple<T extends PropertyContainer> =\n  KeyType<T> extends keyof any\n    ?\n        | {\n            [P in KeyType<T>]: readonly [P, SettableValueType<T, P>];\n          }[KeyType<T>]\n        | (T extends RecordType ? [keyof any, any] : never)\n    : readonly [KeyType<T>, SettableValueType<T, KeyType<T>>];\n\ntype SettableKeyValueRecord<T extends PropertyContainer> =\n  SettableKeyType<T> extends keyof any\n    ? RecordType &\n        ({\n          [P in KeyType<T>]?: SettableValueType<T, P>;\n        } & {\n          [P in SettableKeyType<T>]?: P extends KeyType<T>\n            ? ValueType<T, P>\n            : SettableValueType<T, P>;\n        })\n    : never;\n\ntype SettableValueList<T extends PropertyContainer> = T extends Primitives\n  ? never\n  :\n      | SettableKeyValueRecord<T>\n      | readonly (SettableKeyValueRecord<T> | SettableKeyValueTuple<T>)[];\n\ntype AllKeys<T> = T extends infer T ? keyof T : never;\ntype AnyValue<T, K> = T extends infer T\n  ? K extends keyof T\n    ? T[K]\n    : never\n  : never;\n\ntype MergeObjects<T> = {\n  [P in AllKeys<T>]: AnyValue<T, P>;\n};\n\ntype KeyValueTupleToRecord<Item> = Item extends readonly [infer K, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : Item extends readonly (infer KV)[]\n  ? { [P in KV & keyof any]: KV }\n  : Item extends RecordType\n  ? Item\n  : never;\n\ntype AssignRecord<T, S> = {\n  [P in Exclude<\n    keyof T | keyof S,\n    IsGeneralKey<keyof T | keyof S> extends true ? never : UndefinedKeys<S, T>\n  >]: P extends keyof S\n    ? IsGeneralKey<P> extends true\n      ? AnyValue<S | T, P>\n      : P extends keyof T\n      ? S[P] extends T[P]\n        ? GeneralizeContstants<S[P]> extends T[P]\n          ? GeneralizeContstants<S[P]>\n          : S[P]\n        : never\n      : GeneralizeContstants<S[P]>\n    : P extends keyof T\n    ? T[P]\n    : never;\n};\n\ntype SetResult<\n  T extends PropertyContainer,\n  V extends any\n> = T extends RecordType\n  ? PrettifyIntersection<\n      AssignRecord<\n        T,\n        V extends RecordType\n          ? V\n          : MergeObjects<KeyValueTupleToRecord<V[keyof V]>>\n      >\n    >\n  : T;\n\ntype SetOrUpdateFunction<\n  SettersOnly,\n  ErrorHandler = false,\n  Readonly = false\n> = {\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined,\n    U extends Updater<\n      T extends null | undefined ? never : T,\n      K,\n      ValueType<T, K>,\n      SettersOnly\n    >,\n    K extends KeyType<T>\n  >(\n    target: T,\n    key: K,\n    value: U,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): UpdaterType<U>;\n  <\n    T extends\n      | If<Readonly, ReadonlyPropertyContainer, PropertyContainer>\n      | null\n      | undefined\n  >(\n    target: T,\n    values: BulkUpdates<T extends null | undefined ? never : T, SettersOnly>,\n    ...args: ErrorHandler extends true ? [error: SetErrorHandler<T>] : []\n  ): T;\n};\n\nconst createSetOrUpdateFunction =\n  <SettersOnly, Error>(\n    setter: (target: any, key: any, value: any, error?: any) => any\n  ): SetOrUpdateFunction<SettersOnly, Error> =>\n  (target: PropertyContainer, key: any, value: any = NO_ARG, error?: any) => {\n    if (!target) return undefined;\n    if (value !== NO_ARG) {\n      return setter(target, key, value, error);\n    }\n\n    forEach(key, (item) =>\n      isArray(item)\n        ? setter(target, item[0], item[1])\n        : forEach(item, ([key, value]) => setter(target, key, value))\n    );\n\n    return target;\n  };\n\nexport const assign = createSetOrUpdateFunction<true, false>(setSingle);\nexport const update = createSetOrUpdateFunction<false, false>(updateSingle);\nexport const assignIfUndefined = createSetOrUpdateFunction<false, true>(\n  setSingleIfNotDefined\n);\n\nexport const swap = <T extends PropertyContainer, K extends KeyType<T>>(\n  target: T,\n  key: K,\n  value: ValueType<T, K>\n): ValueType<T, K, \"get\"> => {\n  const current = get(target, key) as any;\n  if (value !== current) setSingle(target, key, value);\n  return current as any;\n};\n\n// #endregion\n\nexport const add = <T extends PropertyContainer<any, boolean>>(\n  target: T,\n  key: KeyType<T>\n) =>\n  target instanceof Set\n    ? target.has(key)\n      ? false\n      : (target.add(key), true)\n    : get(target, key) !== assign(target, key, true as any);\n\nexport const has = <T extends ReadonlyPropertyContainer>(\n  target: T,\n  key: KeyType<T>\n) =>\n  hasMethod(target, \"has\")\n    ? target.has(key)\n    : isDefined((target as any).get?.(key) ?? (target as any)[key]);\n\ntype RemoveDeepArgs<\n  T,\n  Current extends any[] = [],\n  Depth extends number = 20\n> = T extends PropertyContainer\n  ? Depth extends 0\n    ? Current\n    :\n        | (Depth extends 20 ? never : Current)\n        | RemoveDeepArgs<\n            ValueType<T>,\n            [...Current, KeyType<T>[] | KeyType<T>],\n            Minus<Depth, 1>\n          >\n  : Current;\n\ntype RemoveDeepValue<\n  T,\n  Args extends any[],\n  ArrayIt = false\n> = T extends PropertyContainer\n  ? ArrayIt extends true\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>[]]\n    ? (ValueType<T> | undefined)[]\n    : Args extends [KeyType<T>]\n    ? ValueType<T> | undefined\n    : Args extends [infer R, ...infer Rest]\n    ? RemoveDeepValue<ValueType<T>, Rest, R extends any[] ? true : ArrayIt>\n    : never\n  : never;\n\nconst clearSingle = (target: any, key: any) => {\n  if (isUndefined(target ?? key)) return undefined;\n\n  let current = get(target, key);\n\n  if (hasMethod(target, \"delete\")) {\n    target.delete(key);\n  } else {\n    delete target[key];\n  }\n  return current;\n};\n\n/**\n * Removes one or more values from a property container specified by the provided key or array of keys.\n *\n * If more than one level of key arguments are specified, values will be removed from the property container at the deepest level.\n * If a property container becomes empty along the path of keys, it will be removed from its parent.\n *\n */\nexport const clear = <\n  T extends PropertyContainer | null | undefined,\n  Args extends RemoveDeepArgs<T>\n>(\n  target: T,\n  ...keys: Args\n): RemoveDeepValue<T, Args> => {\n  const removed: any[] = [];\n  let array = false;\n\n  const clearStep = (\n    target: any,\n    index: number,\n    parent?: any,\n    parentKey?: any\n  ) => {\n    if (!target) return;\n    const targetKeys = keys[index];\n    if (index === keys.length - 1) {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) => removed.push(clearSingle(target, key)));\n      } else {\n        removed.push(clearSingle(target, targetKeys));\n      }\n    } else {\n      if (isArray(targetKeys)) {\n        array = true;\n        targetKeys.forEach((key) =>\n          clearStep(get(target, key), index + 1, target, key)\n        );\n      } else {\n        clearStep(get(target, targetKeys), index + 1, target, targetKeys);\n      }\n      if (!count(target) && parent) {\n        remove(parent, parentKey);\n      }\n    }\n  };\n  clearStep(target, 0);\n  return array ? removed : removed[0];\n};\n\n/**\n * Removes the specified keys from a  property container.\n *\n * The difference between {@link clear} and this function is that it does not consider nested property containers and that arrays will be spliced (as opposed to `clear` where the index will be set to `undefined`).\n */\nexport const remove: {\n  <T extends PropertyContainer | null | undefined>(\n    target: T,\n    key: KeyType<T> | undefined\n  ): T extends null | undefined ? T : ValueType<T, KeyType<T>> | undefined;\n  <T extends PropertyContainer | null | undefined>(\n    target: T,\n    ...keys: (KeyType<T> | undefined)[]\n  ): (T extends null | undefined ? T : ValueType<T, KeyType<T>> | undefined)[];\n} = (target: PropertyContainer, key: any, ...keys: any[]) => {\n  if (!target) return undefined;\n\n  if (keys.length) {\n    // Sort array keys descending as they would otherwise not match their offset as the array is spliced along the way.\n    return (isArray(target) ? keys.sort((x, y) => y - x) : keys).map((key) =>\n      remove(target, key)\n    );\n  }\n\n  return isArray(target)\n    ? key < target.length\n      ? (target as any[]).splice(key, 1)[0]\n      : undefined\n    : clearSingle(target, key);\n};\n\ntype EntryToObject<Item> = Item extends readonly [infer K & keyof any, infer V]\n  ? {\n      [P in K & keyof any]: V;\n    }\n  : never;\n\ntype EntriesToObject<Entries> = UnionToIntersection<\n  InlinePropertyDescriptors<\n    Entries extends null | undefined | boolean\n      ? {}\n      : Entries extends readonly [\n          Partial<Readonly<PropertyDescriptor>>,\n          ...infer Rest\n        ]\n      ? EntriesToObject<Rest[number]>\n      : Entries extends readonly [infer Item, ...infer Rest]\n      ? EntryToObject<Item> & EntriesToObject<Rest>\n      : Entries extends readonly (infer Items)[]\n      ? EntryToObject<Items>\n      : Entries\n  >\n>;\n\ntype InlinePropertyDescriptors<T> = {\n  [P in keyof T]: T[P] extends { value: infer V }\n    ? V\n    : T[P] extends { get(): infer V }\n    ? V\n    : T[P];\n};\n\ntype PropertyList =\n  | boolean\n  | null\n  | undefined\n  | [defaults: Partial<PropertyDescriptor>, ...items: PropertyList[]]\n  | [key: keyof any, value: any][]\n  | (Record<keyof any, any> & { [Symbol.iterator]?: never });\n\nexport const define: {\n  <T, P extends PropertyList[]>(\n    target: T,\n    ...properties: P\n  ): PrettifyIntersection<T & EntriesToObject<P[number]>>;\n} = (target: any, ...args: any[]) => {\n  const add = (arg: any, defaults?: any) => {\n    if (!arg) return;\n    let properties: readonly any[];\n    if (isArray(arg)) {\n      if (isObject(arg[0])) {\n        // Tuple with the first item the defaults and the next the definitions with those defaults,\n        // ([{enumerable: false, ...}, ...])\n        (arg as any[]).splice(1).forEach((items) => add(items, arg[0]));\n        return;\n      }\n      // ([[key1, value1], [key2, value2], ...])\n      properties = arg;\n    } else {\n      // An object.\n      properties = map(arg)!;\n    }\n\n    properties.forEach(([key, value]) =>\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        writable: false,\n        ...defaults,\n        ...(isObject(value) && (\"get\" in value || \"value\" in value)\n          ? value\n          : { value }),\n      })\n    );\n  };\n\n  args.forEach((arg) => add(arg));\n  return target as any;\n};\n\ntype PropertySelector<T> =\n  | keyof T\n  | {\n      [P in keyof T]?: PropertySelector<T[P]> | [...keys: (keyof T[P])[]];\n    };\n\ntype SinglePickResult<T, Selected> = Selected extends\n  | (string & infer K)\n  | (infer K)[]\n  ? { [P in keyof T & K]: T[P] }\n  : keyof Selected extends infer Keys\n  ? {\n      [P in Keys & keyof any & keyof Selected]: P extends keyof T\n        ? Selected[P] extends true\n          ? T[P]\n          : SinglePickResult<T[P], Selected[P]>\n        : never;\n    }\n  : never;\n\ntype PickResults<T, Selectors> = PrettifyIntersection<\n  Selectors extends [infer Item, ...infer Rest]\n    ? SinglePickResult<T, Item> & SinglePickResult<T, Rest>\n    : never\n>;\n\nexport const pick = <T, Selectors extends PropertySelector<T>[], U>(\n  source: T | (null | (undefined & U)),\n  ...args: Selectors\n): U extends undefined ? undefined : PickResults<T, Selectors> => {\n  if (source === undefined) return undefined as any;\n\n  return Object.fromEntries(\n    args.flatMap((arg) =>\n      isObject(arg, true)\n        ? isArray(arg)\n          ? arg.map((args) =>\n              isArray(args)\n                ? args.length === 1\n                  ? [args[0], source![args[0]]]\n                  : pick(source![args[0]], ...(args[1] as any[]))\n                : [args[0], source![args[1]]]\n            )\n          : Object.entries(args).map(([key, value]) => [\n              key,\n              value === true ? source![key] : pick(source![key], value),\n            ])\n        : ([[arg, source![arg]]] as any)\n    )\n  ) as any;\n};\n\nexport type Wrapped<T> =\n  | T\n  | (() => Wrapped<T>)\n  | ((arg: any, ...args: any) => never);\nexport type Unwrap<T> = T extends Wrapped<infer T> ? T : never;\n\nexport const unwrap = <T extends Wrapped<any>>(value: T): Unwrap<T> =>\n  isFunction(value)\n    ? unwrap(value())\n    : isAwaitable(value)\n    ? value.then((result) => unwrap(result))\n    : value;\n\nexport const unlock = <T extends ReadonlyPropertyContainer>(\n  readonly: T\n): T extends ReadonlyMapLike<infer K, infer V>\n  ? MapLike<K, V>\n  : T extends ReadonlySetLike<infer T>\n  ? SetLike<T>\n  : T => readonly as any;\n"]}