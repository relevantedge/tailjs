{"version":3,"file":"components.js","sourceRoot":"","sources":["components.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ImpressionEvent,\n  cast,\n  type ActivatedComponent,\n  type ActivatedContent,\n  type ConfiguredComponent,\n  type Rectangle,\n  type UserInteractionEvent,\n} from \"@tailjs/types\";\nimport {\n  BoundaryCommand,\n  BoundaryData,\n  TrackerExtensionFactory,\n  getVisibleDuration,\n  isDataBoundaryCommand,\n  isScanComponentsCommand,\n} from \"..\";\nimport {\n  F,\n  NodeWithParentElement,\n  PendingActionHandle,\n  T,\n  any,\n  boundaryData,\n  clear,\n  concat,\n  del,\n  filter,\n  flatMap,\n  forAncestorsOrSelf,\n  forEach,\n  get,\n  getRect,\n  getScreenPos,\n  getViewport,\n  join,\n  map,\n  max,\n  nil,\n  parseTags,\n  push,\n  registerViewEndAction,\n  scanAttributes,\n  set,\n  size,\n  str,\n  timeout,\n  timer,\n  trackerConfig,\n  trackerFlag,\n  trackerProperty,\n  undefined,\n  unshift,\n} from \"../lib\";\nexport type ActivatedDomComponent = ConfiguredComponent & ActivatedComponent;\n\nexport const componentDomConfiguration = Symbol(\"DOM configuration\");\n\nexport const parseActivationTags = (el: Element) =>\n  parseTags(el, undefined, (el) => map(get(boundaryData, el)?.tags));\n\nconst hasComponentOrContent = (boundary?: BoundaryData | null) =>\n  boundary?.component || boundary?.content;\n\nlet entry: BoundaryData | undefined;\nexport const parseBoundaryTags = (el: Element) =>\n  parseTags(\n    el,\n    (ancestor) =>\n      ancestor !== el && !!hasComponentOrContent(get(boundaryData, ancestor)),\n    (el) =>\n      (entry = get(boundaryData, el)) &&\n      concat(\n        flatMap([entry.component, entry.content], (item) =>\n          flatMap(item, (item) => map(item.tags, F))\n        ),\n        entry.tags\n      )\n  );\n\nlet content: ActivatedContent[] | undefined;\nconst stripRects = (\n  component: ActivatedDomComponent,\n  keep?: boolean\n): ActivatedDomComponent =>\n  keep\n    ? component\n    : {\n        ...component,\n        rect: undefined,\n        content:\n          (content = component.content) &&\n          map(content, (content) => ({ ...content, rect: undefined })),\n      };\n\nconst enum IncludeState {\n  Secondary = 0,\n  Primary = 1,\n  Promoted = 2,\n}\n\nconst setContext = timeout();\n\nexport const getComponentContext = (\n  el: NodeWithParentElement,\n  directOnly = F\n) => {\n  clear(setContext);\n\n  let collectedContent: ActivatedContent[] = [];\n\n  type Area = {} & string; // For clarity.\n  let collected: (ActivatedDomComponent | Area)[] = [];\n\n  let includeState = IncludeState.Secondary;\n  let rect: Rectangle | undefined;\n  forAncestorsOrSelf(el, (el) => {\n    const entry = get(boundaryData, el);\n    if (!entry) {\n      return;\n    }\n\n    if (hasComponentOrContent(entry)) {\n      const components = filter(\n        entry.component,\n        (entry) =>\n          includeState === IncludeState.Secondary ||\n          (!directOnly &&\n            ((includeState === IncludeState.Primary &&\n              entry.track?.secondary !== T) ||\n              entry.track?.promote))\n      );\n\n      rect =\n        (any(components, (item) => item.track?.region) && getRect(el)) ||\n        undefined;\n      const tags = parseBoundaryTags(el);\n      entry.content &&\n        unshift(\n          collectedContent,\n          ...map(entry.content, (item) => ({\n            ...item,\n            rect,\n            ...tags,\n          }))\n        );\n\n      components.length &&\n        (unshift(\n          collected,\n          ...map(\n            components,\n            (item) => (\n              (includeState = max(\n                includeState,\n                item.track?.secondary // INV: Secondary components are only included here if we did not have any components from a child element.\n                  ? IncludeState.Primary\n                  : IncludeState.Promoted\n              )),\n              stripRects(\n                {\n                  ...item,\n                  content: collectedContent,\n                  rect,\n                  ...tags,\n                },\n                !!rect\n              )\n            )\n          )\n        ),\n        (collectedContent = []));\n    }\n\n    const area = entry.area || trackerProperty(el, \"area\");\n    area && unshift(collected, ...map(area));\n  });\n\n  let areaPath: string[] | undefined;\n  let components: ActivatedComponent[] | undefined;\n\n  if (collectedContent.length) {\n    // Content without a contaning component is gathered in an ID-less component.\n    push(collected, stripRects({ id: \"\", rect, content: collectedContent }));\n  }\n\n  forEach(collected, (item) => {\n    if (str(item)) {\n      push((areaPath ??= []), item);\n    } else {\n      item.area ??= join(areaPath, \"/\");\n      unshift((components ??= []), item);\n    }\n  });\n\n  return components || areaPath\n    ? { components: components, area: join(areaPath, \"/\") }\n    : undefined;\n};\n\nconst intersectionHandler = Symbol();\nexport const components: TrackerExtensionFactory = {\n  id: \"components\",\n  setup(tracker) {\n    const observer = new IntersectionObserver(\n      (els) =>\n        forEach(\n          els,\n          ({ target, isIntersecting, boundingClientRect, intersectionRatio }) =>\n            target[intersectionHandler]?.(\n              isIntersecting,\n              boundingClientRect,\n              intersectionRatio\n            )\n        ),\n      // Low thresholds used to be able to handle components larger than viewports\n      { threshold: [0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.75] }\n    );\n\n    function registerComponent({ boundary: el, ...command }: BoundaryCommand) {\n      let update =\n        \"add\" in command\n          ? (current: BoundaryData) =>\n              cast<BoundaryData>({\n                ...current,\n                component: concat(current?.component, command.component),\n                content: concat(current?.content, command.content),\n                area: command?.area ?? current?.area,\n                tags: concat(current?.tags, command.tags),\n                cart: command.cart ?? current?.cart,\n                track: command.track ?? current?.track,\n              })\n          : command[\"update\"];\n\n      set(boundaryData, el, update ?? command);\n\n      let components: ConfiguredComponent[] | undefined;\n      if (\n        (components = filter(\n          get(boundaryData, el)?.component,\n          (cmp) =>\n            // Impression settings from the DOM/CSS are ignorred for secondary and inferred components (performance thing)\n            cmp!.track?.impressions ||\n            (cmp.track?.secondary ?? cmp.inferred) !== T\n        ))\n      ) {\n        if (!size(components)) {\n          return;\n        }\n\n        let visible = F;\n        let impressions = 0;\n        let event: PendingActionHandle | null = nil;\n        let fold: number;\n        const captureState = timeout();\n        const t = timer(() => getVisibleDuration(), F);\n\n        el[intersectionHandler] = (\n          intersecting: boolean,\n          rect: DOMRectReadOnly,\n          ratio: number\n        ) => {\n          intersecting =\n            ratio >= 0.75 ||\n            (rect.top < (fold = window.innerHeight / 2) && rect.bottom > fold);\n\n          t(intersecting);\n          if (visible !== (visible = intersecting)) {\n            //el[\"style\"].border = visible ? \"2px solid blue\" : \"\";\n            if (visible) {\n              captureState(() => {\n                ++impressions;\n                if (!event) {\n                  const events = filter(\n                    map(\n                      components,\n                      (cmp) =>\n                        ((cmp!.track?.impressions ||\n                          trackerFlag(\n                            el,\n                            \"impressions\",\n                            T,\n                            (data) => data.track?.impressions\n                          )) &&\n                          cast<ImpressionEvent>({\n                            type: \"IMPRESSION\",\n                            pos: getScreenPos(el),\n                            viewport: getViewport(),\n                            ...getComponentContext(el, T),\n                          })) ||\n                        nil\n                    )\n                  );\n                  event = registerViewEndAction(() =>\n                    push(\n                      tracker,\n                      ...map(\n                        events,\n                        (ev) => (\n                          ((ev.duration = t()), (ev.impressions = impressions)),\n                          ev\n                        )\n                      )\n                    )\n                  );\n                }\n              }, -trackerConfig.impressionThreshold);\n            } else {\n              clear(captureState); // Not visible, clear timeout.\n            }\n          }\n          !el.isConnected && (event?.(), (event = nil));\n        };\n        observer.observe(el);\n      }\n    }\n\n    return {\n      decorate(eventData) {\n        // Strip tracking configuration.\n        forEach((eventData as UserInteractionEvent).components, (component) =>\n          del(component as any, \"track\")\n        );\n      },\n      processCommand(cmd) {\n        return isDataBoundaryCommand(cmd)\n          ? (registerComponent(cmd), T)\n          : isScanComponentsCommand(cmd)\n          ? (map(\n              scanAttributes(cmd.scan.attribute, cmd.scan.components),\n              registerComponent\n            ),\n            T)\n          : F;\n      },\n    };\n  },\n};\n"]}