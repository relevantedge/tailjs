{"version":3,"file":"DefaultCryptoProvider.js","sourceRoot":"","sources":["DefaultCryptoProvider.ts"],"names":[],"mappings":"AAAA,OAAO,EAEL,eAAe,EACf,gBAAgB,EAChB,IAAI,GACL,MAAM,wBAAwB,CAAC;AAGhC;;GAEG;AACH,MAAM,OAAO,qBAAqB;IACf,gBAAgB,CAAS;IACzB,QAAQ,CAA4B;IAErD,YAAY,IAAiC;QAC3C,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,CAAC;YAClB,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;YAC3B,IAAI,CAAC,QAAQ,GAAG,EAAE,EAAE,EAAE,gBAAgB,EAAE,CAAC;YACzC,OAAO;QACT,CAAC;QAED,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC,WAAW,CAChC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC,CACzD,CAAC;QACF,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IAC5C,CAAC;IAED,IAAI,CAAC,KAAa,EAAE,aAAmB;QACrC,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,aAAa,CAAQ,CAAC;IAC9E,CAAC;IAED,OAAO,CAAC,MAAc;QACpB,IAAI,QAAQ,GAAG,EAAE,CAAC;QAClB,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;QACrE,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CACzE,MAAM,CACP,CAAC;IACJ,CAAC;IACD,OAAO,CAAC,MAAc;QACpB,OAAO,GAAG,IAAI,CAAC,gBAAgB,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CACxE,MAAM,CACP,EAAE,CAAC;IACN,CAAC;CACF","sourcesContent":["import {\n  Transport,\n  createTransport,\n  defaultTransport,\n  hash,\n} from \"@tailjs/util/transport\";\nimport { CryptoProvider } from \"..\";\n\n/**\n * A crypto provider based on linear feedback XOR, entropy and padding.\n */\nexport class DefaultCryptoProvider implements CryptoProvider {\n  private readonly _currentCipherId: string;\n  private readonly _ciphers: Record<string, Transport>;\n\n  constructor(keys: string[] | null | undefined) {\n    if (!keys?.length) {\n      this._currentCipherId = \"\";\n      this._ciphers = { \"\": defaultTransport };\n      return;\n    }\n\n    this._ciphers = Object.fromEntries(\n      keys.map((key) => [hash(key, 32), createTransport(key)])\n    );\n    this._currentCipherId = hash(keys[0], 32);\n  }\n\n  hash(value: string, numericOrBits?: any): string {\n    return this._ciphers[this._currentCipherId][2](value, numericOrBits) as any;\n  }\n\n  decrypt(cipher: string): any {\n    let cipherId = \"\";\n    cipher = cipher.replace(/^(.*?)!/, (_, m1) => ((cipherId = m1), \"\"));\n    return (this._ciphers[cipherId] ?? this._ciphers[this._currentCipherId])[1](\n      cipher\n    );\n  }\n  encrypt(source: string): string {\n    return `${this._currentCipherId}!${this._ciphers[this._currentCipherId][0](\n      source\n    )}`;\n  }\n}\n"]}