{"version":3,"file":"ensureTracker.js","sourceRoot":"","sources":["ensureTracker.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,aAAa,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAEzD,MAAM,cAAc,GAAG,aAA6C,CAAC;AAErE,MAAM,WAAW,GAAG,aAAa,CAAC,IAAI,CAAC;AACvC,MAAM,CAAC,IAAI,IAAI,GAAY,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,CAAC;AAC5D,IAAI,WAAW,GAAG,KAAK,CAAC;AAExB,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC;AAEzC,wEAAwE;AACxE,yFAAyF;AACzF,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,aAAa,EAAE,CAAC,CAAC;AAE/C,KAAK,UAAU,aAAa;IAC1B,IAAI,aAAa,CAAC,IAAI,KAAK,WAAW,EAAE,CAAC;QACvC,IAAI,GAAG,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,WAAW,CAAC,CAAC;QAChE,OAAO,UAAU,CAAC,WAAW,CAAC,CAAC;IACjC,CAAC;IACD,IACE,OAAO,MAAM,KAAK,WAAW;QAC7B,IAAI,CAAC,SAAS,CAAC;QACf,cAAc,CAAC,QAAQ;QACvB,WAAW,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC,EACpC,CAAC;QACD,OAAO;IACT,CAAC;IAED,WAAW,GAAG,IAAI,CAAC;IAEnB,IAAI,aAAa,CAAC,QAAQ,EAAE,CAAC;QAC3B,OAAO;IACT,CAAC;IAED,uCAAuC;IAEvC,MAAM,YAAY,GAAG,GAAG,EAAE;QACxB,MAAM,GAAG,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;QAChC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,UAAU,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC;QACzC,IAAI,aAAa,CAAC,IAAI,EAAE,CAAC;YACvB,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,aAAa,CAAC,IAAI,CAAC,CAAC;QACpC,CAAC;QACD,OAAO,QAAQ,CAAC,IAAI,CAAC,WAAW,CAC9B,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;YAC9C,EAAE,EAAE,QAAQ;YACZ,GAAG,EAAE,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;YACjB,KAAK,EAAE,IAAI;SACZ,CAAC,CACH,CAAC;IACJ,CAAC,CAAC;IAEF,QAAQ,CAAC,UAAU,KAAK,SAAS;QAC/B,CAAC,CAAC,YAAY,EAAE;QAChB,CAAC,CAAC,QAAQ,CAAC,gBAAgB,CACvB,kBAAkB,EAClB,GAAG,EAAE,CAAC,QAAQ,CAAC,UAAU,KAAK,SAAS,IAAI,YAAY,EAAE,CAC1D,CAAC;AACR,CAAC","sourcesContent":["import type { EmbeddedTrackerConfiguration } from \".\";\nimport type { Tracker } from \"..\";\nimport { trackerConfig, isTracker } from \"../lib/config\";\n\nconst externalConfig = trackerConfig as EmbeddedTrackerConfiguration;\n\nconst initialName = trackerConfig.name;\nexport let tail: Tracker = (globalThis[initialName] ??= []);\nlet initialized = false;\n\ntail.push((tracker) => (tail = tracker));\n\n// Give consumer a short chance to call configureTracker, before wiring.\n// Do it explicitly with Promise instead of async to avoid, say, babel to miss the point.\nPromise.resolve(0).then(() => ensureTracker());\n\nasync function ensureTracker(): Promise<void> {\n  if (trackerConfig.name !== initialName) {\n    tail = globalThis[trackerConfig.name] = globalThis[initialName];\n    delete globalThis[initialName];\n  }\n  if (\n    typeof window === \"undefined\" ||\n    tail[isTracker] ||\n    externalConfig.external ||\n    initialized === (initialized = true)\n  ) {\n    return;\n  }\n\n  initialized = true;\n\n  if (trackerConfig.disabled) {\n    return;\n  }\n\n  //tail.push({ config: trackerConfig });\n\n  const injectScript = () => {\n    const src = [trackerConfig.src];\n    src.push(\"?\", globalThis.REVISION ?? \"\");\n    if (trackerConfig.name) {\n      src.push(\"#\", trackerConfig.name);\n    }\n    return document.head.appendChild(\n      Object.assign(document.createElement(\"script\"), {\n        id: \"tailjs\",\n        src: src.join(\"\"),\n        async: true,\n      })\n    );\n  };\n\n  document.readyState !== \"loading\"\n    ? injectScript()\n    : document.addEventListener(\n        \"readystatechange\",\n        () => document.readyState !== \"loading\" && injectScript()\n      );\n}\n"]}