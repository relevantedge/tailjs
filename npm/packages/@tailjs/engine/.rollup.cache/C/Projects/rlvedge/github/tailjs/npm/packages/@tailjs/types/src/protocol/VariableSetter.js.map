{"version":3,"file":"VariableSetter.js","sourceRoot":"","sources":["VariableSetter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAqB,kBAAkB,EAAE,MAAM,cAAc,CAAC;AACrE,OAAO,EAOL,kBAAkB,EAClB,WAAW,EACX,YAAY,EACZ,aAAa,GAGd,MAAM,IAAI,CAAC;AAmBZ,MAAM,cAAc,GAAG;IACrB,OAAO,mCAA2B;IAClC,SAAS,qCAA6B;IACtC,QAAQ,oCAA4B;IACpC,WAAW,uCAA+B;IAC1C,MAAM,kCAA0B;IAChC,QAAQ,oCAA4B;IACpC,QAAQ,oCAA4B;IACpC,KAAK,iCAAyB;CACtB,CAAC;AAEX,MAAM,CAAC,MAAM,SAAS,GAAG,kBAAkB,CACzC,cAAc,EACd,KAAK,EACL,qBAAqB,CACtB,CAAC;AA6DF,MAAM,cAAc,GAAG;IACrB,GAAG,+BAAuB;IAC1B,GAAG,+BAAuB;IAC1B,GAAG,+BAAuB;IAC1B,OAAO,mCAA2B;CAC1B,CAAC;AAMX,MAAM,CAAC,MAAM,SAAS,GAAG,kBAAkB,CACzC,cAAc,EACd,KAAK,EACL,qBAAqB,CACtB,CAAC;AAoBF,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,MAAW,EAA2B,EAAE,CACtE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;AAEpB,MAAM,cAAc,GAAG;IACrB,CAAC,OAAO,EAAE,aAAa,CAAC;IACxB,CAAC,SAAS,EAAE,WAAW,CAAC;IACxB,CAAC,UAAU,EAAE,YAAY,CAAC;IAC1B,CAAC,gBAAgB,EAAE,kBAAkB,CAAC;CAC9B,CAAC;AAiBX,MAAM,CAAC,MAAM,QAAQ,GAIb,CAAC,KAAU,EAAE,EAAE;IACrB,IAAI,CAAC,KAAK;QAAE,OAAO,KAAK,CAAC;IAEzB,cAAc,CAAC,OAAO,CACpB,CAAC,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CACxD,CAAC;IAEF,OAAO,KAAY,CAAC;AACtB,CAAC,CAAC;AAqBF,MAAM,CAAC,MAAM,eAAe,GAAG,CAC7B,MAAqB,EAGrB,EAAE,CAAC,MAAM,EAAE,MAAO,uCAA+B,CAAC;AAEpD,MAAM,CAAC,MAAM,gBAAgB,GAAG,CAC9B,MAAwC,EAGxC,EAAE,CAAC,MAAM,EAAE,MAAM,uCAA+B,CAAC;AAEnD,MAAM,CAAC,MAAM,aAAa,GAAG,CAC3B,MAAwC,EAGxC,EAAE,CAAC,MAAM,EAAE,MAAM,oCAA4B,CAAC","sourcesContent":["import { ParsableEnumValue, createEnumAccessor } from \"@tailjs/util\";\r\nimport {\r\n  Variable,\r\n  VariableClassification,\r\n  VariableKey,\r\n  VariableScope,\r\n  VariableVersion,\r\n  VersionedVariableKey,\r\n  dataClassification,\r\n  dataPurpose,\r\n  dataPurposes,\r\n  variableScope,\r\n  DataPurposes,\r\n  DataClassification,\r\n} from \"..\";\r\n\r\nexport type TargetedVariableScope =\r\n  | VariableScope.Session\r\n  | VariableScope.Device\r\n  | VariableScope.User\r\n  | VariableScope.Entity;\r\n\r\nexport const enum VariableSetStatus {\r\n  Success = 0,\r\n  Unchanged = 1,\r\n  Conflict = 2,\r\n  Unsupported = 3,\r\n  Denied = 4,\r\n  ReadOnly = 5,\r\n  NotFound = 6,\r\n  Error = 7,\r\n}\r\n\r\nconst setStatusNames = {\r\n  success: VariableSetStatus.Success,\r\n  unchanged: VariableSetStatus.Unchanged,\r\n  conflict: VariableSetStatus.Conflict,\r\n  unsupported: VariableSetStatus.Unsupported,\r\n  denied: VariableSetStatus.Denied,\r\n  readonly: VariableSetStatus.ReadOnly,\r\n  notFound: VariableSetStatus.NotFound,\r\n  error: VariableSetStatus.Error,\r\n} as const;\r\n\r\nexport const setStatus = createEnumAccessor(\r\n  setStatusNames,\r\n  false,\r\n  \"variable set status\"\r\n);\r\n\r\nexport type VariableSetStatusValue<\r\n  Numeric extends boolean | undefined = boolean\r\n> = ParsableEnumValue<typeof setStatusNames, Numeric, false>;\r\n\r\nexport type VariableSetResult<\r\n  T = any,\r\n  Source extends VariableSetter<T> = VariableSetter<T>\r\n> = {\r\n  source: Source;\r\n} & (\r\n  | {\r\n      status:\r\n        | VariableSetStatus.Success\r\n        | VariableSetStatus.Unchanged\r\n        | VariableSetStatus.Conflict;\r\n      current: Source extends VariableSetter<undefined>\r\n        ? Variable<T, true> | undefined\r\n        : Variable<T, true>;\r\n    }\r\n  | ((\r\n      | {\r\n          status:\r\n            | VariableSetStatus.Denied\r\n            | VariableSetStatus.NotFound\r\n            | VariableSetStatus.Unsupported\r\n            | VariableSetStatus.ReadOnly;\r\n        }\r\n      | { status: VariableSetStatus.Error; transient?: boolean; error: any }\r\n    ) & { current?: never })\r\n);\r\n\r\nexport interface VariablePatchSource<\r\n  T = any,\r\n  NumericEnums extends boolean = boolean\r\n> extends VariableVersion,\r\n    VariableClassification<NumericEnums> {\r\n  value: T;\r\n}\r\n\r\nexport type VariablePatchResult<\r\n  T = any,\r\n  NumericEnums extends boolean = boolean\r\n> =\r\n  | (Partial<VariableClassification<NumericEnums>> & {\r\n      value: T | undefined;\r\n    })\r\n  | undefined;\r\n\r\nexport type VariablePatchAction<T = any> = (\r\n  current: VariablePatchSource<T, true> | undefined\r\n) => VariablePatchResult<T> | undefined;\r\n\r\nexport const enum VariablePatchType {\r\n  Add,\r\n  Min,\r\n  Max,\r\n  IfMatch,\r\n}\r\n\r\nconst patchTypeNames = {\r\n  add: VariablePatchType.Add,\r\n  min: VariablePatchType.Min,\r\n  max: VariablePatchType.Max,\r\n  ifMatch: VariablePatchType.IfMatch,\r\n} as const;\r\n\r\nexport type VariablePatchTypeValue<\r\n  Numeric extends boolean | undefined = boolean\r\n> = ParsableEnumValue<typeof patchTypeNames, Numeric, false>;\r\n\r\nexport const patchType = createEnumAccessor(\r\n  patchTypeNames,\r\n  false,\r\n  \"variable patch type\"\r\n);\r\n\r\nexport type VariableValuePatch<T = any> = {\r\n  selector?: string;\r\n} & (\r\n  | {\r\n      type: VariablePatchType.Add | \"add\";\r\n      by: number;\r\n    }\r\n  | {\r\n      type: VariablePatchType.Min | VariablePatchType.Max | \"min\" | \"max\";\r\n      value: number;\r\n    }\r\n  | {\r\n      type: VariablePatchType.IfMatch | \"ifMatch\";\r\n      match: T | undefined;\r\n      value: T | undefined;\r\n    }\r\n);\r\n\r\nexport const isVariablePatch = (setter: any): setter is VariablePatch =>\r\n  !!setter[\"patch\"];\r\n\r\nconst enumProperties = [\r\n  [\"scope\", variableScope],\r\n  [\"purpose\", dataPurpose],\r\n  [\"purposes\", dataPurposes],\r\n  [\"classification\", dataClassification],\r\n] as const;\r\n\r\ntype EnumPropertyType<\r\n  P extends keyof any,\r\n  Default,\r\n  Props\r\n> = Props extends readonly []\r\n  ? Default\r\n  : Props extends readonly [\r\n      readonly [infer Key, { values: (infer T)[] }],\r\n      ...infer Rest\r\n    ]\r\n  ? P extends Key\r\n    ? T\r\n    : EnumPropertyType<P, Default, Rest>\r\n  : never;\r\n\r\nexport const toStrict: <T>(value: T) => T extends null | undefined\r\n  ? T\r\n  : {\r\n      [P in keyof T]: EnumPropertyType<P, T[P], typeof enumProperties>;\r\n    } = (value: any) => {\r\n  if (!value) return value;\r\n\r\n  enumProperties.forEach(\r\n    ([prop, helper]) => (value[prop] = helper(value[prop]))\r\n  );\r\n\r\n  return value as any;\r\n};\r\n\r\nexport type VariablePatch<\r\n  T = any,\r\n  NumericEnums extends boolean = boolean\r\n> = VariableKey<NumericEnums> &\r\n  Partial<Variable<T, NumericEnums>> &\r\n  (\r\n    | {\r\n        patch: VariablePatchAction<T>;\r\n      }\r\n    | (VariableClassification<NumericEnums> & {\r\n        patch: VariableValuePatch<T>;\r\n      })\r\n  );\r\n\r\nexport type VariableSetter<T = any, NumericEnums extends boolean = boolean> =\r\n  | Variable<T, NumericEnums>\r\n  | (VersionedVariableKey<NumericEnums> & { value: undefined })\r\n  | VariablePatch<T, NumericEnums>;\r\n\r\nexport const isSuccessResult = <T extends VariableSetResult>(\r\n  result: T | undefined\r\n): result is T & {\r\n  status: VariableSetStatus.Success | VariableSetStatus.Unchanged;\r\n} => result?.status! <= VariableSetStatus.Unchanged;\r\n\r\nexport const isConflictResult = <T>(\r\n  result: VariableSetResult<T> | undefined\r\n): result is VariableSetResult<T> & {\r\n  status: VariableSetStatus.Conflict;\r\n} => result?.status === VariableSetStatus.Conflict;\r\n\r\nexport const isErrorResult = <T>(\r\n  result: VariableSetResult<T> | undefined\r\n): result is VariableSetResult<T> & {\r\n  status: VariableSetStatus.Error;\r\n} => result?.status === VariableSetStatus.Error;\r\n"]}