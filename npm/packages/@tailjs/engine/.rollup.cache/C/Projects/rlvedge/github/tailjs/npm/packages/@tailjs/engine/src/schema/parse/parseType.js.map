{"version":3,"file":"parseType.js","sourceRoot":"","sources":["parseType.ts"],"names":[],"mappings":"AAAA,OAAO,EAAU,OAAO,EAA+B,MAAM,cAAc,CAAC;AAC5E,OAAO,EAKL,gBAAgB,EAChB,UAAU,EACV,yBAAyB,EACzB,aAAa,GACd,MAAM,GAAG,CAAC;AAEX,MAAM,CAAC,MAAM,SAAS,GAAG,CACvB,IAAS,EACT,OAAwB,EACxB,iBAAkC,EACV,EAAE;IAC1B,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,EAAE;YACjC,MAAM,UAAU,GAAG,aAAa,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YACnD,MAAM,IAAI,GAAG,SAAS,CAAC,GAAG,EAAE,aAAa,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,CAAC;YAC5D,IAAI,IAAI,EAAE,CAAC;gBACT,UAAU,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YAChD,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,MAAM,iBAAiB,GAAG,yBAAyB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACnE,IAAI,iBAAiB,EAAE,CAAC;QACtB,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,IAAI,EAAE,CAAC;YAC/C,MAAM,UAAU,CACd,OAAO,EACP,iDAAiD,CAClD,CAAC;QACJ,CAAC;QAED,IAAI,IAAI,GAAG,OAAO,CAAC,GAAG,CAAC;QACvB,IAAI,QAAQ,GAAG,iBAAiB,CAAC;QACjC,OAAO,QAAQ,EAAE,CAAC;YAChB,IAAI;gBACF,QAAQ,CAAC,aAAa,CAAC,IAAI;oBAC3B,GAAG;oBACH,QAAQ,CAAC,IAAI;oBACb,CAAC,IAAI,KAAK,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;YAC3C,QAAQ,GAAG,QAAQ,CAAC,aAAa,CAAC,iBAAkB,CAAC;QACvD,CAAC;QAED,MAAM,IAAI,GAAe;YACvB,EAAE,EAAE,OAAO,CAAC,MAAM,EAAE,EAAG,GAAG,GAAG,GAAG,IAAI;YACpC,QAAQ,EAAE,IAAI,CAAC,GAAG;YAClB,IAAI;YACJ,GAAG,gBAAgB,CAAC,IAAI,CAAC;YACzB,OAAO;YACP,iBAAiB;YACjB,QAAQ,EAAE,CAAC,iBAAiB;YAC5B,UAAU,EAAE,IAAI,GAAG,EAAE;YACrB,WAAW,EAAE,iBAAiB;SAC/B,CAAC;QAEF,OAAO,CAAC,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,IAAI,CAAC;QAEnC,OAAO,CAAC,YAAY,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAC/C,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;QAC9C,OAAO,IAAI,CAAC;IACd,CAAC;AACH,CAAC,CAAC","sourcesContent":["import { expand, forEach, isDefined, join, throwError } from \"@tailjs/util\";\r\nimport {\r\n  ParsedProperty,\r\n  ParsedType,\r\n  TraverseContext,\r\n  parseCompositions,\r\n  parseDescription,\r\n  parseError,\r\n  tryParseObjectComposition,\r\n  updateContext,\r\n} from \".\";\r\n\r\nexport const parseType = (\r\n  node: any,\r\n  context: TraverseContext,\r\n  declaringProperty?: ParsedProperty\r\n): ParsedType | undefined => {\r\n  if (node.$defs) {\r\n    forEach(node.$defs, ([key, def]) => {\r\n      const defContext = updateContext(context, \"$defs\");\r\n      const type = parseType(def, updateContext(defContext, key));\r\n      if (type) {\r\n        defContext.schema?.types.set(type.name, type);\r\n      }\r\n    });\r\n  }\r\n\r\n  const objectComposition = tryParseObjectComposition(node, context);\r\n  if (objectComposition) {\r\n    if (node.node === context.schema?.context.node) {\r\n      throw parseError(\r\n        context,\r\n        \"A schema definition cannot declare a root type.\"\r\n      );\r\n    }\r\n\r\n    let name = context.key;\r\n    let property = declaringProperty;\r\n    while (property) {\r\n      name =\r\n        property.declaringType.name +\r\n        \"_\" +\r\n        property.name +\r\n        (name !== context.key ? \"_\" + name : \"\");\r\n      property = property.declaringType.declaringProperty!;\r\n    }\r\n\r\n    const type: ParsedType = {\r\n      id: context.schema?.id! + \"#\" + name,\r\n      schemaId: node.$id,\r\n      name,\r\n      ...parseDescription(node),\r\n      context,\r\n      declaringProperty,\r\n      topLevel: !declaringProperty,\r\n      properties: new Map(),\r\n      composition: objectComposition,\r\n    };\r\n\r\n    context.node.$anchor ??= type.name;\r\n\r\n    context.parseContext.typeNodes.set(node, type);\r\n    context.parseContext.types.set(type.id, type);\r\n    return type;\r\n  }\r\n};\r\n"]}