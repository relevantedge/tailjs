{"version":3,"file":"lfsr.js","sourceRoot":"","sources":["lfsr.ts"],"names":[],"mappings":"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","sourcesContent":["import { hasValue, isBoolean } from \"..\";\n\n/** The number of leading entropy bytes. */\nconst ENTROPY = 4;\n/** The padding length. Cipher texts will always be a multiple of this. */\nconst MAX_PADDING = 16;\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV_hash_parameters\ntype Fnv1aConfiguration = [offset: bigint, prime: bigint];\nconst FNVs: Record<number, Fnv1aConfiguration> = {\n  32: [0x811c9dc5n, 0x01000193n],\n  64: [0xcbf29ce484222325n, 0x100000001b3n],\n  128: [0x6c62272e07bb014262b821756295c58dn, 0x1000000000000000000013bn],\n};\n\n/** A random byte. */\nconst entropy = (max = 256) => (max * Math.random()) | 0;\n\nexport type HashFunction<T> = {\n  (value: T, bits?: 32 | 64 | 128): string;\n  <B extends boolean>(value: T, numeric: B): B extends true ? number : string;\n};\n\nexport type CipherFunction = (data: Uint8Array) => Uint8Array;\nexport type CipherFunctions = [\n  CipherFunction,\n  CipherFunction,\n  HashFunction<Uint8Array>\n];\n\n/**\n * Linear-feedback shift register encryption with leading entropy and fixed padding.\n *\n * Used for on-the-fly encryption. It is not the strongest encryption, yet it is annoyingly challenging to break.\n * Due to entropy the same text with the same key will result in a different cipher text every time.\n *\n *\n * \"It is fast and small.\", Bob said to Alice. \"It is all right.\", she replied.\n *\n * (Adapted from http://quinnftw.com/xor-ciphers/).\n */\nexport const lfsr = (key = \"\"): CipherFunctions => {\n  /** Number of source bytes for (en/de)cryption. */\n  let n: number;\n  /** Source byte index. */\n  let i: number;\n  /** Target byte index. */\n  let j: number;\n  /** Padding length. */\n  let pad: number;\n\n  /** Holds the (en/de)crypted bytes. */\n  let target: Uint8Array;\n\n  /** Hash code. */\n  let hash = 0n;\n\n  /** Bits for FNV-1a hash code. */\n  let bits = 0;\n\n  /** Prime for FNV-1a hash code. */\n  let prime = 0n;\n\n  /**\n   * The sliding window with the past ciphers used to update for the mixer.\n   * It works as a linear feedback shfit register to bolster against frequency analysis.\n   *\n   * http://quinnftw.com/xor-ciphers/.\n   */\n  let window: number[] = [];\n\n  /** The mixer used to iteratively update the key while (en/de)crypting. */\n  let mixer = 0;\n  /** The mixer modulo 256. */\n  let mixer255 = 0;\n\n  /** Current start of the mixer window. */\n  let iw = 0;\n  /** Initial mixer. */\n  let mixer0 = 0;\n  /** Initial bytes for the mixer. */\n  const window0: number[] = [];\n\n  for (iw = 0; iw < key.length; mixer0 += window0[iw] = key.charCodeAt(iw++));\n\n  /** Resets the mixer when (en/de)cryption starts. */\n  const resetMixer = key\n    ? () => {\n        window = [...window0];\n        mixer255 = (mixer = mixer0) & 255;\n        iw = -1;\n      }\n    : () => {};\n\n  /** Updates the mixer with the (en/de)crypted byte. */\n  const updateMixer = (c: number) => (\n    (mixer255 =\n      (mixer +=\n        // Subtract the byte leaving the window.\n        -window[(iw = (iw + 1) % window.length)] +\n        // Add the byte entering the window.\n        (window[iw] = c)) & 255),\n    c\n  );\n\n  return [\n    // Encrypt\n    key\n      ? (source) => {\n          resetMixer();\n          n = source.length;\n          pad = MAX_PADDING - ((n + ENTROPY) % MAX_PADDING);\n          target = new Uint8Array(ENTROPY + n + pad);\n\n          for (j = 0; j < ENTROPY - 1; target[j++] = updateMixer(entropy()));\n\n          // Align last entropy byte to max padding and add padding.\n          target[j++] = updateMixer(\n            mixer255 ^ (MAX_PADDING * entropy(256 / MAX_PADDING) + pad)\n          );\n\n          for (i = 0; i < n; target[j++] = updateMixer(mixer255 ^ source[i++]));\n          while (pad--) target[j++] = entropy();\n\n          return target;\n        }\n      : (source) => source,\n\n    // Decrypt\n    key\n      ? (source) => {\n          resetMixer();\n          for (i = 0; i < ENTROPY - 1; updateMixer(source[i++]));\n          n =\n            source.length -\n            ENTROPY -\n            // Padding. If padding is zero it all last PADDING characters are padding.\n            ((mixer255 ^ updateMixer(source[i++])) % MAX_PADDING ||\n              MAX_PADDING);\n          if (n <= 0) return new Uint8Array(0);\n\n          target = new Uint8Array(n);\n\n          for (j = 0; j < n; target[j++] = mixer255 ^ updateMixer(source[i++]));\n          return target;\n        }\n      : (cipher) => cipher,\n\n    // FNV1a hash code.\n    (source: Uint8Array, numericOrBits: any = 64) => {\n      if (!hasValue(source)) return null;\n      bits = isBoolean(numericOrBits) ? 64 : numericOrBits;\n\n      resetMixer();\n\n      [hash, prime] = FNVs[bits];\n\n      for (\n        i = 0;\n        i < source.length;\n        hash = BigInt.asUintN(\n          bits,\n          (hash ^ BigInt(mixer255 ^ updateMixer(source[i++]))) * prime\n        )\n      );\n\n      return numericOrBits === true\n        ? Number(\n            BigInt(Number.MIN_SAFE_INTEGER) +\n              (hash % BigInt(Number.MAX_SAFE_INTEGER - Number.MIN_SAFE_INTEGER))\n          )\n        : (hash.toString(36) as any);\n    },\n  ];\n};\n"]}