{"version":3,"file":"types.js","sourceRoot":"","sources":["types.ts"],"names":[],"mappings":"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","sourcesContent":["import { Wrapped, map, obj, unwrap, type reduce } from \".\";\n\nexport type IsNever<T> = [T] extends [never] ? true : false;\n\n/**\n * Shorthand for a value that is optionally awaitable.\n */\nexport type MaybePromise<T> = PromiseLike<T> | T;\n\nexport type ValueOrDefault<T, R, D = undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? D\n  : R;\n\n/** Shorter than writing all this out, and slightly easier to read. */\nexport type Nullish = null | undefined;\n\n/**\n * Removes null'ish values from a union.\n */\nexport type OmitNullish<T> = T extends Nullish ? never : T;\n\n/**\n * The defined part of a type, excluding undefined and void (which is also undefined).\n */\nexport type Defined<T> = Exclude<T, undefined | void>;\n\n/**\n * A record that may have the specified keys and values.\n */\nexport type PartialRecord<K extends keyof any, T> = Partial<Record<K, T>>;\n\n/**\n * Makes the specified properties partial.\n */\nexport type PickPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>;\n\n/**\n * Makes all other properties than the specified partial.\n */\nexport type OmitPartial<T, K extends keyof T> = Pick<T, K> &\n  Partial<Omit<T, K>>;\n\n/**\n * The ECMAScript primitive types.\n */\nexport type Primitives =\n  | null\n  | undefined\n  | void\n  | boolean\n  | number\n  | bigint\n  | string\n  | symbol\n  | Date;\n\nexport type RecordType = object &\n  Record<keyof any, any> & {\n    [Symbol.iterator]?: never;\n    [Symbol.hasInstance]?: never;\n  };\n\n/** Simplifies the return value for functions like `get<T,Required extends boolean>(value: T, required?:Required): MaybeRequired<T,Required> => ...` */\nexport type MaybeRequired<T, Required> = If<Required, T, T | undefined>;\n\n/** Negates a Boolean value */\nexport type Not<B> = If<B, false, true>;\n\nexport type And<P1, P2> = P1 | P2 extends true ? true : false;\nexport type Or<P1, P2> = true extends P1 | P2 ? true : false;\n\nexport type All<P extends readonly any[]> = P extends []\n  ? true\n  : P extends [infer Item, ...infer Rest]\n  ? And<Item extends false ? false : true, All<Rest>>\n  : false;\n\nexport type ToBoolean<Criteria> = Criteria extends\n  | null\n  | undefined\n  | never\n  | void\n  | false\n  ? false\n  : true;\n\n/** Simplifies Boolean checks (insted of having to write B extends bla, bla...).  */\nexport type IfNot<B, True = undefined, False = never> = If<B, False, True>;\n\n/** Simplifies Boolean checks (insted of having to write B extends bla, bla...).  */\nexport type If<B, True, False = never> = ToBoolean<B> extends true\n  ? True\n  : False;\n\n/** Type 1 extends type 2 */\nexport type Extends<T1, T2> = T1 extends T2 ? true : false;\n\n/**\n * Common function type used for projection of [key,value] entries.\n */\nexport type KeyValueProjection<K, V, R> = (\n  entry: [key: K, value: V],\n  index: number\n) => R;\n\n/**\n * Shorthand for a type that is inferred from a parameter and can either be the item in an iterable, or just the type itself.\n */\nexport type IterableOrSelf<T> = IterableOrArrayLike<T> | T;\n\ntype FunctionComparisonEqualsWrapped<T> = T extends (\n  T extends {} ? infer R & {} : infer R\n)\n  ? { [P in keyof R]: R[P] }\n  : never;\n\ntype FunctionComparisonEquals<A, B> = (<\n  T\n>() => T extends FunctionComparisonEqualsWrapped<A> ? 1 : 2) extends <\n  T\n>() => T extends FunctionComparisonEqualsWrapped<B> ? 1 : 2\n  ? true\n  : false;\n\n/**\n * Tests if a type is `any`.\n */\nexport type IsAny<T> = FunctionComparisonEquals<T, any>;\n\n/**\n * Only returns the type if it is not `any`.\n */\nexport type ExcludeAny<T> = FunctionComparisonEquals<T, any> extends true\n  ? never\n  : T;\n\n/**\n * Utility type to allow `as const` to be used on tuples returned from functions without actually making them `readonly` (which is annoying).\n * Normally TypeScript considers the return value of a function like `x=>[10,\"four\"]` to be `(string|number)[]` (which is also annoying).\n */\nexport type ConstToNormal<T> = T extends readonly [...any[]]\n  ? { -readonly [P in keyof T]: ConstToNormal<T[P]> }\n  : Voidefined<T>;\n\n/**\n * Goes with {@link Nulls} to simplify the expression.\n */\nexport type ArgNulls<T, Arg> = (T | Nullish) & Arg;\n\n/**\n *  TypeScript may be very literal when it infers types. The type fo a function parameter with the value `10` may be inferred as `10` and not `number`.\n *  This is an issue in e.g. {@link reduce}.\n */\nexport type GeneralizeContstants<T> = T extends number\n  ? number\n  : T extends string\n  ? string\n  : T extends boolean\n  ? boolean\n  : T extends (...args: infer A) => infer R\n  ? (...args: GeneralizeContstants<A>) => GeneralizeContstants<R>\n  : unknown extends T\n  ? unknown\n  : {\n      [P in keyof T]: GeneralizeContstants<T[P]>;\n    };\n\n/**\n * The eclectic type found everywhere on the Internet.\n * It convers a union like `{a:1}|{b:2}` to the intersection `{a:1, b:2}`\n */\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never;\n\n/**\n * Makes a union of objects like `{a:1}&{b:2}` appear as `{a:1,b:2}` in intellisense.\n */\nexport type PrettifyIntersection<T> = T extends { [P in infer K]: any }\n  ? { [P in K]: T[P] }\n  : never;\n\ntype KeyValuePairToProperty<K, V> = K extends keyof any\n  ? { [P in K]: V }\n  : never;\n\n/**\n * Makes an array of key/value pairs to an object with the corresponding properties.\n */\nexport type KeyValuePairsToObject<T> = PrettifyIntersection<\n  T extends []\n    ? {}\n    : T extends [[infer K, infer V], ...infer Rest]\n    ? KeyValuePairToProperty<K, V> & KeyValuePairsToObject<Rest>\n    : T extends [infer K, infer V][]\n    ? UnionToIntersection<KeyValuePairToProperty<K, V>>\n    : never\n>;\n\n/**\n * Anything but a function.\n */\nexport type NotFunction =\n  | bigint\n  | boolean\n  | null\n  | number\n  | string\n  | symbol\n  | undefined\n  | {\n      [key: string | number | symbol]: any;\n      [Symbol.hasInstance]?: never;\n    };\n\ntype CreateArray<Len, Ele, Arr extends Ele[] = []> = Arr[\"length\"] extends Len\n  ? Arr\n  : CreateArray<Len, Ele, [Ele, ...Arr]>;\n\nexport type Add<A extends number, B extends number> = [\n  ...CreateArray<A, 1>,\n  ...CreateArray<B, 1>\n][\"length\"];\n\nexport type Minus<A extends number, B extends number> = CreateArray<\n  A,\n  1\n> extends [...CreateArray<B, 1>, ...infer R]\n  ? R[\"length\"]\n  : never;\n\nexport type Entries<T> = UnionToTuple<\n  {\n    [P in keyof T]: [P, T[P]];\n  } extends infer T\n    ? T[keyof T]\n    : never\n>;\n\nconst internal = Symbol();\ntype Token = typeof internal;\n\n/** Can be used to avoid infinite recursion by recognizing if a type has already been seen. Use with {@link CurrentRecursion}. */\n\nexport type RecursionKey<T, Seen> = Seen extends [Token, T, ...infer Rest]\n  ? [Token, T, T, ...Rest]\n  : [Token, T, T];\n\n/** Can be used to avoid infinite recursion by recognizing if how many times a type has already been seen. Use with {@link RecursionKey}. */\nexport type CurrentRecursion<T, Seen> = Seen extends [Token, T, ...infer Rest]\n  ? Rest[\"length\"]\n  : 0;\n\n/** Can be used to avoid infinite recursion by recognizing if how many times a type has already been seen. Use instead of `never` as the seed for seen types. */\nexport type RecursionSeed = Token;\n\n// From https://www.hacklewayne.com/typescript-convert-union-to-tuple-array-yes-but-how.\n\nexport type UnionToTuple<T> = PickOne<T> extends infer U // assign PickOne<T> to U\n  ? Exclude<T, U> extends never // T and U are the same\n    ? [T]\n    : [...UnionToTuple<Exclude<T, U>>, U] // recursion\n  : never;\n\ntype Contra<T> = T extends any ? (arg: T) => void : never;\n\ntype InferContra<T> = [T] extends [(arg: infer I) => void] ? I : never;\n\ntype PickOne<T> = InferContra<InferContra<Contra<Contra<T>>>>;\n\nexport type MaybeUndefined<T, R = T> = T extends undefined ? undefined : R;\n\n/**\n * Trick for having a function that returns a non-null value, if a formal paramter always has a non-null value,\n * simliar to .NET's [NotNullIfNotNull].\n *\n * If the actual parameter can have a null or undefined value the return value will include these options.\n *\n * `function example<T,A>(arg: (T|null|undefined)&A): string | Null<A> {...}`\n * `example(80)` returns `string`\n *  `const x: number|null; example(x)` returns `string|null`.\n *\n * There can also be a \"null\" default (so all Null'ish values maps to one value). If the function above returned `string | Null<T,undefined>`, then\n * `example(x)` returns `string|undefined`.\n */\nexport type Nulls<T, NullLevels = null | undefined> = T extends\n  | null\n  | undefined\n  | void\n  ? T extends NullLevels | void\n    ? T & NullLevels\n    : NullLevels\n  : never;\n\nexport type AllKeys<Ts> = Ts extends infer T ? keyof T : never;\n/**\n * Creates a new type where with all the properties from any of the specified types.\n * This can make life easier for code working with polymorphic types.\n */\n\nexport type CommonTypeTemplate<Ts> = {\n  [P in AllKeys<Ts>]?: Ts extends infer T\n    ? P extends keyof T\n      ? T[P]\n      : never\n    : never;\n};\n\nexport type ExpandTypes<\n  Ts,\n  Common = CommonTypeTemplate<Ts>\n> = Ts extends infer T\n  ? {\n      [P in keyof Common]: P extends keyof T ? T[P] : Common[P];\n    }\n  : never;\n\n/**\n * Typescript has the distinction between `void` and `undefined`.\n * I'm sure there is a theorically sound explanation. Both that and the distinction are annoying so this little utility type maps `void` to `undefined`.\n *\n * The ampersand union trick makes TypeScript relax instead of the \"The type T could be instantiated etc...\" error.\n */\nexport type Voidefined<T> = T extends void ? T & undefined : T;\n\n/**\n * An extension to T[] and Iterable<T> that also correctly captures weird things like NodeListOf<T>\n */\nexport type IterableOrArrayLike<T> =\n  | Iterable<T>\n  | { [item: number]: T; length: number };\n\nexport const NULL = 0;\nexport const UNDEFINED = 1;\nexport const BOOLEAN = 2;\nexport const NUMBER = 3;\nexport const BIGINT = 4;\nexport const STRING = 5;\nexport const ARRAY = 6;\nexport const OBJECT = 7;\nexport const DATE = 8;\nexport const SYMBOL = 9;\nexport const FUNCTION = 10;\nexport const ITERABLE = 11;\nexport const MAP = 12;\nexport const SET = 13;\nexport const PROMISE = 14;\n\nconst T1 = {\n  [\"n\"]: NUMBER,\n  [\"f\"]: FUNCTION,\n};\nconst T2 = {\n  [\"o\"]: BOOLEAN,\n  [\"i\"]: BIGINT,\n  [\"t\"]: STRING,\n  [\"y\"]: SYMBOL,\n};\n\nexport type TypeTester<T> = (value: any) => value is T;\nexport type TypeConverter<T> = (value: any, parse?: boolean) => T | undefined;\n\nexport const undefined = void 0;\nexport const nil = null;\n\n/** Caching this value potentially speeds up tests rather than using `Number.MAX_SAFE_INTEGER`. */\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/** Using this cached value speeds up testing if an object is iterable seemingly by an order of magnitude. */\nexport const symbolIterator = Symbol.iterator;\n\n/** Fast way to check for precence of function argument. */\nexport const NO_ARG = Symbol();\n\nconst createConverter =\n  <T>(typeTester: TypeTester<T>, parser?: (value: any) => T | undefined) =>\n  (value: any, parse = true) =>\n    typeTester(value)\n      ? value\n      : parser && parse && isDefined((value = parser(value)))\n      ? value\n      : undefined;\n\nexport const tryCatch = <T, C = undefined>(\n  expression: () => T,\n  errorHandler: boolean | ((error: any) => C) = true as any,\n  clean?: () => void\n): T | C => {\n  try {\n    return expression();\n  } catch (e) {\n    if (!isBoolean(errorHandler)) {\n      return errorHandler?.(e) as any;\n    }\n    if (errorHandler) {\n      throw e;\n    }\n    console.error(e);\n    return undefined as any;\n  } finally {\n    clean?.();\n  }\n};\n\nexport const tryCatchAsync = async <T, C = void>(\n  expression: () => PromiseLike<T> | T,\n  errorHandler:\n    | boolean\n    | ((error: any, last: boolean) => Promise<C> | C) = true as any,\n  clean?: () => void,\n  retries = 1\n): Promise<T | C> => {\n  while (retries--) {\n    try {\n      return await expression();\n    } catch (e) {\n      if (!isBoolean(errorHandler)) {\n        (await errorHandler(e, !retries)) as any;\n      } else if (errorHandler && !retries) {\n        throw e;\n      } else {\n        console.error(e);\n      }\n    } finally {\n      clean?.();\n    }\n  }\n  return undefined as any;\n};\n\nexport const as = <T, D = undefined, Args extends any[] = []>(\n  value: any,\n  converter: (value: any, ...rest: Args) => T | undefined,\n  defaultValue?: D,\n  ...args: Args\n): T | D => ((value = converter(value, ...args)) ?? defaultValue) as any;\n\nexport const cast = <T, V, Args extends any[] = []>(\n  value: V,\n  typeTest: (value: any, ...args: Args) => value is T,\n  ...args: Args\n): V extends T ? V : undefined =>\n  typeTest(value, ...args) ? (value as any) : undefined;\n\nexport const isNull = (value: any): value is null => value === nil;\n\nexport const isUndefined = (value: any): value is undefined | void =>\n  value === undefined;\n\nexport const isDefined = <T>(value: T): value is Defined<T> =>\n  value !== undefined;\n\nexport const isNullish = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value == nil;\n\nexport const hasValue = <T>(\n  value: T\n): value is Exclude<T, undefined | void | null> => value != nil;\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\";\n\nexport const parseBoolean = createConverter(isBoolean, (value) => !!value);\nexport const isTruish = (value: any) => !!value;\n\nexport type Falsish = void | null | undefined | 0 | \"\" | false;\n\nexport const isFalsish = (value: any): value is Falsish => !value;\n\nexport const isInteger: (value: any) => value is number =\n  Number.isSafeInteger as any;\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\";\nexport const parseNumber = createConverter(isNumber, (value) =>\n  parseFloat(value)\n);\n\nexport const isBigInt = (value: any): value is bigint =>\n  typeof value === \"bigint\";\nexport const parseBigInt = createConverter(isBigInt, (value) =>\n  tryCatch(() => BigInt(value))\n);\n\nexport const isString = (value: any): value is string =>\n  typeof value === \"string\";\n\nexport const toString = createConverter(isString, (value) =>\n  hasValue(value) ? \"\" + value : value\n);\n\nexport const isArray: (value: any) => value is readonly any[] = Array.isArray;\n\n/**\n * Returns the value as an array following these rules:\n * - If the value is undefined (this does not include `null`), so is the return value.\n * - If the value is already an array its original value is returned unless `clone` is true. In that case a copy of the value is returned.\n * - If the value is iterable, an array containing its values is returned\n * - Otherwise, an array with the value as its single item is returned.\n */\nexport const toArray = <T>(\n  value: T | Iterable<T>,\n  clone = false\n): T extends undefined ? undefined : T[] =>\n  isUndefined(value)\n    ? undefined\n    : !clone && isArray(value)\n    ? value\n    : isIterable(value)\n    ? [...value]\n    : ([value] as any);\n\nexport const isObject = <AcceptIterables extends boolean = false>(\n  value: any,\n  acceptIterables: AcceptIterables = false as any\n): value is AcceptIterables extends true\n  ? object & (Record<keyof any, any> | Iterable<any>)\n  : object & Record<keyof any, any> & { [Symbol.iterator]?: never } =>\n  value != null &&\n  typeof value === \"object\" &&\n  (acceptIterables || !value[symbolIterator]);\n\nexport const hasMethod = <T, Name extends keyof any>(\n  value: T | unknown,\n  name: Name | keyof T\n): value is {\n  [P in keyof T]: P extends Name\n    ? T extends { [P in Name]?: (...args: infer Args) => infer R }\n      ? Args extends unknown\n        ? (...args: any) => any\n        : (...args: Args) => R\n      : (...args: any) => any\n    : T[P];\n} => typeof (value as any)?.[name] === \"function\";\n\nexport const isDate = (value: any): value is Date => value instanceof Date;\nexport const parseDate = createConverter(isDate, (value) =>\n  isNaN((value = Date.parse(value))) ? undefined : value\n);\n\nexport const isSymbol = (value: any): value is symbol =>\n  typeof value === \"symbol\";\n\nexport const isFunction = (value: any): value is (...args: any) => any =>\n  typeof value === \"function\";\n\nexport const isIterable = (\n  value: any,\n  acceptStrings = false\n): value is Iterable<any> =>\n  value?.[symbolIterator] && (typeof value === \"object\" || acceptStrings);\n\nexport const toIterable = <T>(value: T | Iterable<T>): Iterable<T> =>\n  isIterable(value) ? value : [value];\n\nexport const isMap = (value: any): value is Map<any, any> =>\n  value instanceof Map;\n\nexport const isSet = (value: any): value is Set<any> => value instanceof Set;\n\nexport const isAwaitable = (value: any): value is Promise<any> => !!value?.then;\n\nexport const typeCode = (value: any, typeName = typeof value) =>\n  value == nil\n    ? value === nil\n      ? NULL\n      : UNDEFINED\n    : T1[typeName[0]] ??\n      T2[typeName[1]] ??\n      (Array.isArray(value) ? ARRAY : value instanceof Date ? DATE : OBJECT);\n\nexport const identity = <T = any>(value: T) => value;\n\nexport const clone = <T>(value: T, depth: number | boolean = true): T =>\n  isObject(value, true)\n    ? isArray(value)\n      ? depth\n        ? value.map((value) => clone(value, depth === true || --(depth as any)))\n        : [...value]\n      : isSet(value)\n      ? new Set<any>(\n          depth\n            ? (map as any)(value, (value: any) =>\n                clone(value, depth === true || --(depth as any))\n              )\n            : value\n        )\n      : isMap(value)\n      ? new Map<any, any>(\n          depth\n            ? (map as any)(value, (value: any) =>\n                // Does not clone keys.\n                [value[0], clone(value[1], depth === true || --(depth as any))]\n              )\n            : value\n        )\n      : depth\n      ? obj(\n          map(value as any, ([k, v]) => [\n            k,\n            clone(v, depth === true || --(depth as any)),\n          ])!\n        )\n      : { ...value }\n    : (value as any);\n\n/**\n * Evaluates a function that can be used to capture values using parameter default values.\n *\n * For example `(previous=current)=>(current+=2, previous)\n */\nexport const capture = <R>(capture: (...args: any[]) => R) => capture();\n\ntype ErrorGenerator = string | Error | (() => string | Error);\n\nexport const throwError = <T = any>(\n  error: ErrorGenerator,\n  transform: (string: string) => Error = (message) => new TypeError(message)\n): T => {\n  throw isString((error = unwrap(error))) ? transform(error) : error;\n};\n\ntype CombineTypeTests<T> = T extends []\n  ? {}\n  : T extends [infer F, ...infer Rest]\n  ? F extends (value: any) => value is infer R\n    ? (IsAny<R> extends true ? T : R) & CombineTypeTests<Rest>\n    : never\n  : never;\n\nexport const validate = <\n  T,\n  Validator extends\n    | ((candidate: T) => candidate is any)\n    | ((candiate: T) => R)\n    | [\n        validate: (candiate: T) => any,\n        ...typeTests: ((candidate: T) => candidate is any)[]\n      ]\n    | (R & NotFunction),\n  R\n>(\n  value: T,\n  validate: Validator | R,\n  validationError?: ErrorGenerator,\n  undefinedError?: ErrorGenerator\n): Defined<\n  Validator extends [any, ...infer TypeTests]\n    ? CombineTypeTests<TypeTests>\n    : Validator extends ((value: any) => infer R) | infer R\n    ? R extends Falsish\n      ? never\n      : Validator extends (value: any) => value is infer R\n      ? IsAny<R> extends true\n        ? T\n        : Defined<R>\n      : T\n    : never\n> =>\n  (\n    isArray(validate)\n      ? validate.every((test) => test(value))\n      : isFunction(validate)\n      ? validate(value)\n      : validate\n  )\n    ? value\n    : required(value, undefinedError ?? validationError) &&\n      (throwError(validationError ?? \"Validation failed.\") as any);\n\nexport class InvariantViolatedError extends Error {\n  constructor(invariant?: string) {\n    super(invariant ? \"INV: \" + invariant : \"An invariant was violated.\");\n  }\n}\n\n/**\n * States an invariant.\n */\nexport const invariant = <T>(\n  test: Wrapped<T | false>,\n  description?: string\n): Defined<T> => {\n  const valid = unwrap(test);\n  return isDefined(valid) && valid !== false\n    ? (valid as any)\n    : throwError(new InvariantViolatedError(description));\n};\n\nexport const required = <T>(value: T, error?: ErrorGenerator): Defined<T> =>\n  isDefined(value)\n    ? value\n    : throwError(\n        error ?? \"A required value is missing\",\n        (text) => new TypeError(text.replace(\"...\", \" is required.\"))\n      );\n"]}