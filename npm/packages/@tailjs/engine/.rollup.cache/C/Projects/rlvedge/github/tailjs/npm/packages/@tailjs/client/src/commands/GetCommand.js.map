{"version":3,"file":"GetCommand.js","sourceRoot":"","sources":["GetCommand.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,MAAM,UAAU,CAAC;AAuCvC,MAAM,CAAC,MAAM,YAAY,GAAG,WAAW,CAAa,KAAK,CAAC,CAAC","sourcesContent":["import type { ReservedVariables, Tracker } from \"..\";\nimport { commandTest } from \"./shared\";\n\n/** Used to get a context variable from the tracker. This is async, so if a key is anticipated to eventually be set, the callback will wait for it if does not already have a value.\n * This command can also be used for polling by returning `true` from the callback in which case it will be called everytime the value is set (not necessarily with a changed value).\n *\n */\nexport interface GetCommand {\n  /**\n   * If the functions returns true it will be triggered again if the value changes.\n   */\n  get: Record<string, GetCallback> & {\n    [key in keyof ReservedVariables]?: GetCallback<ReservedVariables[key]>;\n  };\n  /**\n   * If no one has set the value after this amount of ms, the callback will be triggered with `undefined` as the value and a flag indicating that the request timed out.\n   * If set to zero the callback will always be called synchronously with either the value or undefined if it is not defined.\n   * Negative values means \"no timeout\".\n   */\n  timeout?: number;\n}\n\n/**\n * The callback that is called for {@link GetCommand}s when a tracker variable is set or changed.\n * To enable/simplify polling the callback gets triggered again next time the variable changes if it returns `true`.\n */\nexport type GetCallback<T = any> = (\n  /** The current value of the variable in the tracker. */\n  value: T | undefined,\n\n  /** The key for which the callback is registered.  */\n  key: string,\n\n  /** Whether the callback is called with an undefined value because the timeout elapsed. */\n  timeout: boolean,\n\n  /** The tracker where the variable was set. */\n  tracker: Tracker\n) => any | true;\n\nexport const isGetCommand = commandTest<GetCommand>(\"get\");\n"]}