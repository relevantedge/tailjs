{"version":3,"file":"InMemoryStorage.js","sourceRoot":"","sources":["InMemoryStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n  DataPurposes,\r\n  Variable,\r\n  VariableFilter,\r\n  VariableGetter,\r\n  VariableHeader,\r\n  VariableKey,\r\n  VariableQueryOptions,\r\n  VariableQueryResult,\r\n  VariableScope,\r\n  VariableScopeValue,\r\n  VariableSetResult,\r\n  VariableSetStatus,\r\n  VariableSetter,\r\n  VersionedVariableKey,\r\n  dataClassification,\r\n  dataPurposes,\r\n  isVariablePatch,\r\n  toStrict,\r\n  variableScope,\r\n} from \"@tailjs/types\";\r\nimport {\r\n  Clock,\r\n  MaybePromise,\r\n  clock,\r\n  forEach,\r\n  isDefined,\r\n  isUndefined,\r\n  map,\r\n  now,\r\n  some,\r\n} from \"@tailjs/util\";\r\nimport { applyPatchOffline, copy, parseKey, variableId } from \"../lib\";\r\n\r\nimport {\r\n  VariableGetResult,\r\n  VariableGetResults,\r\n  VariableSetResults,\r\n  VariableStorage,\r\n  VariableStorageContext,\r\n} from \"..\";\r\n\r\nexport type ScopeVariables = [\r\n  expires: number | undefined,\r\n  Map<string, Variable<any, true>>\r\n];\r\n\r\nexport const hasChanged = (\r\n  getter: VersionedVariableKey,\r\n  current: Variable | undefined\r\n) => isUndefined(getter.version) || current?.version !== getter.version;\r\n\r\nexport abstract class InMemoryStorageBase implements VariableStorage {\r\n  private _ttl: Partial<Record<VariableScope, number>> | undefined;\r\n  private _cleaner: Clock | undefined;\r\n\r\n  /** For testing purposes to have the router apply the patches. @internal */\r\n  public _testDisablePatch: boolean;\r\n\r\n  constructor() {}\r\n\r\n  /** If this method return `undefined`, the variable in question will not be updated. */\r\n  protected abstract _getNextVersion(\r\n    variable: Variable<any, true>\r\n  ): string | undefined;\r\n\r\n  protected abstract _getScopeValues(\r\n    scope: VariableScope,\r\n    targetId: string | undefined,\r\n    require: boolean\r\n  ): ScopeVariables | undefined;\r\n\r\n  protected abstract _resetScope(scope: VariableScope): void;\r\n\r\n  protected abstract _deleteTarget(\r\n    scope: VariableScope,\r\n    targetId: string\r\n  ): void;\r\n\r\n  protected abstract _getTargetsInScope(\r\n    scope: VariableScope\r\n  ): Iterable<[string, ScopeVariables]>;\r\n\r\n  private _remove(variable: VariableKey<true>, timestamp?: number) {\r\n    const values = this._getScopeValues(\r\n      variable.scope,\r\n      variable.targetId,\r\n      false\r\n    );\r\n    if (values?.[1].has(variable.key)) {\r\n      const ttl = this._ttl?.[variable.scope];\r\n      values[0] = ttl ? (timestamp ?? now()) + ttl : undefined;\r\n      values[1].delete(variable.key);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private _update(variable: Variable<any, true>, timestamp?: number) {\r\n    let scopeValues = this._getScopeValues(\r\n      variable.scope,\r\n      variable.targetId,\r\n      true\r\n    )!;\r\n\r\n    variable = toStrict(variable);\r\n\r\n    const ttl = this._ttl?.[variable.scope];\r\n    scopeValues[0] = ttl ? (timestamp ?? now()) + ttl : undefined;\r\n    scopeValues[1].set(variable.key, variable);\r\n\r\n    return variable;\r\n  }\r\n\r\n  private _validateKey<T extends VariableKey<true> | null | undefined>(\r\n    key: T\r\n  ): T {\r\n    if (key && key.scope !== VariableScope.Global && !key.targetId) {\r\n      throw new TypeError(`Target ID is required for non-global scopes.`);\r\n    }\r\n    return key;\r\n  }\r\n\r\n  private _query(\r\n    filters: VariableFilter[],\r\n    settings?: VariableQueryOptions\r\n  ): Variable<any, true>[] {\r\n    const results = new Set<Variable<any, true>>();\r\n    const timestamp = now();\r\n\r\n    const ifNoneMatch = settings?.ifNoneMatch\r\n      ? new Map(\r\n          settings.ifNoneMatch.map((variable) => [\r\n            variableId(variable),\r\n            variable.version,\r\n          ])\r\n        )\r\n      : null;\r\n\r\n    const ifModifiedSince = settings?.ifModifiedSince ?? 0;\r\n\r\n    for (const queryFilter of filters) {\r\n      const match = (\r\n        variable: Variable<any, true> | undefined\r\n      ): variable is Variable<any, true> => {\r\n        const { purposes, classification, tags } = queryFilter;\r\n        if (\r\n          !variable ||\r\n          (variable.purposes &&\r\n            purposes &&\r\n            !(variable.purposes & dataPurposes(purposes))) ||\r\n          (classification &&\r\n            (variable.classification <\r\n              dataClassification(classification.min)! ||\r\n              variable.classification >\r\n                dataClassification(classification.max)! ||\r\n              classification.levels?.some(\r\n                (level) => variable.classification === dataClassification(level)\r\n              ) === false)) ||\r\n          (tags &&\r\n            (!variable.tags ||\r\n              !tags.some((tags) =>\r\n                tags.every((tag) => variable.tags!.includes(tag))\r\n              )))\r\n        ) {\r\n          return false;\r\n        }\r\n\r\n        let matchVersion: string | undefined;\r\n        if (\r\n          (ifModifiedSince && variable.modified! < ifModifiedSince!) ||\r\n          (isDefined((matchVersion = ifNoneMatch?.get(variableId(variable)))) &&\r\n            variable.version === matchVersion)\r\n        ) {\r\n          // Skip the variable because it is too old or unchanged based on the settings provided for the query.\r\n          return false;\r\n        }\r\n\r\n        return true;\r\n      };\r\n      for (const scope of map(queryFilter.scopes, variableScope) ??\r\n        variableScope.values) {\r\n        for (const [, scopeVars] of queryFilter.targetIds?.map(\r\n          (targetId) =>\r\n            [targetId, this._getScopeValues(scope, targetId, false)] as const\r\n        ) ?? this._getTargetsInScope(scope)) {\r\n          if (!scopeVars || scopeVars[0]! <= timestamp) continue;\r\n          const vars = scopeVars[1];\r\n          let nots: Set<string> | undefined = undefined;\r\n          const mappedKeys =\r\n            queryFilter.keys?.map((key) => {\r\n              // Find keys that starts with `!` to exclude them from the results.\r\n              const parsed = parseKey(key);\r\n              if (parsed.not) {\r\n                (nots ??= new Set()).add(parsed.sourceKey);\r\n              }\r\n              return parsed.key;\r\n            }) ?? vars.keys();\r\n\r\n          for (const key of mappedKeys.includes(\"*\")\r\n            ? vars.keys()\r\n            : mappedKeys) {\r\n            if (nots!?.has(key)) continue;\r\n\r\n            const value = vars.get(key);\r\n            if (match(value)) {\r\n              results.add(value);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return [...results];\r\n  }\r\n\r\n  public clean() {\r\n    const timestamp = now();\r\n    forEach(this._ttl, ([scope, ttl]) => {\r\n      if (isUndefined(ttl)) return;\r\n\r\n      const variables = this._getTargetsInScope(scope);\r\n      forEach(\r\n        variables,\r\n        ([targetId, variables]) =>\r\n          variables[0]! <= timestamp - ttl &&\r\n          this._deleteTarget(scope, targetId)\r\n      );\r\n    });\r\n  }\r\n\r\n  public renew(\r\n    scope: VariableScope,\r\n    targetIds: string[],\r\n    context?: VariableStorageContext\r\n  ) {\r\n    const timestamp = now();\r\n\r\n    const ttl = this._ttl?.[scope];\r\n    if (!ttl) return;\r\n\r\n    for (const targetId of targetIds) {\r\n      const vars = this._getScopeValues(scope, targetId, false);\r\n      if (vars) {\r\n        vars[0] = timestamp;\r\n      }\r\n    }\r\n  }\r\n\r\n  public configureScopeDurations(\r\n    durations: Partial<Record<VariableScopeValue<false>, number>>,\r\n    context?: VariableStorageContext\r\n  ): MaybePromise<void> {\r\n    this._ttl ??= {};\r\n    for (const [scope, duration] of Object.entries(durations).map(\r\n      ([scope, duration]) => [variableScope(scope), duration]\r\n    )) {\r\n      duration! > 0 ? (this._ttl![scope] = duration) : delete this._ttl![scope];\r\n    }\r\n\r\n    let hasTtl = some(this._ttl, ([, ttl]) => ttl! > 0);\r\n    if (this._cleaner || hasTtl) {\r\n      (this._cleaner ??= clock({\r\n        callback: () => this.clean(),\r\n        frequency: 10000,\r\n      })).toggle(hasTtl);\r\n    }\r\n  }\r\n\r\n  private _applyGetFilters(\r\n    getter: VariableGetter<any, true>,\r\n    variable: Variable<any, true> | undefined\r\n  ) {\r\n    return !variable ||\r\n      (getter.purpose && // The variable has explicit purposes and not the one requested.\r\n        isDefined(variable.purposes) &&\r\n        !(variable.purposes & getter.purpose))\r\n      ? undefined\r\n      : isDefined(getter.version) && variable?.version == getter.version\r\n      ? variable\r\n      : copy(variable);\r\n  }\r\n\r\n  public async get<\r\n    K extends (VariableGetter<any, boolean> | null | undefined)[]\r\n  >(\r\n    getters: K,\r\n    context?: VariableStorageContext\r\n  ): Promise<VariableGetResults<K>> {\r\n    const results = getters.map(toStrict).map((getter) => ({\r\n      current: (getter = this._validateKey(getter))\r\n        ? (this._applyGetFilters(\r\n            getter,\r\n            this._getScopeValues(getter.scope, getter.targetId, false)?.[1].get(\r\n              getter.key\r\n            )\r\n          ) as VariableGetResult<any>)\r\n        : undefined,\r\n      getter,\r\n    }));\r\n\r\n    for (const item of results) {\r\n      if (item.getter?.initializer && !isDefined(item[0])) {\r\n        const initialValue = await item.getter.initializer();\r\n        if (initialValue) {\r\n          // Check if the variable has been created by someone else while the initializer was running.\r\n          const current = this._getScopeValues(\r\n            item.getter.scope,\r\n            item.getter.targetId,\r\n            false\r\n          )?.[1].get(item.getter.key);\r\n          if (!current) {\r\n            item.current = copy(this._update({ ...item[1], ...initialValue }));\r\n            item.current.initialized = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return results.map((item) => {\r\n      const variable = copy(item.current);\r\n      if (\r\n        variable &&\r\n        item.getter?.version &&\r\n        item.getter?.version === item.current?.version\r\n      ) {\r\n        variable.unchanged = true;\r\n      }\r\n      return variable;\r\n    }) as VariableGetResults<K>;\r\n  }\r\n\r\n  public head(\r\n    filters: VariableFilter[],\r\n    options?: VariableQueryOptions | undefined,\r\n    context?: VariableStorageContext\r\n  ) {\r\n    return this.query(filters, options);\r\n  }\r\n\r\n  public query(\r\n    filters: VariableFilter[],\r\n    options?: VariableQueryOptions,\r\n    context?: VariableStorageContext\r\n  ) {\r\n    const results = this._query(filters, options);\r\n    return {\r\n      count: options?.count ? results.length : undefined,\r\n      // This current implementation does not bother with cursors. If one is requested we just return all results. Boom.\r\n      results: (options?.top && !options?.cursor?.include\r\n        ? results.slice(options.top)\r\n        : results\r\n      ).map((variable) => copy(variable)),\r\n    };\r\n  }\r\n\r\n  public set<Setters extends (VariableSetter<any> | null | undefined)[]>(\r\n    variables: Setters & VariableSetter<any>[],\r\n    context?: VariableStorageContext\r\n  ): VariableSetResults<Setters> {\r\n    const timestamp = now();\r\n    const results: (VariableSetResult | undefined)[] = [];\r\n    for (const source of variables.map(toStrict)) {\r\n      this._validateKey(source);\r\n\r\n      if (!source) {\r\n        results.push(undefined);\r\n        continue;\r\n      }\r\n\r\n      let {\r\n        key,\r\n        targetId,\r\n        scope,\r\n        classification,\r\n        purposes,\r\n        value,\r\n        version,\r\n        tags,\r\n      } = source as Variable<any, true>;\r\n\r\n      let scopeVars = this._getScopeValues(\r\n        source.scope,\r\n        source.targetId,\r\n        false\r\n      );\r\n      if (scopeVars?.[0]! < timestamp) {\r\n        scopeVars = undefined;\r\n      }\r\n      let current = scopeVars?.[1].get(key);\r\n\r\n      if (isVariablePatch(source)) {\r\n        if (this._testDisablePatch) {\r\n          results.push({ status: VariableSetStatus.Unsupported, source });\r\n          continue;\r\n        }\r\n\r\n        const patched = toStrict(applyPatchOffline(current, source));\r\n\r\n        if (!isDefined(patched)) {\r\n          results.push({\r\n            status: VariableSetStatus.Unchanged,\r\n            source,\r\n            current: copy(current),\r\n          });\r\n          continue;\r\n        }\r\n        classification = patched.classification!;\r\n        purposes = patched.purposes;\r\n        value = patched.value;\r\n      } else if (current?.version !== version) {\r\n        results.push({\r\n          status: VariableSetStatus.Conflict,\r\n          source,\r\n          current: copy(current),\r\n        });\r\n        continue;\r\n      }\r\n\r\n      if (isUndefined(value)) {\r\n        results.push({\r\n          status:\r\n            current && this._remove(current)\r\n              ? VariableSetStatus.Success\r\n              : VariableSetStatus.Unchanged,\r\n          source,\r\n          current: undefined,\r\n        });\r\n        continue;\r\n      }\r\n\r\n      const nextValue: Variable<any, true> = {\r\n        key,\r\n        value,\r\n        classification,\r\n        targetId,\r\n        scope,\r\n        purposes:\r\n          isDefined(current?.purposes) || purposes\r\n            ? (current?.purposes ?? 0) | (purposes ?? 0)\r\n            : DataPurposes.Necessary,\r\n        tags: tags && [...tags],\r\n      };\r\n\r\n      nextValue.version = this._getNextVersion(nextValue);\r\n      current = this._update(nextValue, timestamp);\r\n\r\n      results.push(\r\n        current\r\n          ? {\r\n              status: VariableSetStatus.Success,\r\n              source,\r\n              current,\r\n            }\r\n          : { status: VariableSetStatus.Denied, source }\r\n      );\r\n    }\r\n\r\n    return results as VariableSetResults<Setters>;\r\n  }\r\n\r\n  public purge(filters: VariableFilter[], context?: VariableStorageContext) {\r\n    for (const variable of this._query(filters)) {\r\n      this._remove(variable);\r\n    }\r\n  }\r\n}\r\n\r\nexport class InMemoryStorage extends InMemoryStorageBase {\r\n  private readonly _variables: Map<string, ScopeVariables>[] =\r\n    variableScope.values.map(() => new Map());\r\n\r\n  private _nextVersion = 0;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  protected _getNextVersion(key: VariableKey) {\r\n    return \"\" + ++this._nextVersion;\r\n  }\r\n\r\n  protected _getScopeValues(\r\n    scope: VariableScope,\r\n    targetId: string | undefined,\r\n    require: boolean\r\n  ) {\r\n    let values = this._variables[scope].get(targetId ?? \"\");\r\n    if (!values && require) {\r\n      this._variables[scope].set(\r\n        targetId ?? \"\",\r\n        (values = [undefined, new Map()])\r\n      );\r\n    }\r\n    return values;\r\n  }\r\n\r\n  protected _resetScope(scope: VariableScope): void {\r\n    this._variables[scope].clear();\r\n  }\r\n\r\n  protected _deleteTarget(scope: VariableScope, targetId: string): void {\r\n    this._variables[scope].delete(targetId);\r\n  }\r\n\r\n  protected _getTargetsInScope(\r\n    scope: VariableScope\r\n  ): Iterable<[string, ScopeVariables]> {\r\n    return this._variables[scope];\r\n  }\r\n}\r\n"]}