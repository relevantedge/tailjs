{"version":3,"file":"concurrency.js","sourceRoot":"","sources":["concurrency.ts"],"names":[],"mappings":"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","sourcesContent":["import { isDefined, isFunction } from \".\";\n\nexport type Lock<D = any> = {\n  <T = void>(action: () => Promise<T> | T): Promise<T>;\n  <T = void>(action: () => Promise<T> | T, waitTimeout: number): Promise<\n    [value: T | undefined, acquired: boolean]\n  >;\n  data: {\n    get(): D | undefined;\n    update<Undefined extends undefined | never = never>(\n      newValue: (current: D | undefined) => D | Undefined\n    ): D | Undefined;\n  };\n};\n\nexport class ResetablePromise<T = void, E = any> implements PromiseLike<T> {\n  private _promise: OpenPromise<T>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public get value() {\n    return this._promise.value;\n  }\n  public get error() {\n    return this._promise.error;\n  }\n  public get pending() {\n    return this._promise.pending;\n  }\n\n  public resolve(value: T, ifPending = false) {\n    this._promise.resolve(value, ifPending);\n    return this;\n  }\n\n  public reject(value?: E, ifPending = false) {\n    this._promise.reject(value, ifPending);\n    return this;\n  }\n\n  public reset() {\n    this._promise = new OpenPromise<T>();\n    return this;\n  }\n\n  public signal(value: T) {\n    this.resolve(value);\n    this.reset();\n    return this;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): PromiseLike<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport class OpenPromise<T = void, E = any> implements PromiseLike<T> {\n  private readonly _promise: Promise<T>;\n\n  public readonly resolve: (value: T, ifPending?: boolean) => this;\n  public readonly reject: (reason: E | undefined, ifPending?: boolean) => this;\n  public readonly value: (T extends void ? true : T) | undefined;\n  public readonly error: E | true;\n  public pending = true;\n\n  constructor() {\n    let captured: any[];\n    this._promise = new Promise((...args: any[]) => {\n      captured = args.map((inner, i) => (value: any, ifPending: boolean) => {\n        if (!this.pending) {\n          if (ifPending) return this;\n          throw new TypeError(\"Promise already resolved/rejected.\");\n        }\n\n        (this as any).pending = false;\n        (this as any)[i ? \"error\" : \"value\"] = !isDefined(value) || value;\n        inner(value);\n        return this;\n      });\n    });\n\n    [this.resolve, this.reject] = captured!;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | null\n      | undefined,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | null\n      | undefined\n  ): Promise<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled, onrejected);\n  }\n}\n\nexport const delay = <T = void>(ms: number, action?: () => T): Promise<T> =>\n  new Promise<T>((resolve) => setTimeout(() => resolve(action?.() as T), ms));\n\nexport const promise = <T = void, Resetable extends boolean = false>(\n  resetable?: Resetable\n): Resetable extends true ? ResetablePromise<T> : OpenPromise<T> =>\n  resetable ? new ResetablePromise<T>() : (new OpenPromise<T>() as any);\n\ntype UnwrapPromiseArg<T> = T extends () => infer T ? Awaited<T> : Awaited<T>;\n\ntype UnwrapPromiseArgs<T extends any[]> = T extends [infer Arg]\n  ? [UnwrapPromiseArg<Arg>]\n  : T extends [infer Arg, ...infer Rest]\n  ? [UnwrapPromiseArg<Arg>, ...UnwrapPromiseArgs<Rest>]\n  : [];\n\nexport type AsyncValue<T> =\n  | T\n  | PromiseLike<T>\n  | (() => T)\n  | (() => PromiseLike<T>);\n\nexport const waitAll = <Args extends AsyncValue<any>[]>(\n  args: Args\n): Promise<UnwrapPromiseArgs<Args>> =>\n  Promise.all(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n\nexport const race = <Args extends AsyncValue<any>[]>(\n  args: Args\n): Promise<UnwrapPromiseArgs<Args>[number]> =>\n  Promise.race(args.map((arg) => (isFunction(arg) ? arg() : arg))) as any;\n"]}