{"version":3,"file":"parseEventTypes.js","sourceRoot":"","sources":["parseEventTypes.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,yBAAyB,EACzB,OAAO,EACP,QAAQ,EACR,UAAU,GACX,MAAM,cAAc,CAAC;AACtB,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AACxC,OAAO,EAAE,yBAAyB,EAAE,MAAM,6BAA6B,CAAC;AAGxE,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,OAAwB,EAAE,EAAE;IAC1D,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC;IAChC,IAAI,CAAC,IAAI,EAAE,CAAC;QACV,OAAO;IACT,CAAC;IAED,6GAA6G;IAC7G,mHAAmH;IACnH,EAAE;IACF,gBAAgB;IAChB,0EAA0E;IAC1E,qDAAqD;IACrD,EAAE;IACF,+EAA+E;IAE/E,OAAO,CACL,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE,UAAU,CAAC,EACrE,CAAC,SAAS,EAAE,EAAE,CACZ,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC,IAAI,EAAE,WAAW,CAAC,EAAE,EAAE;QACzC,IAAI,CAAC,yBAAyB,CAAC,WAAW,EAAE,OAAO,CAAC,EAAE,CAAC;YACrD,UAAU,CAAC,kDAAkD,CAAC,CAAC;QACjE,CAAC;QAED,IAAI,WAAW,CAAC,IAAI,KAAK,WAAW,CAAC,KAAK,EAAE,CAAC;YAC3C,MAAM,KAAK,GAAU,CAAC,WAAW,CAAC,KAAK,KAAK,EAAE,CAAC,CAAC;YAChD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,EAAE,IAAI,KAAK,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC5D,KAAK,CAAC,OAAO,CAAC,EAAE,IAAI,EAAE,WAAW,CAAC,KAAK,EAAE,CAAC,CAAC;YAC7C,CAAC;QACH,CAAC;QAED,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,EAAE,CAAC;YAClC,CAAC,WAAW,CAAC,UAAU,KAAK,EAAE,CAAC,CAAC,IAAI,GAAG;gBACrC,KAAK,EAAE,yBAAyB,CAC9B,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,EAC1B,OAAO,CACR;aACF,CAAC;QACJ,CAAC;aAAM,IACL,QAAQ,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,EAAE,KAAK,CAAC;YAC7C,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,EACnD,CAAC;YACD,UAAU,CACR,yIAAyI,CAC1I,CAAC;QACJ,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC;IAC3B,CAAC,CAAC,CACL,CAAC;IAEF,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtB,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC;AACxB,CAAC,CAAC","sourcesContent":["import {\r\n  changeIdentifierCaseStyle,\r\n  forEach,\r\n  isString,\r\n  throwError,\r\n} from \"@tailjs/util\";\r\nimport { systemTypes } from \"../consts\";\r\nimport { tryParseObjectComposition } from \"./tryParseObjectComposition\";\r\nimport { TraverseContext } from \"./types\";\r\n\r\nexport const parseEventTypes = (context: TraverseContext) => {\r\n  const defs = context.node.$defs;\r\n  if (!defs) {\r\n    return;\r\n  }\r\n\r\n  // Events can be defined either as a type/class named `Events` with the individual event types as properties.\r\n  // Alternatively, events can be defined in a nested schema called `events` with the event types defined as `$defs`.\r\n  //\r\n  // Specifically:\r\n  // `#/$defs/Events: {type: \"object\", properties: {Type1: ..., Type2: ...}}\r\n  // `#/$defs/events: {$defs: {Type1: ..., Type2: ...}}\r\n  //\r\n  // The event type names will be the kebab_cased equivalent of their type names.\r\n\r\n  forEach(\r\n    [defs.events?.$defs ?? defs.Events?.$defs ?? defs.Events?.properties],\r\n    (eventDefs) =>\r\n      forEach(eventDefs, ([name, eventSchema]) => {\r\n        if (!tryParseObjectComposition(eventSchema, context)) {\r\n          throwError(\"All event type definitions must be object types.\");\r\n        }\r\n\r\n        if (eventSchema.$ref !== systemTypes.event) {\r\n          const allOf: any[] = (eventSchema.allOf ??= []);\r\n          if (!allOf.some((item) => item?.$ref === systemTypes.event)) {\r\n            allOf.unshift({ $ref: systemTypes.event });\r\n          }\r\n        }\r\n\r\n        if (!eventSchema.properties?.type) {\r\n          (eventSchema.properties ??= {}).type = {\r\n            const: changeIdentifierCaseStyle(\r\n              name.replace(/Event$/, \"\"),\r\n              \"kebab\"\r\n            ),\r\n          };\r\n        } else if (\r\n          isString(eventSchema.properties?.type?.const) ||\r\n          !eventSchema.properties?.type?.enum.every(isString)\r\n        ) {\r\n          throwError(\r\n            \"When a type property is explicitly specified on an implicit event type, it must be either a string const or an enum with string values.\"\r\n          );\r\n        }\r\n\r\n        defs[name] = eventSchema;\r\n      })\r\n  );\r\n\r\n  delete defs[\"Events\"];\r\n  delete defs[\"events\"];\r\n};\r\n"]}