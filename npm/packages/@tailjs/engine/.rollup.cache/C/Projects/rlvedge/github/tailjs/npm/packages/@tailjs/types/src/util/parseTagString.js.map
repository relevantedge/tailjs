{"version":3,"file":"parseTagString.js","sourceRoot":"","sources":["parseTagString.ts"],"names":[],"mappings":"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","sourcesContent":["export type ParsedTag = { ranks: string[]; value?: string };\n\nconst splitRanks = (ranks?: string) =>\n  ranks\n    ?.toLowerCase()\n    .replace(/[^a-zA-Z0-9:.-]/g, \"_\")\n    .split(\":\")\n    .filter((rank) => rank) ?? [];\n\n/**\n * Parses the tags out of a string\n */\nexport const parseTagString = (\n  input: string | string[] | null | undefined,\n  baseRank?: string,\n  target?: Set<string>\n) => {\n  if (!input) return [];\n  if (Array.isArray(input)) input = input.join(\",\");\n  // We have an unescaped percentage sign followed by an uppercase two-digit hexadecimal number. Smells like URI encoding!\n  if (/(?<!(?<!\\\\)\\\\)%[A-Z0-9]{2}/.test(input)) {\n    try {\n      input = decodeURIComponent(\n        input.replace(\n          // Change ampersands to commas (as they are value separators), and quote all values just to be sure nothing gets out of control.\n          // That is, `tag=test&tag2&tag3=Encoded%3A%20%22%F0%9F%A5%B3%22` becomes `tag=\"test\",tag2,tag3=\"Encoded: \\\"ðŸ¥³\\\"\"\n          /([^=&]+)(?:\\=([^&]+))?(&|$)/g,\n          (_, name, value, sep) =>\n            [\n              name,\n              value && `=\"${value.replace(/(?<!(?<!\\\\)\\\\)(\"|%22)/g, '\\\\\"')}\"`, // Escape double quotes (both encoded `%22` and non-encoded `\"`\"), but ignore quotes that are already escaped (yes, why not?).\n              sep && \",\",\n            ].join(\"\")\n        )\n      );\n      // Need to catch exceptions. `decodeURIComponent` will fail on invalid surrogate code points. `%80` is one of those.\n    } catch {}\n  }\n\n  let tags: ParsedTag[] = [],\n    parsedTag: ParsedTag,\n    baseRanks = splitRanks(baseRank);\n\n  input.replace(\n    // Explained:\n    // 1. Tag (group 1): (\\s*(?=\\=)|(?:\\\\.|[^,=\\r\\n])+). It means \"skip leading white-space\", then either\"\n    //   1.1. \\s*(?=\\=) is \"nothing but a `=`\": a blank tag name causing the expression to skip to the actual value. (\"=80,=43\" are techincally supported but will get omitted unless the are base ranks (*))\n    //   2.1. (?:\\\\.|[^,=\\r\\n])+ is \"something not a linebreak including escaped characters such as \\=\":\n    // 2. Value: (?:\\=\\s*(?:\"((?:\\\\.|[^\"])*)\"|'((?:\\\\.|[^'])*)'|((?:\\\\.|\\s*[^,\\s])*)))?. Anything that starts with a `=` until we find a (non-escaped) comma\n    //  2.1: (group 2) \"((?:\\\\.|[^\"])*)\" is any double-quoted ()`\"`) value, can contain commas, anything escaped, or whatever. Goes well with JSON.\n    //  2.2: (group 3) is same as 2.1 just with a single quote (`'`).\n    //  2.3: (group 4) is anything but a non-escaped comma (`,`)\n    // 3. The end. (?:[,\\s]+|$). This is the tag separator or end of string.\n    //        Since tags cannot have line-breaks in them, this technically allows tags to be separated by line-breaks instead of comma.\n    //        This should not be documented as values can very much have line-breaks, and that syntax will then bite you in the money-maker at some point.\n    //        In the scary example below we get \"tag1\", \"tag21:tag22\" and then \"tag3\" with the value \"value\\tag4=value\"(!).\n    //        `tag1\n    //        tag21:tag22\n    //        tag3=value\n    //        tag4=value`\n    /\\s*(\\s*(?=\\=)|(?:\\\\.|[^,=\\r\\n])+)\\s*(?:\\=\\s*(?:\"((?:\\\\.|[^\"])*)\"|'((?:\\\\.|[^'])*)'|((?:\\\\.|[^,])*)))?\\s*(?:[,\\s]+|$)/g,\n    (_0, tag, quote1, quote2, unquoted) => {\n      let value = quote1 || quote2 || unquoted;\n      let ranks = splitRanks(tag);\n\n      baseRanks.length &&\n        // If we have base ranks (that, is a \"prefix\"), a single tag value is interpreted as a value. E.g. `<a data-name=\"foo\"...` becomes `data:name=foo`.\n        // We have this situation if there is exactly one rank, and no value.\n        // Other examples: `<a data-employee=\"foo:test\" ...` gives `data:employee:foo:test`. `data-employee=\"=test\"` gives us `data:employee=test`, and\n        //    `data-employee=\"id=80\"` gives us `data:employee:id=80`.\n        (ranks.length === 1 && !value && (value = ranks.pop()),\n        (ranks = baseRanks.concat(ranks))),\n        // If we don't have any ranks (only a value), we don't have a tag.\n        ranks.length && // * cf. expression explanition 1.1\n          (tags.push(\n            (parsedTag = {\n              ranks,\n              value: value || undefined,\n            })\n          ),\n          target?.add(encodeTag(parsedTag)));\n      return \"\"; // This is a trick. We are not really replacing anything, we are instead using replace as a for loop.\n    }\n  );\n  return tags;\n};\n\nexport const encodeTag = <T extends ParsedTag | null | undefined>(\n  tag: T\n): T extends ParsedTag ? string : null | undefined =>\n  tag == null\n    ? (tag as any)\n    : `${tag.ranks.join(\":\")}${\n        tag.value ? `=${tag.value.replace(/,/g, \"\\\\,\")}` : \"\"\n      }`;\n"]}