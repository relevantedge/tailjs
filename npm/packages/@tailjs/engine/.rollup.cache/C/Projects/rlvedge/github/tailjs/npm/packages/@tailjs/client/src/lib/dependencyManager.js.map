{"version":3,"file":"dependencyManager.js","sourceRoot":"","sources":["dependencyManager.ts"],"names":[],"mappings":"AAEA,OAAO,EACL,CAAC,EACD,GAAG,EACH,GAAG,EACH,MAAM,EACN,GAAG,EACH,QAAQ,EACR,OAAO,EACP,OAAO,EACP,GAAG,EACH,GAAG,GACJ,MAAM,GAAG,CAAC;AAEX,MAAM,YAAY,GAAG,MAAM,EAAE,CAAC;AAE9B,MAAM,OAAO,GAAG,OAAO,EAAgB,CAAC;AAExC,oFAAoF;AACpF,oFAAoF;AACpF,kDAAkD;AAClD,MAAM,mBAAmB,GAAG,OAAO,EAAmC,CAAC;AACvE,MAAM,wBAAwB,GAAG,CAAC,EAAgB,EAAE,EAAE,CACpD,CAAC,GAAG,CAAC,EAAE,CAAC,YAAY,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC;AAEtD,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,KAAmB,EAAE,EAAE,CACrD,CAAC,wBAAwB,CAAC,KAAK,CAAC;IAChC,CAAC,GAAG,CAAC,KAAK,CAAC,YAAY,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAChC,GAAG,CACD,QAAQ,CAAC,mBAAmB,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,OAAO,EAAE,CAAC,EACnD,KAAK,CACN,CACF;QACD,CAAC,CAAC,CAAC;AAEL,IAAI,OAAoC,CAAC;AACzC,MAAM,CAAC,MAAM,kBAAkB,GAAG,CAAC,KAAmB,EAAE,EAAE,CAAC,CACzD,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC;IACnB,CAAC,OAAO,GAAG,mBAAmB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,IAAI,oDAAoD;QAChG,CAAC,CAAC,OAAO,CAAC,IAAI,IAAI,GAAG,CAAC,mBAAmB,EAAE,KAAK,CAAC;YACjD,MAAM,CACJ,OAAO,EACP,CAAC,GAAG,EAAE,EAAE,CAAC,wBAAwB,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAQ,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,CAClE,CAAC,CACL,CAAC;AAEF,MAAM,CAAC,MAAM,aAAa,GAAG,CAC3B,KAAmB,EACnB,UAAwB,EACxB,EAAE,CAAC,CACH,KAAK,KAAK,UAAU;IACjB,CAAC,KAAK,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAS;IACxD,KAAK,CACN,CAAC","sourcesContent":["import { TrackedEvent } from \"@tailjs/types\";\nimport type { Nullish } from \"@tailjs/util\";\nimport {\n  T,\n  any,\n  del,\n  filter,\n  get,\n  getOrSet,\n  hashMap,\n  hashSet,\n  map,\n  set,\n} from \".\";\n\nconst dependencies = Symbol();\n\nconst cleared = hashSet<TrackedEvent>();\n\n// If an event refers to another event it will not get posted before that is posted.\n// That also means that if the referred event is never posted, neither is the event.\n// TODO: Evaluate if this may cause a memory leak.\nconst pendingDependencies = hashMap<TrackedEvent, Set<TrackedEvent>>();\nconst areAllDependenciesPosted = (ev: TrackedEvent) =>\n  !any(ev[dependencies], (dep) => !get(cleared, dep));\n\nexport const hasDependencies = (event: TrackedEvent) =>\n  !areAllDependenciesPosted(event) &&\n  (map(event[dependencies], (dep) =>\n    set(\n      getOrSet(pendingDependencies, dep, () => hashSet()),\n      event\n    )\n  ),\n  T);\n\nlet stalled: Set<TrackedEvent> | Nullish;\nexport const completeDependency = (event: TrackedEvent) => (\n  set(cleared, event),\n  (stalled = pendingDependencies.get(event)) && // Free memory when all dependant events are cleared\n    (!stalled.size && del(pendingDependencies, event),\n    filter(\n      stalled,\n      (dep) => areAllDependenciesPosted(dep) && (del(stalled!, dep), T)\n    ))\n);\n\nexport const addDependency = (\n  event: TrackedEvent,\n  dependency: TrackedEvent\n) => (\n  event !== dependency &&\n    ((event[dependencies] ??= []).push(dependency) as any),\n  event\n);\n"]}