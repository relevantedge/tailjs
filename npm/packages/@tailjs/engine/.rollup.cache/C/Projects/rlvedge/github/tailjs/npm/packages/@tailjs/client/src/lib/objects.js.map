{"version":3,"file":"objects.js","sourceRoot":"","sources":["objects.ts"],"names":[],"mappings":"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","sourcesContent":["// Utility functions for testing and manipulating values, sets and objects.\n\nimport type {\n  ArgNulls,\n  KeyValueProjection,\n  Nullish,\n  Nulls,\n  OmitNullish,\n} from \"@tailjs/util\";\nimport {\n  F,\n  T,\n  array,\n  assign,\n  entries,\n  filter,\n  forEach,\n  fromEntries,\n  fun,\n  keys,\n  nil,\n  obj,\n} from \".\";\n\n/**\n * Better minifyable way to instantiate a Set.\n */\nexport const hashSet = <T = any>(values?: readonly T[] | null) =>\n  new Set<T>(values);\n\n/**\n * Better minifyable way to instantiate a Map.\n */\nexport const hashMap = <K = any, V = any>(\n  entries?: readonly (readonly [K, V])[] | null\n) => new Map<K, V>(entries);\n\n/**\n * Better minifyable way to instantiate a WeakMap.\n */\nexport const weakMap = <K extends object = any, V = any>(\n  entries?: readonly (readonly [K, V])[] | null\n) => new WeakMap<K, V>(entries);\n\n/**\n * A common pattern used in the code base where something has a `clear` method.\n */\ntype Clearable<A extends any[]> = { clear(...args: A): any };\n\n/**\n *  General function to \"clear\" objects, arrays, sets and maps.\n */\nexport const clear: {\n  <T extends Clearable<A> | Nullish, A extends any[] = []>(\n    map: T,\n    ...args: A\n  ): T;\n  <T extends Record<keyof any, any>>(record: T): T;\n} = (clearable: any, ...args: any[]) => (\n  clearable != nil &&\n    (clearable.clear\n      ? clearable.clear(...args)\n      : array(clearable)\n      ? (clearable.length = 0)\n      : keys(clearable, (key) => del(clearable, key))),\n  clearable\n);\n\n/**\n * Test whether a set has a specified key, and if not, sets it and returns `true`. `false` otherwise.\n *\n * This is useful for recursive iteration where the same element must not be visited more than once (because infinite recursion sucks).\n */\nexport const mark = <K>(\n  set: { has(value: K): boolean; add(value: K): any },\n  value: K\n) => (set.has(value) ? F : (set.add(value), T));\n\n/**\n * A generalized function to get values from maps, test existence in sets and get properties on objects.\n */\nexport const get: {\n  <K, V, Arg>(\n    target: ArgNulls<{ get(key: K): V } | { has(key: K): V }, Arg>,\n    key: K\n  ): V | Nulls<Arg, undefined>;\n  <K extends keyof any, V, Arg>(target: ArgNulls<Record<K, V>, Arg>, key: K):\n    | V\n    | Nulls<Arg, undefined>;\n} = (target: any, key: any) =>\n  target.get?.(key) ?? target?.has(key) ?? target?.[key];\n\n/**\n * A generalized function to remove items from sets and maps, and delete properties from objects.\n * When only a single key/property is specified the deleted value is returned (`undefined` if not present).\n *\n * Multiple keys can be specified as once in which case the target will just be returned (like fluent API or whatever).\n */\n\nexport const del: {\n  (target: null | undefined, keys: string | string[]): undefined;\n  <K, V>(target: { get(key: K): V; delete(key: K): any }, item: K):\n    | V\n    | undefined;\n  <K, R>(\n    target: { has(key: K): boolean; delete(key: K): any },\n    item: K\n  ): boolean;\n  <T extends { delete(key: K): any }, K>(target: T, keys: K[]): T;\n  <T, K extends keyof T>(target: T, key: K): T[K] | undefined;\n  <T>(target: T, keys: (keyof T)[]): T;\n} = <T>(\n  target:\n    | { get?(item: T): any; has?(key: any): boolean; delete?(item: T): any }\n    | null\n    | undefined,\n  key: any\n) =>\n  !target\n    ? undefined\n    : array(key)\n    ? (forEach(key, (key) => target.delete?.(key) ?? delete target[key]),\n      target)\n    : (currentValue = target.has?.(key)) != null\n    ? !currentValue\n      ? undefined\n      : ((currentValue = target.get?.(key)),\n        target.delete!(key),\n        currentValue ?? T)\n    : ((currentValue = target[key]), delete target[key], currentValue);\n\n/**\n * Sets the value for the specified key in a map, toggles the item in a set, or sets the property on an object.\n *\n * The value `undefined` deletes the key/property from maps and objects.\n * For sets `undefined` corresponds to the default value `true`, so here it has the opposite effect.\n */\nlet currentValue: any;\nexport const set: {\n  <T>(\n    set: { add(key: T): void; delete(key: T): void },\n    item: T,\n    toggle?: boolean\n  ): boolean;\n  <K, V>(\n    map: {\n      get(key: K): V | null;\n      set(key: K, value: V): any;\n      delete(key: K): void;\n    },\n    key: K,\n    value: V | ((current: V | null) => V | null) | Nullish\n  ): boolean;\n} = (target: any, key: any, value: any = undefined) =>\n  !!target.add // It's a set\n    ? ((currentValue = target.has(key)),\n      currentValue === (value ??= T) // Toggle? (Default is `true` which we set here).\n        ? F\n        : (value ? target.add(key) : del(target, key), T))\n    : ((currentValue = target.get?.(key) ?? target[key]), // Get item from map / read property from object.\n      fun(value) && (value = value(currentValue)), // Apply optional projection on current value.\n      value === currentValue\n        ? F // No change\n        : (value === undefined // `undefined` means \"delete\".\n            ? del(target, key)\n            : target.set?.(key, value) ?? (target[key] = value),\n          // Return that the value was changed.\n          T));\n\n/**\n * Gets the current item for a key in a map, or a property on an object.\n * If no value is present, it is initialized with the `defaultValue` and then returned.\n */\nexport const getOrSet: {\n  <K, V, R extends V | Readonly<V>>(\n    map:\n      | {\n          has(key: K): boolean;\n          get(key: K): V | Nullish;\n          set(key: K, value: V): void;\n        }\n      | Record<keyof any, any>,\n    key: K,\n    defaultValue: (key: K) => R\n  ): V;\n  <\n    T extends Record<keyof any, any>,\n    K extends keyof T,\n    V,\n    R extends V | Readonly<V>\n  >(\n    target: T,\n    key: K,\n    defaultValue: (key: K) => R\n  ): V;\n} = (map: any, key: any, defaultValue: (key: any) => any) =>\n  map.has?.(key)\n    ? map.get?.(key)\n    : ((currentValue = defaultValue(key)),\n      map.set?.(key, currentValue)\n        ? currentValue\n        : (map[key] ??= defaultValue(key)));\n\n/**\n * Convenient way to use the values from a tuple.\n * If the tuple is null or undefined, that will be returned instead of applying the function.\n */\nexport const decompose = <Values extends any[] | Nullish, R>(\n  tuple: Values,\n  apply: (...values: OmitNullish<Values>) => R\n): R | Nulls<Values> => tuple && apply(...(tuple as any));\n\n/**\n * Creates a new object by projecting or excluding the properties of an existing one.\n */\nexport const transpose = <\n  K extends keyof any,\n  V,\n  KP extends keyof any = K,\n  VP = V\n>(\n  source: Record<K, V>,\n  projection?: KeyValueProjection<K, V, [KP, VP] | null>,\n  additionalEntries?: Record<KP, VP>\n): Record<KP, VP> =>\n  additionalEntries\n    ? assign(transpose(source, projection), additionalEntries)\n    : projection\n    ? (fromEntries(filter(entries(source, projection)) as any) as any)\n    : source;\n\n/** Removes null'ish properties from an object */\nexport const clean = <T extends object>(o: T): Required<T> => {\n  const inner = (o: object) =>\n    forEach(entries(o), ([key, value], F) =>\n      value == nil || (obj(value) && !inner(value)) ? (del(o, key), F) : T\n    );\n  inner(o);\n  return o as any;\n};\n"]}