{"version":3,"file":"SchemaManager.js","sourceRoot":"","sources":["SchemaManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { UserConsent, variableScope } from \"@tailjs/types\";\r\nimport {\r\n  IfNot,\r\n  MaybeRequired,\r\n  assignIfUndefined,\r\n  first,\r\n  forEach,\r\n  invariant,\r\n  isString,\r\n  obj,\r\n  required,\r\n  throwError,\r\n  toArray,\r\n  unlock,\r\n  validate,\r\n} from \"@tailjs/util\";\r\nimport addFormats from \"ajv-formats\";\r\nimport Ajv from \"ajv/dist/2020\";\r\nimport {\r\n  Schema,\r\n  SchemaClassification,\r\n  SchemaObjectType,\r\n  SchemaProperty,\r\n  SchemaType,\r\n  SchemaVariable,\r\n  SchemaVariableSet,\r\n  VariableMap,\r\n  systemTypes,\r\n} from \"..\";\r\nimport { censor, parseError, parseSchema, validationError } from \"./parse\";\r\n\r\nexport class SchemaManager {\r\n  public readonly schema: Schema;\r\n  public readonly subSchemas: ReadonlyMap<string, Schema> = new Map();\r\n  public readonly types: ReadonlyMap<string, SchemaObjectType> = new Map();\r\n\r\n  constructor(schemas: any[]) {\r\n    const combinedSchema = {\r\n      $schema: \"https://json-schema.org/draft/2020-12/schema\",\r\n      $id: \"urn:tailjs:runtime\",\r\n      description:\r\n        \"The effective schema for this particular configuration of tail.js that bundles all included schemas.\",\r\n      $defs: obj(schemas, (schema) => [\r\n        validate(\r\n          schema.$id,\r\n          schema.$id && schema.$schema,\r\n          \"A schema must have an $id and $schema property.\"\r\n        ),\r\n        schema,\r\n      ]),\r\n    };\r\n\r\n    const reset = () => {\r\n      const ajv = new Ajv()\r\n        .addKeyword(\"x-privacy-class\")\r\n        .addKeyword(\"x-privacy-purpose\")\r\n        .addKeyword(\"x-privacy-purposes\")\r\n        .addKeyword(\"x-tags\")\r\n        .addKeyword(\"$anchor\")\r\n        .addKeyword(\"x-privacy-censor\");\r\n\r\n      addFormats(ajv);\r\n      return ajv;\r\n    };\r\n    let ajv = reset();\r\n\r\n    ajv.addSchema(combinedSchema);\r\n    const [parsedSchemas, parsedTypes] = parseSchema(combinedSchema, ajv);\r\n\r\n    // A brand new instance is required since we have tampered with the schema while parsing (e.g. setting unevaluatedProperties true/false and added anchors).\r\n    (ajv = reset()).compile(combinedSchema);\r\n    parsedSchemas.forEach((parsed) => {\r\n      const schema: Schema = {\r\n        id: parsed.id,\r\n        classification: parsed.classification!,\r\n        purposes: parsed.purposes!,\r\n        types: new Map(),\r\n        subSchemas: new Map(),\r\n      };\r\n\r\n      (this.subSchemas as Map<any, any>).set(schema.id, schema);\r\n    });\r\n\r\n    parsedSchemas.forEach((parsed) => {\r\n      const schema = this.subSchemas.get(parsed.id)!;\r\n      forEach(parsed.subSchemas, ([, parsedSubSchema]) => {\r\n        const subSchema = required(this.subSchemas.get(parsedSubSchema.id));\r\n        subSchema.parent = schema;\r\n        ((schema.subSchemas ??= new Map()) as Map<string, Schema>).set(\r\n          subSchema.id,\r\n          subSchema\r\n        );\r\n      });\r\n    });\r\n\r\n    parsedTypes.forEach((parsed) => {\r\n      const validate = required(\r\n        ajv.getSchema(parsed.context.$ref!),\r\n        () =>\r\n          `INV <> The ref '${parsed.context.$ref}' does not address the type '${parsed.id}' in the schema.`\r\n      );\r\n\r\n      const type: SchemaObjectType = {\r\n        id: parsed.id,\r\n        name: parsed.name,\r\n        description: parsed.description,\r\n        classification: parsed.classification!,\r\n        purposes: parsed.purposes!,\r\n        primitive: false,\r\n        abstract: !!parsed.abstract,\r\n        schema: invariant(\r\n          this.subSchemas.get(parsed.context.schema!.id),\r\n          \"Schemas are mapped.\"\r\n        ),\r\n\r\n        censor: (value, classification) =>\r\n          censor(parsed, value, classification),\r\n\r\n        tryValidate: (value) => (validate(value) ? value : undefined),\r\n\r\n        validate: (value) =>\r\n          validate(value)\r\n            ? value\r\n            : throwError(validationError(type.id, validate.errors, value)),\r\n      };\r\n      unlock(type.schema.types).set(type.id, type);\r\n      (this.types as Map<any, any>).set(type.id, type);\r\n    });\r\n\r\n    var trackedEvent = first(\r\n      parsedTypes,\r\n      ([, type]) => type.schemaId === systemTypes.event\r\n    )?.[1];\r\n    parsedTypes.forEach((parsed) => {\r\n      const type = this.types.get(parsed.id)!;\r\n\r\n      const set = <T extends { id: string }>(\r\n        target: ReadonlyMap<string, T>,\r\n        item: T\r\n      ) => (target as Map<string, T>).set(item.id, item);\r\n\r\n      forEach(parsed.extends, (parsedBaseType) =>\r\n        set(\r\n          (type.subtypes ??= new Map()),\r\n          invariant(\r\n            this.types.get(parsedBaseType.id),\r\n            `Extended type is mapped.`\r\n          )\r\n        )\r\n      );\r\n      forEach(parsed.subtypes, (parsedBaseType) =>\r\n        set(\r\n          (type.subtypes ??= new Map()),\r\n          invariant(\r\n            this.types.get(parsedBaseType.id),\r\n            \"Extending type is mapped.\"\r\n          )\r\n        )\r\n      );\r\n\r\n      forEach(parsed.properties, ([key, parsedProperty]) => {\r\n        const property: SchemaProperty = {\r\n          id: type + \"#\" + key,\r\n          name: parsedProperty.name,\r\n          description: parsedProperty.description,\r\n          classification: parsedProperty.classification,\r\n          purposes: parsedProperty.purposes,\r\n          declaringType: type,\r\n          structure: parsedProperty.structure,\r\n          required: parsedProperty.required,\r\n          type: required(\r\n            parsedProperty.objectType\r\n              ? this.types.get(parsedProperty.objectType.id)\r\n              : parsedProperty.primitiveType ?? ({} as any),\r\n            () =>\r\n              parseError(\r\n                parsed.context,\r\n                `Unknown property type. (${JSON.stringify(\r\n                  parsedProperty.typeContext!.node\r\n                )})`\r\n              )\r\n          ),\r\n        };\r\n        unlock((type.properties ??= new Map())).set(property.name, property);\r\n\r\n        if (\r\n          trackedEvent &&\r\n          key === \"type\" &&\r\n          parsed.extends?.has(trackedEvent)\r\n        ) {\r\n          toArray(\r\n            parsedProperty.typeContext?.node.const ??\r\n              parsedProperty.typeContext?.node.enum\r\n          )?.forEach((alias) =>\r\n            assignIfUndefined(\r\n              unlock((type.schema!.events ??= new Map())),\r\n              alias,\r\n              type,\r\n              (key, current) =>\r\n                `The event '${type.id}' cannot be defined for the type '${key}' since '${current.id}' is already registered.`\r\n            )\r\n          );\r\n        }\r\n\r\n        // If $defs defines object types named of a variable scope (\"Global\", \"Session\", \"Device\",  \"User\" or\"Entity\"),\r\n        // their properties will be added as variable definitions to the respective scopes.\r\n        if (variableScope.tryParse(type.name)) {\r\n          const scopeId = variableScope.parse(type.name);\r\n          forEach(type.properties, ([, property]: [any, SchemaVariable]) => {\r\n            if (property.required) {\r\n              throw new Error(\r\n                `The type '${type.id}' cannot have required properties since it defines scope variables.`\r\n              );\r\n            }\r\n\r\n            property.censor = (value, consent) =>\r\n              property.type.censor({ [property.name]: value }, consent)?.[\r\n                property.name\r\n              ];\r\n\r\n            property.validate = (value) =>\r\n              type.validate({ [property.name]: value })[property.name];\r\n\r\n            property.tryValidate = (value) =>\r\n              type.tryValidate({ [property.name]: value })?.[property.name];\r\n\r\n            property.scope = scopeId;\r\n\r\n            (type.schema!.variables ??= new VariableMap()).set(\r\n              scopeId,\r\n              property.name,\r\n              property\r\n            );\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    // Push nested schema types and events to parent schema. At the same time validate that event type IDs are unique.\r\n    //\r\n    // Also, don't push variables since those are scoped to their schema IDs. It is not sensible to detect variable name clashes\r\n    // at the global level since prefixed variable storages may only use a subset of the schema.\r\n    // Hence, it is their responsibility to merge their respective schemas and check for name clashes.\r\n    this.subSchemas.forEach((schema) => {\r\n      let parent = schema.parent;\r\n      while (parent) {\r\n        schema.events?.forEach((event, key) => {\r\n          if (parent!.events?.has(key)) {\r\n            throw new Error(\r\n              `The events '${parent!.events!.get(key)!.id}' and '${\r\n                event.id\r\n              }' cannot both have the type name '${key}'.`\r\n            );\r\n          }\r\n          unlock((parent!.events ??= new Map())).set(key, event);\r\n        });\r\n        schema.types.forEach((type) => {\r\n          (parent!.types as Map<string, SchemaType>).set(type.id, type);\r\n        });\r\n        parent = parent.parent;\r\n      }\r\n    });\r\n\r\n    parsedTypes.forEach((parsed) => {\r\n      const type = this.types.get(parsed.id);\r\n      forEach(type?.referencedBy, (parsedProperty) =>\r\n        ((type!.referencedBy ??= new Set()) as Set<SchemaProperty>).add(\r\n          invariant(\r\n            this.types\r\n              .get(parsedProperty.declaringType.id)\r\n              ?.properties?.get(parsedProperty.name),\r\n            \"Referencing property is mapped.\"\r\n          )\r\n        )\r\n      );\r\n    });\r\n\r\n    this.schema = invariant(\r\n      this.subSchemas.get(\"urn:tailjs:runtime\"),\r\n      \"Runtime schema is registered.\"\r\n    );\r\n  }\r\n\r\n  public getSchema<Required = true>(\r\n    schemaId: MaybeRequired<string, Required>,\r\n    require?: Required & boolean\r\n  ): MaybeRequired<Schema, Required> {\r\n    return require\r\n      ? required(\r\n          this.getSchema(schemaId, false as any) as any,\r\n          () => `The schema '${schemaId}' has not been registered.`\r\n        )\r\n      : schemaId && this.subSchemas.get(schemaId);\r\n  }\r\n\r\n  public getType<Required = true>(\r\n    typeId: MaybeRequired<string, Required>,\r\n    require?: Required & boolean,\r\n    concreteOnly = true\r\n  ): SchemaType | IfNot<Required> {\r\n    return require\r\n      ? required(\r\n          this.getType<false>(typeId, false, concreteOnly),\r\n          () => `The type '${typeId}' is not defined.`\r\n        )\r\n      : typeId &&\r\n          validate(\r\n            this.schema.events?.get(typeId!) ?? this.types.get(typeId!),\r\n            (type) => !type || !concreteOnly || (type && !type.abstract),\r\n            () =>\r\n              `The type '${typeId}' is abstract and cannot be used directly.`\r\n          );\r\n  }\r\n\r\n  public tryValidate<T>(\r\n    typeId: string | null | undefined,\r\n    value: T\r\n  ): T | undefined;\r\n  public tryValidate<T>(\r\n    eventType: string | null | undefined,\r\n    event: T\r\n  ): T | undefined;\r\n  public tryValidate(id: string | null | undefined, value: any) {\r\n    return (\r\n      id &&\r\n      (this.schema.events?.get(id) ?? this.getType(id, false))?.tryValidate(\r\n        value\r\n      )\r\n    );\r\n  }\r\n\r\n  public validate<T>(typeId: string, value: T): T;\r\n  public validate<T>(eventType: string, event: T): T;\r\n  public validate(id: string, value: any) {\r\n    return (this.schema.events?.get(id) ?? this.getType(id, true)).validate(\r\n      value\r\n    );\r\n  }\r\n\r\n  public censor<T>(\r\n    typeId: string,\r\n    value: T,\r\n    consent: SchemaClassification | UserConsent\r\n  ): T | undefined;\r\n  public censor<T>(\r\n    eventType: string,\r\n    event: T,\r\n    consent: SchemaClassification | UserConsent\r\n  ): T | undefined;\r\n  public censor(\r\n    id: string,\r\n    value: any,\r\n    consent: SchemaClassification | UserConsent\r\n  ) {\r\n    return (this.schema.events?.get(id) ?? this.getType(id, true)).censor(\r\n      value,\r\n      consent\r\n    );\r\n  }\r\n\r\n  public createVariableSet(\r\n    schemas?: string | Iterable<string | Schema | undefined>\r\n  ) {\r\n    return new SchemaVariableSet(\r\n      this,\r\n      isString(schemas) ? [schemas] : schemas ?? this.subSchemas.values()\r\n    );\r\n  }\r\n}\r\n"]}