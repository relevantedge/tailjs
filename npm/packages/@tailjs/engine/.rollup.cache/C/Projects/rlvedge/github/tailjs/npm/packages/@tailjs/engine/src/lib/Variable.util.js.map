{"version":3,"file":"Variable.util.js","sourceRoot":"","sources":["Variable.util.ts"],"names":[],"mappings":"AAAA,OAAO,EAcL,eAAe,EACf,SAAS,EACT,QAAQ,GACT,MAAM,eAAe,CAAC;AACvB,OAAO,EAGL,MAAM,EACN,SAAS,EACT,UAAU,EACV,QAAQ,EACR,QAAQ,EACR,WAAW,GAEZ,MAAM,cAAc,CAAC;AAGtB;;GAEG;AACH,MAAM,CAAC,MAAM,UAAU,GAAG,CACxB,QAAW,EACX,EAAE,CACF,QAAQ;IACN,CAAC,CAAC,QAAQ,CAAC,QAAQ;QACjB,CAAC,CAAC,QAAQ,CAAC,KAAK,GAAG,QAAQ,CAAC,QAAQ,GAAG,QAAQ,CAAC,GAAG;QACnD,CAAC,CAAC,QAAQ,CAAC,KAAK,GAAG,QAAQ,CAAC,GAAG;IACjC,CAAC,CAAC,SAAS,CAAC;AAEhB,MAAM,CAAC,MAAM,IAAI,GAAG,CAGlB,QAAW,EACX,SAA6B,EAC1B,EAAE;IACL,OAAO,CACL,QAAQ,IAAI;QACV,GAAG,QAAQ;QACX,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAC5C,GAAG,SAAS;KACb,CACF,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAAC,MAA0B,EAAE,EAAE;IACjE,IAAI,CAAC,MAAM,IAAI,eAAe,CAAC,MAAM,CAAC;QAAE,OAAO,SAAS,CAAC;IAEzD,OAAO,MAAM,CAAC;QACZ,UAAU,MAAM,CAAC,MAAM,YAAY,MAAM,CAAC,MAAM,CAAC,GAAG,KAAK,MAAM,CAAC,MAAM,CAAC,KAAK,GAAG;QAC/E,MAAM,CAAC,OAAO,CAAC,EAAE,QAAQ,EAAE;KAC5B,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACjB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,UAAU,GAAG,CACxB,QAAW,EAC0B,EAAE,CACvC,QAAQ;IACN,CAAC,CAAE;QACC,KAAK,EAAE,QAAQ,CAAC,KAAK;QACrB,QAAQ,EAAE,QAAQ,CAAC,QAAQ;QAC3B,GAAG,EAAE,QAAQ,CAAC,GAAG;KACe;IACpC,CAAC,CAAC,SAAS,CAAC;AAEhB,MAAM,aAAa,GAAG,CACpB,KAAU,EACV,QAA4B,EAC5B,MAA6B,EAC7B,EAAE;IACF,IAAI,CAAC,QAAQ;QAAE,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;IAEpC,IAAI,WAAmB,CAAC;IACxB,CAAC,GAAG,GAAG,QAAQ,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE;QACvD,IAAI,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QAC/C,IAAI,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC;YAC1C,MAAM,IAAI,SAAS,CACjB,iFAAiF,CAClF,CAAC;QACJ,IAAI,CAAC,KAAK,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC1B,MAAM,OAAO,GAAG,CAAC,WAAW,CAAC,OAAO,CAAC,GAAG,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACtE,WAAW,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC;YAC/B,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC;gBACvB,OAAO,WAAW,CAAC,OAAO,CAAC,CAAC;YAC9B,CAAC;QACH,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,OAAO,EAAE,CAAC;gBACb,WAAW,GAAG,CAAC;oBACb,CAAC,CAAC,CAAC,OAAO,GAAG,WAAW,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;oBAC1C,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE,CAAC,CAAC;YACrB,CAAC;QACH,CAAC;IACH,CAAC,CAAC,CAAC;IACH,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AAEF,MAAM,wBAAwB,GAAG,CAAC,KAAU,EAAsB,EAAE;IAClE,IAAI,WAAW,CAAC,KAAK,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC;QAAE,OAAO,KAAM,CAAC;IACzD,MAAM,IAAI,SAAS,CAAC,kDAAkD,CAAC,CAAC;AAC1E,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAC/B,OAAmD,EACnD,EAAE,cAAc,EAAE,KAAK,EAAE,QAAQ,EAAE,KAAK,EAA4B,EACxB,EAAE;IAC9C,IAAI,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;QACtB,MAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;QAEzC,IAAI,OAAO,EAAE,CAAC;YACZ,OAAO,CAAC,cAAc;gBACpB,OAAO,EAAE,cAAc,wCAAgC,CAAC;YAC1D,CAAC,CAAC,UAAU,IAAI,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,GAAG,OAAO,EAAE,QAAQ,CAAC,CAAC;YACnE,CAAC,CAAC,MAAM,IAAI,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,GAAG,OAAO,EAAE,IAAI,CAAC,CAAC;QACzD,CAAC;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,MAAM,cAAc,GAAiC;QACnD,cAAc,EAAE,KAAM;QACtB,QAAQ,EAAE,QAAQ;KACnB,CAAC;IAEF,MAAM,KAAK,GAAG,OAAO,EAAE,KAAK,CAAC;IAE7B,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAEnC,QAAQ,KAAK,CAAC,IAAI,EAAE,CAAC;QACnB;YACE,OAAO;gBACL,GAAG,cAAc;gBACjB,KAAK,EAAE,aAAa,CAClB,wBAAwB,CAAC,KAAK,CAAC,EAC/B,KAAK,CAAC,QAAQ,EACd,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,EAAE,CACnC;aACF,CAAC;QACJ,mCAA2B;QAC3B;YACE,OAAO;gBACL,GAAG,cAAc;gBACjB,KAAK,EAAE,aAAa,CAAC,KAAK,EAAE,KAAK,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,EAAE,CACpD,SAAS,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;oBACxC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,kCAA0B,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CACxD,KAAK,EACL,KAAK,CAAC,KAAK,CACZ;oBACH,CAAC,CAAC,KAAK,CAAC,KAAK,CAChB;aACF,CAAC;QACJ;YACE,IAAI,OAAO,EAAE,KAAK,KAAK,KAAK,CAAC,KAAK,EAAE,CAAC;gBACnC,OAAO,SAAS,CAAC;YACnB,CAAC;YACD,OAAO;gBACL,GAAG,cAAc;gBACjB,KAAK,EAAE,aAAa,CAAC,KAAK,EAAE,KAAK,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC;aAC/D,CAAC;IACN,CAAC;AACH,CAAC,CAAC;AAiBF,MAAM,CAAC,MAAM,eAAe,GAAG,CAAkB,KAAQ,EAAqB,EAAE,CAC9E,KAAK,CAAC,GAAG,CACP,CAAC,IAAI,EAAE,WAAW,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,IAAI,CAAU,CAC/B,CAAC;AAEzB,MAAM,CAAC,MAAM,cAAc,GAAG,CAAkB,KAAwB,EAAK,EAAE,CAC7E,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAM,CAAC;AAEpC,MAAM,CAAC,MAAM,SAAS,GAAG,KAAK,EAC5B,OAAU,EACV,iBAAoC,EACpC,gBAA+C,EAC/C,EAAE,CACF,iBAAiB,EAAE,MAAM;IACzB,CACE,MAAM,gBAAgB,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAM,CAAC,CACxE,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAEpE,MAAM,CAAC,MAAM,SAAS,GAAG,CAAC,GAAuB,EAAE,EAAE,CAAC,GAAG,EAAE,QAAQ,CAAC,GAAG,CAAC,CAAC;AAEzE,MAAM,CAAC,MAAM,QAAQ,GAAG,CACtB,SAAY,EACoB,EAAE;IAClC,IAAI,WAAW,CAAC,SAAS,CAAC;QAAE,OAAO,SAAgB,CAAC;IACpD,MAAM,GAAG,GAAG,SAAS,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC;IACjC,IAAI,GAAG,EAAE,CAAC;QACR,SAAS,GAAI,SAAS,CAAC,KAAK,CAAC,CAAC,CAAQ,CAAC;IACzC,CAAC;IACD,MAAM,WAAW,GAAG,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IAC3C,MAAM,MAAM,GAAG,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;IAC1E,MAAM,GAAG,GAAG,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAE5E,OAAO;QACL,MAAM;QACN,GAAG;QACH,SAAS;QACT,GAAG;KACG,CAAC;AACX,CAAC,CAAC;AAQF,MAAM,CAAC,MAAM,YAAY,GAAG,CAC1B,OAAyB,EACzB,MAAsB,EACtB,UAAU,GAAG,KAAK,EAClB,EAAE;IACF,MAAM,YAAY,GAAuB,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;IAC9D,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;QAC7B,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC;QACxC,KAAK,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,IAAI,MAAM,EAAE,CAAC;YAC/D,IAAI,SAAS,GAAG,IAAI,CAAC;YACrB,IAAI,QAAQ,IAAI,SAAS,EAAE,CAAC;gBAC1B,MAAM,EAAE,OAAO,GAAG,KAAK,EAAE,KAAK,EAAE,GAAG,QAAQ,CAAC;gBAC5C,SAAS,GAAG,SAAS,CAAC,MAAM,CAC1B,CAAC,GAAG,EAAE,EAAE,CACN,GAAG,CAAC,MAAM,KAAK,GAAG;oBAClB,GAAG,CAAC,SAAS,KAAK,GAAG;oBACrB,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,OAAO,CACpC,CAAC;YACJ,CAAC;YAED,IAAI,SAAS,EAAE,MAAM,KAAK,CAAC,EAAE,CAAC;gBAC5B,YAAY,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC;oBACxB,GAAG,MAAM;oBACT,MAAM,EAAE,CAAC,GAAG,MAAM,CAAC;oBACnB,IAAI,EAAE,SAAS,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;iBACtE,CAAC,CAAC;YACL,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO,YAAY,CAAC;AACtB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,iBAAiB,GAAG,KAAK,EACpC,QAAmC,EACnC,OAA2B,EAC3B,OAA6B,EAC7B,EAAE,GAAE,CAAC,CAAC","sourcesContent":["import {\r\n  DataClassification,\r\n  Variable,\r\n  VariableClassification,\r\n  VariableFilter,\r\n  VariableKey,\r\n  VariablePatch,\r\n  VariablePatchResult,\r\n  VariablePatchSource,\r\n  VariablePatchType,\r\n  VariableQueryOptions,\r\n  VariableScope,\r\n  VariableSetResult,\r\n  isConflictResult,\r\n  isSuccessResult,\r\n  patchType,\r\n  toStrict,\r\n} from \"@tailjs/types\";\r\nimport {\r\n  MaybePromise,\r\n  delay,\r\n  filter,\r\n  isDefined,\r\n  isFunction,\r\n  isNumber,\r\n  isObject,\r\n  isUndefined,\r\n  now,\r\n} from \"@tailjs/util\";\r\nimport { ReadOnlyVariableStorage, VariableStorage } from \"..\";\r\n\r\n/**\r\n * A key that can be used to look up {@link Variable}s in Maps and Sets.\r\n */\r\nexport const variableId = <T extends VariableKey | undefined | null>(\r\n  variable: T\r\n) =>\r\n  variable\r\n    ? variable.targetId\r\n      ? variable.scope + variable.targetId + variable.key\r\n      : variable.scope + variable.key\r\n    : undefined;\r\n\r\nexport const copy = <\r\n  T extends (Variable<any, any> & { value: any }) | undefined\r\n>(\r\n  variable: T,\r\n  overrides?: Partial<Variable>\r\n): T => {\r\n  return (\r\n    variable && {\r\n      ...variable,\r\n      ...(variable.tags ? [...variable.tags] : {}),\r\n      ...overrides,\r\n    }\r\n  );\r\n};\r\n\r\nexport const formatSetResultError = (result?: VariableSetResult) => {\r\n  if (!result || isSuccessResult(result)) return undefined;\r\n\r\n  return filter([\r\n    `Status ${result.status} for key ${result.source.key} (${result.source.scope})`,\r\n    result[\"error\"]?.toString(),\r\n  ]).join(\" - \");\r\n};\r\n\r\nexport const extractKey = <T extends VariableKey>(\r\n  variable: T\r\n): T extends undefined ? undefined : T =>\r\n  variable\r\n    ? ({\r\n        scope: variable.scope,\r\n        targetId: variable.targetId,\r\n        key: variable.key,\r\n      } as Required<VariableKey> as any)\r\n    : undefined;\r\n\r\nconst patchSelector = (\r\n  value: any,\r\n  selector: string | undefined,\r\n  update: (current: any) => any\r\n) => {\r\n  if (!selector) return update(value);\r\n\r\n  let patchTarget: object;\r\n  (\".\" + selector).split(\".\").forEach((segment, i, path) => {\r\n    let current = i ? patchTarget[segment] : value;\r\n    if (isDefined(current) && !isObject(current))\r\n      throw new TypeError(\r\n        `Invalid patch operation. The selector does not address a property on an object.`\r\n      );\r\n    if (i === path.length - 1) {\r\n      const updated = (patchTarget[segment] = update(patchTarget[segment]));\r\n      patchTarget[segment] = updated;\r\n      if (!isDefined(update)) {\r\n        delete patchTarget[segment];\r\n      }\r\n    } else {\r\n      if (!current) {\r\n        patchTarget = i\r\n          ? (current = patchTarget[selector] ??= {})\r\n          : (value ??= {});\r\n      }\r\n    }\r\n  });\r\n  return value;\r\n};\r\n\r\nconst requireNumberOrUndefined = (value: any): number | undefined => {\r\n  if (isUndefined(value) || isNumber(value)) return value!;\r\n  throw new TypeError(\"The current value must be undefined or a number.\");\r\n};\r\n\r\nexport const applyPatchOffline = (\r\n  current: VariablePatchSource<any, true> | undefined,\r\n  { classification: level, purposes, patch }: VariablePatch<any, true>\r\n): VariablePatchResult<any, true> | undefined => {\r\n  if (isFunction(patch)) {\r\n    const patched = toStrict(patch(current));\r\n\r\n    if (patched) {\r\n      patched.classification ??=\r\n        current?.classification ?? DataClassification.Anonymous;\r\n      !(\"purposes\" in patched) && (patched.purposes = current?.purposes);\r\n      !(\"tags\" in patched) && (patched.tags = current?.tags);\r\n    }\r\n    return patched;\r\n  }\r\n\r\n  const classification: VariableClassification<true> = {\r\n    classification: level!,\r\n    purposes: purposes,\r\n  };\r\n\r\n  const value = current?.value;\r\n\r\n  patch.type = patchType(patch.type);\r\n\r\n  switch (patch.type) {\r\n    case VariablePatchType.Add:\r\n      return {\r\n        ...classification,\r\n        value: patchSelector(\r\n          requireNumberOrUndefined(value),\r\n          patch.selector,\r\n          (value) => (value ?? 0) + patch.by\r\n        ),\r\n      };\r\n    case VariablePatchType.Min:\r\n    case VariablePatchType.Max:\r\n      return {\r\n        ...classification,\r\n        value: patchSelector(value, patch.selector, (value) =>\r\n          isDefined(requireNumberOrUndefined(value))\r\n            ? Math[patch.type === VariablePatchType.Min ? \"min\" : \"max\"](\r\n                value,\r\n                patch.value\r\n              )\r\n            : patch.value\r\n        ),\r\n      };\r\n    case VariablePatchType.IfMatch:\r\n      if (current?.value !== patch.match) {\r\n        return undefined;\r\n      }\r\n      return {\r\n        ...classification,\r\n        value: patchSelector(value, patch.selector, () => patch.value),\r\n      };\r\n  }\r\n};\r\n\r\nexport type ParsedKey = {\r\n  prefix: string;\r\n  key: string;\r\n  sourceKey: string;\r\n  // For filters.\r\n  not?: boolean;\r\n};\r\n\r\nexport type PartitionItem<T> = [sourceIndex: number, item: T];\r\nexport type PartitionItems<T extends any[] = any[]> = T extends []\r\n  ? []\r\n  : T extends [infer Item, ...infer Rest]\r\n  ? [PartitionItem<Item>, ...PartitionItems<Rest>]\r\n  : PartitionItem<T[number]>[];\r\n\r\nexport const withSourceIndex = <T extends any[]>(items: T): PartitionItems<T> =>\r\n  items.map(\r\n    (item, sourceIndex) => [sourceIndex, item] as const\r\n  ) as PartitionItems<T>;\r\n\r\nexport const partitionItems = <T extends any[]>(items: PartitionItems<T>): T =>\r\n  items.map((item) => item[1]) as T;\r\n\r\nexport const mergeKeys = async <K extends any[], T extends any[]>(\r\n  results: T,\r\n  partitionMappings: PartitionItems<K>,\r\n  partitionResults: (items: K) => MaybePromise<T>\r\n) =>\r\n  partitionMappings?.length &&\r\n  (\r\n    await partitionResults(partitionMappings.map((item) => item?.[1]) as K)\r\n  ).forEach((result) => result && (results[result[0]] = result[1]));\r\n\r\nexport const hasPrefix = (key: string | undefined) => key?.includes(\":\");\r\n\r\nexport const parseKey = <T extends string | undefined>(\r\n  sourceKey: T\r\n): Exclude<T, string> | ParsedKey => {\r\n  if (isUndefined(sourceKey)) return undefined as any;\r\n  const not = sourceKey[0] === \"1\";\r\n  if (not) {\r\n    sourceKey = (sourceKey.slice(1) as T)!;\r\n  }\r\n  const prefixIndex = sourceKey.indexOf(\":\");\r\n  const prefix = prefixIndex < 0 ? \"\" : sourceKey.substring(0, prefixIndex);\r\n  const key = prefixIndex > -1 ? sourceKey.slice(prefixIndex + 1) : sourceKey;\r\n\r\n  return {\r\n    prefix,\r\n    key,\r\n    sourceKey,\r\n    not,\r\n  } as any;\r\n};\r\n\r\nexport type FilterTarget = {\r\n  targetIndex: number;\r\n  scopes: Set<VariableScope>;\r\n  prefixes: { exclude?: boolean; match: Set<string> };\r\n};\r\n\r\nexport const splitFilters = (\r\n  filters: VariableFilter[],\r\n  splits: FilterTarget[],\r\n  keepPrefix = false\r\n) => {\r\n  const splitFilters: VariableFilter[][] = splits.map(() => []);\r\n  for (const filter of filters) {\r\n    const keys = filter.keys?.map(parseKey);\r\n    for (const { targetIndex: target, scopes, prefixes } of splits) {\r\n      let splitKeys = keys;\r\n      if (prefixes && splitKeys) {\r\n        const { exclude = false, match } = prefixes;\r\n        splitKeys = splitKeys.filter(\r\n          (key) =>\r\n            key.prefix === \"*\" ||\r\n            key.sourceKey === \"*\" ||\r\n            match.has(key.prefix) !== exclude\r\n        );\r\n      }\r\n\r\n      if (splitKeys?.length !== 0) {\r\n        splitFilters[target].push({\r\n          ...filter,\r\n          scopes: [...scopes],\r\n          keys: splitKeys?.map((key) => (keepPrefix ? key.sourceKey : key.key)),\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return splitFilters;\r\n};\r\n\r\nexport const distributeQueries = async (\r\n  storages: ReadOnlyVariableStorage[],\r\n  filters: VariableFilter[][],\r\n  options: VariableQueryOptions\r\n) => {};\r\n"]}