{"version":3,"file":"enums.js","sourceRoot":"","sources":["enums.ts"],"names":[],"mappings":"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","sourcesContent":["import { Entries, define, isDefined, isNumber, isString } from \".\";\r\n\r\ntype MaybeArray<T, Flags, ArrayIfArray = false> = Flags extends true\r\n  ? (ArrayIfArray extends true ? never : T) | T[]\r\n  : T;\r\n\r\ntype Lookup<T, V, Name extends boolean> = V extends never\r\n  ? never\r\n  : {\r\n      [P in keyof T]: V extends T[P] ? (Name extends true ? P : T[P]) : never;\r\n    } extends infer T\r\n  ? T[keyof T]\r\n  : never;\r\n\r\ntype ParsedValue<T, V, Flags> = V extends keyof T\r\n  ? T[V]\r\n  : V extends T[keyof T]\r\n  ? Lookup<T, V, false>\r\n  : [Flags, V] extends [true, number]\r\n  ? T[keyof T]\r\n  : never;\r\n\r\nexport type ParsableEnumValue<\r\n  T extends Record<string, Enum>,\r\n  Numeric extends boolean | undefined,\r\n  Flags,\r\n  Enum extends number = number\r\n> =\r\n  | (boolean extends Numeric\r\n      ? MaybeArray<\r\n          | (Flags extends true ? number | T[keyof T] : T[keyof T])\r\n          | keyof T\r\n          | (Flags extends true ? \"any\" : never),\r\n          Flags\r\n        >\r\n      : Numeric extends true\r\n      ? Flags extends true\r\n        ? T[keyof T] | number\r\n        : T[keyof T]\r\n      : Flags extends true\r\n      ? (keyof T)[]\r\n      : keyof T)\r\n  | (undefined extends Numeric ? undefined : never);\r\n\r\ntype ParsableArg<T extends Record<string, number>, Flags> = ParsableEnumValue<\r\n  T,\r\n  boolean | undefined,\r\n  Flags\r\n>;\r\n\r\ntype ParseFunction<\r\n  T extends Record<string, number>,\r\n  Flags extends boolean,\r\n  Numeric extends boolean,\r\n  InvalidValue extends undefined | never = never,\r\n  MainFunction = false\r\n> = {\r\n  <V extends string | number | symbol | null | undefined>(\r\n    value:\r\n      | V\r\n      | ParsableArg<T, Flags>\r\n      | (Flags extends true ? V[] | ParsableArg<T, Flags>[] : never),\r\n    ...args: MainFunction extends true ? [] : [validateNumbers?: boolean]\r\n  ): V extends null | undefined\r\n    ? undefined\r\n    : Numeric extends false\r\n    ? MaybeArray<\r\n        ParsedValue<T, V, Flags> extends never\r\n          ? V extends string | number\r\n            ? keyof T | InvalidValue\r\n            : InvalidValue\r\n          : Lookup<T, ParsedValue<T, V, Flags>, true>,\r\n        Flags,\r\n        true\r\n      >\r\n    : ParsedValue<T, V, Flags> extends never\r\n    ? string extends V\r\n      ? T[keyof T] | InvalidValue\r\n      : InvalidValue\r\n    : ParsedValue<T, V, Flags>;\r\n};\r\n\r\nexport type EnumHelper<\r\n  T extends Record<string, number> = Record<string, number>,\r\n  Flags extends boolean = boolean\r\n> = T &\r\n  ParseFunction<T, Flags, true, never, true> & {\r\n    parse: ParseFunction<T, Flags, true>;\r\n    tryParse: ParseFunction<T, Flags, true, undefined>;\r\n    values: T[keyof T][];\r\n    entries: Entries<T>;\r\n    lookup: ParseFunction<T, Flags, false>;\r\n  } & (Flags extends true\r\n    ? {\r\n        any: T[keyof T];\r\n        map<R = T[keyof T]>(\r\n          flags: ParsableEnumValue<T, boolean | undefined, Flags>,\r\n          map?: (entry: Entries<T>[number], index: number) => R\r\n        ): R[];\r\n      }\r\n    : {});\r\n\r\nexport const createEnumAccessor = <\r\n  T extends Record<string, number>,\r\n  Flags extends boolean\r\n>(\r\n  names: T,\r\n  flags: Flags,\r\n  enumName: string\r\n): EnumHelper<T, Flags> => {\r\n  const entries = Object.entries(names);\r\n  const values = Object.values(names);\r\n  const any = values.reduce((any, flag) => any | flag, 0);\r\n\r\n  const nameLookup: Record<string, number> = flags ? { ...names, any } : names;\r\n  const valueLookup = Object.fromEntries(\r\n    entries.map(([key, value]) => [value, key])\r\n  );\r\n\r\n  const parseValue = (value: any, validateNumbers?: boolean) =>\r\n    isString(value)\r\n      ? nameLookup[value] ?? nameLookup[value.toLowerCase()]\r\n      : isNumber(value)\r\n      ? !flags && validateNumbers\r\n        ? isDefined(valueLookup[value])\r\n          ? value\r\n          : undefined\r\n        : value\r\n      : undefined;\r\n\r\n  const [tryParse, lookup] = flags\r\n    ? [\r\n        (value: any) =>\r\n          Array.isArray(value)\r\n            ? value.reduce(\r\n                (flags, flag) =>\r\n                  (flag = parseValue(flag)) == null\r\n                    ? flags\r\n                    : (flags ?? 0) | flag,\r\n                undefined as number | undefined\r\n              )\r\n            : parseValue(value),\r\n        (value: any) =>\r\n          (value = tryParse(value)) == null\r\n            ? undefined\r\n            : entries.filter(([, flag]) => value & flag).map(([name]) => name),\r\n      ]\r\n    : [\r\n        parseValue,\r\n        (value: any) =>\r\n          (value = parseValue(value)) != null ? valueLookup[value] : undefined,\r\n      ];\r\n  const throwError = (err: any) => {\r\n    throw err;\r\n  };\r\n\r\n  let originalValue: any;\r\n  const parse = (value: any) =>\r\n    value == null\r\n      ? undefined\r\n      : (value = tryParse((originalValue = value))) == null\r\n      ? throwError(\r\n          new TypeError(\r\n            `${JSON.stringify(originalValue)} is not a valid ${enumName} value.`\r\n          )\r\n        )\r\n      : value;\r\n\r\n  return define(parse, names, [\r\n    { enumerable: false },\r\n    {\r\n      parse,\r\n      tryParse,\r\n      entries,\r\n      values,\r\n      lookup,\r\n    } as const,\r\n    flags &&\r\n      ({\r\n        any,\r\n        map: (flags: any, map?: (flag: any, index: number) => any) => (\r\n          (flags = parse(flags)),\r\n          entries\r\n            .filter(([, flag]) => flag & flags)\r\n            .map(map ?? (([, flag]) => flag))\r\n        ),\r\n      } as const),\r\n  ]) as any;\r\n};\r\n"]}