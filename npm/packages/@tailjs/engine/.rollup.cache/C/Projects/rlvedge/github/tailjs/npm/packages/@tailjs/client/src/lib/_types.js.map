{"version":3,"file":"_types.js","sourceRoot":"","sources":["_types.ts"],"names":[],"mappings":"","sourcesContent":["import { Voidefined } from \"@tailjs/util\";\n\nexport type JsonArray = Json[];\n\nexport type JsonTuple = {\n  [TupleIndex in number]?: Json;\n};\n\nexport type JsonObject = {\n  [P in string]?: Json;\n};\n\n/**\n * All possible values that can be represented with JSON.\n */\nexport type Json =\n  | null\n  | undefined\n  | string\n  | number\n  | boolean\n  | JsonArray\n  | JsonTuple\n  | JsonObject;\n\ntype ToJsonAble<T> = { toJSON(): T };\n/**\n * The shape the JSON data when a given type is serialized.\n *\n * This assumes that only the shapes permitted by {@link JsonSerializable} are serialized.\n * Otherwise not ignored since functions are in fact serialized as `{}`.\n */\nexport type JsonOf<T> = Json extends T\n  ? Json\n  : T extends string | number | boolean | null | undefined | void\n  ? Voidefined<T>\n  : T extends ToJsonAble<infer R>\n  ? R extends ToJsonAble<any>\n    ? R\n    : JsonOf<R>\n  : T extends any[]\n  ? { [index in keyof T]: JsonOf<T[index]> }\n  : T extends Iterable<infer T>\n  ? JsonOf<T>[]\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      -readonly [P in keyof T as P extends string\n        ? JsonOf<T[P]> extends undefined\n          ? never\n          : P\n        : never]: JsonOf<T[P]>;\n    }\n  : never;\n\n/**\n * The broadest possible subtype of a given type that can be serialized and then deserialized without violating the type's contract,\n * with the exception of symbol properties. Those are ignored.\n *\n * Not violating the constract does not mean that the type can loslessly be serialized and then deserialized back.\n * It just means that its contract will not be violated if values of a certain type are omitted or deserialized back to another valid subtype.\n * For example, an iterable that is not an array will be deserialized as an array.\n *\n * In particular functions or promises are serialized as empty objects `{}`, and cannot be deserialized back.\n * This means that required constraints on properies that only allow these types can never be met.\n * Similarly, arrays the can only hold functions or promises must be empty (`never[]`) to satisfy the type constraint.\n *\n */\n\nexport type JsonSerializable<T> = Json extends T\n  ? Json\n  : T extends string | number | boolean | null | undefined | void\n  ? Voidefined<T>\n  : T extends ToJsonAble<infer R>\n  ? R extends ToJsonAble<any>\n    ? R\n    : JsonSerializable<R>\n  : T extends any[]\n  ? { [index in keyof T]: JsonSerializable<T[index]> }\n  : T extends Iterable<any>\n  ? T\n  : T extends (...args: any[]) => any\n  ? undefined\n  : T extends object\n  ? {\n      [P in keyof T as P extends string\n        ? undefined extends T[P]\n          ? P\n          : JsonSerializable<T[P]> extends undefined\n          ? never\n          : P\n        : never]: undefined extends T[P] // It's okay to have a function if it can be undefined. It will not break the contract even though it will always get deserialized as `undefined`.\n        ? T[P]\n        : JsonSerializable<T[P]>;\n    }\n  : never;\n"]}